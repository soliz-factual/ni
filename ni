#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q'applied_to';
$d=q'metaclass.c';
$e={$d,1};
$f=q'name';
$g=q'slices';
$h=q'class.c';
$i={$h,1};
$j=q'module.c';
$k={$h,1,$j,1};
$l=q'lib/behavior.c';
$m=q'lib/branch.c';
$n=q'lib/dataslice.c';
$o=q'lib/doc.c';
$p=q'lib/fn.c';
$q=q'lib/image.c';
$r=q'lib/ni.c';
$s=q'lib/slice.c';
$t=q'lib/tag.c';
$u=q'lib/test_value.c';
$v=q'object.c';
$w=q'unix/cat.c';
$x=q'unix/fd.c';
$y=q'unix/fifo.c';
$z=q'unix/file.c';
$A=q'unix/io.c';
$B=q'unix/pid.c';
$C=q'unix/pipeline.c';
$D=q'unix/str.c';
$E={$h,1,$l,1,$m,1,$n,1,$o,1,$p,1,$q,1,$r,1,$s,1,$t,1,$u,1,$j,1,$v,1,$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$F=[undef];
$G=q'metaclass';
$H=bless({$c,$E,$f,$v,$g,$F},$G);
$I=q'metaclass::ctors';
$J={$s,1};
$K={$h,1,$l,1,$m,1,$n,1,$s,1,$t,1,$j,1};
$L=[$H];
$M=bless({$c,$K,$f,$l,$g,$L},$G);
$N=q'metaclass::ctors';
$O=[$M];
$P=bless({$c,$J,$f,$s,$g,$O},$G);
$Q=q'metaclass::ctors';
$R=q'lib/slice';
$S={$R,1};
$T=q'class';
$U=q'lib/behavior';
$V=q'lib/branch';
$W=q'lib/dataslice';
$X=q'lib/tag';
$Y=q'lib/test_value.c';
$Z=q'module';
$c1={$T,1,$h,1,$U,1,$l,1,$V,1,$m,1,$W,1,$n,1,$o,1,$p,1,$q,1,$r,1,$R,1,$s,1,$X,1,$t,1,$Y,1,$G,1,$d,1,$Z,1,$j,1,$v,1,$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$d1=q'lib/doc';
$e1=q'lib/fn';
$f1=q'lib/image';
$g1=q'lib/ni';
$h1=q'lib/test_value';
$i1=q'lib/test_value.c';
$j1=q'object';
$k1=q'unix/cat';
$l1=q'unix/fd';
$m1=q'unix/fifo';
$n1=q'unix/file';
$o1=q'unix/io';
$p1=q'unix/pid';
$q1=q'unix/pipeline';
$r1=q'unix/str';
$s1={$T,1,$h,1,$U,1,$l,1,$V,1,$m,1,$W,1,$n,1,$d1,1,$o,1,$e1,1,$p,1,$f1,1,$q,1,$g1,1,$r,1,$R,1,$s,1,$X,1,$t,1,$h1,1,$i1,1,$G,1,$d,1,$Z,1,$j,1,$j1,1,$v,1,$k1,1,$w,1,$l1,1,$x,1,$m1,1,$y,1,$n1,1,$z,1,$o1,1,$A,1,$p1,1,$B,1,$q1,1,$C,1,$r1,1,$D,1};
$t1={};
$u1=q'ctor';
$v1=undef;
$w1=q'dtor';
$x1=q'methods';
$y1={$p,1};
$z1=[$H];
$A1=bless({$c,$y1,$f,$p,$g,$z1},$G);
$B1=q'metaclass::ctors';
$C1={$e1,1};
$D1={};
$E1=q'code';
$F1=q'shift->compile';
$G1=q'proto';
$H1=q'';
$I1=bless({$E1,$F1,$G1,$H1},$e1);
$J1=q'lib/fn::ctors';
$K1=q'compile';
$L1=q'local $@;
my $self = shift;
$$self{proto} ||= \'\';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};';
$M1=bless({$E1,$L1,$G1,$H1},$e1);
$N1=q'instantiate';
$O1=q'my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : \'\';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};';
$P1=bless({$E1,$O1,$G1,$H1},$e1);
$Q1={$K1,$M1,$N1,$P1};
$R1=q'lib/fn_init.b';
$S1=bless({$c,$D1,$u1,$I1,$w1,$v1,$x1,$Q1,$f,$R1},$R);
$T1=q'lib/slice::ctors';
$U1={};
$V1=q'annotations';
$W1=[];
$X1=q'shift->{\'annotations\'}';
$Y1=bless({$V1,$W1,$E1,$X1,$G1,$H1},$e1);
$Z1=[];
$c2=q'shift->{\'code\'}';
$d2=bless({$V1,$Z1,$E1,$c2,$G1,$H1},$e1);
$e2=q'fn';
$f2=[];
$g2=q'shift->{\'fn\'}';
$h2=bless({$V1,$f2,$E1,$g2,$G1,$H1},$e1);
$i2={$V1,$Y1,$E1,$d2,$e2,$h2};
$j2=q'lib/fn_ro.b';
$k2=bless({$c,$U1,$u1,$v1,$w1,$v1,$x1,$i2,$f,$j2},$R);
$l2=q'lib/slice::ctors';
$m2={};
$n2=q'(""';
$o2=[];
$p2=q'shift->{code}';
$q2=bless({$V1,$o2,$E1,$p2,$G1,$H1},$e1);
$r2=q'(eq';
$s2=[];
$t2=q'ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])';
$u2=bless({$V1,$s2,$E1,$t2,$G1,$H1},$e1);
$v2={$n2,$q2,$r2,$u2};
$w2=q'lib/fn_ops.b';
$x2=bless({$c,$m2,$u1,$v1,$w1,$v1,$x1,$v2,$f,$w2},$R);
$y2=q'lib/slice::ctors';
$z2={};
$A2=q'serialize';
$B2=[];
$C2=q'local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = \' \' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);';
$D2=bless({$V1,$B2,$E1,$C2,$G1,$H1},$e1);
$E2={$A2,$D2};
$F2=q'lib/fn_serialize.b';
$G2=bless({$c,$z2,$u1,$v1,$w1,$v1,$x1,$E2,$f,$F2},$R);
$H2=q'lib/slice::ctors';
$I2=[undef,undef,$S1,$k2,$x2,$G2];
$J2=bless({$c,$C1,$f,$e1,$g,$I2},$p);
$K2=q'lib/fn.c::ctors';
$L2=q'ni \'ni:\' . ref shift';
$M2=bless({$E1,$L2,$G1,$H1},$e1);
$N2={$T,$M2};
$O2=q'lib/instance.b';
$P2=bless({$c,$t1,$u1,$v1,$w1,$v1,$x1,$N2,$f,$O2},$R);
$Q2=q'lib/test_value.c';
$R2=q'lib/slice::ctors';
$S2=[$P2];
$T2=bless({$c,$s1,$f,$j1,$g,$S2},$v);
$U2=q'object.c::ctors';
$V2={};
$W2=q'doc';
$X2=q'my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can(\'exists\') && ni->exists("ni.doc:$name");
ni(\'ni:lib/doc\')->new($name);';
$Y2=bless({$E1,$X2,$G1,$H1},$e1);
$Z2={$W2,$Y2};
$c3=q'lib/documentable.b';
$d3=bless({$c,$V2,$u1,$v1,$w1,$v1,$x1,$Z2,$f,$c3},$R);
$e3=q'lib/test_value.c';
$f3=q'lib/slice::ctors';
$g3=[$T2,$d3];
$h3=bless({$c,$c1,$f,$U,$g,$g3},$l);
$i3=q'lib/behavior.c::ctors';
$j3={};
$k3=q'my $s = shift; ni->def($s->name, $s)';
$l3=bless({$E1,$k3,$G1,$H1},$e1);
$m3=q'$_[0]->namespace . ":" . $_[0]->{name}';
$n3=bless({$E1,$m3,$G1,$H1},$e1);
$o3={$f,$n3};
$p3=q'lib/named.b';
$q3=bless({$c,$j3,$u1,$l3,$w1,$v1,$x1,$o3,$f,$p3},$R);
$r3=q'lib/test_value.c';
$s3=q'lib/slice::ctors';
$t3=q'local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);';
$u3=bless({$E1,$t3,$G1,$H1},$e1);
$v3=q'local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;';
$w3=bless({$E1,$v3,$G1,$H1},$e1);
$x3=q'lib/slice::apply';
$y3=q'lib/slice::apply_unsafe';
$z3={};
$A3=q'apply';
$B3=q'apply_unsafe';
$C3={$A3,$u3,$B3,$w3};
$D3=q'lib/slice.b';
$E3=bless({$c,$z3,$x1,$C3,$f,$D3},$R);
$F3=q'lib/slice::ctors';
$G3={};
$H3=q'my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};';
$I3=bless({$E1,$H3,$G1,$H1},$e1);
$J3={$N1,$I3};
$K3=q'lib/slice_init.b';
$L3=bless({$c,$G3,$x1,$J3,$f,$K3},$R);
$M3=q'lib/slice::ctors';
$N3={};
$O3=[];
$P3=q'local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq \'ni:lib/slice.b\') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      \'*\' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;';
$Q3=bless({$V1,$O3,$E1,$P3,$G1,$H1},$e1);
$R3={$A2,$Q3};
$S3=q'lib/slice_serialize.b';
$T3=bless({$c,$N3,$u1,$v1,$w1,$v1,$x1,$R3,$f,$S3},$R);
$U3=q'lib/slice::ctors';
$V3=[$h3,$q3,$E3,$L3,$T3];
$W3=bless({$c,$S,$f,$R,$g,$V3},$s);
$X3=q'lib/slice.c::ctors';
$Y3={};
$Z3=q'DESTROY';
$c4=q'local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};';
$d4=bless({$E1,$c4,$G1,$H1},$e1);
$e4=q'new';
$f4=q'local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;';
$g4=bless({$E1,$f4,$G1,$H1},$e1);
$h4={$Z3,$d4,$e4,$g4};
$i4=q'lib/instantiable.b';
$j4=bless({$c,$Y3,$x1,$h4,$f,$i4},$R);
$k4=q'lib/test_value.c';
$l4=q'lib/slice::ctors';
$m4=[$H,$j4,$M];
$n4=bless({$c,$k,$f,$j,$g,$m4},$G);
$o4=q'metaclass::ctors';
$p4=[$n4];
$q4=bless({$c,$i,$f,$h,$g,$p4},$G);
$r4=q'metaclass::ctors';
$s4=q'lib/test_value.c';
$t4={$T,1,$h,1,$l,1,$m,1,$n,1,$o,1,$p,1,$q,1,$r,1,$s,1,$t,1,$s4,1,$d,1,$j,1,$v,1,$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$u4=q'lib/test_value.c';
$v4={$T,1,$h,1,$l,1,$m,1,$n,1,$o,1,$p,1,$q,1,$r,1,$s,1,$t,1,$u4,1,$G,1,$d,1,$Z,1,$j,1,$v,1,$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$w4={$t,1};
$x4=[$M];
$y4=bless({$c,$w4,$f,$t,$g,$x4},$G);
$z4=q'metaclass::ctors';
$A4={$X,1};
$B4={};
$C4=q'local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;';
$D4=bless({$E1,$C4,$G1,$H1},$e1);
$E4={$A3,$D4};
$F4=q'lib/tag.b';
$G4=bless({$c,$B4,$u1,$v1,$w1,$v1,$x1,$E4,$f,$F4},$R);
$H4=q'lib/slice::ctors';
$I4={};
$J4=q'local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};';
$K4=bless({$E1,$J4,$G1,$H1},$e1);
$L4={$N1,$K4};
$M4=q'lib/tag_init.b';
$N4=bless({$c,$I4,$u1,$v1,$w1,$v1,$x1,$L4,$f,$M4},$R);
$O4=q'lib/slice::ctors';
$P4=[$h3,$q3,$G4,$N4];
$Q4=bless({$c,$A4,$f,$X,$g,$P4},$t);
$R4=q'lib/tag.c::ctors';
$S4=q'lib/perlbranch.b';
$T4={};
$U4=q'add';
$V4=q'local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;';
$W4=bless({$E1,$V4,$G1,$H1},$e1);
$X4=q'local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;';
$Y4=bless({$E1,$X4,$G1,$H1},$e1);
$Z4={$U4,$W4,$A3,$Y4};
$c5=q'lib/branch.b';
$d5=bless({$c,$T4,$u1,$v1,$w1,$v1,$x1,$Z4,$f,$c5},$R);
$e5=q'lib/test_value.c';
$f5=q'lib/slice::ctors';
$g5={};
$h5=q'namespace';
$i5=q'\'ni\'';
$j5=bless({$E1,$i5,$G1,$H1},$e1);
$k5={$h5,$j5};
$l5=q'lib/named_in_ni.b';
$m5=bless({$c,$g5,$u1,$v1,$w1,$v1,$x1,$k5,$f,$l5},$R);
$n5=q'lib/test_value.c';
$o5=q'lib/slice::ctors';
$p5={};
$q5=q'package';
$r5=q'shift->{name}';
$s5=bless({$E1,$r5,$G1,$H1},$e1);
$t5={$q5,$s5};
$u5=q'lib/namespaced.b';
$v5=bless({$c,$p5,$u1,$v1,$w1,$v1,$x1,$t5,$f,$u5},$R);
$w5=q'lib/test_value.c';
$x5=q'lib/slice::ctors';
$y5={};
$z5=q'resolve';
$A5=q'ref $_[1] ? $_[1] : ni"ni:$_[1]"';
$B5=bless({$E1,$A5,$G1,$H1},$e1);
$C5={$z5,$B5};
$D5=q'lib/resolver.b';
$E5=bless({$c,$y5,$u1,$v1,$w1,$v1,$x1,$C5,$f,$D5},$R);
$F5=q'lib/test_value.c';
$G5=q'lib/slice::ctors';
$H5=[$d5,$q3,$m5,$v5,$E5];
$I5=bless({$f,$S4,$g,$H5},$X);
$J5=q'lib/tag::ctors';
$K5={};
$L5=q'my $s = shift; $s->apply($s->package)';
$M5=bless({$E1,$L5,$G1,$H1},$e1);
$N5=q'local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};';
$O5=bless({$E1,$N5,$G1,$H1},$e1);
$P5={$N1,$O5};
$Q5=q'lib/class_init.b';
$R5=bless({$c,$K5,$u1,$M5,$w1,$v1,$x1,$P5,$f,$Q5},$R);
$S5=q'lib/test_value.c';
$T5=q'lib/slice::ctors';
$U5={$m,1};
$V5=[$M];
$W5=bless({$c,$U5,$f,$m,$g,$V5},$G);
$X5=q'metaclass::ctors';
$Y5={$V,1};
$Z5={};
$c6=q'local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};';
$d6=bless({$E1,$c6,$G1,$H1},$e1);
$e6={$N1,$d6};
$f6=q'lib/branch_init.b';
$g6=bless({$c,$Z5,$u1,$v1,$w1,$v1,$x1,$e6,$f,$f6},$R);
$h6=q'lib/slice::ctors';
$i6=[$h3,$q3,$d5,$g6,undef];
$j6=bless({$c,$Y5,$f,$V,$g,$i6},$m);
$k6=q'lib/branch.c::ctors';
$l6=q'lib/test_value.c';
$m6={$T,1,$h,1,$l,1,$V,1,$m,1,$n,1,$o,1,$p,1,$q,1,$r,1,$s,1,$t,1,$l6,1,$G,1,$d,1,$Z,1,$j,1,$v,1,$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$n6=q'lib/definition.b';
$o6={};
$p6=q'def';
$q6=q'shift->add(ni(\'ni:lib/slice\')->new(@_))';
$r6=bless({$E1,$q6,$G1,$H1},$e1);
$s6={$p6,$r6};
$t6=q'lib/definition_def.b';
$u6=bless({$c,$o6,$u1,$v1,$w1,$v1,$x1,$s6,$f,$t6},$R);
$v6=q'lib/test_value.c';
$w6=q'lib/slice::ctors';
$x6={};
$y6=q'ro';
$z6=q'my ($self, $slice, @rs) = @_;
$self->add(ni(\'ni:lib/slice\')->new(
  $slice,
  map +($_ => fn qq{shift->{\'$_\'}}), @rs));';
$A6=bless({$E1,$z6,$G1,$H1},$e1);
$B6=q'rw';
$C6=q'my ($self, $slice, @as) = @_;
$self->add(ni(\'ni:lib/slice\')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{\'$_\'} = \\$_[1] : shift->{\'$_\'}}), @as));';
$D6=bless({$E1,$C6,$G1,$H1},$e1);
$E6={$y6,$A6,$B6,$D6};
$F6=q'lib/accessor.b';
$G6=bless({$c,$x6,$u1,$v1,$w1,$v1,$x1,$E6,$f,$F6},$R);
$H6=q'lib/test_value.c';
$I6=q'lib/slice::ctors';
$J6={};
$K6=q'shift->name';
$L6=bless({$E1,$K6,$G1,$H1},$e1);
$M6={$n2,$L6};
$N6=q'lib/name_as_string.b';
$O6=bless({$c,$J6,$u1,$v1,$w1,$v1,$x1,$M6,$f,$N6},$R);
$P6=q'lib/test_value.c';
$Q6=q'lib/slice::ctors';
$R6={};
$S6=q'ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);';
$T6=bless({$E1,$S6,$G1,$H1},$e1);
$U6={$r2,$T6};
$V6=q'lib/ref_eq.b';
$W6=bless({$c,$R6,$u1,$v1,$w1,$v1,$x1,$U6,$f,$V6},$R);
$X6=q'lib/test_value.c';
$Y6=q'lib/slice::ctors';
$Z6={};
$c7=q'defdata';
$d7=q'shift->add(ni(\'ni:lib/dataslice\')->new(@_))';
$e7=bless({$E1,$d7,$G1,$H1},$e1);
$f7={$c7,$e7};
$g7=q'lib/definition_defdata.b';
$h7=bless({$c,$Z6,$u1,$v1,$w1,$v1,$x1,$f7,$f,$g7},$R);
$i7=q'lib/test_value.c';
$j7=q'lib/slice::ctors';
$k7=[$u6,$G6,$O6,$W6,$h7];
$l7=bless({$c,$m6,$f,$n6,$g,$k7},$V);
$m7=q'lib/branch::ctors';
$n7=[$I5,$R5,$T2,$h3,$l7];
$o7=bless({$c,$v4,$f,$Z,$g,$n7},$j);
$p7=q'module.c::ctors';
$q7={};
$r7=q'child';
$s7=q'my ($self, $name, @slices) = @_;
ni("ni:metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);';
$t7=bless({$E1,$s7,$G1,$H1},$e1);
$u7={$r7,$t7};
$v7=q'lib/subclass.b';
$w7=bless({$c,$q7,$u1,$v1,$w1,$v1,$x1,$u7,$f,$v7},$R);
$x7=q'lib/test_value.c';
$y7=q'lib/slice::ctors';
$z7=[$o7,$j4,$R5,$o7,$w7];
$A7=bless({$c,$t4,$f,$T,$g,$z7},$h);
$B7=q'class.c::ctors';
$C7=[$A7];
$D7=bless({$c,$e,$f,$d,$g,$C7},$G);
$E7=q'metaclass::ctors';
$F7={$G,1};
$G7=[$I5,$j4,$R5,$o7];
$H7=bless({$c,$F7,$f,$G,$g,$G7},$d);
$I7=q'metaclass.c::ctors';
$J7={$r,1};
$K7=[$H];
$L7=bless({$c,$J7,$f,$r,$g,$K7},$G);
$M7=q'metaclass::ctors';
$N7={$g1,1};
$O7={};
$P7=q'is_mutable';
$Q7=[];
$R7=q'$0 ne "-" && -w $0';
$S7=bless({$V1,$Q7,$E1,$R7,$G1,$H1},$e1);
$T7=q'modify';
$U7=[];
$V7=q'my ($self, $fn) = @_;
# TODO: replace all of this with a generalized "atomic-update" function
# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join \'/\', @r;
open my $w, \'>\', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";';
$W7=bless({$V1,$U7,$E1,$V7,$G1,$H1},$e1);
$X7={$P7,$S7,$T7,$W7};
$Y7=q'lib/ni_self.b';
$Z7=bless({$c,$O7,$u1,$v1,$w1,$v1,$x1,$X7,$f,$Y7},$R);
$c8=q'lib/slice::ctors';
$d8={};
$e8=q'exists';
$f8=[];
$g8=q'exists $_[0]->{named}{$_[1]}';
$h8=bless({$V1,$f8,$E1,$g8,$G1,$H1},$e1);
$i8=q'quoted';
$j8=[];
$k8=q'my $self = shift;
my $q = ni(\'ni:lib/image\')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;';
$l8=bless({$V1,$j8,$E1,$k8,$G1,$H1},$e1);
$m8={$e8,$h8,$i8,$l8};
$n8=q'lib/ni_image.b';
$o8=bless({$c,$d8,$u1,$v1,$w1,$v1,$x1,$m8,$f,$n8},$R);
$p8=q'lib/slice::ctors';
$q8={};
$r8=q'--internal/+=';
$s8=[];
$t8=q'my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
  die "ni: failed to run $_: $!" unless $r;
}
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;';
$u8=bless({$V1,$s8,$E1,$t8,$G1,$H1},$e1);
$v8=q'--internal/eval';
$w8=[];
$x8=q'my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;';
$y8=bless({$V1,$w8,$E1,$x8,$G1,$H1},$e1);
$z8=q'--internal/image';
$A8=[];
$B8=q'shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;';
$C8=bless({$V1,$A8,$E1,$B8,$G1,$H1},$e1);
$D8=q'--internal/test';
$E8=[];
$F8=q'my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL: $@ in $t\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL: $r\\n";
  }
}
my $passed = @tests - $fails;
print "$passed test(s) passed\\n";
!!$fails;';
$G8=bless({$V1,$E8,$E1,$F8,$G1,$H1},$e1);
$H8=q'run';
$I8=[];
$J8=q'my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);';
$K8=bless({$V1,$I8,$E1,$J8,$G1,$H1},$e1);
$L8={$r8,$u8,$v8,$y8,$z8,$C8,$D8,$G8,$H8,$K8};
$M8=q'lib/ni_main.b';
$N8=bless({$c,$q8,$u1,$v1,$w1,$v1,$x1,$L8,$f,$M8},$R);
$O8=q'lib/slice::ctors';
$P8={};
$Q8=[];
$R8=q'my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";';
$S8=bless({$V1,$Q8,$E1,$R8,$G1,$H1},$e1);
$T8=q'resolver_for';
$U8=[];
$V8=q'my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;';
$W8=bless({$V1,$U8,$E1,$V8,$G1,$H1},$e1);
$X8={$z5,$S8,$T8,$W8};
$Y8=q'lib/ni_resolver.b';
$Z8=bless({$c,$P8,$u1,$v1,$w1,$v1,$x1,$X8,$f,$Y8},$R);
$c9=q'lib/slice::ctors';
$d9=[$T2,$Z7,$o8,$N8,$Z8];
$e9=bless({$c,$N7,$f,$g1,$g,$d9},$r);
$f9=q'lib/ni.c::ctors';
$g9=q'named';
$h9=q'ni.doc:class';
$i9={$o,1};
$j9=[$H];
$k9=bless({$c,$i9,$f,$o,$g,$j9},$G);
$l9=q'metaclass::ctors';
$m9={$d1,1};
$n9={};
$o9=q'shift; +{name => shift, doc => []}';
$p9=bless({$E1,$o9,$G1,$H1},$e1);
$q9={$N1,$p9};
$r9=q'lib/doc_init.b';
$s9=bless({$c,$n9,$u1,$v1,$w1,$v1,$x1,$q9,$f,$r9},$R);
$t9=q'lib/slice::ctors';
$u9={};
$v9=q'\'ni.doc\'';
$w9=bless({$E1,$v9,$G1,$H1},$e1);
$x9={$h5,$w9};
$y9=q'lib/doc_namespace.b';
$z9=bless({$c,$u9,$u1,$v1,$w1,$v1,$x1,$x9,$f,$y9},$R);
$A9=q'lib/slice::ctors';
$B9={};
$C9=q'AUTOLOAD';
$D9=q'my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;';
$E9=bless({$E1,$D9,$G1,$H1},$e1);
$F9={$C9,$E9};
$G9=q'lib/doc_define.b';
$H9=bless({$c,$B9,$u1,$v1,$w1,$v1,$x1,$F9,$f,$G9},$R);
$I9=q'lib/slice::ctors';
$J9={};
$K9=q'eg';
$L9=q'my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;';
$M9=bless({$E1,$L9,$G1,$H1},$e1);
$N9=q'tests';
$O9=q'my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq \'eg\';
}
@tests;';
$P9=bless({$E1,$O9,$G1,$H1},$e1);
$Q9={$K9,$M9,$N9,$P9};
$R9=q'lib/doc_test.b';
$S9=bless({$c,$J9,$u1,$v1,$w1,$v1,$x1,$Q9,$f,$R9},$R);
$T9=q'lib/slice::ctors';
$U9=[$T2,$q3,$s9,$z9,$H9,$S9];
$V9=bless({$c,$m9,$f,$d1,$g,$U9},$o);
$W9=q'lib/doc.c::ctors';
$X9=q'synopsis';
$Y9=q'
    ni(\'ni:object\')->child(\'message\')
      ->add(\'behaviorname.b\')           # add existing behavior
      ->def(\'message_init.b\',           # define new slice behavior
        instantiate => fn q{            # called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       # return object to be blessed
        })
      ->def(\'behaviorname.b\',           # define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! \'" . $$self{message} . "\'\\n";
        });
    ni(\'ni:child\')->new(\'hello world!\')->method1;
  ';
$Z9=[$X9,$Y9];
$ca=q'description';
$da=q'ni:class is at the core of ni\'s object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you\'d expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.';
$ea=[$ca,$da];
$fa=q'behaviors';
$ga=q'ni\'s objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:lib/slice, which represents a set of methods you can add to a
      package.';
$ha=[];
$ia=q'my $fn = fn q{"hi"};
my $slice = ni(\'ni:lib/slice\')->new(\'myslice\', f => $fn);
$slice->apply(\'foo\');
now foo->f == \'hi\';';
$ja=bless({$V1,$ha,$E1,$ia,$G1,$H1},$e1);
$ka=q'TODO...';
$la=[$fa,$ga,$K9,$ja,$ka];
$ma=q'classes';
$na=q'ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni\'s classes are slice unions and as such don\'t
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn\'t in the picture,
      which makes multiple inheritance straightforward to implement.';
$oa=[$ma,$na,$ka];
$pa=[$Z9,$ea,$la,$oa];
$qa=bless({$W2,$pa,$f,$T},$d1);
$ra=q'lib/doc::ctors';
$sa=q'ni.doc:lib/doc';
$ta=q'
    ni("ni:some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...';
$ua=[$X9,$ta];
$va=q'Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class\'s code without bringing along all of
      its documentation and unit tests.';
$wa=q'Documentation objects are internally represented as arrays of quoted
      method calls:';
$xa=[];
$ya=q'my $doc = ni("ni:lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];';
$za=bless({$V1,$xa,$E1,$ya,$G1,$H1},$e1);
$Aa=q'This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":';
$Ba=[];
$Ca=q'my $doc = ni("ni:lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];';
$Da=bless({$V1,$Ba,$E1,$Ca,$G1,$H1},$e1);
$Ea=[$ca,$va,$wa,$K9,$za,$Aa,$K9,$Da];
$Fa=[$ua,$Ea];
$Ga=bless({$W2,$Fa,$f,$d1},$d1);
$Ha=q'ni.doc:unix/cat';
$Ia=q'
    my $combined = ni(\'ni:unix/cat\')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  ';
$Ja=[$X9,$Ia];
$Ka=q'Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.';
$La=[$ca,$Ka];
$Ma=[];
$Na=q'my $cat = ni("str:foo") + ni("str:bar");
$cat->into(ni(\'ni:unix/str\')->new(my $data = ""));
now $data == "foo\\nbar\\n";';
$Oa=bless({$V1,$Ma,$E1,$Na,$G1,$H1},$e1);
$Pa=[$K9,$Oa];
$Qa=[$Ja,$La,$Pa];
$Ra=bless({$W2,$Qa,$f,$k1},$d1);
$Sa=q'ni.doc:unix/pid';
$Ta=q'
    my $pid = ni::fork {something};
    my $pid = ni::fork_with(stdin => $mypipe, ..., sub {something});
    my $pid = ni::fork_exec("ls", "-l")';
$Ua=[$X9,$Ta];
$Va=[];
$Wa=q'my $pid = ni("sh:seq 4");
$pid->into(ni("ni:unix/str")->new(my $data));
now $pid->await == 0;
now $data == "1\\n2\\n3\\n4\\n";';
$Xa=bless({$V1,$Va,$E1,$Wa,$G1,$H1},$e1);
$Ya=[$K9,$Xa];
$Za=[$Ua,$Ya];
$cb=bless({$W2,$Za,$f,$p1},$d1);
$db=q'ni:class';
$eb=q'ni:class.c';
$fb=q'ni:lib/accessor.b';
$gb=q'ni:lib/behavior';
$hb=q'ni:lib/behavior.c';
$ib=q'ni:lib/branch';
$jb=q'ni:lib/branch.b';
$kb=q'ni:lib/branch.c';
$lb=q'ni:lib/branch_init.b';
$mb=q'ni:lib/class_init.b';
$nb=q'ni:lib/dataslice';
$ob={$n,1};
$pb=[$M];
$qb=bless({$c,$ob,$f,$n,$g,$pb},$G);
$rb=q'metaclass::ctors';
$sb={$W,1};
$tb={};
$ub=q'my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};';
$vb=bless({$E1,$ub,$G1,$H1},$e1);
$wb={$N1,$vb};
$xb=q'lib/dataslice_init.b';
$yb=bless({$c,$tb,$u1,$v1,$w1,$v1,$x1,$wb,$f,$xb},$R);
$zb=q'lib/slice::ctors';
$Ab={};
$Bb=q'local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;';
$Cb=bless({$E1,$Bb,$G1,$H1},$e1);
$Db={$A3,$Cb};
$Eb=q'lib/dataslice_apply.b';
$Fb=bless({$c,$Ab,$u1,$v1,$w1,$v1,$x1,$Db,$f,$Eb},$R);
$Gb=q'lib/slice::ctors';
$Hb=[$h3,$yb,$Fb];
$Ib=bless({$c,$sb,$f,$W,$g,$Hb},$n);
$Jb=q'lib/dataslice.c::ctors';
$Kb=q'ni:lib/dataslice.c';
$Lb=q'ni:lib/dataslice_apply.b';
$Mb=q'ni:lib/dataslice_init.b';
$Nb=q'ni:lib/definition.b';
$Ob=q'ni:lib/definition_def.b';
$Pb=q'ni:lib/definition_defdata.b';
$Qb=q'ni:lib/doc';
$Rb=q'ni:lib/doc.c';
$Sb=q'ni:lib/doc_define.b';
$Tb=q'ni:lib/doc_init.b';
$Ub=q'ni:lib/doc_namespace.b';
$Vb=q'ni:lib/doc_test.b';
$Wb=q'ni:lib/documentable.b';
$Xb=q'ni:lib/fn';
$Yb=q'ni:lib/fn.c';
$Zb=q'ni:lib/fn_init.b';
$cc=q'ni:lib/fn_ops.b';
$dc=q'ni:lib/fn_ro.b';
$ec=q'ni:lib/fn_serialize.b';
$fc=q'ni:lib/global_static_test.b';
$gc={};
$hc=q'now';
$ic=[];
$jc=q'ni(\'ni:lib/test_value\')->new(shift)';
$kc=q'($)';
$lc=bless({$V1,$ic,$E1,$jc,$G1,$kc},$e1);
$mc={$hc,$lc};
$nc=q'lib/global_static_test.b';
$oc=bless({$c,$gc,$u1,$v1,$w1,$v1,$x1,$mc,$f,$nc},$R);
$pc=q'main';
$qc=q'lib/slice::ctors';
$rc=q'ni:lib/image';
$sc={$q,1};
$tc=[$H];
$uc=bless({$c,$sc,$f,$q,$g,$tc},$G);
$vc=q'metaclass::ctors';
$wc={$f1,1};
$xc={};
$yc=[];
$zc=q'my $class = shift;
my %args  = (
  include_shebang => 1,
  include_license => 1,
  include_boot    => 1,
  include_classes => 1,
  include_run     => 1,
  local_vars      => 0,
  use_newlines    => 0,
  @_);

+{include_shebang => $args{include_shebang},
  include_license => $args{include_license},
  include_boot    => $args{include_boot},
  include_classes => $args{include_classes},
  include_run     => $args{include_run},
  local_vars      => $args{local_vars},
  use_newlines    => $args{use_newlines},

  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};';
$Ac=bless({$V1,$yc,$E1,$zc,$G1,$H1},$e1);
$Bc={$N1,$Ac};
$Cc=q'lib/image_init.b';
$Dc=bless({$c,$xc,$u1,$v1,$w1,$v1,$x1,$Bc,$f,$Cc},$R);
$Ec=q'lib/slice::ctors';
$Fc={};
$Gc=q'address';
$Hc=[];
$Ic=q'return \'undef\' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 16;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);';
$Jc=bless({$V1,$Hc,$E1,$Ic,$G1,$H1},$e1);
$Kc=q'allocate_gensym';
$Lc=[];
$Mc=q'my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;';
$Nc=bless({$V1,$Lc,$E1,$Mc,$G1,$H1},$e1);
$Oc=q'boot_side_effect';
$Pc=[];
$Qc=q'unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]';
$Rc=bless({$V1,$Pc,$E1,$Qc,$G1,$H1},$e1);
$Sc=q'circular_links';
$Tc=[];
$Uc=q'local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};';
$Vc=bless({$V1,$Tc,$E1,$Uc,$G1,$H1},$e1);
$Wc=q'finalizer';
$Xc=[];
$Yc=q'push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]';
$Zc=bless({$V1,$Xc,$E1,$Yc,$G1,$H1},$e1);
$cd=q'gensym';
$dd=[];
$ed=q'my $n = shift->{gensym_n}++;
my $s = \'$\' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;';
$fd=bless({$V1,$dd,$E1,$ed,$G1,$H1},$e1);
$gd=q'is_circular';
$hd=[];
$id=q'my $self = shift;
ref $$self{visited}{$self->address($_[0])};';
$jd=bless({$V1,$hd,$E1,$id,$G1,$H1},$e1);
$kd=q'quote';
$ld=[];
$md=q'my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? \'undef\' : $v if defined $v;
$$self{visited}{$a} = \\\'undef\';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));';
$nd=bless({$V1,$ld,$E1,$md,$G1,$H1},$e1);
$od=q'quote_array';
$pd=[];
$qd=q'local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_])
  && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
for 0..$#{$v};
\'[\' . join(\',\', map $self->quote($_), @$v) . \']\';';
$rd=bless({$V1,$pd,$E1,$qd,$G1,$H1},$e1);
$sd=q'quote_blessed';
$td=[];
$ud=q'my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq \'HASH\' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";';
$vd=bless({$V1,$td,$E1,$ud,$G1,$H1},$e1);
$wd=q'quote_class';
$xd=[];
$yd=q'my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");';
$zd=bless({$V1,$xd,$E1,$yd,$G1,$H1},$e1);
$Ad=q'quote_hash';
$Bd=[];
$Cd=q'local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  push @{$$self{circular}}, [$a, "{" . $self->quote($k) . "}",
                                 $self->address($$v{$k})]
  if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
\'{\' . join(",", @qs) . \'}\';';
$Dd=bless({$V1,$Bd,$E1,$Cd,$G1,$H1},$e1);
$Ed=q'quote_object';
$Fd=[];
$Gd=q'my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can(\'serialize\') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;';
$Hd=bless({$V1,$Fd,$E1,$Gd,$G1,$H1},$e1);
$Id=q'quote_scalar';
$Jd=[];
$Kd=q'my $v = $_[1];
return \'undef\' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\'])/\\\\$1/g;
"q\'$v\'";';
$Ld=bless({$V1,$Jd,$E1,$Kd,$G1,$H1},$e1);
$Md=q'quote_value';
$Nd=[];
$Od=q'my $self = shift;
return $self->quote_scalar($_[0]) unless ref $_[0];
return $self->quote_array($_[0])  if \'ARRAY\' eq ref $_[0];
return $self->quote_hash($_[0])   if \'HASH\'  eq ref $_[0];
die "cannot serialize $_[0]"      if \'CODE\'  eq ref $_[0];
$self->quote_object($_[0]);';
$Pd=bless({$V1,$Nd,$E1,$Od,$G1,$H1},$e1);
$Qd=q'reconstruction';
$Rd=[];
$Sd=q'my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});';
$Td=bless({$V1,$Rd,$E1,$Sd,$G1,$H1},$e1);
$Ud=q'side_effect';
$Vd=[];
$Wd=q'push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]';
$Xd=bless({$V1,$Vd,$E1,$Wd,$G1,$H1},$e1);
$Yd=q'write';
$Zd=[];
$ce=q'local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  ($$self{include_shebang} ? ("#!/usr/bin/env perl\\n") : ()),
  ($$self{include_license} ? ("chomp(\\$ni::license=<<\'_\');\\n", $ni::license, "\\n_\\n") : ()),
  ($$self{include_boot}    ? ("BEGIN{eval(\\$ni::boot=<<\'_\')}\\n", $ni::boot, "\\n_\\n") : ()),
  ($$self{use_newlines}    ? map("$_\\n", $self->reconstruction) : $self->reconstruction),
  ($$self{include_run}     ? ("ni->run(\\@ARGV);", "\\n__DATA__\\n") : ());';
$de=bless({$V1,$Zd,$E1,$ce,$G1,$H1},$e1);
$ee={$Gc,$Jc,$Kc,$Nc,$Oc,$Rc,$Sc,$Vc,$Wc,$Zc,$cd,$fd,$gd,$jd,$kd,$nd,$od,$rd,$sd,$vd,$wd,$zd,$Ad,$Dd,$Ed,$Hd,$Id,$Ld,$Md,$Pd,$Qd,$Td,$Ud,$Xd,$Yd,$de};
$fe=q'lib/image_quoting.b';
$ge=bless({$c,$Fc,$u1,$v1,$w1,$v1,$x1,$ee,$f,$fe},$R);
$he=q'lib/slice::ctors';
$ie=[$T2,$Dc,$ge];
$je=bless({$c,$wc,$f,$f1,$g,$ie},$q);
$ke=q'lib/image.c::ctors';
$le=q'ni:lib/image.c';
$me=q'ni:lib/image_init.b';
$ne=q'ni:lib/image_quoting.b';
$oe=q'ni:lib/instance.b';
$pe=q'ni:lib/instantiable.b';
$qe=q'ni:lib/json.b';
$re={};
$se=q'json_decode';
$te=[];
$ue=q'local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];';
$ve=bless({$V1,$te,$E1,$ue,$G1,$kc},$e1);
$we=q'json_encode';
$xe=[];
$ye=q'local $_;
my ($v) = @_;
return "[" . join(\',\', map ni::json_encode($_), @$v) . "]" if \'ARRAY\' eq ref $v;
return "{" . join(\',\', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if \'HASH\' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : \'null\';';
$ze=bless({$V1,$xe,$E1,$ye,$G1,$kc},$e1);
$Ae=q'json_escape';
$Be=[];
$Ce=q'(my $x = $_[0]) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . $ni::json_escapes{$1}/eg;
"\\"$x\\"";';
$De=bless({$V1,$Be,$E1,$Ce,$G1,$kc},$e1);
$Ee=q'json_unescape';
$Fe=[];
$Ge=q'my $x = substr $_[0], 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;';
$He=bless({$V1,$Fe,$E1,$Ge,$G1,$kc},$e1);
$Ie=q'json_unescape_one';
$Je=[];
$Ke=q'$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1';
$Le=bless({$V1,$Je,$E1,$Ke,$G1,$kc},$e1);
$Me={$se,$ve,$we,$ze,$Ae,$De,$Ee,$He,$Ie,$Le};
$Ne=q'lib/json.b';
$Oe=bless({$c,$re,$u1,$v1,$w1,$v1,$x1,$Me,$f,$Ne},$R);
$Pe=q'ni';
$Qe=q'lib/slice::ctors';
$Re=q'ni:lib/name_as_string.b';
$Se=q'ni:lib/named.b';
$Te=q'ni:lib/named_in_ni.b';
$Ue=q'ni:lib/namespaced.b';
$Ve=q'ni:lib/ni';
$We=q'ni:lib/ni.c';
$Xe=q'ni:lib/ni_fork.b';
$Ye={};
$Ze=q'fork';
$cf=[];
$df=q'ni::fork_with(shift)';
$ef=q'(&)';
$ff=bless({$V1,$cf,$E1,$df,$G1,$ef},$e1);
$gf=q'fork_with';
$hf=[];
$if=q'my $fn     = pop;
my %pipes  = @_;
my $stdin  = $pipes{stdin}  || ni(\'ni:unix/fifo\')->new;
my $stdout = $pipes{stdout} || ni(\'ni:unix/fifo\')->new;
my $stderr = $pipes{stderr} || ni(\'ni:unix/fifo\')->new;
my $pid    = fork;
die "ni:unix/pid.c: failed to fork: $!" unless defined $pid;

return ni(\'ni:unix/pid\')->new($pid,
  $pipes{stdin}  ? undef : $stdin->write_side,
  $pipes{stdout} ? undef : $stdout->read_side,
  $pipes{stderr} ? undef : $stderr->read_side) if $pid;

$stdin->read_side;
$stdout->write_side;
$stderr->write_side;
exit &$fn($stdin, $stdout, $stderr);';
$jf=bless({$V1,$hf,$E1,$if,$G1,$H1},$e1);
$kf={$Ze,$ff,$gf,$jf};
$lf=q'lib/ni_fork.b';
$mf=bless({$c,$Ye,$u1,$v1,$w1,$v1,$x1,$kf,$f,$lf},$R);
$nf=q'lib/slice::ctors';
$of=q'ni:lib/ni_fork_exec.b';
$pf={};
$qf=q'fork_exec';
$rf=[];
$sf=q'my @argv = @_;
ni::fork {
  my ($stdin, $stdout, $stderr) = @_;
  my $fd0 = ni(\'ni:unix/fd\')->new(fileno $stdin->read_side->read_fh)->move_to(0);
  my $fd1 = ni(\'ni:unix/fd\')->new(fileno $stdout->write_side->write_fh)->move_to(1);
  my $fd2 = ni(\'ni:unix/fd\')->new(fileno $stderr->write_side->write_fh)->move_to(2);
  exec @argv or die "ni:unix/pid.c: failed to exec @argv: $!";
};';
$tf=bless({$V1,$rf,$E1,$sf,$G1,$H1},$e1);
$uf={$qf,$tf};
$vf=q'lib/ni_fork_exec.b';
$wf=bless({$c,$pf,$u1,$v1,$w1,$v1,$x1,$uf,$f,$vf},$R);
$xf=q'lib/slice::ctors';
$yf=q'ni:lib/ni_image.b';
$zf=q'ni:lib/ni_main.b';
$Af=q'ni:lib/ni_resolver.b';
$Bf=q'ni:lib/ni_self.b';
$Cf=q'ni:lib/ni_static_util.b';
$Df={};
$Ef=q'abbrev';
$Ff=[];
$Gf=q'length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . \'...\'';
$Hf=bless({$V1,$Ff,$E1,$Gf,$G1,$H1},$e1);
$If=q'dor';
$Jf=[];
$Kf=q'defined $_[0] ? $_[0] : $_[1]';
$Lf=bless({$V1,$Jf,$E1,$Kf,$G1,$H1},$e1);
$Mf=q'indent';
$Nf=[];
$Of=q'my ($s, $indent) = (@_, 2);
join "\\n", map \' \' x $indent . $_, split /\\n/, $s;';
$Pf=bless({$V1,$Nf,$E1,$Of,$G1,$H1},$e1);
$Qf=q'max';
$Rf=[];
$Sf=q'local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m';
$Tf=bless({$V1,$Rf,$E1,$Sf,$G1,$H1},$e1);
$Uf=q'maxstr';
$Vf=[];
$Wf=q'local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m';
$Xf=bless({$V1,$Vf,$E1,$Wf,$G1,$H1},$e1);
$Yf=q'mean';
$Zf=[];
$cg=q'sum(@_) / (@_ || 1)';
$dg=bless({$V1,$Zf,$E1,$cg,$G1,$H1},$e1);
$eg=q'min';
$fg=[];
$gg=q'local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m';
$hg=bless({$V1,$fg,$E1,$gg,$G1,$H1},$e1);
$ig=q'minstr';
$jg=[];
$kg=q'local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m';
$lg=bless({$V1,$jg,$E1,$kg,$G1,$H1},$e1);
$mg=q'sgr';
$ng=[];
$og=q'(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x';
$pg=bless({$V1,$ng,$E1,$og,$G1,$H1},$e1);
$qg=q'sr';
$rg=[];
$sg=q'(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x';
$tg=bless({$V1,$rg,$E1,$sg,$G1,$H1},$e1);
$ug=q'sum';
$vg=[];
$wg=q'local $_; my $x = 0; $x += $_ for @_; $x';
$xg=bless({$V1,$vg,$E1,$wg,$G1,$H1},$e1);
$yg=q'swap';
$zg=[];
$Ag=q'@_[0, 1] = @_[1, 0]';
$Bg=bless({$V1,$zg,$E1,$Ag,$G1,$H1},$e1);
$Cg={$Ef,$Hf,$If,$Lf,$Mf,$Pf,$Qf,$Tf,$Uf,$Xf,$Yf,$dg,$eg,$hg,$ig,$lg,$mg,$pg,$qg,$tg,$ug,$xg,$yg,$Bg};
$Dg=q'lib/ni_static_util.b';
$Eg=bless({$c,$Df,$u1,$v1,$w1,$v1,$x1,$Cg,$f,$Dg},$R);
$Fg=q'lib/slice::ctors';
$Gg=q'ni:lib/perlbranch.b';
$Hg=q'ni:lib/ref_eq.b';
$Ig=q'ni:lib/resolver.b';
$Jg=q'ni:lib/slice';
$Kg=q'ni:lib/slice.b';
$Lg=q'ni:lib/slice.c';
$Mg=q'ni:lib/slice_init.b';
$Ng=q'ni:lib/slice_serialize.b';
$Og=q'ni:lib/static_fn.b';
$Pg={};
$Qg=[];
$Rg=q'ni(\'ni:lib/fn\')->new(@_)';
$Sg=bless({$V1,$Qg,$E1,$Rg,$G1,$kc},$e1);
$Tg=q'fp';
$Ug=[];
$Vg=q'ni(\'ni:lib/fn\')->new(@_)';
$Wg=q'($$)';
$Xg=bless({$V1,$Ug,$E1,$Vg,$G1,$Wg},$e1);
$Yg={$e2,$Sg,$Tg,$Xg};
$Zg=q'lib/static_fn.b';
$ch=bless({$c,$Pg,$u1,$v1,$w1,$v1,$x1,$Yg,$f,$Zg},$R);
$dh=q'lib/slice::ctors';
$eh=q'ni:lib/subclass.b';
$fh=q'ni:lib/tag';
$gh=q'ni:lib/tag.b';
$hh=q'ni:lib/tag.c';
$ih=q'ni:lib/tag_init.b';
$jh=q'ni:lib/test_value';
$kh=q'lib/test_value.c';
$lh={$kh,1};
$mh=q'lib/test_value.c';
$nh=[$H];
$oh=bless({$c,$lh,$f,$mh,$g,$nh},$G);
$ph=q'metaclass::ctors';
$qh={$h1,1};
$rh={};
$sh=[];
$th=q'\\$_[1]';
$uh=bless({$V1,$sh,$E1,$th,$G1,$H1},$e1);
$vh={$N1,$uh};
$wh=q'lib/test_value_init.b';
$xh=bless({$c,$rh,$u1,$v1,$w1,$v1,$x1,$vh,$f,$wh},$R);
$yh=q'lib/slice::ctors';
$zh={};
$Ah=q'(==';
$Bh=[];
$Ch=q'my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;';
$Dh=bless({$V1,$Bh,$E1,$Ch,$G1,$H1},$e1);
$Eh=q'diff';
$Fh=[];
$Gh=q'my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq \'HASH\') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq \'ARRAY\') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq \'SCALAR\') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;';
$Hh=bless({$V1,$Fh,$E1,$Gh,$G1,$H1},$e1);
$Ih={$Ah,$Dh,$Eh,$Hh};
$Jh=q'lib/test_value_eq.b';
$Kh=bless({$c,$zh,$u1,$v1,$w1,$v1,$x1,$Ih,$f,$Jh},$R);
$Lh=q'lib/slice::ctors';
$Mh={};
$Nh=[];
$Oh=q'ni::json_encode ${$_[0]}';
$Ph=bless({$V1,$Nh,$E1,$Oh,$G1,$H1},$e1);
$Qh={$n2,$Ph};
$Rh=q'lib/test_value_str.b';
$Sh=bless({$c,$Mh,$u1,$v1,$w1,$v1,$x1,$Qh,$f,$Rh},$R);
$Th=q'lib/slice::ctors';
$Uh=[$T2,$xh,$Kh,$Sh];
$Vh=q'lib/test_value.c';
$Wh=bless({$c,$qh,$f,$h1,$g,$Uh},$Vh);
$Xh=q'lib/test_value.c::ctors';
$Yh=q'ni:lib/test_value.c';
$Zh=q'ni:lib/test_value_eq.b';
$ci=q'ni:lib/test_value_init.b';
$di=q'ni:lib/test_value_str.b';
$ei=q'ni:main';
$fi={$pc,1};
$gi=[$ch,$oc];
$hi=bless({$c,$fi,$f,$pc,$g,$gi},$Z);
$ii=q'module::ctors';
$ji=q'ni:metaclass';
$ki=q'ni:metaclass.c';
$li=q'ni:module';
$mi=q'ni:module.c';
$ni=q'ni:ni';
$oi={$Pe,1};
$pi={$Pe,1};
$qi=q'data';
$ri=q'json_escapes';
$si=q'';
$ti=q'b';
$ui=q'	';
$vi=q't';
$wi=q'
';
$xi=q'n';
$yi=q'';
$zi=q'r';
$Ai=q'"';
$Bi=q'/';
$Ci=q'\\';
$Di={$si,$ti,$ui,$vi,$wi,$xi,$yi,$zi,$Ai,$Ai,$Bi,$Bi,$Ci,$Ci};
$Ei=q'json_unescapes';
$Fi={$Ai,$Ai,$Bi,$Bi,$Ci,$Ci,$ti,$si,$xi,$wi,$zi,$yi,$vi,$ui};
$Gi={$ri,$Di,$Ei,$Fi};
$Hi=q'lib/json_data.b';
$Ii=bless({$c,$pi,$qi,$Gi,$f,$Hi},$W);
$Ji=q'lib/dataslice::ctors';
$Ki=[$Ii,$Oe,$Eg,$mf,$wf];
$Li=bless({$c,$oi,$f,$Pe,$g,$Ki},$Z);
$Mi=q'ni:object';
$Ni=q'ni:object.c';
$Oi=q'ni:unix/cat';
$Pi={$w,1};
$Qi={$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$Ri=[$H];
$Si=bless({$c,$Qi,$f,$A,$g,$Ri},$G);
$Ti=q'metaclass::ctors';
$Ui=[$Si];
$Vi=bless({$c,$Pi,$f,$w,$g,$Ui},$G);
$Wi=q'metaclass::ctors';
$Xi={$k1,1};
$Yi={$k1,1,$l1,1,$m1,1,$n1,1,$o1,1,$p1,1,$q1,1,$r1,1};
$Zi={};
$cj=q'into';
$dj=[];
$ej=q'local $_;
my ($self, $dest, $each) = @_;
my $block_size = $self->can(\'read_size\') ? $self->read_size : 8192;
while ($self->read($_, $block_size)) {
  &$each($_) if defined $each;
  $dest->write($_);
}';
$fj=bless({$V1,$dj,$E1,$ej,$G1,$H1},$e1);
$gj={$cj,$fj};
$hj=q'unix/io_stream.b';
$ij=bless({$c,$Zi,$u1,$v1,$w1,$v1,$x1,$gj,$f,$hj},$R);
$jj=q'lib/slice::ctors';
$kj={};
$lj=q'(+';
$mj=[];
$nj=q'ni(\'ni:unix/cat\')->new(@_[0, 1])';
$oj=bless({$V1,$mj,$E1,$nj,$G1,$H1},$e1);
$pj={$lj,$oj};
$qj=q'unix/io_constructors.b';
$rj=bless({$c,$kj,$u1,$v1,$w1,$v1,$x1,$pj,$f,$qj},$R);
$sj=q'lib/slice::ctors';
$tj={};
$uj=q'(<>';
$vj=[];
$wj=q'my $fh = shift->read_fh;
# TODO: buffered line reading with a pushback queue';
$xj=bless({$V1,$vj,$E1,$wj,$G1,$H1},$e1);
$yj=q'(@{}';
$zj=[];
$Aj=q'my $self = shift; [<$self>]';
$Bj=bless({$V1,$zj,$E1,$Aj,$G1,$H1},$e1);
$Cj={$uj,$xj,$yj,$Bj};
$Dj=q'unix/io_readers.b';
$Ej=bless({$c,$tj,$u1,$v1,$w1,$v1,$x1,$Cj,$f,$Dj},$R);
$Fj=q'lib/slice::ctors';
$Gj=[$T2,$ij,$rj,$Ej];
$Hj=bless({$c,$Yi,$f,$o1,$g,$Gj},$A);
$Ij=q'unix/io.c::ctors';
$Jj={};
$Kj=[];
$Lj=q'shift; +{fs => [@_]}';
$Mj=bless({$V1,$Kj,$E1,$Lj,$G1,$H1},$e1);
$Nj={$N1,$Mj};
$Oj=q'unix/cat_init.b';
$Pj=bless({$c,$Jj,$u1,$v1,$w1,$v1,$x1,$Nj,$f,$Oj},$R);
$Qj=q'lib/slice::ctors';
$Rj={};
$Sj=q'read';
$Tj=[];
$Uj=q'my $fs = shift->{fs};
my $n;
shift @$fs until !@$fs or $n = $$fs[0]->read(@_);
return $n;';
$Vj=bless({$V1,$Tj,$E1,$Uj,$G1,$H1},$e1);
$Wj={$Sj,$Vj};
$Xj=q'unix/cat_read.b';
$Yj=bless({$c,$Rj,$u1,$v1,$w1,$v1,$x1,$Wj,$f,$Xj},$R);
$Zj=q'lib/slice::ctors';
$ck=[$Hj,$Pj,$Yj];
$dk=bless({$c,$Xi,$f,$k1,$g,$ck},$w);
$ek=q'unix/cat.c::ctors';
$fk=q'ni:unix/cat.c';
$gk=q'ni:unix/cat_init.b';
$hk=q'ni:unix/cat_read.b';
$ik=q'ni:unix/fd';
$jk={$x,1};
$kk=[$Si];
$lk=bless({$c,$jk,$f,$x,$g,$kk},$G);
$mk=q'metaclass::ctors';
$nk={$l1,1};
$ok={};
$pk=q'fd';
$qk=[];
$rk=q'shift->{\'fd\'}';
$sk=bless({$V1,$qk,$E1,$rk,$G1,$H1},$e1);
$tk={$pk,$sk};
$uk=q'unix/fd_readers.b';
$vk=bless({$c,$ok,$u1,$v1,$w1,$v1,$x1,$tk,$f,$uk},$R);
$wk=q'lib/slice::ctors';
$xk={};
$yk=[];
$zk=q'my ($class, $fd) = @_;
+{fd => $fd, fh => undef};';
$Ak=bless({$V1,$yk,$E1,$zk,$G1,$H1},$e1);
$Bk={$N1,$Ak};
$Ck=q'unix/fd_init.b';
$Dk=bless({$c,$xk,$u1,$v1,$w1,$v1,$x1,$Bk,$f,$Ck},$R);
$Ek=q'lib/slice::ctors';
$Fk={};
$Gk=q'move_to';
$Hk=[];
$Ik=q'use POSIX qw/dup2/;
my ($self, $new) = @_;
return $self if $new == $$self{fd};
close $$self{fh} if Scalar::Util::openhandle $$self{fh};
dup2 $$self{fd}, $new or die "ni:unix/fd: dup2($$self{fd}, $new): $!";
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;';
$Jk=bless({$V1,$Hk,$E1,$Ik,$G1,$H1},$e1);
$Kk={$Gk,$Jk};
$Lk=q'unix/fd_shell.b';
$Mk=bless({$c,$Fk,$u1,$v1,$w1,$v1,$x1,$Kk,$f,$Lk},$R);
$Nk=q'lib/slice::ctors';
$Ok={$l1,1,$m1,1,$n1,1,$p1,1,$q1,1};
$Pk=q'unix/has_fd.b';
$Qk={};
$Rk=[];
$Sk=q'no warnings \'io\';
use Errno qw/EINTR/;
my $fh = shift->read_fh;
my $n;
do {
  return $n if defined($n = read $fh, $_[0], $_[1], $_[2] || 0);
} while $!{EINTR};
return undef;';
$Tk=bless({$V1,$Rk,$E1,$Sk,$G1,$H1},$e1);
$Uk=[];
$Vk=q'my $fh = shift->write_fh;
my $n;
do {
  return $n if defined($n = syswrite $fh, $_[0]);
} while $!{EINTR};
return undef;';
$Wk=bless({$V1,$Uk,$E1,$Vk,$G1,$H1},$e1);
$Xk={$Sj,$Tk,$Yd,$Wk};
$Yk=q'unix/fd_safeio.b';
$Zk=bless({$c,$Qk,$u1,$v1,$w1,$v1,$x1,$Xk,$f,$Yk},$R);
$cl=q'lib/slice::ctors';
$dl=[$Zk];
$el=bless({$c,$Ok,$f,$Pk,$g,$dl},$V);
$fl=q'lib/branch::ctors';
$gl={};
$hl=q'read_fh';
$il=[];
$jl=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'<&=\', $self->{fd}
  or die "ni:unix/fd $self->{fd} failed to read: $!";
$self->{fh} = $fh;';
$kl=bless({$V1,$il,$E1,$jl,$G1,$H1},$e1);
$ll=q'write_fh';
$ml=[];
$nl=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'>&=\', $self->{fd}
  or die "ni:unix/file $self->{fd} failed to write: $!";
$self->{fh} = $fh;';
$ol=bless({$V1,$ml,$E1,$nl,$G1,$H1},$e1);
$pl={$hl,$kl,$ll,$ol};
$ql=q'unix/fd_io.b';
$rl=bless({$c,$gl,$u1,$v1,$w1,$v1,$x1,$pl,$f,$ql},$R);
$sl=q'lib/slice::ctors';
$tl=[$Hj,$vk,$Dk,$Mk,$el,$rl];
$ul=bless({$c,$nk,$f,$l1,$g,$tl},$x);
$vl=q'unix/fd.c::ctors';
$wl=q'ni:unix/fd.c';
$xl=q'ni:unix/fd_init.b';
$yl=q'ni:unix/fd_io.b';
$zl=q'ni:unix/fd_readers.b';
$Al=q'ni:unix/fd_safeio.b';
$Bl=q'ni:unix/fd_shell.b';
$Cl=q'ni:unix/fifo';
$Dl={$y,1};
$El=[$Si];
$Fl=bless({$c,$Dl,$f,$y,$g,$El},$G);
$Gl=q'metaclass::ctors';
$Hl={$m1,1};
$Il={};
$Jl=[];
$Kl=q'shift->{\'read_fh\'}';
$Ll=bless({$V1,$Jl,$E1,$Kl,$G1,$H1},$e1);
$Ml=[];
$Nl=q'shift->{\'write_fh\'}';
$Ol=bless({$V1,$Ml,$E1,$Nl,$G1,$H1},$e1);
$Pl={$hl,$Ll,$ll,$Ol};
$Ql=q'unix/fifo_io.b';
$Rl=bless({$c,$Il,$u1,$v1,$w1,$v1,$x1,$Pl,$f,$Ql},$R);
$Sl=q'lib/slice::ctors';
$Tl={};
$Ul=[];
$Vl=q'my ($class) = @_;
pipe my ($r, $w) or die "ni:unix/fifo failed: $!";
+{read_fh => $r, write_fh => $w};';
$Wl=bless({$V1,$Ul,$E1,$Vl,$G1,$H1},$e1);
$Xl={$N1,$Wl};
$Yl=q'unix/fifo_init.b';
$Zl=bless({$c,$Tl,$u1,$v1,$w1,$v1,$x1,$Xl,$f,$Yl},$R);
$cm=q'lib/slice::ctors';
$dm={};
$em=q'read_side';
$fm=[];
$gm=q'my $self = shift; close $$self{write_fh}; $self';
$hm=bless({$V1,$fm,$E1,$gm,$G1,$H1},$e1);
$im=q'write_side';
$jm=[];
$km=q'my $self = shift; close $$self{read_fh};  $self';
$lm=bless({$V1,$jm,$E1,$km,$G1,$H1},$e1);
$mm={$em,$hm,$im,$lm};
$nm=q'unix/fifo_direction.b';
$om=bless({$c,$dm,$u1,$v1,$w1,$v1,$x1,$mm,$f,$nm},$R);
$pm=q'lib/slice::ctors';
$qm=[$Hj,$Rl,$Zl,$el,$om];
$rm=bless({$c,$Hl,$f,$m1,$g,$qm},$y);
$sm=q'unix/fifo.c::ctors';
$tm=q'ni:unix/fifo.c';
$um=q'ni:unix/fifo_direction.b';
$vm=q'ni:unix/fifo_init.b';
$wm=q'ni:unix/fifo_io.b';
$xm=q'ni:unix/file';
$ym={$z,1};
$zm=[$Si];
$Am=bless({$c,$ym,$f,$z,$g,$zm},$G);
$Bm=q'metaclass::ctors';
$Cm={$n1,1};
$Dm={};
$Em=[];
$Fm=q'shift->{\'name\'}';
$Gm=bless({$V1,$Em,$E1,$Fm,$G1,$H1},$e1);
$Hm={$f,$Gm};
$Im=q'unix/file_readers.b';
$Jm=bless({$c,$Dm,$u1,$v1,$w1,$v1,$x1,$Hm,$f,$Im},$R);
$Km=q'lib/slice::ctors';
$Lm={};
$Mm=[];
$Nm=q'my ($class, $name) = @_;
+{name => $name, fh => undef};';
$Om=bless({$V1,$Mm,$E1,$Nm,$G1,$H1},$e1);
$Pm={$N1,$Om};
$Qm=q'unix/file_init.b';
$Rm=bless({$c,$Lm,$u1,$v1,$w1,$v1,$x1,$Pm,$f,$Qm},$R);
$Sm=q'lib/slice::ctors';
$Tm={};
$Um=[];
$Vm=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'<\', $self->{name}
  or die "ni:unix/file $self->{name} failed to read: $!";
$self->{fh} = $fh;';
$Wm=bless({$V1,$Um,$E1,$Vm,$G1,$H1},$e1);
$Xm=[];
$Ym=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'>\', $self->{name}
  or die "ni:unix/file $self->{name} failed to write: $!";
$self->{fh} = $fh;';
$Zm=bless({$V1,$Xm,$E1,$Ym,$G1,$H1},$e1);
$cn={$hl,$Wm,$ll,$Zm};
$dn=q'unix/file_io.b';
$en=bless({$c,$Tm,$u1,$v1,$w1,$v1,$x1,$cn,$f,$dn},$R);
$fn=q'lib/slice::ctors';
$gn=[$Hj,$Jm,$Rm,$el,$en];
$hn=bless({$c,$Cm,$f,$n1,$g,$gn},$z);
$in=q'unix/file.c::ctors';
$jn=q'ni:unix/file.c';
$kn=q'ni:unix/file_init.b';
$ln=q'ni:unix/file_io.b';
$mn=q'ni:unix/file_readers.b';
$nn=q'ni:unix/has_fd.b';
$on=q'ni:unix/io';
$pn=q'ni:unix/io.c';
$qn=q'ni:unix/io_constructors.b';
$rn=q'ni:unix/io_readers.b';
$sn=q'ni:unix/io_stream.b';
$tn=q'ni:unix/pid';
$un={$B,1};
$vn=[$Si];
$wn=bless({$c,$un,$f,$B,$g,$vn},$G);
$xn=q'metaclass::ctors';
$yn={$p1,1};
$zn={};
$An=q'pid';
$Bn=[];
$Cn=q'shift->{\'pid\'}';
$Dn=bless({$V1,$Bn,$E1,$Cn,$G1,$H1},$e1);
$En=q'stderr';
$Fn=[];
$Gn=q'shift->{\'stderr\'}';
$Hn=bless({$V1,$Fn,$E1,$Gn,$G1,$H1},$e1);
$In=q'stdin';
$Jn=[];
$Kn=q'shift->{\'stdin\'}';
$Ln=bless({$V1,$Jn,$E1,$Kn,$G1,$H1},$e1);
$Mn=q'stdout';
$Nn=[];
$On=q'shift->{\'stdout\'}';
$Pn=bless({$V1,$Nn,$E1,$On,$G1,$H1},$e1);
$Qn={$An,$Dn,$En,$Hn,$In,$Ln,$Mn,$Pn};
$Rn=q'unix/pid_readers.b';
$Sn=bless({$c,$zn,$u1,$v1,$w1,$v1,$x1,$Qn,$f,$Rn},$R);
$Tn=q'lib/slice::ctors';
$Un={};
$Vn=[];
$Wn=q'shift->await';
$Xn=bless({$V1,$Vn,$E1,$Wn,$G1,$H1},$e1);
$Yn=[];
$Zn=q'my ($class, $pid, $i, $o, $e) = @_;
+{pid    => $pid,
  stdin  => $i,
  stdout => $o,
  stderr => $e,
  status => undef};';
$co=bless({$V1,$Yn,$E1,$Zn,$G1,$H1},$e1);
$do={$N1,$co};
$eo=q'unix/pid_init.b';
$fo=bless({$c,$Un,$u1,$v1,$w1,$Xn,$x1,$do,$f,$eo},$R);
$go=q'lib/slice::ctors';
$ho={};
$io=q'await';
$jo=[];
$ko=q'my $self = shift;
return $$self{status} if defined $$self{status};
$$self{status} = $? if waitpid $$self{pid}, 0;';
$lo=bless({$V1,$jo,$E1,$ko,$G1,$H1},$e1);
$mo={$io,$lo};
$no=q'unix/pid_wait.b';
$oo=bless({$c,$ho,$u1,$v1,$w1,$v1,$x1,$mo,$f,$no},$R);
$po=q'lib/slice::ctors';
$qo={};
$ro=[];
$so=q'shift->{stdout}->read_fh';
$to=bless({$V1,$ro,$E1,$so,$G1,$H1},$e1);
$uo=[];
$vo=q'shift->{stdin}->write_fh';
$wo=bless({$V1,$uo,$E1,$vo,$G1,$H1},$e1);
$xo={$hl,$to,$ll,$wo};
$yo=q'unix/pid_io.b';
$zo=bless({$c,$qo,$u1,$v1,$w1,$v1,$x1,$xo,$f,$yo},$R);
$Ao=q'lib/slice::ctors';
$Bo=[$Hj,$Sn,$fo,$oo,$el,$zo];
$Co=bless({$c,$yn,$f,$p1,$g,$Bo},$B);
$Do=q'unix/pid.c::ctors';
$Eo=q'ni:unix/pid.c';
$Fo=q'ni:unix/pid_init.b';
$Go=q'ni:unix/pid_io.b';
$Ho=q'ni:unix/pid_readers.b';
$Io=q'ni:unix/pid_wait.b';
$Jo=q'ni:unix/pipeline';
$Ko={$C,1};
$Lo=[$Si];
$Mo=bless({$c,$Ko,$f,$C,$g,$Lo},$G);
$No=q'metaclass::ctors';
$Oo={$q1,1};
$Po={};
$Qo=[];
$Ro=q'shift->{\'stdin\'}';
$So=bless({$V1,$Qo,$E1,$Ro,$G1,$H1},$e1);
$To=[];
$Uo=q'shift->{\'stdout\'}';
$Vo=bless({$V1,$To,$E1,$Uo,$G1,$H1},$e1);
$Wo={$In,$So,$Mn,$Vo};
$Xo=q'unix/pipeline_ro.b';
$Yo=bless({$c,$Po,$u1,$v1,$w1,$v1,$x1,$Wo,$f,$Xo},$R);
$Zo=q'lib/slice::ctors';
$cp={};
$dp=[];
$ep=q'my $class  = shift;
my $stdin  = ni(\'ni:unix/fifo\')->new;
my $stdout = ni(\'ni:unix/fifo\')->new;
# TODO: stderr and multiplexing, which probably happens here

my @rs = ($stdin, @_);
my @ws = (@_, $stdout);
my $rv; vec($rv, fileno $_->read_fh,  1) = 1 for @rs;
my $wv; vec($wv, fileno $_->write_fh, 1) = 1 for @ws;

+{ps     => [@_],
  stdin  => $stdin,
  stdout => $stdout,
  rs => \\@rs, rv => $rv,
  ws => \\@ws, wv => $wv};';
$fp=bless({$V1,$dp,$E1,$ep,$G1,$H1},$e1);
$gp={$N1,$fp};
$hp=q'unix/pipeline_init.b';
$ip=bless({$c,$cp,$u1,$v1,$w1,$v1,$x1,$gp,$f,$hp},$R);
$jp=q'lib/slice::ctors';
$kp={};
$lp=q'async_step';
$mp=[];
$np=q'local $_;
my $self = shift;
my $rv = $$self{rv};
my $wv = $$self{wv};
my $ev = $$self{ev};
return $self unless select $rv, $wv, $ev, 0;
for my $i (0..$#{$$self{rs}}) {
  my $rfh = $$self{rs}[$i]->read_fh;
  my $wfh = $$self{ws}[$i]->write_fh;
  next unless vec $rv, fileno $rfh, 1 and vec $wv, fileno $wfh, 1;
  $$self{rs}[$i]->read($_, 8192);
  $$self{ws}[$i]->write($_);
}
$self;';
$op=bless({$V1,$mp,$E1,$np,$G1,$H1},$e1);
$pp={$lp,$op};
$qp=q'unix/pipeline_async.b';
$rp=bless({$c,$kp,$u1,$v1,$w1,$v1,$x1,$pp,$f,$qp},$R);
$sp=q'lib/slice::ctors';
$tp={};
$up=[];
$vp=q'shift->{stdout}->read_fh';
$wp=bless({$V1,$up,$E1,$vp,$G1,$H1},$e1);
$xp=[];
$yp=q'shift->{stdin}->write_fh';
$zp=bless({$V1,$xp,$E1,$yp,$G1,$H1},$e1);
$Ap={$hl,$wp,$ll,$zp};
$Bp=q'unix/pipeline_io.b';
$Cp=bless({$c,$tp,$u1,$v1,$w1,$v1,$x1,$Ap,$f,$Bp},$R);
$Dp=q'lib/slice::ctors';
$Ep=[$Hj,$Yo,$ip,$rp,$el,$Cp];
$Fp=bless({$c,$Oo,$f,$q1,$g,$Ep},$C);
$Gp=q'unix/pipeline.c::ctors';
$Hp=q'ni:unix/pipeline.c';
$Ip=q'ni:unix/pipeline_async.b';
$Jp=q'ni:unix/pipeline_init.b';
$Kp=q'ni:unix/pipeline_io.b';
$Lp=q'ni:unix/pipeline_ro.b';
$Mp=q'ni:unix/str';
$Np={$D,1};
$Op=[$Si];
$Pp=bless({$c,$Np,$f,$D,$g,$Op},$G);
$Qp=q'metaclass::ctors';
$Rp={$r1,1};
$Sp={};
$Tp=[];
$Up=q'shift->{\'data\'}';
$Vp=bless({$V1,$Tp,$E1,$Up,$G1,$H1},$e1);
$Wp=q'end';
$Xp=[];
$Yp=q'shift->{\'end\'}';
$Zp=bless({$V1,$Xp,$E1,$Yp,$G1,$H1},$e1);
$cq=q'start';
$dq=[];
$eq=q'shift->{\'start\'}';
$fq=bless({$V1,$dq,$E1,$eq,$G1,$H1},$e1);
$gq={$qi,$Vp,$Wp,$Zp,$cq,$fq};
$hq=q'unix/str_ro.b';
$iq=bless({$c,$Sp,$u1,$v1,$w1,$v1,$x1,$gq,$f,$hq},$R);
$jq=q'lib/slice::ctors';
$kq={};
$lq=[];
$mq=q'my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};';
$nq=bless({$V1,$lq,$E1,$mq,$G1,$H1},$e1);
$oq={$N1,$nq};
$pq=q'unix/str_init.b';
$qq=bless({$c,$kq,$u1,$v1,$w1,$v1,$x1,$oq,$f,$pq},$R);
$rq=q'lib/slice::ctors';
$sq={};
$tq=[];
$uq=q'my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;';
$vq=bless({$V1,$tq,$E1,$uq,$G1,$H1},$e1);
$wq=q'remaining';
$xq=[];
$yq=q'my $self = shift; $$self{end} - $$self{start}';
$zq=bless({$V1,$xq,$E1,$yq,$G1,$H1},$e1);
$Aq=[];
$Bq=q'my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];';
$Cq=bless({$V1,$Aq,$E1,$Bq,$G1,$H1},$e1);
$Dq={$Sj,$vq,$wq,$zq,$Yd,$Cq};
$Eq=q'unix/str_io.b';
$Fq=bless({$c,$sq,$u1,$v1,$w1,$v1,$x1,$Dq,$f,$Eq},$R);
$Gq=q'lib/slice::ctors';
$Hq=[$Hj,$iq,$qq,$Fq];
$Iq=bless({$c,$Rp,$f,$r1,$g,$Hq},$D);
$Jq=q'unix/str.c::ctors';
$Kq=q'ni:unix/str.c';
$Lq=q'ni:unix/str_init.b';
$Mq=q'ni:unix/str_io.b';
$Nq=q'ni:unix/str_ro.b';
$Oq={$h9,$qa,$sa,$Ga,$Ha,$Ra,$Sa,$cb,$db,$A7,$eb,$q4,$fb,$G6,$gb,$h3,$hb,$M,$ib,$j6,$jb,$d5,$kb,$W5,$lb,$g6,$mb,$R5,$nb,$Ib,$Kb,$qb,$Lb,$Fb,$Mb,$yb,$Nb,$l7,$Ob,$u6,$Pb,$h7,$Qb,$V9,$Rb,$k9,$Sb,$H9,$Tb,$s9,$Ub,$z9,$Vb,$S9,$Wb,$d3,$Xb,$J2,$Yb,$A1,$Zb,$S1,$cc,$x2,$dc,$k2,$ec,$G2,$fc,$oc,$rc,$je,$le,$uc,$me,$Dc,$ne,$ge,$oe,$P2,$pe,$j4,$qe,$Oe,$Re,$O6,$Se,$q3,$Te,$m5,$Ue,$v5,$Ve,$e9,$We,$L7,$Xe,$mf,$of,$wf,$yf,$o8,$zf,$N8,$Af,$Z8,$Bf,$Z7,$Cf,$Eg,$Gg,$I5,$Hg,$W6,$Ig,$E5,$Jg,$W3,$Kg,$E3,$Lg,$P,$Mg,$L3,$Ng,$T3,$Og,$ch,$eh,$w7,$fh,$Q4,$gh,$G4,$hh,$y4,$ih,$N4,$jh,$Wh,$Yh,$oh,$Zh,$Kh,$ci,$xh,$di,$Sh,$ei,$hi,$ji,$H7,$ki,$D7,$li,$o7,$mi,$n4,$ni,$Li,$Mi,$T2,$Ni,$H,$Oi,$dk,$fk,$Vi,$gk,$Pj,$hk,$Yj,$ik,$ul,$wl,$lk,$xl,$Dk,$yl,$rl,$zl,$vk,$Al,$Zk,$Bl,$Mk,$Cl,$rm,$tm,$Fl,$um,$om,$vm,$Zl,$wm,$Rl,$xm,$hn,$jn,$Am,$kn,$Rm,$ln,$en,$mn,$Jm,$nn,$el,$on,$Hj,$pn,$Si,$qn,$rj,$rn,$Ej,$sn,$ij,$tn,$Co,$Eo,$wn,$Fo,$fo,$Go,$zo,$Ho,$Sn,$Io,$oo,$Jo,$Fp,$Hp,$Mo,$Ip,$rp,$Jp,$ip,$Kp,$Cp,$Lp,$Yo,$Mp,$Iq,$Kq,$Pp,$Lq,$qq,$Mq,$Fq,$Nq,$iq};
$Pq=q'resolvers';
$Qq=[];
$Rq=q'my $f = shift;
$f =~ s/^fd:(?:\\/\\/)?//;
ni(\'ni:unix/fd\')->new($f);';
$Sq=bless({$V1,$Qq,$E1,$Rq,$G1,$H1},$e1);
$Tq=q'file';
$Uq=[];
$Vq=q'my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni(\'ni:unix/file\')->new($f);';
$Wq=bless({$V1,$Uq,$E1,$Vq,$G1,$H1},$e1);
$Xq=q'sh';
$Yq=[];
$Zq=q'ni::fork_exec \'/bin/sh\', \'-c\', substr shift, 3';
$cr=bless({$V1,$Yq,$E1,$Zq,$G1,$H1},$e1);
$dr=q'str';
$er=[];
$fr=q'my $s = shift;
ni(\'ni:unix/str\')->new(substr($s, 4) . "\\n");';
$gr=bless({$V1,$er,$E1,$fr,$G1,$H1},$e1);
$hr={$pk,$Sq,$Tq,$Wq,$Xq,$cr,$dr,$gr};
$ir=bless({$g9,$Oq,$Pq,$hr},$g1);
$jr=q'lib/ni::ctors';
$$F[0]=$A7;
$$I2[0]=$T2;
$$I2[1]=$j4;
$$i6[4]=$l7;
*$y3=\&$w3;
*$x3=\&$u3;
$S1->apply_unsafe($e1);
$k2->apply_unsafe($e1);
$x2->apply_unsafe($e1);
$G2->apply_unsafe($e1);
$P2->apply_unsafe($T);
$P2->apply_unsafe($h);
$P2->apply_unsafe($U);
$P2->apply_unsafe($l);
$P2->apply_unsafe($V);
$P2->apply_unsafe($m);
$P2->apply_unsafe($W);
$P2->apply_unsafe($n);
$P2->apply_unsafe($d1);
$P2->apply_unsafe($o);
$P2->apply_unsafe($e1);
$P2->apply_unsafe($p);
$P2->apply_unsafe($f1);
$P2->apply_unsafe($q);
$P2->apply_unsafe($g1);
$P2->apply_unsafe($r);
$P2->apply_unsafe($R);
$P2->apply_unsafe($s);
$P2->apply_unsafe($X);
$P2->apply_unsafe($t);
$P2->apply_unsafe($h1);
$P2->apply_unsafe($Q2);
$P2->apply_unsafe($G);
$P2->apply_unsafe($d);
$P2->apply_unsafe($Z);
$P2->apply_unsafe($j);
$P2->apply_unsafe($j1);
$P2->apply_unsafe($v);
$P2->apply_unsafe($k1);
$P2->apply_unsafe($w);
$P2->apply_unsafe($l1);
$P2->apply_unsafe($x);
$P2->apply_unsafe($m1);
$P2->apply_unsafe($y);
$P2->apply_unsafe($n1);
$P2->apply_unsafe($z);
$P2->apply_unsafe($o1);
$P2->apply_unsafe($A);
$P2->apply_unsafe($p1);
$P2->apply_unsafe($B);
$P2->apply_unsafe($q1);
$P2->apply_unsafe($C);
$P2->apply_unsafe($r1);
$P2->apply_unsafe($D);
$d3->apply_unsafe($T);
$d3->apply_unsafe($h);
$d3->apply_unsafe($U);
$d3->apply_unsafe($l);
$d3->apply_unsafe($V);
$d3->apply_unsafe($m);
$d3->apply_unsafe($W);
$d3->apply_unsafe($n);
$d3->apply_unsafe($o);
$d3->apply_unsafe($p);
$d3->apply_unsafe($q);
$d3->apply_unsafe($r);
$d3->apply_unsafe($R);
$d3->apply_unsafe($s);
$d3->apply_unsafe($X);
$d3->apply_unsafe($t);
$d3->apply_unsafe($e3);
$d3->apply_unsafe($G);
$d3->apply_unsafe($d);
$d3->apply_unsafe($Z);
$d3->apply_unsafe($j);
$d3->apply_unsafe($v);
$d3->apply_unsafe($w);
$d3->apply_unsafe($x);
$d3->apply_unsafe($y);
$d3->apply_unsafe($z);
$d3->apply_unsafe($A);
$d3->apply_unsafe($B);
$d3->apply_unsafe($C);
$d3->apply_unsafe($D);
$q3->apply_unsafe($T);
$q3->apply_unsafe($h);
$q3->apply_unsafe($l);
$q3->apply_unsafe($V);
$q3->apply_unsafe($m);
$q3->apply_unsafe($n);
$q3->apply_unsafe($d1);
$q3->apply_unsafe($o);
$q3->apply_unsafe($p);
$q3->apply_unsafe($q);
$q3->apply_unsafe($r);
$q3->apply_unsafe($R);
$q3->apply_unsafe($s);
$q3->apply_unsafe($X);
$q3->apply_unsafe($t);
$q3->apply_unsafe($r3);
$q3->apply_unsafe($G);
$q3->apply_unsafe($d);
$q3->apply_unsafe($Z);
$q3->apply_unsafe($j);
$q3->apply_unsafe($v);
$q3->apply_unsafe($w);
$q3->apply_unsafe($x);
$q3->apply_unsafe($y);
$q3->apply_unsafe($z);
$q3->apply_unsafe($A);
$q3->apply_unsafe($B);
$q3->apply_unsafe($C);
$q3->apply_unsafe($D);
$E3->apply_unsafe($R);
$L3->apply_unsafe($R);
$T3->apply_unsafe($R);
$j4->apply_unsafe($T);
$j4->apply_unsafe($h);
$j4->apply_unsafe($l);
$j4->apply_unsafe($m);
$j4->apply_unsafe($n);
$j4->apply_unsafe($o);
$j4->apply_unsafe($e1);
$j4->apply_unsafe($p);
$j4->apply_unsafe($q);
$j4->apply_unsafe($r);
$j4->apply_unsafe($R);
$j4->apply_unsafe($s);
$j4->apply_unsafe($X);
$j4->apply_unsafe($t);
$j4->apply_unsafe($k4);
$j4->apply_unsafe($G);
$j4->apply_unsafe($d);
$j4->apply_unsafe($j);
$j4->apply_unsafe($v);
$j4->apply_unsafe($w);
$j4->apply_unsafe($x);
$j4->apply_unsafe($y);
$j4->apply_unsafe($z);
$j4->apply_unsafe($A);
$j4->apply_unsafe($B);
$j4->apply_unsafe($C);
$j4->apply_unsafe($D);
$G4->apply_unsafe($X);
$N4->apply_unsafe($X);
$d5->apply_unsafe($T);
$d5->apply_unsafe($h);
$d5->apply_unsafe($l);
$d5->apply_unsafe($V);
$d5->apply_unsafe($m);
$d5->apply_unsafe($n);
$d5->apply_unsafe($o);
$d5->apply_unsafe($p);
$d5->apply_unsafe($q);
$d5->apply_unsafe($r);
$d5->apply_unsafe($s);
$d5->apply_unsafe($t);
$d5->apply_unsafe($e5);
$d5->apply_unsafe($G);
$d5->apply_unsafe($d);
$d5->apply_unsafe($Z);
$d5->apply_unsafe($j);
$d5->apply_unsafe($v);
$d5->apply_unsafe($w);
$d5->apply_unsafe($x);
$d5->apply_unsafe($y);
$d5->apply_unsafe($z);
$d5->apply_unsafe($A);
$d5->apply_unsafe($B);
$d5->apply_unsafe($C);
$d5->apply_unsafe($D);
$m5->apply_unsafe($T);
$m5->apply_unsafe($h);
$m5->apply_unsafe($l);
$m5->apply_unsafe($V);
$m5->apply_unsafe($m);
$m5->apply_unsafe($n);
$m5->apply_unsafe($o);
$m5->apply_unsafe($p);
$m5->apply_unsafe($q);
$m5->apply_unsafe($r);
$m5->apply_unsafe($R);
$m5->apply_unsafe($s);
$m5->apply_unsafe($X);
$m5->apply_unsafe($t);
$m5->apply_unsafe($n5);
$m5->apply_unsafe($G);
$m5->apply_unsafe($d);
$m5->apply_unsafe($Z);
$m5->apply_unsafe($j);
$m5->apply_unsafe($v);
$m5->apply_unsafe($w);
$m5->apply_unsafe($x);
$m5->apply_unsafe($y);
$m5->apply_unsafe($z);
$m5->apply_unsafe($A);
$m5->apply_unsafe($B);
$m5->apply_unsafe($C);
$m5->apply_unsafe($D);
$v5->apply_unsafe($T);
$v5->apply_unsafe($h);
$v5->apply_unsafe($l);
$v5->apply_unsafe($V);
$v5->apply_unsafe($m);
$v5->apply_unsafe($n);
$v5->apply_unsafe($o);
$v5->apply_unsafe($p);
$v5->apply_unsafe($q);
$v5->apply_unsafe($r);
$v5->apply_unsafe($R);
$v5->apply_unsafe($s);
$v5->apply_unsafe($X);
$v5->apply_unsafe($t);
$v5->apply_unsafe($w5);
$v5->apply_unsafe($G);
$v5->apply_unsafe($d);
$v5->apply_unsafe($Z);
$v5->apply_unsafe($j);
$v5->apply_unsafe($v);
$v5->apply_unsafe($w);
$v5->apply_unsafe($x);
$v5->apply_unsafe($y);
$v5->apply_unsafe($z);
$v5->apply_unsafe($A);
$v5->apply_unsafe($B);
$v5->apply_unsafe($C);
$v5->apply_unsafe($D);
$E5->apply_unsafe($T);
$E5->apply_unsafe($h);
$E5->apply_unsafe($l);
$E5->apply_unsafe($V);
$E5->apply_unsafe($m);
$E5->apply_unsafe($n);
$E5->apply_unsafe($o);
$E5->apply_unsafe($p);
$E5->apply_unsafe($q);
$E5->apply_unsafe($r);
$E5->apply_unsafe($s);
$E5->apply_unsafe($X);
$E5->apply_unsafe($t);
$E5->apply_unsafe($F5);
$E5->apply_unsafe($G);
$E5->apply_unsafe($d);
$E5->apply_unsafe($Z);
$E5->apply_unsafe($j);
$E5->apply_unsafe($v);
$E5->apply_unsafe($w);
$E5->apply_unsafe($x);
$E5->apply_unsafe($y);
$E5->apply_unsafe($z);
$E5->apply_unsafe($A);
$E5->apply_unsafe($B);
$E5->apply_unsafe($C);
$E5->apply_unsafe($D);
$R5->apply_unsafe($T);
$R5->apply_unsafe($h);
$R5->apply_unsafe($l);
$R5->apply_unsafe($m);
$R5->apply_unsafe($n);
$R5->apply_unsafe($o);
$R5->apply_unsafe($p);
$R5->apply_unsafe($q);
$R5->apply_unsafe($r);
$R5->apply_unsafe($s);
$R5->apply_unsafe($t);
$R5->apply_unsafe($S5);
$R5->apply_unsafe($G);
$R5->apply_unsafe($d);
$R5->apply_unsafe($Z);
$R5->apply_unsafe($j);
$R5->apply_unsafe($v);
$R5->apply_unsafe($w);
$R5->apply_unsafe($x);
$R5->apply_unsafe($y);
$R5->apply_unsafe($z);
$R5->apply_unsafe($A);
$R5->apply_unsafe($B);
$R5->apply_unsafe($C);
$R5->apply_unsafe($D);
$g6->apply_unsafe($V);
$u6->apply_unsafe($T);
$u6->apply_unsafe($h);
$u6->apply_unsafe($l);
$u6->apply_unsafe($V);
$u6->apply_unsafe($m);
$u6->apply_unsafe($n);
$u6->apply_unsafe($o);
$u6->apply_unsafe($p);
$u6->apply_unsafe($q);
$u6->apply_unsafe($r);
$u6->apply_unsafe($s);
$u6->apply_unsafe($t);
$u6->apply_unsafe($v6);
$u6->apply_unsafe($G);
$u6->apply_unsafe($d);
$u6->apply_unsafe($Z);
$u6->apply_unsafe($j);
$u6->apply_unsafe($v);
$u6->apply_unsafe($w);
$u6->apply_unsafe($x);
$u6->apply_unsafe($y);
$u6->apply_unsafe($z);
$u6->apply_unsafe($A);
$u6->apply_unsafe($B);
$u6->apply_unsafe($C);
$u6->apply_unsafe($D);
$G6->apply_unsafe($T);
$G6->apply_unsafe($h);
$G6->apply_unsafe($l);
$G6->apply_unsafe($V);
$G6->apply_unsafe($m);
$G6->apply_unsafe($n);
$G6->apply_unsafe($o);
$G6->apply_unsafe($p);
$G6->apply_unsafe($q);
$G6->apply_unsafe($r);
$G6->apply_unsafe($s);
$G6->apply_unsafe($t);
$G6->apply_unsafe($H6);
$G6->apply_unsafe($G);
$G6->apply_unsafe($d);
$G6->apply_unsafe($Z);
$G6->apply_unsafe($j);
$G6->apply_unsafe($v);
$G6->apply_unsafe($w);
$G6->apply_unsafe($x);
$G6->apply_unsafe($y);
$G6->apply_unsafe($z);
$G6->apply_unsafe($A);
$G6->apply_unsafe($B);
$G6->apply_unsafe($C);
$G6->apply_unsafe($D);
$O6->apply_unsafe($T);
$O6->apply_unsafe($h);
$O6->apply_unsafe($l);
$O6->apply_unsafe($V);
$O6->apply_unsafe($m);
$O6->apply_unsafe($n);
$O6->apply_unsafe($o);
$O6->apply_unsafe($p);
$O6->apply_unsafe($q);
$O6->apply_unsafe($r);
$O6->apply_unsafe($s);
$O6->apply_unsafe($t);
$O6->apply_unsafe($P6);
$O6->apply_unsafe($G);
$O6->apply_unsafe($d);
$O6->apply_unsafe($Z);
$O6->apply_unsafe($j);
$O6->apply_unsafe($v);
$O6->apply_unsafe($w);
$O6->apply_unsafe($x);
$O6->apply_unsafe($y);
$O6->apply_unsafe($z);
$O6->apply_unsafe($A);
$O6->apply_unsafe($B);
$O6->apply_unsafe($C);
$O6->apply_unsafe($D);
$W6->apply_unsafe($T);
$W6->apply_unsafe($h);
$W6->apply_unsafe($l);
$W6->apply_unsafe($V);
$W6->apply_unsafe($m);
$W6->apply_unsafe($n);
$W6->apply_unsafe($o);
$W6->apply_unsafe($p);
$W6->apply_unsafe($q);
$W6->apply_unsafe($r);
$W6->apply_unsafe($s);
$W6->apply_unsafe($t);
$W6->apply_unsafe($X6);
$W6->apply_unsafe($G);
$W6->apply_unsafe($d);
$W6->apply_unsafe($Z);
$W6->apply_unsafe($j);
$W6->apply_unsafe($v);
$W6->apply_unsafe($w);
$W6->apply_unsafe($x);
$W6->apply_unsafe($y);
$W6->apply_unsafe($z);
$W6->apply_unsafe($A);
$W6->apply_unsafe($B);
$W6->apply_unsafe($C);
$W6->apply_unsafe($D);
$h7->apply_unsafe($T);
$h7->apply_unsafe($h);
$h7->apply_unsafe($l);
$h7->apply_unsafe($V);
$h7->apply_unsafe($m);
$h7->apply_unsafe($n);
$h7->apply_unsafe($o);
$h7->apply_unsafe($p);
$h7->apply_unsafe($q);
$h7->apply_unsafe($r);
$h7->apply_unsafe($s);
$h7->apply_unsafe($t);
$h7->apply_unsafe($i7);
$h7->apply_unsafe($G);
$h7->apply_unsafe($d);
$h7->apply_unsafe($Z);
$h7->apply_unsafe($j);
$h7->apply_unsafe($v);
$h7->apply_unsafe($w);
$h7->apply_unsafe($x);
$h7->apply_unsafe($y);
$h7->apply_unsafe($z);
$h7->apply_unsafe($A);
$h7->apply_unsafe($B);
$h7->apply_unsafe($C);
$h7->apply_unsafe($D);
$w7->apply_unsafe($T);
$w7->apply_unsafe($h);
$w7->apply_unsafe($l);
$w7->apply_unsafe($m);
$w7->apply_unsafe($n);
$w7->apply_unsafe($o);
$w7->apply_unsafe($p);
$w7->apply_unsafe($q);
$w7->apply_unsafe($r);
$w7->apply_unsafe($s);
$w7->apply_unsafe($t);
$w7->apply_unsafe($x7);
$w7->apply_unsafe($d);
$w7->apply_unsafe($j);
$w7->apply_unsafe($v);
$w7->apply_unsafe($w);
$w7->apply_unsafe($x);
$w7->apply_unsafe($y);
$w7->apply_unsafe($z);
$w7->apply_unsafe($A);
$w7->apply_unsafe($B);
$w7->apply_unsafe($C);
$w7->apply_unsafe($D);
$Z7->apply_unsafe($g1);
$o8->apply_unsafe($g1);
$N8->apply_unsafe($g1);
$Z8->apply_unsafe($g1);
$s9->apply_unsafe($d1);
$z9->apply_unsafe($d1);
$H9->apply_unsafe($d1);
$S9->apply_unsafe($d1);
$yb->apply_unsafe($W);
$Fb->apply_unsafe($W);
$oc->apply_unsafe($pc);
$Dc->apply_unsafe($f1);
$ge->apply_unsafe($f1);
$Oe->apply_unsafe($Pe);
$mf->apply_unsafe($Pe);
$wf->apply_unsafe($Pe);
$Eg->apply_unsafe($Pe);
$ch->apply_unsafe($pc);
$xh->apply_unsafe($h1);
$Kh->apply_unsafe($h1);
$Sh->apply_unsafe($h1);
$ij->apply_unsafe($k1);
$ij->apply_unsafe($l1);
$ij->apply_unsafe($m1);
$ij->apply_unsafe($n1);
$ij->apply_unsafe($o1);
$ij->apply_unsafe($p1);
$ij->apply_unsafe($q1);
$ij->apply_unsafe($r1);
$rj->apply_unsafe($k1);
$rj->apply_unsafe($l1);
$rj->apply_unsafe($m1);
$rj->apply_unsafe($n1);
$rj->apply_unsafe($o1);
$rj->apply_unsafe($p1);
$rj->apply_unsafe($q1);
$rj->apply_unsafe($r1);
$Ej->apply_unsafe($k1);
$Ej->apply_unsafe($l1);
$Ej->apply_unsafe($m1);
$Ej->apply_unsafe($n1);
$Ej->apply_unsafe($o1);
$Ej->apply_unsafe($p1);
$Ej->apply_unsafe($q1);
$Ej->apply_unsafe($r1);
$Pj->apply_unsafe($k1);
$Yj->apply_unsafe($k1);
$vk->apply_unsafe($l1);
$Dk->apply_unsafe($l1);
$Mk->apply_unsafe($l1);
$Zk->apply_unsafe($l1);
$Zk->apply_unsafe($m1);
$Zk->apply_unsafe($n1);
$Zk->apply_unsafe($p1);
$Zk->apply_unsafe($q1);
$rl->apply_unsafe($l1);
$Rl->apply_unsafe($m1);
$Zl->apply_unsafe($m1);
$om->apply_unsafe($m1);
$Jm->apply_unsafe($n1);
$Rm->apply_unsafe($n1);
$en->apply_unsafe($n1);
$Sn->apply_unsafe($p1);
$fo->apply_unsafe($p1);
$oo->apply_unsafe($p1);
$zo->apply_unsafe($p1);
$Yo->apply_unsafe($q1);
$ip->apply_unsafe($q1);
$rp->apply_unsafe($q1);
$Cp->apply_unsafe($q1);
$iq->apply_unsafe($r1);
$qq->apply_unsafe($r1);
$Fq->apply_unsafe($r1);
$ni::self=$ir;
&$_($H)for@$I;
&$_($M)for@$N;
&$_($P)for@$Q;
&$_($A1)for@$B1;
&$_($I1)for@$J1;
&$_($M1)for@$J1;
&$_($P1)for@$J1;
&$_($S1)for@$T1;
&$_($Y1)for@$J1;
&$_($d2)for@$J1;
&$_($h2)for@$J1;
&$_($k2)for@$l2;
&$_($q2)for@$J1;
&$_($u2)for@$J1;
&$_($x2)for@$y2;
&$_($D2)for@$J1;
&$_($G2)for@$H2;
&$_($J2)for@$K2;
&$_($M2)for@$J1;
&$_($P2)for@$R2;
&$_($T2)for@$U2;
&$_($Y2)for@$J1;
&$_($d3)for@$f3;
&$_($h3)for@$i3;
&$_($l3)for@$J1;
&$_($n3)for@$J1;
&$_($q3)for@$s3;
&$_($u3)for@$J1;
&$_($w3)for@$J1;
&$_($E3)for@$F3;
&$_($I3)for@$J1;
&$_($L3)for@$M3;
&$_($Q3)for@$J1;
&$_($T3)for@$U3;
&$_($W3)for@$X3;
&$_($d4)for@$J1;
&$_($g4)for@$J1;
&$_($j4)for@$l4;
&$_($n4)for@$o4;
&$_($q4)for@$r4;
&$_($y4)for@$z4;
&$_($D4)for@$J1;
&$_($G4)for@$H4;
&$_($K4)for@$J1;
&$_($N4)for@$O4;
&$_($Q4)for@$R4;
&$_($W4)for@$J1;
&$_($Y4)for@$J1;
&$_($d5)for@$f5;
&$_($j5)for@$J1;
&$_($m5)for@$o5;
&$_($s5)for@$J1;
&$_($v5)for@$x5;
&$_($B5)for@$J1;
&$_($E5)for@$G5;
&$_($I5)for@$J5;
&$_($M5)for@$J1;
&$_($O5)for@$J1;
&$_($R5)for@$T5;
&$_($W5)for@$X5;
&$_($d6)for@$J1;
&$_($g6)for@$h6;
&$_($j6)for@$k6;
&$_($r6)for@$J1;
&$_($u6)for@$w6;
&$_($A6)for@$J1;
&$_($D6)for@$J1;
&$_($G6)for@$I6;
&$_($L6)for@$J1;
&$_($O6)for@$Q6;
&$_($T6)for@$J1;
&$_($W6)for@$Y6;
&$_($e7)for@$J1;
&$_($h7)for@$j7;
&$_($l7)for@$m7;
&$_($o7)for@$p7;
&$_($t7)for@$J1;
&$_($w7)for@$y7;
&$_($A7)for@$B7;
&$_($D7)for@$E7;
&$_($H7)for@$I7;
&$_($L7)for@$M7;
&$_($S7)for@$J1;
&$_($W7)for@$J1;
&$_($Z7)for@$c8;
&$_($h8)for@$J1;
&$_($l8)for@$J1;
&$_($o8)for@$p8;
&$_($u8)for@$J1;
&$_($y8)for@$J1;
&$_($C8)for@$J1;
&$_($G8)for@$J1;
&$_($K8)for@$J1;
&$_($N8)for@$O8;
&$_($S8)for@$J1;
&$_($W8)for@$J1;
&$_($Z8)for@$c9;
&$_($e9)for@$f9;
&$_($k9)for@$l9;
&$_($p9)for@$J1;
&$_($s9)for@$t9;
&$_($w9)for@$J1;
&$_($z9)for@$A9;
&$_($E9)for@$J1;
&$_($H9)for@$I9;
&$_($M9)for@$J1;
&$_($P9)for@$J1;
&$_($S9)for@$T9;
&$_($V9)for@$W9;
&$_($ja)for@$J1;
&$_($qa)for@$ra;
&$_($za)for@$J1;
&$_($Da)for@$J1;
&$_($Ga)for@$ra;
&$_($Oa)for@$J1;
&$_($Ra)for@$ra;
&$_($Xa)for@$J1;
&$_($cb)for@$ra;
&$_($qb)for@$rb;
&$_($vb)for@$J1;
&$_($yb)for@$zb;
&$_($Cb)for@$J1;
&$_($Fb)for@$Gb;
&$_($Ib)for@$Jb;
&$_($lc)for@$J1;
&$_($oc)for@$qc;
&$_($uc)for@$vc;
&$_($Ac)for@$J1;
&$_($Dc)for@$Ec;
&$_($Jc)for@$J1;
&$_($Nc)for@$J1;
&$_($Rc)for@$J1;
&$_($Vc)for@$J1;
&$_($Zc)for@$J1;
&$_($fd)for@$J1;
&$_($jd)for@$J1;
&$_($nd)for@$J1;
&$_($rd)for@$J1;
&$_($vd)for@$J1;
&$_($zd)for@$J1;
&$_($Dd)for@$J1;
&$_($Hd)for@$J1;
&$_($Ld)for@$J1;
&$_($Pd)for@$J1;
&$_($Td)for@$J1;
&$_($Xd)for@$J1;
&$_($de)for@$J1;
&$_($ge)for@$he;
&$_($je)for@$ke;
&$_($ve)for@$J1;
&$_($ze)for@$J1;
&$_($De)for@$J1;
&$_($He)for@$J1;
&$_($Le)for@$J1;
&$_($Oe)for@$Qe;
&$_($ff)for@$J1;
&$_($jf)for@$J1;
&$_($mf)for@$nf;
&$_($tf)for@$J1;
&$_($wf)for@$xf;
&$_($Hf)for@$J1;
&$_($Lf)for@$J1;
&$_($Pf)for@$J1;
&$_($Tf)for@$J1;
&$_($Xf)for@$J1;
&$_($dg)for@$J1;
&$_($hg)for@$J1;
&$_($lg)for@$J1;
&$_($pg)for@$J1;
&$_($tg)for@$J1;
&$_($xg)for@$J1;
&$_($Bg)for@$J1;
&$_($Eg)for@$Fg;
&$_($Sg)for@$J1;
&$_($Xg)for@$J1;
&$_($ch)for@$dh;
&$_($oh)for@$ph;
&$_($uh)for@$J1;
&$_($xh)for@$yh;
&$_($Dh)for@$J1;
&$_($Hh)for@$J1;
&$_($Kh)for@$Lh;
&$_($Ph)for@$J1;
&$_($Sh)for@$Th;
&$_($Wh)for@$Xh;
&$_($hi)for@$ii;
&$_($Ii)for@$Ji;
&$_($Li)for@$ii;
&$_($Si)for@$Ti;
&$_($Vi)for@$Wi;
&$_($fj)for@$J1;
&$_($ij)for@$jj;
&$_($oj)for@$J1;
&$_($rj)for@$sj;
&$_($xj)for@$J1;
&$_($Bj)for@$J1;
&$_($Ej)for@$Fj;
&$_($Hj)for@$Ij;
&$_($Mj)for@$J1;
&$_($Pj)for@$Qj;
&$_($Vj)for@$J1;
&$_($Yj)for@$Zj;
&$_($dk)for@$ek;
&$_($lk)for@$mk;
&$_($sk)for@$J1;
&$_($vk)for@$wk;
&$_($Ak)for@$J1;
&$_($Dk)for@$Ek;
&$_($Jk)for@$J1;
&$_($Mk)for@$Nk;
&$_($Tk)for@$J1;
&$_($Wk)for@$J1;
&$_($Zk)for@$cl;
&$_($el)for@$fl;
&$_($kl)for@$J1;
&$_($ol)for@$J1;
&$_($rl)for@$sl;
&$_($ul)for@$vl;
&$_($Fl)for@$Gl;
&$_($Ll)for@$J1;
&$_($Ol)for@$J1;
&$_($Rl)for@$Sl;
&$_($Wl)for@$J1;
&$_($Zl)for@$cm;
&$_($hm)for@$J1;
&$_($lm)for@$J1;
&$_($om)for@$pm;
&$_($rm)for@$sm;
&$_($Am)for@$Bm;
&$_($Gm)for@$J1;
&$_($Jm)for@$Km;
&$_($Om)for@$J1;
&$_($Rm)for@$Sm;
&$_($Wm)for@$J1;
&$_($Zm)for@$J1;
&$_($en)for@$fn;
&$_($hn)for@$in;
&$_($wn)for@$xn;
&$_($Dn)for@$J1;
&$_($Hn)for@$J1;
&$_($Ln)for@$J1;
&$_($Pn)for@$J1;
&$_($Sn)for@$Tn;
&$_($Xn)for@$J1;
&$_($co)for@$J1;
&$_($fo)for@$go;
&$_($lo)for@$J1;
&$_($oo)for@$po;
&$_($to)for@$J1;
&$_($wo)for@$J1;
&$_($zo)for@$Ao;
&$_($Co)for@$Do;
&$_($Mo)for@$No;
&$_($So)for@$J1;
&$_($Vo)for@$J1;
&$_($Yo)for@$Zo;
&$_($fp)for@$J1;
&$_($ip)for@$jp;
&$_($op)for@$J1;
&$_($rp)for@$sp;
&$_($wp)for@$J1;
&$_($zp)for@$J1;
&$_($Cp)for@$Dp;
&$_($Fp)for@$Gp;
&$_($Pp)for@$Qp;
&$_($Vp)for@$J1;
&$_($Zp)for@$J1;
&$_($fq)for@$J1;
&$_($iq)for@$jq;
&$_($nq)for@$J1;
&$_($qq)for@$rq;
&$_($vq)for@$J1;
&$_($zq)for@$J1;
&$_($Cq)for@$J1;
&$_($Fq)for@$Gq;
&$_($Iq)for@$Jq;
&$_($Sq)for@$J1;
&$_($Wq)for@$J1;
&$_($cr)for@$J1;
&$_($gr)for@$J1;
&$_($ir)for@$jr;
ni->run(@ARGV);
__DATA__
