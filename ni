#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use POSIX;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/lib/doc#;
$P=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$Q=[$f,$P];
$R=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$S=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$T=[];
$U=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$V=bless({$o,$T,$q,$U,$s,$t},$u);
$W=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$X=[];
$Y=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$Z=bless({$o,$X,$q,$Y,$s,$t},$u);
$c1=[$i,$R,$S,$n,$V,$W,$n,$Z];
$d1=[$Q,$c1];
$e1=q#/lib/doc#;
$f1=bless({$e,$d1,$D,$e1},$F);
$g1=q#ni.doc:/unix#;
$h1=q#Abstractions around UNIX stuff like file descriptors and child processes.
      We bypass as much Perl machinery as possible to keep things simple,
      particularly in terms of IO: FDs are just numbers so we don't have to
      contend with Perl close-on-deallocation issues or buffering. (Part of the
      reason we have to do this is that older Perls don't behave ideally:
      interrupted system calls sometimes look like EOF until Perl 5.14, for
      example.)#;
$i1=q#ni tries to be aware of the reality of file descriptors as a
      process-specific lens into the state of IO resources while providing a
      more functional interface. For our purposes, each IO resource is fully
      owned by a single process; a handoff involves closing the resource in the
      parent process and opening it under a possibly-different FD within the
      child. There are cases where IO resources have multiple readers or
      writers, but this is always mediated by a process rather than increasing
      the underlying reference count.#;
$j1=q#Forks are negotiated fully before they happen; the only exception is that
      it's assumed you want to be able to use stdio for a process, so any
      unmapped stdio descriptors are optimistically piped into the local FD
      namespace.#;
$k1=[$i,$h1,$i1,$j1];
$l1=[$k1];
$m1=q#/unix#;
$n1=bless({$e,$l1,$D,$m1},$F);
$o1=q#ni.doc:/unix/cat#;
$p1=q#
    my $combined = ni('ni:/unix/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  #;
$q1=[$f,$p1];
$r1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$s1=[$i,$r1];
$t1=[];
$u1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$v1=bless({$o,$t1,$q,$u1,$s,$t},$u);
$w1=[$n,$v1];
$x1=[$q1,$s1,$w1];
$y1=q#/unix/cat#;
$z1=bless({$e,$x1,$D,$y1},$F);
$A1=q#ni.doc:/unix/exec#;
$B1=q#
    my $pid = ni("ni:/unix/exec")->new("ls", "-l")
      ->fds(1 => ni"file:foo")
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$C1=[$f,$B1];
$D1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up FIFO connections to stdin/out if you use it
      this way.#;
$E1=[$i,$D1];
$F1=[];
$G1=q#my $e   = ni('ni:/unix/exec')->new('sh', '-c', 'echo hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$H1=bless({$o,$F1,$q,$G1,$s,$t},$u);
$I1=[$n,$H1];
$J1=[$C1,$E1,$I1];
$K1=q#/unix/exec#;
$L1=bless({$e,$J1,$D,$K1},$F);
$M1=q#ni.doc:/unix/pid#;
$N1=[];
$O1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$P1=bless({$o,$N1,$q,$O1,$s,$t},$u);
$Q1=[$n,$P1];
$R1=[];
$S1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$T1=bless({$o,$R1,$q,$S1,$s,$t},$u);
$U1=[$n,$T1];
$V1=[];
$W1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/unix/exec')->new('egrep', '[13579]$')
  ->fds(0 => $seq->stdout)
  ->fork;
now $grep->read_all == "1\\n3\\n5\\n7\\n9\\n";
now $seq->await == 0;
now $grep->await == 0;#;
$X1=bless({$o,$V1,$q,$W1,$s,$t},$u);
$Y1=[$n,$X1];
$Z1=[$Q1,$U1,$Y1];
$c2=q#/unix/pid#;
$d2=bless({$e,$Z1,$D,$c2},$F);
$e2=q#ni:/class#;
$f2=q#applied_to#;
$g2=q#class#;
$h2=q#class.c#;
$i2=q#lib/behavior.c#;
$j2=q#lib/branch.c#;
$k2=q#lib/dataslice.c#;
$l2=q#lib/doc.c#;
$m2=q#lib/fn.c#;
$n2=q#lib/image.c#;
$o2=q#lib/ni.c#;
$p2=q#lib/slice.c#;
$q2=q#lib/tag.c#;
$r2=q#lib/test_value.c#;
$s2=q#metaclass.c#;
$t2=q#module.c#;
$u2=q#object.c#;
$v2=q#unix/cat.c#;
$w2=q#unix/exec.c#;
$x2=q#unix/fd.c#;
$y2=q#unix/fifo.c#;
$z2=q#unix/file.c#;
$A2=q#unix/io.c#;
$B2=q#unix/pid.c#;
$C2=q#unix/pipeline.c#;
$D2=q#unix/str.c#;
$E2={$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1};
$F2=q#slices#;
$G2=q#lib/test_value.c#;
$H2=q#metaclass#;
$I2=q#module#;
$J2={$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$G2,1,$H2,1,$s2,1,$I2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1};
$K2=q#/module#;
$L2=q#/lib/perlbranch.b#;
$M2={};
$N2=q#ctor#;
$O2=undef;
$P2=q#dtor#;
$Q2=q#methods#;
$R2=q#add#;
$S2=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$T2=bless({$q,$S2,$s,$t},$u);
$U2=q#apply#;
$V2=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$W2=bless({$q,$V2,$s,$t},$u);
$X2={$R2,$T2,$U2,$W2};
$Y2=q#/lib/branch.b#;
$Z2=q#lib/slice#;
$c3=bless({$f2,$M2,$N2,$O2,$P2,$O2,$Q2,$X2,$D,$Y2},$Z2);
$d3=q#lib/branch#;
$e3=q#lib/test_value.c#;
$f3=q#lib/slice::ctors#;
$g3={};
$h3=q#my $s = shift; ni->def($s->name, $s)#;
$i3=bless({$q,$h3,$s,$t},$u);
$j3=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$k3=bless({$q,$j3,$s,$t},$u);
$l3={$D,$k3};
$m3=q#/lib/named.b#;
$n3=bless({$f2,$g3,$N2,$i3,$P2,$O2,$Q2,$l3,$D,$m3},$Z2);
$o3=q#lib/tag#;
$p3=q#lib/test_value.c#;
$q3=q#lib/slice::ctors#;
$r3={};
$s3=q#namespace#;
$t3=q#'ni'#;
$u3=bless({$q,$t3,$s,$t},$u);
$v3={$s3,$u3};
$w3=q#/lib/named_in_ni.b#;
$x3=bless({$f2,$r3,$N2,$O2,$P2,$O2,$Q2,$v3,$D,$w3},$Z2);
$y3=q#lib/test_value.c#;
$z3=q#lib/slice::ctors#;
$A3={};
$B3=q#package#;
$C3=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$D3=bless({$q,$C3,$s,$t},$u);
$E3={$B3,$D3};
$F3=q#/lib/namespaced.b#;
$G3=bless({$f2,$A3,$N2,$O2,$P2,$O2,$Q2,$E3,$D,$F3},$Z2);
$H3=q#lib/test_value.c#;
$I3=q#lib/slice::ctors#;
$J3={};
$K3=q#resolve#;
$L3=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$M3=bless({$q,$L3,$s,$t},$u);
$N3={$K3,$M3};
$O3=q#/lib/resolver.b#;
$P3=bless({$f2,$J3,$N2,$O2,$P2,$O2,$Q2,$N3,$D,$O3},$Z2);
$Q3=q#lib/test_value.c#;
$R3=q#lib/slice::ctors#;
$S3=[$c3,$n3,$x3,$G3,$P3];
$T3=bless({$D,$L2,$F2,$S3},$o3);
$U3=q#lib/tag::ctors#;
$V3={};
$W3=q#my $s = shift; $s->apply($s->package)#;
$X3=bless({$q,$W3,$s,$t},$u);
$Y3=q#instantiate#;
$Z3=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$c4=bless({$q,$Z3,$s,$t},$u);
$d4={$Y3,$c4};
$e4=q#/lib/class_init.b#;
$f4=bless({$f2,$V3,$N2,$X3,$P2,$O2,$Q2,$d4,$D,$e4},$Z2);
$g4=q#lib/test_value.c#;
$h4=q#lib/slice::ctors#;
$i4=q#lib/behavior#;
$j4=q#lib/dataslice#;
$k4=q#lib/image#;
$l4=q#lib/ni#;
$m4=q#lib/test_value#;
$n4=q#lib/test_value.c#;
$o4=q#object#;
$p4=q#unix/cat#;
$q4=q#unix/exec#;
$r4=q#unix/fd#;
$s4=q#unix/fifo#;
$t4=q#unix/file#;
$u4=q#unix/io#;
$v4=q#unix/pid#;
$w4=q#unix/pipeline#;
$x4=q#unix/str#;
$y4={$g2,1,$h2,1,$i4,1,$i2,1,$d3,1,$j2,1,$j4,1,$k2,1,$F,1,$l2,1,$u,1,$m2,1,$k4,1,$n2,1,$l4,1,$o2,1,$Z2,1,$p2,1,$o3,1,$q2,1,$m4,1,$n4,1,$H2,1,$s2,1,$I2,1,$t2,1,$o4,1,$u2,1,$p4,1,$v2,1,$q4,1,$w2,1,$r4,1,$x2,1,$s4,1,$y2,1,$t4,1,$z2,1,$u4,1,$A2,1,$v4,1,$B2,1,$w4,1,$C2,1,$x4,1,$D2,1};
$z4=q#/object#;
$A4={};
$B4=q#ni 'ni:/' . ref shift#;
$C4=bless({$q,$B4,$s,$t},$u);
$D4={$g2,$C4};
$E4=q#/lib/instance.b#;
$F4=bless({$f2,$A4,$N2,$O2,$P2,$O2,$Q2,$D4,$D,$E4},$Z2);
$G4=q#lib/test_value.c#;
$H4=q#lib/slice::ctors#;
$I4=[$F4];
$J4=bless({$f2,$y4,$D,$z4,$F2,$I4},$u2);
$K4=q#object.c::ctors#;
$L4=q#lib/test_value.c#;
$M4={$g2,1,$h2,1,$i4,1,$i2,1,$d3,1,$j2,1,$j4,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$Z2,1,$p2,1,$o3,1,$q2,1,$L4,1,$H2,1,$s2,1,$I2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1};
$N4=q#/lib/behavior#;
$O4={};
$P4=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$Q4=bless({$q,$P4,$s,$t},$u);
$R4={$e,$Q4};
$S4=q#/lib/documentable.b#;
$T4=bless({$f2,$O4,$N2,$O2,$P2,$O2,$Q2,$R4,$D,$S4},$Z2);
$U4=q#lib/test_value.c#;
$V4=q#lib/slice::ctors#;
$W4=[$J4,$T4];
$X4=bless({$f2,$M4,$D,$N4,$F2,$W4},$i2);
$Y4=q#lib/behavior.c::ctors#;
$Z4=q#lib/test_value.c#;
$c5={$g2,1,$h2,1,$i2,1,$d3,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$Z4,1,$H2,1,$s2,1,$I2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1};
$d5=q#/lib/definition.b#;
$e5={};
$f5=q#def#;
$g5=q#shift->add(ni('ni:/lib/slice')->new(@_))#;
$h5=bless({$q,$g5,$s,$t},$u);
$i5={$f5,$h5};
$j5=q#/lib/definition_def.b#;
$k5=bless({$f2,$e5,$N2,$O2,$P2,$O2,$Q2,$i5,$D,$j5},$Z2);
$l5=q#lib/test_value.c#;
$m5=q#lib/slice::ctors#;
$n5={};
$o5=q#ro#;
$p5=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$q5=bless({$q,$p5,$s,$t},$u);
$r5=q#rw#;
$s5=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$t5=bless({$q,$s5,$s,$t},$u);
$u5={$o5,$q5,$r5,$t5};
$v5=q#/lib/accessor.b#;
$w5=bless({$f2,$n5,$N2,$O2,$P2,$O2,$Q2,$u5,$D,$v5},$Z2);
$x5=q#lib/test_value.c#;
$y5=q#lib/slice::ctors#;
$z5={};
$A5=q#(""#;
$B5=q#shift->name#;
$C5=bless({$q,$B5,$s,$t},$u);
$D5={$A5,$C5};
$E5=q#/lib/name_as_string.b#;
$F5=bless({$f2,$z5,$N2,$O2,$P2,$O2,$Q2,$D5,$D,$E5},$Z2);
$G5=q#lib/test_value.c#;
$H5=q#lib/slice::ctors#;
$I5={};
$J5=q#(eq#;
$K5=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$L5=bless({$q,$K5,$s,$t},$u);
$M5={$J5,$L5};
$N5=q#/lib/ref_eq.b#;
$O5=bless({$f2,$I5,$N2,$O2,$P2,$O2,$Q2,$M5,$D,$N5},$Z2);
$P5=q#lib/test_value.c#;
$Q5=q#lib/slice::ctors#;
$R5={};
$S5=q#defdata#;
$T5=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$U5=bless({$q,$T5,$s,$t},$u);
$V5={$S5,$U5};
$W5=q#/lib/definition_defdata.b#;
$X5=bless({$f2,$R5,$N2,$O2,$P2,$O2,$Q2,$V5,$D,$W5},$Z2);
$Y5=q#lib/test_value.c#;
$Z5=q#lib/slice::ctors#;
$c6=[$k5,$w5,$F5,$O5,$X5];
$d6=bless({$f2,$c5,$D,$d5,$F2,$c6},$d3);
$e6=q#lib/branch::ctors#;
$f6=[$T3,$f4,$J4,$X4,$d6];
$g6=bless({$f2,$J2,$D,$K2,$F2,$f6},$t2);
$h6=q#module.c::ctors#;
$i6={};
$j6=q#DESTROY#;
$k6=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$l6=bless({$q,$k6,$s,$t},$u);
$m6=q#new#;
$n6=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$o6=bless({$q,$n6,$s,$t},$u);
$p6={$j6,$l6,$m6,$o6};
$q6=q#/lib/instantiable.b#;
$r6=bless({$f2,$i6,$Q2,$p6,$D,$q6},$Z2);
$s6=q#lib/test_value.c#;
$t6=q#lib/slice::ctors#;
$u6={};
$v6=q#child#;
$w6=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$x6=bless({$q,$w6,$s,$t},$u);
$y6={$v6,$x6};
$z6=q#/lib/subclass.b#;
$A6=bless({$f2,$u6,$N2,$O2,$P2,$O2,$Q2,$y6,$D,$z6},$Z2);
$B6=q#lib/test_value.c#;
$C6=q#lib/slice::ctors#;
$D6=[$g6,$r6,$f4,$g6,$A6];
$E6=bless({$f2,$E2,$D,$E,$F2,$D6},$h2);
$F6=q#class.c::ctors#;
$G6=q#ni:/class.c#;
$H6={$h2,1};
$I6=q#/class.c#;
$J6={$h2,1,$t2,1};
$K6=q#/module.c#;
$L6=q#lib/test_value.c#;
$M6={$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$L6,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1};
$N6=q#/object.c#;
$O6=[$E6];
$P6=bless({$f2,$M6,$D,$N6,$F2,$O6},$H2);
$Q6=q#metaclass::ctors#;
$R6={$h2,1,$i2,1,$j2,1,$k2,1,$p2,1,$q2,1,$t2,1};
$S6=q#/lib/behavior.c#;
$T6=[$P6];
$U6=bless({$f2,$R6,$D,$S6,$F2,$T6},$H2);
$V6=q#metaclass::ctors#;
$W6=[$P6,$r6,$U6];
$X6=bless({$f2,$J6,$D,$K6,$F2,$W6},$H2);
$Y6=q#metaclass::ctors#;
$Z6=[$X6];
$c7=bless({$f2,$H6,$D,$I6,$F2,$Z6},$H2);
$d7=q#metaclass::ctors#;
$e7=q#ni:/lib/accessor.b#;
$f7=q#ni:/lib/behavior#;
$g7=q#ni:/lib/behavior.c#;
$h7=q#ni:/lib/branch#;
$i7={$d3,1};
$j7=q#/lib/branch#;
$k7={};
$l7=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$m7=bless({$q,$l7,$s,$t},$u);
$n7={$Y3,$m7};
$o7=q#/lib/branch_init.b#;
$p7=bless({$f2,$k7,$N2,$O2,$P2,$O2,$Q2,$n7,$D,$o7},$Z2);
$q7=q#lib/slice::ctors#;
$r7=[$X4,$n3,$c3,$p7,$d6];
$s7=bless({$f2,$i7,$D,$j7,$F2,$r7},$j2);
$t7=q#lib/branch.c::ctors#;
$u7=q#ni:/lib/branch.b#;
$v7=q#ni:/lib/branch.c#;
$w7={$j2,1};
$x7=q#/lib/branch.c#;
$y7=[$U6];
$z7=bless({$f2,$w7,$D,$x7,$F2,$y7},$H2);
$A7=q#metaclass::ctors#;
$B7=q#ni:/lib/branch_init.b#;
$C7=q#ni:/lib/class_init.b#;
$D7=q#ni:/lib/dataslice#;
$E7={$j4,1};
$F7=q#/lib/dataslice#;
$G7={};
$H7=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$I7=bless({$q,$H7,$s,$t},$u);
$J7={$Y3,$I7};
$K7=q#/lib/dataslice_init.b#;
$L7=bless({$f2,$G7,$N2,$O2,$P2,$O2,$Q2,$J7,$D,$K7},$Z2);
$M7=q#lib/slice::ctors#;
$N7={};
$O7=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$P7=bless({$q,$O7,$s,$t},$u);
$Q7={$U2,$P7};
$R7=q#/lib/dataslice_apply.b#;
$S7=bless({$f2,$N7,$N2,$O2,$P2,$O2,$Q2,$Q7,$D,$R7},$Z2);
$T7=q#lib/slice::ctors#;
$U7=[$X4,$L7,$S7];
$V7=bless({$f2,$E7,$D,$F7,$F2,$U7},$k2);
$W7=q#lib/dataslice.c::ctors#;
$X7=q#ni:/lib/dataslice.c#;
$Y7={$k2,1};
$Z7=q#/lib/dataslice.c#;
$c8=[$U6];
$d8=bless({$f2,$Y7,$D,$Z7,$F2,$c8},$H2);
$e8=q#metaclass::ctors#;
$f8=q#ni:/lib/dataslice_apply.b#;
$g8=q#ni:/lib/dataslice_init.b#;
$h8=q#ni:/lib/definition.b#;
$i8=q#ni:/lib/definition_def.b#;
$j8=q#ni:/lib/definition_defdata.b#;
$k8=q#ni:/lib/doc#;
$l8={$F,1};
$m8={};
$n8=q#shift; +{name => shift, doc => []}#;
$o8=bless({$q,$n8,$s,$t},$u);
$p8={$Y3,$o8};
$q8=q#/lib/doc_init.b#;
$r8=bless({$f2,$m8,$N2,$O2,$P2,$O2,$Q2,$p8,$D,$q8},$Z2);
$s8=q#lib/slice::ctors#;
$t8={};
$u8=q#'ni.doc'#;
$v8=bless({$q,$u8,$s,$t},$u);
$w8={$s3,$v8};
$x8=q#/lib/doc_namespace.b#;
$y8=bless({$f2,$t8,$N2,$O2,$P2,$O2,$Q2,$w8,$D,$x8},$Z2);
$z8=q#lib/slice::ctors#;
$A8={};
$B8=q#AUTOLOAD#;
$C8=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$D8=bless({$q,$C8,$s,$t},$u);
$E8={$B8,$D8};
$F8=q#/lib/doc_define.b#;
$G8=bless({$f2,$A8,$N2,$O2,$P2,$O2,$Q2,$E8,$D,$F8},$Z2);
$H8=q#lib/slice::ctors#;
$I8={};
$J8=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$K8=bless({$q,$J8,$s,$t},$u);
$L8=q#tests#;
$M8=q#my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$N8=bless({$q,$M8,$s,$t},$u);
$O8={$n,$K8,$L8,$N8};
$P8=q#/lib/doc_test.b#;
$Q8=bless({$f2,$I8,$N2,$O2,$P2,$O2,$Q2,$O8,$D,$P8},$Z2);
$R8=q#lib/slice::ctors#;
$S8=[$J4,$n3,$r8,$y8,$G8,$Q8];
$T8=bless({$f2,$l8,$D,$e1,$F2,$S8},$l2);
$U8=q#lib/doc.c::ctors#;
$V8=q#ni:/lib/doc.c#;
$W8={$l2,1};
$X8=q#/lib/doc.c#;
$Y8=[$P6];
$Z8=bless({$f2,$W8,$D,$X8,$F2,$Y8},$H2);
$c9=q#metaclass::ctors#;
$d9=q#ni:/lib/doc_define.b#;
$e9=q#ni:/lib/doc_init.b#;
$f9=q#ni:/lib/doc_namespace.b#;
$g9=q#ni:/lib/doc_test.b#;
$h9=q#ni:/lib/documentable.b#;
$i9=q#ni:/lib/fn#;
$j9={$u,1};
$k9=q#/lib/fn#;
$l9={};
$m9=q#shift->compile#;
$n9=bless({$q,$m9,$s,$t},$u);
$o9=q#compile#;
$p9=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$q9=bless({$q,$p9,$s,$t},$u);
$r9=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$s9=bless({$q,$r9,$s,$t},$u);
$t9={$o9,$q9,$Y3,$s9};
$u9=q#/lib/fn_init.b#;
$v9=bless({$f2,$l9,$N2,$n9,$P2,$O2,$Q2,$t9,$D,$u9},$Z2);
$w9=q#lib/slice::ctors#;
$x9={};
$y9=[];
$z9=q#shift->{'annotations'}#;
$A9=bless({$o,$y9,$q,$z9,$s,$t},$u);
$B9=[];
$C9=q#shift->{'code'}#;
$D9=bless({$o,$B9,$q,$C9,$s,$t},$u);
$E9=q#fn#;
$F9=[];
$G9=q#shift->{'fn'}#;
$H9=bless({$o,$F9,$q,$G9,$s,$t},$u);
$I9={$o,$A9,$q,$D9,$E9,$H9};
$J9=q#/lib/fn_ro.b#;
$K9=bless({$f2,$x9,$N2,$O2,$P2,$O2,$Q2,$I9,$D,$J9},$Z2);
$L9=q#lib/slice::ctors#;
$M9={};
$N9=[];
$O9=q#shift->{code}#;
$P9=bless({$o,$N9,$q,$O9,$s,$t},$u);
$Q9=[];
$R9=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$S9=bless({$o,$Q9,$q,$R9,$s,$t},$u);
$T9={$A5,$P9,$J5,$S9};
$U9=q#/lib/fn_ops.b#;
$V9=bless({$f2,$M9,$N2,$O2,$P2,$O2,$Q2,$T9,$D,$U9},$Z2);
$W9=q#lib/slice::ctors#;
$X9={};
$Y9=q#serialize#;
$Z9=[];
$ca=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$da=bless({$o,$Z9,$q,$ca,$s,$t},$u);
$ea={$Y9,$da};
$fa=q#/lib/fn_serialize.b#;
$ga=bless({$f2,$X9,$N2,$O2,$P2,$O2,$Q2,$ea,$D,$fa},$Z2);
$ha=q#lib/slice::ctors#;
$ia=[$J4,$r6,$v9,$K9,$V9,$ga];
$ja=bless({$f2,$j9,$D,$k9,$F2,$ia},$m2);
$ka=q#lib/fn.c::ctors#;
$la=q#ni:/lib/fn.c#;
$ma={$m2,1};
$na=q#/lib/fn.c#;
$oa=[$P6];
$pa=bless({$f2,$ma,$D,$na,$F2,$oa},$H2);
$qa=q#metaclass::ctors#;
$ra=q#ni:/lib/fn_init.b#;
$sa=q#ni:/lib/fn_ops.b#;
$ta=q#ni:/lib/fn_ro.b#;
$ua=q#ni:/lib/fn_serialize.b#;
$va=q#ni:/lib/global_static_test.b#;
$wa={};
$xa=q#now#;
$ya=[];
$za=q#ni('ni:/lib/test_value')->new(shift)#;
$Aa=q#($)#;
$Ba=bless({$o,$ya,$q,$za,$s,$Aa},$u);
$Ca={$xa,$Ba};
$Da=q#/lib/global_static_test.b#;
$Ea=bless({$f2,$wa,$N2,$O2,$P2,$O2,$Q2,$Ca,$D,$Da},$Z2);
$Fa=q#main#;
$Ga=q#lib/slice::ctors#;
$Ha=q#ni:/lib/image#;
$Ia={$k4,1};
$Ja=q#/lib/image#;
$Ka={};
$La=[];
$Ma=q#my $class = shift;
my %args  = (
  include_shebang => 1,
  include_license => 1,
  include_boot    => 1,
  include_classes => 1,
  include_run     => 1,
  local_vars      => 0,
  use_newlines    => 0,
  @_);

+{include_shebang => $args{include_shebang},
  include_license => $args{include_license},
  include_boot    => $args{include_boot},
  include_classes => $args{include_classes},
  include_run     => $args{include_run},
  local_vars      => $args{local_vars},
  use_newlines    => $args{use_newlines},

  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$Na=bless({$o,$La,$q,$Ma,$s,$t},$u);
$Oa={$Y3,$Na};
$Pa=q#/lib/image_init.b#;
$Qa=bless({$f2,$Ka,$N2,$O2,$P2,$O2,$Q2,$Oa,$D,$Pa},$Z2);
$Ra=q#lib/slice::ctors#;
$Sa={};
$Ta=q#address#;
$Ua=[];
$Va=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 16;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$Wa=bless({$o,$Ua,$q,$Va,$s,$t},$u);
$Xa=q#allocate_gensym#;
$Ya=[];
$Za=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$cb=bless({$o,$Ya,$q,$Za,$s,$t},$u);
$db=q#boot_side_effect#;
$eb=[];
$fb=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$gb=bless({$o,$eb,$q,$fb,$s,$t},$u);
$hb=q#circular_links#;
$ib=[];
$jb=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$kb=bless({$o,$ib,$q,$jb,$s,$t},$u);
$lb=q#finalizer#;
$mb=[];
$nb=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$ob=bless({$o,$mb,$q,$nb,$s,$t},$u);
$pb=q#gensym#;
$qb=[];
$rb=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$sb=bless({$o,$qb,$q,$rb,$s,$t},$u);
$tb=q#is_circular#;
$ub=[];
$vb=q#my $self = shift;
ref $$self{visited}{$self->address($_[0])};#;
$wb=bless({$o,$ub,$q,$vb,$s,$t},$u);
$xb=q#quote#;
$yb=[];
$zb=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? 'undef' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$Ab=bless({$o,$yb,$q,$zb,$s,$t},$u);
$Bb=q#quote_array#;
$Cb=[];
$Db=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_])
  && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$Eb=bless({$o,$Cb,$q,$Db,$s,$t},$u);
$Fb=q#quote_blessed#;
$Gb=[];
$Hb=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$Ib=bless({$o,$Gb,$q,$Hb,$s,$t},$u);
$Jb=q#quote_class#;
$Kb=[];
$Lb=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$Mb=bless({$o,$Kb,$q,$Lb,$s,$t},$u);
$Nb=q#quote_hash#;
$Ob=[];
$Pb=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  push @{$$self{circular}}, [$a, "{" . $self->quote($k) . "}",
                                 $self->address($$v{$k})]
  if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$Qb=bless({$o,$Ob,$q,$Pb,$s,$t},$u);
$Rb=q#quote_object#;
$Sb=[];
$Tb=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$Ub=bless({$o,$Sb,$q,$Tb,$s,$t},$u);
$Vb=q#quote_scalar#;
$Wb=[];
$Xb=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$Yb=bless({$o,$Wb,$q,$Xb,$s,$t},$u);
$Zb=q#quote_value#;
$cc=[];
$dc=q#my $self = shift;
return $self->quote_scalar($_[0]) unless ref $_[0];
return $self->quote_array($_[0])  if 'ARRAY' eq ref $_[0];
return $self->quote_hash($_[0])   if 'HASH'  eq ref $_[0];
die "cannot serialize $_[0]"      if 'CODE'  eq ref $_[0];
$self->quote_object($_[0]);#;
$ec=bless({$o,$cc,$q,$dc,$s,$t},$u);
$fc=q#reconstruction#;
$gc=[];
$hc=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$ic=bless({$o,$gc,$q,$hc,$s,$t},$u);
$jc=q#side_effect#;
$kc=[];
$lc=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$mc=bless({$o,$kc,$q,$lc,$s,$t},$u);
$nc=q#write#;
$oc=[];
$pc=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  ($$self{include_shebang} ? ("\#!/usr/bin/env perl\\n") : ()),
  ($$self{include_license} ? ("chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n") : ()),
  ($$self{include_boot}    ? ("BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n") : ()),
  ($$self{use_newlines}    ? map("$_\\n", $self->reconstruction) : $self->reconstruction),
  ($$self{include_run}     ? ("ni->run(\\@ARGV);", "\\n__DATA__\\n") : ());#;
$qc=bless({$o,$oc,$q,$pc,$s,$t},$u);
$rc={$Ta,$Wa,$Xa,$cb,$db,$gb,$hb,$kb,$lb,$ob,$pb,$sb,$tb,$wb,$xb,$Ab,$Bb,$Eb,$Fb,$Ib,$Jb,$Mb,$Nb,$Qb,$Rb,$Ub,$Vb,$Yb,$Zb,$ec,$fc,$ic,$jc,$mc,$nc,$qc};
$sc=q#/lib/image_quoting.b#;
$tc=bless({$f2,$Sa,$N2,$O2,$P2,$O2,$Q2,$rc,$D,$sc},$Z2);
$uc=q#lib/slice::ctors#;
$vc=[$J4,$Qa,$tc];
$wc=bless({$f2,$Ia,$D,$Ja,$F2,$vc},$n2);
$xc=q#lib/image.c::ctors#;
$yc=q#ni:/lib/image.c#;
$zc={$n2,1};
$Ac=q#/lib/image.c#;
$Bc=[$P6];
$Cc=bless({$f2,$zc,$D,$Ac,$F2,$Bc},$H2);
$Dc=q#metaclass::ctors#;
$Ec=q#ni:/lib/image_init.b#;
$Fc=q#ni:/lib/image_quoting.b#;
$Gc=q#ni:/lib/instance.b#;
$Hc=q#ni:/lib/instantiable.b#;
$Ic=q#ni:/lib/json.b#;
$Jc={};
$Kc=q#json_decode#;
$Lc=[];
$Mc=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$Nc=bless({$o,$Lc,$q,$Mc,$s,$Aa},$u);
$Oc=q#json_encode#;
$Pc=[];
$Qc=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$Rc=bless({$o,$Pc,$q,$Qc,$s,$Aa},$u);
$Sc=q#json_escape#;
$Tc=[];
$Uc=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$Vc=bless({$o,$Tc,$q,$Uc,$s,$Aa},$u);
$Wc=q#json_unescape#;
$Xc=[];
$Yc=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$Zc=bless({$o,$Xc,$q,$Yc,$s,$Aa},$u);
$cd=q#json_unescape_one#;
$dd=[];
$ed=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$fd=bless({$o,$dd,$q,$ed,$s,$Aa},$u);
$gd={$Kc,$Nc,$Oc,$Rc,$Sc,$Vc,$Wc,$Zc,$cd,$fd};
$hd=q#/lib/json.b#;
$id=bless({$f2,$Jc,$N2,$O2,$P2,$O2,$Q2,$gd,$D,$hd},$Z2);
$jd=q#ni#;
$kd=q#lib/slice::ctors#;
$ld=q#ni:/lib/name_as_string.b#;
$md=q#ni:/lib/named.b#;
$nd=q#ni:/lib/named_in_ni.b#;
$od=q#ni:/lib/namespaced.b#;
$pd=q#ni:/lib/ni#;
$qd={$l4,1};
$rd=q#/lib/ni#;
$sd={};
$td=q#extend#;
$ud=[];
$vd=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$wd=bless({$o,$ud,$q,$vd,$s,$t},$u);
$xd=q#is_mutable#;
$yd=[];
$zd=q#$0 ne "-" && -w $0#;
$Ad=bless({$o,$yd,$q,$zd,$s,$t},$u);
$Bd=q#modify#;
$Cd=[];
$Dd=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$Ed=bless({$o,$Cd,$q,$Dd,$s,$t},$u);
$Fd={$td,$wd,$xd,$Ad,$Bd,$Ed};
$Gd=q#/lib/ni_self.b#;
$Hd=bless({$f2,$sd,$N2,$O2,$P2,$O2,$Q2,$Fd,$D,$Gd},$Z2);
$Id=q#lib/slice::ctors#;
$Jd={};
$Kd=q#exists#;
$Ld=[];
$Md=q#exists $_[0]->{named}{$_[1]}#;
$Nd=bless({$o,$Ld,$q,$Md,$s,$t},$u);
$Od=q#quoted#;
$Pd=[];
$Qd=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$Rd=bless({$o,$Pd,$q,$Qd,$s,$t},$u);
$Sd={$Kd,$Nd,$Od,$Rd};
$Td=q#/lib/ni_image.b#;
$Ud=bless({$f2,$Jd,$N2,$O2,$P2,$O2,$Q2,$Sd,$D,$Td},$Z2);
$Vd=q#lib/slice::ctors#;
$Wd={};
$Xd=q#--internal/+=#;
$Yd=[];
$Zd=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$ce=bless({$o,$Yd,$q,$Zd,$s,$t},$u);
$de=q#--internal/eval#;
$ee=[];
$fe=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$ge=bless({$o,$ee,$q,$fe,$s,$t},$u);
$he=q#--internal/image#;
$ie=[];
$je=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$ke=bless({$o,$ie,$q,$je,$s,$t},$u);
$le=q#--internal/test#;
$me=[];
$ne=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$oe=bless({$o,$me,$q,$ne,$s,$t},$u);
$pe=q#run#;
$qe=[];
$re=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$se=bless({$o,$qe,$q,$re,$s,$t},$u);
$te={$Xd,$ce,$de,$ge,$he,$ke,$le,$oe,$pe,$se};
$ue=q#/lib/ni_main.b#;
$ve=bless({$f2,$Wd,$N2,$O2,$P2,$O2,$Q2,$te,$D,$ue},$Z2);
$we=q#lib/slice::ctors#;
$xe={};
$ye=[];
$ze=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$Ae=bless({$o,$ye,$q,$ze,$s,$t},$u);
$Be=q#resolver_for#;
$Ce=[];
$De=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$Ee=bless({$o,$Ce,$q,$De,$s,$t},$u);
$Fe={$K3,$Ae,$Be,$Ee};
$Ge=q#/lib/ni_resolver.b#;
$He=bless({$f2,$xe,$N2,$O2,$P2,$O2,$Q2,$Fe,$D,$Ge},$Z2);
$Ie=q#lib/slice::ctors#;
$Je=[$J4,$Hd,$Ud,$ve,$He];
$Ke=bless({$f2,$qd,$D,$rd,$F2,$Je},$o2);
$Le=q#lib/ni.c::ctors#;
$Me=q#ni:/lib/ni.c#;
$Ne={$o2,1};
$Oe=q#/lib/ni.c#;
$Pe=[$P6];
$Qe=bless({$f2,$Ne,$D,$Oe,$F2,$Pe},$H2);
$Re=q#metaclass::ctors#;
$Se=q#ni:/lib/ni_image.b#;
$Te=q#ni:/lib/ni_main.b#;
$Ue=q#ni:/lib/ni_resolver.b#;
$Ve=q#ni:/lib/ni_self.b#;
$We=q#ni:/lib/ni_static_util.b#;
$Xe={};
$Ye=q#abbrev#;
$Ze=[];
$cf=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$df=bless({$o,$Ze,$q,$cf,$s,$t},$u);
$ef=q#dor#;
$ff=[];
$gf=q#defined $_[0] ? $_[0] : $_[1]#;
$hf=bless({$o,$ff,$q,$gf,$s,$t},$u);
$if=q#indent#;
$jf=[];
$kf=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$lf=bless({$o,$jf,$q,$kf,$s,$t},$u);
$mf=q#max#;
$nf=[];
$of=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$pf=bless({$o,$nf,$q,$of,$s,$t},$u);
$qf=q#maxstr#;
$rf=[];
$sf=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$tf=bless({$o,$rf,$q,$sf,$s,$t},$u);
$uf=q#mean#;
$vf=[];
$wf=q#sum(@_) / (@_ || 1)#;
$xf=bless({$o,$vf,$q,$wf,$s,$t},$u);
$yf=q#min#;
$zf=[];
$Af=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$Bf=bless({$o,$zf,$q,$Af,$s,$t},$u);
$Cf=q#minstr#;
$Df=[];
$Ef=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$Ff=bless({$o,$Df,$q,$Ef,$s,$t},$u);
$Gf=q#sgr#;
$Hf=[];
$If=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$Jf=bless({$o,$Hf,$q,$If,$s,$t},$u);
$Kf=q#sr#;
$Lf=[];
$Mf=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$Nf=bless({$o,$Lf,$q,$Mf,$s,$t},$u);
$Of=q#sum#;
$Pf=[];
$Qf=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$Rf=bless({$o,$Pf,$q,$Qf,$s,$t},$u);
$Sf=q#swap#;
$Tf=[];
$Uf=q#@_[0, 1] = @_[1, 0]#;
$Vf=bless({$o,$Tf,$q,$Uf,$s,$t},$u);
$Wf={$Ye,$df,$ef,$hf,$if,$lf,$mf,$pf,$qf,$tf,$uf,$xf,$yf,$Bf,$Cf,$Ff,$Gf,$Jf,$Kf,$Nf,$Of,$Rf,$Sf,$Vf};
$Xf=q#/lib/ni_static_util.b#;
$Yf=bless({$f2,$Xe,$N2,$O2,$P2,$O2,$Q2,$Wf,$D,$Xf},$Z2);
$Zf=q#lib/slice::ctors#;
$cg=q#ni:/lib/perlbranch.b#;
$dg=q#ni:/lib/ref_eq.b#;
$eg=q#ni:/lib/resolver.b#;
$fg=q#ni:/lib/slice#;
$gg={$Z2,1};
$hg=q#/lib/slice#;
$ig=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$jg=bless({$q,$ig,$s,$t},$u);
$kg=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$lg=bless({$q,$kg,$s,$t},$u);
$mg=q#lib/slice::apply#;
$ng=q#lib/slice::apply_unsafe#;
$og={};
$pg=q#apply_unsafe#;
$qg={$U2,$jg,$pg,$lg};
$rg=q#/lib/slice.b#;
$sg=bless({$f2,$og,$Q2,$qg,$D,$rg},$Z2);
$tg=q#lib/slice::ctors#;
$ug={};
$vg=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$wg=bless({$q,$vg,$s,$t},$u);
$xg={$Y3,$wg};
$yg=q#/lib/slice_init.b#;
$zg=bless({$f2,$ug,$Q2,$xg,$D,$yg},$Z2);
$Ag=q#lib/slice::ctors#;
$Bg={};
$Cg=[];
$Dg=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$Eg=bless({$o,$Cg,$q,$Dg,$s,$t},$u);
$Fg={$Y9,$Eg};
$Gg=q#/lib/slice_serialize.b#;
$Hg=bless({$f2,$Bg,$N2,$O2,$P2,$O2,$Q2,$Fg,$D,$Gg},$Z2);
$Ig=q#lib/slice::ctors#;
$Jg=[$X4,$n3,$sg,$zg,$Hg];
$Kg=bless({$f2,$gg,$D,$hg,$F2,$Jg},$p2);
$Lg=q#lib/slice.c::ctors#;
$Mg=q#ni:/lib/slice.b#;
$Ng=q#ni:/lib/slice.c#;
$Og={$p2,1};
$Pg=q#/lib/slice.c#;
$Qg=[$U6];
$Rg=bless({$f2,$Og,$D,$Pg,$F2,$Qg},$H2);
$Sg=q#metaclass::ctors#;
$Tg=q#ni:/lib/slice_init.b#;
$Ug=q#ni:/lib/slice_serialize.b#;
$Vg=q#ni:/lib/static_fn.b#;
$Wg={};
$Xg=[];
$Yg=q#ni('ni:/lib/fn')->new(@_)#;
$Zg=bless({$o,$Xg,$q,$Yg,$s,$Aa},$u);
$ch=q#fp#;
$dh=[];
$eh=q#ni('ni:/lib/fn')->new(@_)#;
$fh=q#($$)#;
$gh=bless({$o,$dh,$q,$eh,$s,$fh},$u);
$hh={$E9,$Zg,$ch,$gh};
$ih=q#/lib/static_fn.b#;
$jh=bless({$f2,$Wg,$N2,$O2,$P2,$O2,$Q2,$hh,$D,$ih},$Z2);
$kh=q#lib/slice::ctors#;
$lh=q#ni:/lib/subclass.b#;
$mh=q#ni:/lib/tag#;
$nh={$o3,1};
$oh=q#/lib/tag#;
$ph={};
$qh=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$rh=bless({$q,$qh,$s,$t},$u);
$sh={$U2,$rh};
$th=q#/lib/tag.b#;
$uh=bless({$f2,$ph,$N2,$O2,$P2,$O2,$Q2,$sh,$D,$th},$Z2);
$vh=q#lib/slice::ctors#;
$wh={};
$xh=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$yh=bless({$q,$xh,$s,$t},$u);
$zh={$Y3,$yh};
$Ah=q#/lib/tag_init.b#;
$Bh=bless({$f2,$wh,$N2,$O2,$P2,$O2,$Q2,$zh,$D,$Ah},$Z2);
$Ch=q#lib/slice::ctors#;
$Dh=[$X4,$n3,$uh,$Bh];
$Eh=bless({$f2,$nh,$D,$oh,$F2,$Dh},$q2);
$Fh=q#lib/tag.c::ctors#;
$Gh=q#ni:/lib/tag.b#;
$Hh=q#ni:/lib/tag.c#;
$Ih={$q2,1};
$Jh=q#/lib/tag.c#;
$Kh=[$U6];
$Lh=bless({$f2,$Ih,$D,$Jh,$F2,$Kh},$H2);
$Mh=q#metaclass::ctors#;
$Nh=q#ni:/lib/tag_init.b#;
$Oh=q#ni:/lib/test_value#;
$Ph={$m4,1};
$Qh=q#/lib/test_value#;
$Rh={};
$Sh=[];
$Th=q#\\$_[1]#;
$Uh=bless({$o,$Sh,$q,$Th,$s,$t},$u);
$Vh={$Y3,$Uh};
$Wh=q#/lib/test_value_init.b#;
$Xh=bless({$f2,$Rh,$N2,$O2,$P2,$O2,$Q2,$Vh,$D,$Wh},$Z2);
$Yh=q#lib/slice::ctors#;
$Zh={};
$ci=q#(==#;
$di=[];
$ei=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$fi=bless({$o,$di,$q,$ei,$s,$t},$u);
$gi=q#diff#;
$hi=[];
$ii=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$ji=bless({$o,$hi,$q,$ii,$s,$t},$u);
$ki={$ci,$fi,$gi,$ji};
$li=q#/lib/test_value_eq.b#;
$mi=bless({$f2,$Zh,$N2,$O2,$P2,$O2,$Q2,$ki,$D,$li},$Z2);
$ni=q#lib/slice::ctors#;
$oi={};
$pi=[];
$qi=q#ni::json_encode ${$_[0]}#;
$ri=bless({$o,$pi,$q,$qi,$s,$t},$u);
$si={$A5,$ri};
$ti=q#/lib/test_value_str.b#;
$ui=bless({$f2,$oi,$N2,$O2,$P2,$O2,$Q2,$si,$D,$ti},$Z2);
$vi=q#lib/slice::ctors#;
$wi=[$J4,$Xh,$mi,$ui];
$xi=q#lib/test_value.c#;
$yi=bless({$f2,$Ph,$D,$Qh,$F2,$wi},$xi);
$zi=q#lib/test_value.c::ctors#;
$Ai=q#ni:/lib/test_value.c#;
$Bi=q#lib/test_value.c#;
$Ci={$Bi,1};
$Di=q#/lib/test_value.c#;
$Ei=[$P6];
$Fi=bless({$f2,$Ci,$D,$Di,$F2,$Ei},$H2);
$Gi=q#metaclass::ctors#;
$Hi=q#ni:/lib/test_value_eq.b#;
$Ii=q#ni:/lib/test_value_init.b#;
$Ji=q#ni:/lib/test_value_str.b#;
$Ki=q#ni:/metaclass#;
$Li={$H2,1};
$Mi=q#/metaclass#;
$Ni=[$T3,$r6,$f4,$g6];
$Oi=bless({$f2,$Li,$D,$Mi,$F2,$Ni},$s2);
$Pi=q#metaclass.c::ctors#;
$Qi=q#ni:/metaclass.c#;
$Ri={$s2,1};
$Si=q#/metaclass.c#;
$Ti=[$E6];
$Ui=bless({$f2,$Ri,$D,$Si,$F2,$Ti},$H2);
$Vi=q#metaclass::ctors#;
$Wi=q#ni:/module#;
$Xi=q#ni:/module.c#;
$Yi=q#ni:/object#;
$Zi=q#ni:/object.c#;
$cj=q#ni:/unix/cat#;
$dj={$p4,1};
$ej={$p4,1,$r4,1,$s4,1,$t4,1,$u4,1,$v4,1,$w4,1,$x4,1};
$fj=q#/unix/io#;
$gj={};
$hj=q#(bool#;
$ij=[];
$jj=bless({$o,$ij,$q,1,$s,$t},$u);
$kj={$hj,$jj};
$lj=q#/unix/io_ops.b#;
$mj=bless({$f2,$gj,$N2,$O2,$P2,$O2,$Q2,$kj,$D,$lj},$Z2);
$nj=q#lib/slice::ctors#;
$oj={};
$pj=q#into#;
$qj=[];
$rj=q#local $_;
my ($self, $dest, $each) = @_;
my $block_size = $self->can('read_size') ? $self->read_size : 8192;
while ($self->read($_, $block_size)) {
  $dest->write($_);
  &$each($_) && return if defined $each;
}#;
$sj=bless({$o,$qj,$q,$rj,$s,$t},$u);
$tj={$pj,$sj};
$uj=q#/unix/io_stream.b#;
$vj=bless({$f2,$oj,$N2,$O2,$P2,$O2,$Q2,$tj,$D,$uj},$Z2);
$wj=q#lib/slice::ctors#;
$xj={};
$yj=q#(+#;
$zj=[];
$Aj=q#ni('ni:/unix/cat')->new(@_[0, 1])#;
$Bj=bless({$o,$zj,$q,$Aj,$s,$t},$u);
$Cj={$yj,$Bj};
$Dj=q#/unix/io_constructors.b#;
$Ej=bless({$f2,$xj,$N2,$O2,$P2,$O2,$Q2,$Cj,$D,$Dj},$Z2);
$Fj=q#lib/slice::ctors#;
$Gj={};
$Hj=q#read_all#;
$Ij=[];
$Jj=q#shift->into(ni('ni:/unix/str')->new(my $data = ''));
$data;#;
$Kj=bless({$o,$Ij,$q,$Jj,$s,$t},$u);
$Lj={$Hj,$Kj};
$Mj=q#/unix/io_memory.b#;
$Nj=bless({$f2,$Gj,$N2,$O2,$P2,$O2,$Q2,$Lj,$D,$Mj},$Z2);
$Oj=q#lib/slice::ctors#;
$Pj=[$J4,$mj,$vj,$Ej,$Nj];
$Qj=bless({$f2,$ej,$D,$fj,$F2,$Pj},$A2);
$Rj=q#unix/io.c::ctors#;
$Sj={};
$Tj=[];
$Uj=q#shift; +{fs => [@_]}#;
$Vj=bless({$o,$Tj,$q,$Uj,$s,$t},$u);
$Wj={$Y3,$Vj};
$Xj=q#/unix/cat_init.b#;
$Yj=bless({$f2,$Sj,$N2,$O2,$P2,$O2,$Q2,$Wj,$D,$Xj},$Z2);
$Zj=q#lib/slice::ctors#;
$ck={};
$dk=q#read#;
$ek=[];
$fk=q#my $fs = shift->{fs};
my $n;
shift @$fs until !@$fs or $n = $$fs[0]->read(@_);
return $n;#;
$gk=bless({$o,$ek,$q,$fk,$s,$t},$u);
$hk={$dk,$gk};
$ik=q#/unix/cat_read.b#;
$jk=bless({$f2,$ck,$N2,$O2,$P2,$O2,$Q2,$hk,$D,$ik},$Z2);
$kk=q#lib/slice::ctors#;
$lk=[$Qj,$Yj,$jk];
$mk=bless({$f2,$dj,$D,$y1,$F2,$lk},$v2);
$nk=q#unix/cat.c::ctors#;
$ok=q#ni:/unix/cat.c#;
$pk={$v2,1};
$qk=q#/unix/cat.c#;
$rk={$v2,1,$x2,1,$y2,1,$z2,1,$A2,1,$B2,1,$C2,1,$D2,1};
$sk=q#/unix/io.c#;
$tk={};
$uk=q#has_fd#;
$vk=[];
$wk=q#shift->add('/unix/has_fd.b')#;
$xk=bless({$o,$vk,$q,$wk,$s,$t},$u);
$yk={$uk,$xk};
$zk=q#/unix/io.c_has_fd.b#;
$Ak=bless({$f2,$tk,$N2,$O2,$P2,$O2,$Q2,$yk,$D,$zk},$Z2);
$Bk=q#lib/slice::ctors#;
$Ck=[$P6,$Ak];
$Dk=bless({$f2,$rk,$D,$sk,$F2,$Ck},$H2);
$Ek=q#metaclass::ctors#;
$Fk=[$Dk];
$Gk=bless({$f2,$pk,$D,$qk,$F2,$Fk},$H2);
$Hk=q#metaclass::ctors#;
$Ik=q#ni:/unix/cat_init.b#;
$Jk=q#ni:/unix/cat_read.b#;
$Kk=q#ni:/unix/exec#;
$Lk={$q4,1};
$Mk={};
$Nk=q#argv#;
$Ok=[];
$Pk=q#shift->{'argv'}#;
$Qk=bless({$o,$Ok,$q,$Pk,$s,$t},$u);
$Rk={$Nk,$Qk};
$Sk=q#/unix/exec_ro.b#;
$Tk=bless({$f2,$Mk,$N2,$O2,$P2,$O2,$Q2,$Rk,$D,$Sk},$Z2);
$Uk=q#lib/slice::ctors#;
$Vk={};
$Wk=[];
$Xk=q#my ($class, @argv) = @_;
+{argv  => \\@argv,
  env   => {%ENV},
  fds   => {},
  pipes => {}};#;
$Yk=bless({$o,$Wk,$q,$Xk,$s,$t},$u);
$Zk={$Y3,$Yk};
$cl=q#/unix/exec_init.b#;
$dl=bless({$f2,$Vk,$N2,$O2,$P2,$O2,$Q2,$Zk,$D,$cl},$Z2);
$el=q#lib/slice::ctors#;
$fl={};
$gl=q#fds#;
$hl=[];
$il=q#my ($self, %fds) = @_;
return $$self{fds} unless keys %fds;
@{$$self{fds}}{keys %fds} = values %fds;
$self;#;
$jl=bless({$o,$hl,$q,$il,$s,$t},$u);
$kl=q#pipes#;
$ll=[];
$ml=q#local $^F = 1024;
my ($self, @fds) = @_;
return $$self{pipes} unless @fds;
for (@fds) {
  die "ni:/unix/exec: must append 'r' or 'w' to extended fds"
    if $_ > 2 && !/^(\\d+)[rw]$/;
  $$self{pipes}{$_} ||= $$self{fds}{$_} = ni("ni:/unix/fifo")->new;
}
$self;#;
$nl=bless({$o,$ll,$q,$ml,$s,$t},$u);
$ol=q#setup_stdio#;
$pl=[];
$ql=q#my $self = shift;
$self->pipes(grep !exists $$self{fds}{$_}, 0..2);
$self;#;
$rl=bless({$o,$pl,$q,$ql,$s,$t},$u);
$sl={$gl,$jl,$kl,$nl,$ol,$rl};
$tl=q#/unix/exec_io_setup.b#;
$ul=bless({$f2,$fl,$N2,$O2,$P2,$O2,$Q2,$sl,$D,$tl},$Z2);
$vl=q#lib/slice::ctors#;
$wl={};
$xl=q#fd#;
$yl=[];
$zl=q#my ($self, $fd) = @_;
return $$self{pipes}{$fd} if exists $$self{pipes}{$fd};
$self->pipes($fd)->fd($fd);#;
$Al=bless({$o,$yl,$q,$zl,$s,$t},$u);
$Bl=q#stderr#;
$Cl=[];
$Dl=q#shift->fd(2)#;
$El=bless({$o,$Cl,$q,$Dl,$s,$t},$u);
$Fl=q#stdin#;
$Gl=[];
$Hl=q#shift->fd(0)#;
$Il=bless({$o,$Gl,$q,$Hl,$s,$t},$u);
$Jl=q#stdout#;
$Kl=[];
$Ll=q#shift->fd(1)#;
$Ml=bless({$o,$Kl,$q,$Ll,$s,$t},$u);
$Nl={$xl,$Al,$Bl,$El,$Fl,$Il,$Jl,$Ml};
$Ol=q#/unix/exec_io_accessors.b#;
$Pl=bless({$f2,$wl,$N2,$O2,$P2,$O2,$Q2,$Nl,$D,$Ol},$Z2);
$Ql=q#lib/slice::ctors#;
$Rl={};
$Sl=q#env#;
$Tl=[];
$Ul=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$Vl=bless({$o,$Tl,$q,$Ul,$s,$t},$u);
$Wl={$Sl,$Vl};
$Xl=q#/unix/exec_env.b#;
$Yl=bless({$f2,$Rl,$N2,$O2,$P2,$O2,$Q2,$Wl,$D,$Xl},$Z2);
$Zl=q#lib/slice::ctors#;
$cm={};
$dm=q#exec#;
$em=[];
$fm=q#no warnings 'numeric';
my $self = shift->setup_stdio;
local %ENV = %{$$self{env}};
$self->move_fds;
for (keys %{$$self{pipes}}) {
  my $p = $$self{pipes}{$_};
  ($_ < 2 ? !$_ : /r$/) ? $p->r : $p->w;
}
my @argv = (@{$$self{argv}}, @_);
{ exec @argv };
print STDERR "ni:/unix/exec: exec @argv failed: $!";
exit 1;#;
$gm=bless({$o,$em,$q,$fm,$s,$t},$u);
$hm=q#fork#;
$im=[];
$jm=q#no warnings 'numeric';
my $self = shift->setup_stdio;
my $pid = fork;
die "ni:/unix/exec: fork failed: $!" unless defined $pid;
return $self->exec(@_) unless $pid;
for (keys %{$$self{pipes}}) {
  my $p = $$self{pipes}{$_};
  ($_ < 2 ? $_ : /r$/) ? $p->w : $p->r;
}
ni('ni:/unix/pid')->new($pid, %{$$self{pipes}});#;
$km=bless({$o,$im,$q,$jm,$s,$t},$u);
$lm=q#move_fds#;
$mm=[];
$nm=q#my $self = shift;
$$self{fds}{$_}->be($_) for keys %{$$self{fds}};
$self;#;
$om=bless({$o,$mm,$q,$nm,$s,$t},$u);
$pm={$dm,$gm,$hm,$km,$lm,$om};
$qm=q#/unix/exec_fork.b#;
$rm=bless({$f2,$cm,$N2,$O2,$P2,$O2,$Q2,$pm,$D,$qm},$Z2);
$sm=q#lib/slice::ctors#;
$tm=[$J4,$Tk,$dl,$ul,$Pl,$Yl,$rm];
$um=bless({$f2,$Lk,$D,$K1,$F2,$tm},$w2);
$vm=q#unix/exec.c::ctors#;
$wm=q#ni:/unix/exec.c#;
$xm={$w2,1};
$ym=q#/unix/exec.c#;
$zm=[$P6];
$Am=bless({$f2,$xm,$D,$ym,$F2,$zm},$H2);
$Bm=q#metaclass::ctors#;
$Cm=q#ni:/unix/exec_env.b#;
$Dm=q#ni:/unix/exec_fork.b#;
$Em=q#ni:/unix/exec_init.b#;
$Fm=q#ni:/unix/exec_io_accessors.b#;
$Gm=q#ni:/unix/exec_io_setup.b#;
$Hm=q#ni:/unix/exec_ro.b#;
$Im=q#ni:/unix/fd#;
$Jm={$r4,1};
$Km=q#/unix/fd#;
$Lm={};
$Mm=[];
$Nm=q#shift->{'fd'}#;
$Om=bless({$o,$Mm,$q,$Nm,$s,$t},$u);
$Pm={$xl,$Om};
$Qm=q#/unix/fd_readers.b#;
$Rm=bless({$f2,$Lm,$N2,$O2,$P2,$O2,$Q2,$Pm,$D,$Qm},$Z2);
$Sm=q#lib/slice::ctors#;
$Tm={};
$Um=[];
$Vm=q#my ($class, $fd) = @_;
+{fd => ref $fd ? fileno $fd : $fd,
  fh => ref $fd ? $fd        : undef};#;
$Wm=bless({$o,$Um,$q,$Vm,$s,$t},$u);
$Xm={$Y3,$Wm};
$Ym=q#/unix/fd_init.b#;
$Zm=bless({$f2,$Tm,$N2,$O2,$P2,$O2,$Q2,$Xm,$D,$Ym},$Z2);
$cn=q#lib/slice::ctors#;
$dn={};
$en=q#be#;
$fn=[];
$gn=q#use POSIX qw/dup2/;
my ($self, $new) = @_;
return $self if $new == $$self{fd};
close $$self{fh} if Scalar::Util::openhandle $$self{fh};
dup2 $$self{fd}, $new or die "ni:/unix/fd: dup2($$self{fd}, $new): $!";
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$hn=bless({$o,$fn,$q,$gn,$s,$t},$u);
$in={$en,$hn};
$jn=q#/unix/fd_shell.b#;
$kn=bless({$f2,$dn,$N2,$O2,$P2,$O2,$Q2,$in,$D,$jn},$Z2);
$ln=q#lib/slice::ctors#;
$mn={$r4,1,$s4,1,$t4,1,$v4,1,$w4,1};
$nn=q#/unix/has_fd.b#;
$on={};
$pn=q#read_fd#;
$qn=[];
$rn=q#ni("ni:/unix/fd")->new(fileno shift->read_fh)#;
$sn=bless({$o,$qn,$q,$rn,$s,$t},$u);
$tn=q#write_fd#;
$un=[];
$vn=q#ni("ni:/unix/fd")->new(fileno shift->write_fh)#;
$wn=bless({$o,$un,$q,$vn,$s,$t},$u);
$xn={$pn,$sn,$tn,$wn};
$yn=q#/unix/fd_accessors.b#;
$zn=bless({$f2,$on,$N2,$O2,$P2,$O2,$Q2,$xn,$D,$yn},$Z2);
$An=q#lib/slice::ctors#;
$Bn={};
$Cn=[];
$Dn=q#no warnings 'io';
use Errno qw/EINTR/;
my $fh = shift->read_fh;
my $n;
do {
  return $n if defined($n = read $fh, $_[0], $_[1], $_[2] || 0);
} while $!{EINTR};
return undef;#;
$En=bless({$o,$Cn,$q,$Dn,$s,$t},$u);
$Fn=[];
$Gn=q#my $fh = shift->write_fh;
my $n;
do {
  return $n if defined($n = syswrite $fh, $_[0]);
} while $!{EINTR};
return undef;#;
$Hn=bless({$o,$Fn,$q,$Gn,$s,$t},$u);
$In={$dk,$En,$nc,$Hn};
$Jn=q#/unix/fd_safeio.b#;
$Kn=bless({$f2,$Bn,$N2,$O2,$P2,$O2,$Q2,$In,$D,$Jn},$Z2);
$Ln=q#lib/slice::ctors#;
$Mn=[$zn,$Kn];
$Nn=bless({$f2,$mn,$D,$nn,$F2,$Mn},$d3);
$On=q#lib/branch::ctors#;
$Pn={};
$Qn=q#read_fh#;
$Rn=[];
$Sn=q#my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, '<&=', $$self{fd}
  or die "ni:/unix/fd $$self{fd} failed to read: $!";
$self->{fh} = $fh;#;
$Tn=bless({$o,$Rn,$q,$Sn,$s,$t},$u);
$Un=q#write_fh#;
$Vn=[];
$Wn=q#my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, '>&=', $$self{fd}
  or die "ni:/unix/file $$self{fd} failed to write: $!";
$self->{fh} = $fh;#;
$Xn=bless({$o,$Vn,$q,$Wn,$s,$t},$u);
$Yn={$Qn,$Tn,$Un,$Xn};
$Zn=q#/unix/fd_io.b#;
$co=bless({$f2,$Pn,$N2,$O2,$P2,$O2,$Q2,$Yn,$D,$Zn},$Z2);
$do=q#lib/slice::ctors#;
$eo=[$Qj,$Rm,$Zm,$kn,$Nn,$co];
$fo=bless({$f2,$Jm,$D,$Km,$F2,$eo},$x2);
$go=q#unix/fd.c::ctors#;
$ho=q#ni:/unix/fd.c#;
$io={$x2,1};
$jo=q#/unix/fd.c#;
$ko=[$Dk];
$lo=bless({$f2,$io,$D,$jo,$F2,$ko},$H2);
$mo=q#metaclass::ctors#;
$no=q#ni:/unix/fd_accessors.b#;
$oo=q#ni:/unix/fd_init.b#;
$po=q#ni:/unix/fd_io.b#;
$qo=q#ni:/unix/fd_readers.b#;
$ro=q#ni:/unix/fd_safeio.b#;
$so=q#ni:/unix/fd_shell.b#;
$to=q#ni:/unix/fifo#;
$uo={$s4,1};
$vo=q#/unix/fifo#;
$wo={};
$xo=[];
$yo=q#shift->{'read_fh'}#;
$zo=bless({$o,$xo,$q,$yo,$s,$t},$u);
$Ao=[];
$Bo=q#shift->{'write_fh'}#;
$Co=bless({$o,$Ao,$q,$Bo,$s,$t},$u);
$Do={$Qn,$zo,$Un,$Co};
$Eo=q#/unix/fifo_io.b#;
$Fo=bless({$f2,$wo,$N2,$O2,$P2,$O2,$Q2,$Do,$D,$Eo},$Z2);
$Go=q#lib/slice::ctors#;
$Ho={};
$Io=[];
$Jo=q#my ($class) = @_;
pipe my ($r, $w) or die "ni:/unix/fifo failed: $!";
+{read_fh => $r, write_fh => $w};#;
$Ko=bless({$o,$Io,$q,$Jo,$s,$t},$u);
$Lo={$Y3,$Ko};
$Mo=q#/unix/fifo_init.b#;
$No=bless({$f2,$Ho,$N2,$O2,$P2,$O2,$Q2,$Lo,$D,$Mo},$Z2);
$Oo=q#lib/slice::ctors#;
$Po={};
$Qo=[];
$Ro=q#my ($self, $fd) = @_;
(!$fd || $fd > 2 && $fd =~ s/[rw]$// && $1 eq 'r'
  ? $self->r
  : $self->w)->be($fd);
$self;#;
$So=bless({$o,$Qo,$q,$Ro,$s,$t},$u);
$To={$en,$So};
$Uo=q#/unix/fifo_stdio.b#;
$Vo=bless({$f2,$Po,$N2,$O2,$P2,$O2,$Q2,$To,$D,$Uo},$Z2);
$Wo=q#lib/slice::ctors#;
$Xo={};
$Yo=q#r#;
$Zo=[];
$cp=q#my $self = shift;
close $$self{write_fh};
$self->read_fd;#;
$dp=bless({$o,$Zo,$q,$cp,$s,$t},$u);
$ep=q#w#;
$fp=[];
$gp=q#my $self = shift;
close $$self{read_fh};
$self->write_fd;#;
$hp=bless({$o,$fp,$q,$gp,$s,$t},$u);
$ip={$Yo,$dp,$ep,$hp};
$jp=q#/unix/fifo_direction.b#;
$kp=bless({$f2,$Xo,$N2,$O2,$P2,$O2,$Q2,$ip,$D,$jp},$Z2);
$lp=q#lib/slice::ctors#;
$mp=[$Qj,$Fo,$No,$Vo,$Nn,$kp];
$np=bless({$f2,$uo,$D,$vo,$F2,$mp},$y2);
$op=q#unix/fifo.c::ctors#;
$pp=q#ni:/unix/fifo.c#;
$qp={$y2,1};
$rp=q#/unix/fifo.c#;
$sp=[$Dk];
$tp=bless({$f2,$qp,$D,$rp,$F2,$sp},$H2);
$up=q#metaclass::ctors#;
$vp=q#ni:/unix/fifo_direction.b#;
$wp=q#ni:/unix/fifo_init.b#;
$xp=q#ni:/unix/fifo_io.b#;
$yp=q#ni:/unix/fifo_stdio.b#;
$zp=q#ni:/unix/file#;
$Ap={$t4,1};
$Bp=q#/unix/file#;
$Cp={};
$Dp=[];
$Ep=q#shift->{'name'}#;
$Fp=bless({$o,$Dp,$q,$Ep,$s,$t},$u);
$Gp={$D,$Fp};
$Hp=q#/unix/file_readers.b#;
$Ip=bless({$f2,$Cp,$N2,$O2,$P2,$O2,$Q2,$Gp,$D,$Hp},$Z2);
$Jp=q#lib/slice::ctors#;
$Kp={};
$Lp=[];
$Mp=q#my ($class, $name) = @_;
+{name => $name, fh => undef};#;
$Np=bless({$o,$Lp,$q,$Mp,$s,$t},$u);
$Op={$Y3,$Np};
$Pp=q#/unix/file_init.b#;
$Qp=bless({$f2,$Kp,$N2,$O2,$P2,$O2,$Q2,$Op,$D,$Pp},$Z2);
$Rp=q#lib/slice::ctors#;
$Sp={};
$Tp=[];
$Up=q#my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, '<', $self->{name}
  or die "ni:/unix/file $self->{name} failed to read: $!";
$self->{fh} = $fh;#;
$Vp=bless({$o,$Tp,$q,$Up,$s,$t},$u);
$Wp=[];
$Xp=q#my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, '>', $self->{name}
  or die "ni:/unix/file $self->{name} failed to write: $!";
$self->{fh} = $fh;#;
$Yp=bless({$o,$Wp,$q,$Xp,$s,$t},$u);
$Zp={$Qn,$Vp,$Un,$Yp};
$cq=q#/unix/file_io.b#;
$dq=bless({$f2,$Sp,$N2,$O2,$P2,$O2,$Q2,$Zp,$D,$cq},$Z2);
$eq=q#lib/slice::ctors#;
$fq=[$Qj,$Ip,$Qp,$Nn,$dq];
$gq=bless({$f2,$Ap,$D,$Bp,$F2,$fq},$z2);
$hq=q#unix/file.c::ctors#;
$iq=q#ni:/unix/file.c#;
$jq={$z2,1};
$kq=q#/unix/file.c#;
$lq=[$Dk];
$mq=bless({$f2,$jq,$D,$kq,$F2,$lq},$H2);
$nq=q#metaclass::ctors#;
$oq=q#ni:/unix/file_init.b#;
$pq=q#ni:/unix/file_io.b#;
$qq=q#ni:/unix/file_readers.b#;
$rq=q#ni:/unix/has_fd.b#;
$sq=q#ni:/unix/io#;
$tq=q#ni:/unix/io.c#;
$uq=q#ni:/unix/io.c_has_fd.b#;
$vq=q#ni:/unix/io_constructors.b#;
$wq=q#ni:/unix/io_memory.b#;
$xq=q#ni:/unix/io_ops.b#;
$yq=q#ni:/unix/io_stream.b#;
$zq=q#ni:/unix/pid#;
$Aq={$v4,1};
$Bq={};
$Cq=q#pid#;
$Dq=[];
$Eq=q#shift->{'pid'}#;
$Fq=bless({$o,$Dq,$q,$Eq,$s,$t},$u);
$Gq=q#status#;
$Hq=[];
$Iq=q#shift->{'status'}#;
$Jq=bless({$o,$Hq,$q,$Iq,$s,$t},$u);
$Kq={$Cq,$Fq,$Gq,$Jq};
$Lq=q#/unix/pid_readers.b#;
$Mq=bless({$f2,$Bq,$N2,$O2,$P2,$O2,$Q2,$Kq,$D,$Lq},$Z2);
$Nq=q#lib/slice::ctors#;
$Oq={};
$Pq=[];
$Qq=q#shift->await#;
$Rq=bless({$o,$Pq,$q,$Qq,$s,$t},$u);
$Sq=[];
$Tq=q#my ($class, $pid, %exposed_fds) = @_;
+{pid    => $pid,
  fds    => \\%exposed_fds,
  status => undef};#;
$Uq=bless({$o,$Sq,$q,$Tq,$s,$t},$u);
$Vq={$Y3,$Uq};
$Wq=q#/unix/pid_init.b#;
$Xq=bless({$f2,$Oq,$N2,$O2,$P2,$Rq,$Q2,$Vq,$D,$Wq},$Z2);
$Yq=q#lib/slice::ctors#;
$Zq={};
$cr=q#await#;
$dr=[];
$er=q#my $self = shift;
return $$self{status} if defined $$self{status};
defined(waitpid $$self{pid}, 0)
  ? $$self{status} = $?
  : die "/unix/pid_wait.b: waitpid: $!";#;
$fr=bless({$o,$dr,$q,$er,$s,$t},$u);
$gr=q#running#;
$hr=[];
$ir=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$jr=bless({$o,$hr,$q,$ir,$s,$t},$u);
$kr={$cr,$fr,$gr,$jr};
$lr=q#/unix/pid_wait.b#;
$mr=bless({$f2,$Zq,$N2,$O2,$P2,$O2,$Q2,$kr,$D,$lr},$Z2);
$nr=q#lib/slice::ctors#;
$or={};
$pr=[];
$qr=q#shift->fd(1)->read_fh#;
$rr=bless({$o,$pr,$q,$qr,$s,$t},$u);
$sr=[];
$tr=q#shift->fd(0)->write_fh#;
$ur=bless({$o,$sr,$q,$tr,$s,$t},$u);
$vr={$Qn,$rr,$Un,$ur};
$wr=q#/unix/pid_io.b#;
$xr=bless({$f2,$or,$N2,$O2,$P2,$O2,$Q2,$vr,$D,$wr},$Z2);
$yr=q#lib/slice::ctors#;
$zr={};
$Ar=[];
$Br=q#$_[0]->{fds}{$_[1]}#;
$Cr=bless({$o,$Ar,$q,$Br,$s,$t},$u);
$Dr=[];
$Er=bless({$o,$Dr,$q,$Dl,$s,$t},$u);
$Fr=[];
$Gr=bless({$o,$Fr,$q,$Hl,$s,$t},$u);
$Hr=[];
$Ir=bless({$o,$Hr,$q,$Ll,$s,$t},$u);
$Jr={$xl,$Cr,$Bl,$Er,$Fl,$Gr,$Jl,$Ir};
$Kr=q#/unix/pid_accessors.b#;
$Lr=bless({$f2,$zr,$N2,$O2,$P2,$O2,$Q2,$Jr,$D,$Kr},$Z2);
$Mr=q#lib/slice::ctors#;
$Nr=[$Qj,$Mq,$Xq,$mr,$Nn,$xr,$Lr];
$Or=bless({$f2,$Aq,$D,$c2,$F2,$Nr},$B2);
$Pr=q#unix/pid.c::ctors#;
$Qr=q#ni:/unix/pid.c#;
$Rr={$B2,1};
$Sr=q#/unix/pid.c#;
$Tr=[$Dk];
$Ur=bless({$f2,$Rr,$D,$Sr,$F2,$Tr},$H2);
$Vr=q#metaclass::ctors#;
$Wr=q#ni:/unix/pid_accessors.b#;
$Xr=q#ni:/unix/pid_init.b#;
$Yr=q#ni:/unix/pid_io.b#;
$Zr=q#ni:/unix/pid_readers.b#;
$cs=q#ni:/unix/pid_wait.b#;
$ds=q#ni:/unix/pipeline#;
$es={$w4,1};
$fs=q#/unix/pipeline#;
$gs={};
$hs=[];
$is=q#shift->{'stdin'}#;
$js=bless({$o,$hs,$q,$is,$s,$t},$u);
$ks=[];
$ls=q#shift->{'stdout'}#;
$ms=bless({$o,$ks,$q,$ls,$s,$t},$u);
$ns={$Fl,$js,$Jl,$ms};
$os=q#/unix/pipeline_ro.b#;
$ps=bless({$f2,$gs,$N2,$O2,$P2,$O2,$Q2,$ns,$D,$os},$Z2);
$qs=q#lib/slice::ctors#;
$rs={};
$ss=[];
$ts=q#my $class  = shift;
my $stdin  = ni('ni:/unix/fifo')->new;
my $stdout = ni('ni:/unix/fifo')->new;
\# TODO: stderr and multiplexing, which probably happens here

my @rs = ($stdin, @_);
my @ws = (@_, $stdout);
my $rv; vec($rv, fileno $_->read_fh,  1) = 1 for @rs;
my $wv; vec($wv, fileno $_->write_fh, 1) = 1 for @ws;

+{ps     => [@_],
  stdin  => $stdin,
  stdout => $stdout,
  rs => \\@rs, rv => $rv,
  ws => \\@ws, wv => $wv};#;
$us=bless({$o,$ss,$q,$ts,$s,$t},$u);
$vs={$Y3,$us};
$ws=q#/unix/pipeline_init.b#;
$xs=bless({$f2,$rs,$N2,$O2,$P2,$O2,$Q2,$vs,$D,$ws},$Z2);
$ys=q#lib/slice::ctors#;
$zs={};
$As=q#async_step#;
$Bs=[];
$Cs=q#local $_;
my $self = shift;
my $rv = $$self{rv};
my $wv = $$self{wv};
my $ev = $$self{ev};
return $self unless select $rv, $wv, $ev, 0;
for my $i (0..$\#{$$self{rs}}) {
  my $rfh = $$self{rs}[$i]->read_fh;
  my $wfh = $$self{ws}[$i]->write_fh;
  next unless vec $rv, fileno $rfh, 1 and vec $wv, fileno $wfh, 1;
  $$self{rs}[$i]->read($_, 8192);
  $$self{ws}[$i]->write($_);
}
$self;#;
$Ds=bless({$o,$Bs,$q,$Cs,$s,$t},$u);
$Es={$As,$Ds};
$Fs=q#/unix/pipeline_async.b#;
$Gs=bless({$f2,$zs,$N2,$O2,$P2,$O2,$Q2,$Es,$D,$Fs},$Z2);
$Hs=q#lib/slice::ctors#;
$Is={};
$Js=[];
$Ks=q#shift->{stdout}->read_fh#;
$Ls=bless({$o,$Js,$q,$Ks,$s,$t},$u);
$Ms=[];
$Ns=q#shift->{stdin}->write_fh#;
$Os=bless({$o,$Ms,$q,$Ns,$s,$t},$u);
$Ps={$Qn,$Ls,$Un,$Os};
$Qs=q#/unix/pipeline_io.b#;
$Rs=bless({$f2,$Is,$N2,$O2,$P2,$O2,$Q2,$Ps,$D,$Qs},$Z2);
$Ss=q#lib/slice::ctors#;
$Ts=[$Qj,$ps,$xs,$Gs,$Nn,$Rs];
$Us=bless({$f2,$es,$D,$fs,$F2,$Ts},$C2);
$Vs=q#unix/pipeline.c::ctors#;
$Ws=q#ni:/unix/pipeline.c#;
$Xs={$C2,1};
$Ys=q#/unix/pipeline.c#;
$Zs=[$Dk];
$ct=bless({$f2,$Xs,$D,$Ys,$F2,$Zs},$H2);
$dt=q#metaclass::ctors#;
$et=q#ni:/unix/pipeline_async.b#;
$ft=q#ni:/unix/pipeline_init.b#;
$gt=q#ni:/unix/pipeline_io.b#;
$ht=q#ni:/unix/pipeline_ro.b#;
$it=q#ni:/unix/str#;
$jt={$x4,1};
$kt=q#/unix/str#;
$lt={};
$mt=q#data#;
$nt=[];
$ot=q#shift->{'data'}#;
$pt=bless({$o,$nt,$q,$ot,$s,$t},$u);
$qt=q#end#;
$rt=[];
$st=q#shift->{'end'}#;
$tt=bless({$o,$rt,$q,$st,$s,$t},$u);
$ut=q#start#;
$vt=[];
$wt=q#shift->{'start'}#;
$xt=bless({$o,$vt,$q,$wt,$s,$t},$u);
$yt={$mt,$pt,$qt,$tt,$ut,$xt};
$zt=q#/unix/str_ro.b#;
$At=bless({$f2,$lt,$N2,$O2,$P2,$O2,$Q2,$yt,$D,$zt},$Z2);
$Bt=q#lib/slice::ctors#;
$Ct={};
$Dt=[];
$Et=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$Ft=bless({$o,$Dt,$q,$Et,$s,$t},$u);
$Gt={$Y3,$Ft};
$Ht=q#/unix/str_init.b#;
$It=bless({$f2,$Ct,$N2,$O2,$P2,$O2,$Q2,$Gt,$D,$Ht},$Z2);
$Jt=q#lib/slice::ctors#;
$Kt={};
$Lt=[];
$Mt=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$Nt=bless({$o,$Lt,$q,$Mt,$s,$t},$u);
$Ot=q#remaining#;
$Pt=[];
$Qt=q#my $self = shift; $$self{end} - $$self{start}#;
$Rt=bless({$o,$Pt,$q,$Qt,$s,$t},$u);
$St=[];
$Tt=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$Ut=bless({$o,$St,$q,$Tt,$s,$t},$u);
$Vt={$dk,$Nt,$Ot,$Rt,$nc,$Ut};
$Wt=q#/unix/str_io.b#;
$Xt=bless({$f2,$Kt,$N2,$O2,$P2,$O2,$Q2,$Vt,$D,$Wt},$Z2);
$Yt=q#lib/slice::ctors#;
$Zt=[$Qj,$At,$It,$Xt];
$cu=bless({$f2,$jt,$D,$kt,$F2,$Zt},$D2);
$du=q#unix/str.c::ctors#;
$eu=q#ni:/unix/str.c#;
$fu={$D2,1};
$gu=q#/unix/str.c#;
$hu=[$Dk];
$iu=bless({$f2,$fu,$D,$gu,$F2,$hu},$H2);
$ju=q#metaclass::ctors#;
$ku=q#ni:/unix/str_init.b#;
$lu=q#ni:/unix/str_io.b#;
$mu=q#ni:/unix/str_ro.b#;
$nu=q#ni:main#;
$ou={$Fa,1};
$pu=[$jh,$Ea];
$qu=bless({$f2,$ou,$D,$Fa,$F2,$pu},$I2);
$ru=q#module::ctors#;
$su=q#ni:ni#;
$tu={$jd,1};
$uu={$jd,1};
$vu=q#json_escapes#;
$wu=q##;
$xu=q#b#;
$yu=q#	#;
$zu=q#t#;
$Au=q#
#;
$Bu=q#n#;
$Cu=q##;
$Du=q#"#;
$Eu=q#/#;
$Fu=q#\\#;
$Gu={$wu,$xu,$yu,$zu,$Au,$Bu,$Cu,$Yo,$Du,$Du,$Eu,$Eu,$Fu,$Fu};
$Hu=q#json_unescapes#;
$Iu={$Du,$Du,$Eu,$Eu,$Fu,$Fu,$xu,$wu,$Bu,$Au,$Yo,$Cu,$zu,$yu};
$Ju={$vu,$Gu,$Hu,$Iu};
$Ku=q#/lib/json_data.b#;
$Lu=bless({$f2,$uu,$mt,$Ju,$D,$Ku},$j4);
$Mu=q#lib/dataslice::ctors#;
$Nu=[$Lu,$id,$Yf];
$Ou=bless({$f2,$tu,$D,$jd,$F2,$Nu},$I2);
$Pu={$d,$G,$I,$N,$O,$f1,$g1,$n1,$o1,$z1,$A1,$L1,$M1,$d2,$e2,$E6,$G6,$c7,$e7,$w5,$f7,$X4,$g7,$U6,$h7,$s7,$u7,$c3,$v7,$z7,$B7,$p7,$C7,$f4,$D7,$V7,$X7,$d8,$f8,$S7,$g8,$L7,$h8,$d6,$i8,$k5,$j8,$X5,$k8,$T8,$V8,$Z8,$d9,$G8,$e9,$r8,$f9,$y8,$g9,$Q8,$h9,$T4,$i9,$ja,$la,$pa,$ra,$v9,$sa,$V9,$ta,$K9,$ua,$ga,$va,$Ea,$Ha,$wc,$yc,$Cc,$Ec,$Qa,$Fc,$tc,$Gc,$F4,$Hc,$r6,$Ic,$id,$ld,$F5,$md,$n3,$nd,$x3,$od,$G3,$pd,$Ke,$Me,$Qe,$Se,$Ud,$Te,$ve,$Ue,$He,$Ve,$Hd,$We,$Yf,$cg,$T3,$dg,$O5,$eg,$P3,$fg,$Kg,$Mg,$sg,$Ng,$Rg,$Tg,$zg,$Ug,$Hg,$Vg,$jh,$lh,$A6,$mh,$Eh,$Gh,$uh,$Hh,$Lh,$Nh,$Bh,$Oh,$yi,$Ai,$Fi,$Hi,$mi,$Ii,$Xh,$Ji,$ui,$Ki,$Oi,$Qi,$Ui,$Wi,$g6,$Xi,$X6,$Yi,$J4,$Zi,$P6,$cj,$mk,$ok,$Gk,$Ik,$Yj,$Jk,$jk,$Kk,$um,$wm,$Am,$Cm,$Yl,$Dm,$rm,$Em,$dl,$Fm,$Pl,$Gm,$ul,$Hm,$Tk,$Im,$fo,$ho,$lo,$no,$zn,$oo,$Zm,$po,$co,$qo,$Rm,$ro,$Kn,$so,$kn,$to,$np,$pp,$tp,$vp,$kp,$wp,$No,$xp,$Fo,$yp,$Vo,$zp,$gq,$iq,$mq,$oq,$Qp,$pq,$dq,$qq,$Ip,$rq,$Nn,$sq,$Qj,$tq,$Dk,$uq,$Ak,$vq,$Ej,$wq,$Nj,$xq,$mj,$yq,$vj,$zq,$Or,$Qr,$Ur,$Wr,$Lr,$Xr,$Xq,$Yr,$xr,$Zr,$Mq,$cs,$mr,$ds,$Us,$Ws,$ct,$et,$Gs,$ft,$xs,$gt,$Rs,$ht,$ps,$it,$cu,$eu,$iu,$ku,$It,$lu,$Xt,$mu,$At,$nu,$qu,$su,$Ou};
$Qu=q#resolvers#;
$Ru=[];
$Su=q#ni('ni:/unix/fd')->new(0 + substr shift, 3)#;
$Tu=bless({$o,$Ru,$q,$Su,$s,$t},$u);
$Uu=q#file#;
$Vu=[];
$Wu=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/unix/file')->new($f);#;
$Xu=bless({$o,$Vu,$q,$Wu,$s,$t},$u);
$Yu=q#sh#;
$Zu=[];
$cv=q#ni('ni:/unix/exec')->new('/bin/sh', '-c', substr shift, 3)->fork;#;
$dv=bless({$o,$Zu,$q,$cv,$s,$t},$u);
$ev=q#str#;
$fv=[];
$gv=q#my $s = shift;
ni('ni:/unix/str')->new(substr($s, 4) . "\\n");#;
$hv=bless({$o,$fv,$q,$gv,$s,$t},$u);
$iv={$xl,$Tu,$Uu,$Xu,$Yu,$dv,$ev,$hv};
$jv=bless({$c,$Pu,$Qu,$iv},$l4);
$kv=q#lib/ni::ctors#;
*$ng=\&$lg;
*$mg=\&$jg;
$c3->apply_unsafe($g2);
$c3->apply_unsafe($h2);
$c3->apply_unsafe($i2);
$c3->apply_unsafe($d3);
$c3->apply_unsafe($j2);
$c3->apply_unsafe($k2);
$c3->apply_unsafe($l2);
$c3->apply_unsafe($m2);
$c3->apply_unsafe($n2);
$c3->apply_unsafe($o2);
$c3->apply_unsafe($p2);
$c3->apply_unsafe($q2);
$c3->apply_unsafe($e3);
$c3->apply_unsafe($H2);
$c3->apply_unsafe($s2);
$c3->apply_unsafe($I2);
$c3->apply_unsafe($t2);
$c3->apply_unsafe($u2);
$c3->apply_unsafe($v2);
$c3->apply_unsafe($w2);
$c3->apply_unsafe($x2);
$c3->apply_unsafe($y2);
$c3->apply_unsafe($z2);
$c3->apply_unsafe($A2);
$c3->apply_unsafe($B2);
$c3->apply_unsafe($C2);
$c3->apply_unsafe($D2);
$n3->apply_unsafe($g2);
$n3->apply_unsafe($h2);
$n3->apply_unsafe($i2);
$n3->apply_unsafe($d3);
$n3->apply_unsafe($j2);
$n3->apply_unsafe($k2);
$n3->apply_unsafe($F);
$n3->apply_unsafe($l2);
$n3->apply_unsafe($m2);
$n3->apply_unsafe($n2);
$n3->apply_unsafe($o2);
$n3->apply_unsafe($Z2);
$n3->apply_unsafe($p2);
$n3->apply_unsafe($o3);
$n3->apply_unsafe($q2);
$n3->apply_unsafe($p3);
$n3->apply_unsafe($H2);
$n3->apply_unsafe($s2);
$n3->apply_unsafe($I2);
$n3->apply_unsafe($t2);
$n3->apply_unsafe($u2);
$n3->apply_unsafe($v2);
$n3->apply_unsafe($w2);
$n3->apply_unsafe($x2);
$n3->apply_unsafe($y2);
$n3->apply_unsafe($z2);
$n3->apply_unsafe($A2);
$n3->apply_unsafe($B2);
$n3->apply_unsafe($C2);
$n3->apply_unsafe($D2);
$x3->apply_unsafe($g2);
$x3->apply_unsafe($h2);
$x3->apply_unsafe($i2);
$x3->apply_unsafe($d3);
$x3->apply_unsafe($j2);
$x3->apply_unsafe($k2);
$x3->apply_unsafe($l2);
$x3->apply_unsafe($m2);
$x3->apply_unsafe($n2);
$x3->apply_unsafe($o2);
$x3->apply_unsafe($Z2);
$x3->apply_unsafe($p2);
$x3->apply_unsafe($o3);
$x3->apply_unsafe($q2);
$x3->apply_unsafe($y3);
$x3->apply_unsafe($H2);
$x3->apply_unsafe($s2);
$x3->apply_unsafe($I2);
$x3->apply_unsafe($t2);
$x3->apply_unsafe($u2);
$x3->apply_unsafe($v2);
$x3->apply_unsafe($w2);
$x3->apply_unsafe($x2);
$x3->apply_unsafe($y2);
$x3->apply_unsafe($z2);
$x3->apply_unsafe($A2);
$x3->apply_unsafe($B2);
$x3->apply_unsafe($C2);
$x3->apply_unsafe($D2);
$G3->apply_unsafe($g2);
$G3->apply_unsafe($h2);
$G3->apply_unsafe($i2);
$G3->apply_unsafe($d3);
$G3->apply_unsafe($j2);
$G3->apply_unsafe($k2);
$G3->apply_unsafe($l2);
$G3->apply_unsafe($m2);
$G3->apply_unsafe($n2);
$G3->apply_unsafe($o2);
$G3->apply_unsafe($Z2);
$G3->apply_unsafe($p2);
$G3->apply_unsafe($o3);
$G3->apply_unsafe($q2);
$G3->apply_unsafe($H3);
$G3->apply_unsafe($H2);
$G3->apply_unsafe($s2);
$G3->apply_unsafe($I2);
$G3->apply_unsafe($t2);
$G3->apply_unsafe($u2);
$G3->apply_unsafe($v2);
$G3->apply_unsafe($w2);
$G3->apply_unsafe($x2);
$G3->apply_unsafe($y2);
$G3->apply_unsafe($z2);
$G3->apply_unsafe($A2);
$G3->apply_unsafe($B2);
$G3->apply_unsafe($C2);
$G3->apply_unsafe($D2);
$P3->apply_unsafe($g2);
$P3->apply_unsafe($h2);
$P3->apply_unsafe($i2);
$P3->apply_unsafe($d3);
$P3->apply_unsafe($j2);
$P3->apply_unsafe($k2);
$P3->apply_unsafe($l2);
$P3->apply_unsafe($m2);
$P3->apply_unsafe($n2);
$P3->apply_unsafe($o2);
$P3->apply_unsafe($p2);
$P3->apply_unsafe($o3);
$P3->apply_unsafe($q2);
$P3->apply_unsafe($Q3);
$P3->apply_unsafe($H2);
$P3->apply_unsafe($s2);
$P3->apply_unsafe($I2);
$P3->apply_unsafe($t2);
$P3->apply_unsafe($u2);
$P3->apply_unsafe($v2);
$P3->apply_unsafe($w2);
$P3->apply_unsafe($x2);
$P3->apply_unsafe($y2);
$P3->apply_unsafe($z2);
$P3->apply_unsafe($A2);
$P3->apply_unsafe($B2);
$P3->apply_unsafe($C2);
$P3->apply_unsafe($D2);
$f4->apply_unsafe($g2);
$f4->apply_unsafe($h2);
$f4->apply_unsafe($i2);
$f4->apply_unsafe($j2);
$f4->apply_unsafe($k2);
$f4->apply_unsafe($l2);
$f4->apply_unsafe($m2);
$f4->apply_unsafe($n2);
$f4->apply_unsafe($o2);
$f4->apply_unsafe($p2);
$f4->apply_unsafe($q2);
$f4->apply_unsafe($g4);
$f4->apply_unsafe($H2);
$f4->apply_unsafe($s2);
$f4->apply_unsafe($I2);
$f4->apply_unsafe($t2);
$f4->apply_unsafe($u2);
$f4->apply_unsafe($v2);
$f4->apply_unsafe($w2);
$f4->apply_unsafe($x2);
$f4->apply_unsafe($y2);
$f4->apply_unsafe($z2);
$f4->apply_unsafe($A2);
$f4->apply_unsafe($B2);
$f4->apply_unsafe($C2);
$f4->apply_unsafe($D2);
$F4->apply_unsafe($g2);
$F4->apply_unsafe($h2);
$F4->apply_unsafe($i4);
$F4->apply_unsafe($i2);
$F4->apply_unsafe($d3);
$F4->apply_unsafe($j2);
$F4->apply_unsafe($j4);
$F4->apply_unsafe($k2);
$F4->apply_unsafe($F);
$F4->apply_unsafe($l2);
$F4->apply_unsafe($u);
$F4->apply_unsafe($m2);
$F4->apply_unsafe($k4);
$F4->apply_unsafe($n2);
$F4->apply_unsafe($l4);
$F4->apply_unsafe($o2);
$F4->apply_unsafe($Z2);
$F4->apply_unsafe($p2);
$F4->apply_unsafe($o3);
$F4->apply_unsafe($q2);
$F4->apply_unsafe($m4);
$F4->apply_unsafe($G4);
$F4->apply_unsafe($H2);
$F4->apply_unsafe($s2);
$F4->apply_unsafe($I2);
$F4->apply_unsafe($t2);
$F4->apply_unsafe($o4);
$F4->apply_unsafe($u2);
$F4->apply_unsafe($p4);
$F4->apply_unsafe($v2);
$F4->apply_unsafe($q4);
$F4->apply_unsafe($w2);
$F4->apply_unsafe($r4);
$F4->apply_unsafe($x2);
$F4->apply_unsafe($s4);
$F4->apply_unsafe($y2);
$F4->apply_unsafe($t4);
$F4->apply_unsafe($z2);
$F4->apply_unsafe($u4);
$F4->apply_unsafe($A2);
$F4->apply_unsafe($v4);
$F4->apply_unsafe($B2);
$F4->apply_unsafe($w4);
$F4->apply_unsafe($C2);
$F4->apply_unsafe($x4);
$F4->apply_unsafe($D2);
$T4->apply_unsafe($g2);
$T4->apply_unsafe($h2);
$T4->apply_unsafe($i4);
$T4->apply_unsafe($i2);
$T4->apply_unsafe($d3);
$T4->apply_unsafe($j2);
$T4->apply_unsafe($j4);
$T4->apply_unsafe($k2);
$T4->apply_unsafe($l2);
$T4->apply_unsafe($m2);
$T4->apply_unsafe($n2);
$T4->apply_unsafe($o2);
$T4->apply_unsafe($Z2);
$T4->apply_unsafe($p2);
$T4->apply_unsafe($o3);
$T4->apply_unsafe($q2);
$T4->apply_unsafe($U4);
$T4->apply_unsafe($H2);
$T4->apply_unsafe($s2);
$T4->apply_unsafe($I2);
$T4->apply_unsafe($t2);
$T4->apply_unsafe($u2);
$T4->apply_unsafe($v2);
$T4->apply_unsafe($w2);
$T4->apply_unsafe($x2);
$T4->apply_unsafe($y2);
$T4->apply_unsafe($z2);
$T4->apply_unsafe($A2);
$T4->apply_unsafe($B2);
$T4->apply_unsafe($C2);
$T4->apply_unsafe($D2);
$k5->apply_unsafe($g2);
$k5->apply_unsafe($h2);
$k5->apply_unsafe($i2);
$k5->apply_unsafe($d3);
$k5->apply_unsafe($j2);
$k5->apply_unsafe($k2);
$k5->apply_unsafe($l2);
$k5->apply_unsafe($m2);
$k5->apply_unsafe($n2);
$k5->apply_unsafe($o2);
$k5->apply_unsafe($p2);
$k5->apply_unsafe($q2);
$k5->apply_unsafe($l5);
$k5->apply_unsafe($H2);
$k5->apply_unsafe($s2);
$k5->apply_unsafe($I2);
$k5->apply_unsafe($t2);
$k5->apply_unsafe($u2);
$k5->apply_unsafe($v2);
$k5->apply_unsafe($w2);
$k5->apply_unsafe($x2);
$k5->apply_unsafe($y2);
$k5->apply_unsafe($z2);
$k5->apply_unsafe($A2);
$k5->apply_unsafe($B2);
$k5->apply_unsafe($C2);
$k5->apply_unsafe($D2);
$w5->apply_unsafe($g2);
$w5->apply_unsafe($h2);
$w5->apply_unsafe($i2);
$w5->apply_unsafe($d3);
$w5->apply_unsafe($j2);
$w5->apply_unsafe($k2);
$w5->apply_unsafe($l2);
$w5->apply_unsafe($m2);
$w5->apply_unsafe($n2);
$w5->apply_unsafe($o2);
$w5->apply_unsafe($p2);
$w5->apply_unsafe($q2);
$w5->apply_unsafe($x5);
$w5->apply_unsafe($H2);
$w5->apply_unsafe($s2);
$w5->apply_unsafe($I2);
$w5->apply_unsafe($t2);
$w5->apply_unsafe($u2);
$w5->apply_unsafe($v2);
$w5->apply_unsafe($w2);
$w5->apply_unsafe($x2);
$w5->apply_unsafe($y2);
$w5->apply_unsafe($z2);
$w5->apply_unsafe($A2);
$w5->apply_unsafe($B2);
$w5->apply_unsafe($C2);
$w5->apply_unsafe($D2);
$F5->apply_unsafe($g2);
$F5->apply_unsafe($h2);
$F5->apply_unsafe($i2);
$F5->apply_unsafe($d3);
$F5->apply_unsafe($j2);
$F5->apply_unsafe($k2);
$F5->apply_unsafe($l2);
$F5->apply_unsafe($m2);
$F5->apply_unsafe($n2);
$F5->apply_unsafe($o2);
$F5->apply_unsafe($p2);
$F5->apply_unsafe($q2);
$F5->apply_unsafe($G5);
$F5->apply_unsafe($H2);
$F5->apply_unsafe($s2);
$F5->apply_unsafe($I2);
$F5->apply_unsafe($t2);
$F5->apply_unsafe($u2);
$F5->apply_unsafe($v2);
$F5->apply_unsafe($w2);
$F5->apply_unsafe($x2);
$F5->apply_unsafe($y2);
$F5->apply_unsafe($z2);
$F5->apply_unsafe($A2);
$F5->apply_unsafe($B2);
$F5->apply_unsafe($C2);
$F5->apply_unsafe($D2);
$O5->apply_unsafe($g2);
$O5->apply_unsafe($h2);
$O5->apply_unsafe($i2);
$O5->apply_unsafe($d3);
$O5->apply_unsafe($j2);
$O5->apply_unsafe($k2);
$O5->apply_unsafe($l2);
$O5->apply_unsafe($m2);
$O5->apply_unsafe($n2);
$O5->apply_unsafe($o2);
$O5->apply_unsafe($p2);
$O5->apply_unsafe($q2);
$O5->apply_unsafe($P5);
$O5->apply_unsafe($H2);
$O5->apply_unsafe($s2);
$O5->apply_unsafe($I2);
$O5->apply_unsafe($t2);
$O5->apply_unsafe($u2);
$O5->apply_unsafe($v2);
$O5->apply_unsafe($w2);
$O5->apply_unsafe($x2);
$O5->apply_unsafe($y2);
$O5->apply_unsafe($z2);
$O5->apply_unsafe($A2);
$O5->apply_unsafe($B2);
$O5->apply_unsafe($C2);
$O5->apply_unsafe($D2);
$X5->apply_unsafe($g2);
$X5->apply_unsafe($h2);
$X5->apply_unsafe($i2);
$X5->apply_unsafe($d3);
$X5->apply_unsafe($j2);
$X5->apply_unsafe($k2);
$X5->apply_unsafe($l2);
$X5->apply_unsafe($m2);
$X5->apply_unsafe($n2);
$X5->apply_unsafe($o2);
$X5->apply_unsafe($p2);
$X5->apply_unsafe($q2);
$X5->apply_unsafe($Y5);
$X5->apply_unsafe($H2);
$X5->apply_unsafe($s2);
$X5->apply_unsafe($I2);
$X5->apply_unsafe($t2);
$X5->apply_unsafe($u2);
$X5->apply_unsafe($v2);
$X5->apply_unsafe($w2);
$X5->apply_unsafe($x2);
$X5->apply_unsafe($y2);
$X5->apply_unsafe($z2);
$X5->apply_unsafe($A2);
$X5->apply_unsafe($B2);
$X5->apply_unsafe($C2);
$X5->apply_unsafe($D2);
$r6->apply_unsafe($g2);
$r6->apply_unsafe($h2);
$r6->apply_unsafe($i2);
$r6->apply_unsafe($j2);
$r6->apply_unsafe($k2);
$r6->apply_unsafe($l2);
$r6->apply_unsafe($u);
$r6->apply_unsafe($m2);
$r6->apply_unsafe($n2);
$r6->apply_unsafe($o2);
$r6->apply_unsafe($Z2);
$r6->apply_unsafe($p2);
$r6->apply_unsafe($o3);
$r6->apply_unsafe($q2);
$r6->apply_unsafe($s6);
$r6->apply_unsafe($H2);
$r6->apply_unsafe($s2);
$r6->apply_unsafe($t2);
$r6->apply_unsafe($u2);
$r6->apply_unsafe($v2);
$r6->apply_unsafe($w2);
$r6->apply_unsafe($x2);
$r6->apply_unsafe($y2);
$r6->apply_unsafe($z2);
$r6->apply_unsafe($A2);
$r6->apply_unsafe($B2);
$r6->apply_unsafe($C2);
$r6->apply_unsafe($D2);
$A6->apply_unsafe($g2);
$A6->apply_unsafe($h2);
$A6->apply_unsafe($i2);
$A6->apply_unsafe($j2);
$A6->apply_unsafe($k2);
$A6->apply_unsafe($l2);
$A6->apply_unsafe($m2);
$A6->apply_unsafe($n2);
$A6->apply_unsafe($o2);
$A6->apply_unsafe($p2);
$A6->apply_unsafe($q2);
$A6->apply_unsafe($B6);
$A6->apply_unsafe($s2);
$A6->apply_unsafe($t2);
$A6->apply_unsafe($u2);
$A6->apply_unsafe($v2);
$A6->apply_unsafe($w2);
$A6->apply_unsafe($x2);
$A6->apply_unsafe($y2);
$A6->apply_unsafe($z2);
$A6->apply_unsafe($A2);
$A6->apply_unsafe($B2);
$A6->apply_unsafe($C2);
$A6->apply_unsafe($D2);
$p7->apply_unsafe($d3);
$L7->apply_unsafe($j4);
$S7->apply_unsafe($j4);
$r8->apply_unsafe($F);
$y8->apply_unsafe($F);
$G8->apply_unsafe($F);
$Q8->apply_unsafe($F);
$v9->apply_unsafe($u);
$K9->apply_unsafe($u);
$V9->apply_unsafe($u);
$ga->apply_unsafe($u);
$Ea->apply_unsafe($Fa);
$Qa->apply_unsafe($k4);
$tc->apply_unsafe($k4);
$id->apply_unsafe($jd);
$Hd->apply_unsafe($l4);
$Ud->apply_unsafe($l4);
$ve->apply_unsafe($l4);
$He->apply_unsafe($l4);
$Yf->apply_unsafe($jd);
$sg->apply_unsafe($Z2);
$zg->apply_unsafe($Z2);
$Hg->apply_unsafe($Z2);
$jh->apply_unsafe($Fa);
$uh->apply_unsafe($o3);
$Bh->apply_unsafe($o3);
$Xh->apply_unsafe($m4);
$mi->apply_unsafe($m4);
$ui->apply_unsafe($m4);
$mj->apply_unsafe($p4);
$mj->apply_unsafe($r4);
$mj->apply_unsafe($s4);
$mj->apply_unsafe($t4);
$mj->apply_unsafe($u4);
$mj->apply_unsafe($v4);
$mj->apply_unsafe($w4);
$mj->apply_unsafe($x4);
$vj->apply_unsafe($p4);
$vj->apply_unsafe($r4);
$vj->apply_unsafe($s4);
$vj->apply_unsafe($t4);
$vj->apply_unsafe($u4);
$vj->apply_unsafe($v4);
$vj->apply_unsafe($w4);
$vj->apply_unsafe($x4);
$Ej->apply_unsafe($p4);
$Ej->apply_unsafe($r4);
$Ej->apply_unsafe($s4);
$Ej->apply_unsafe($t4);
$Ej->apply_unsafe($u4);
$Ej->apply_unsafe($v4);
$Ej->apply_unsafe($w4);
$Ej->apply_unsafe($x4);
$Nj->apply_unsafe($p4);
$Nj->apply_unsafe($r4);
$Nj->apply_unsafe($s4);
$Nj->apply_unsafe($t4);
$Nj->apply_unsafe($u4);
$Nj->apply_unsafe($v4);
$Nj->apply_unsafe($w4);
$Nj->apply_unsafe($x4);
$Yj->apply_unsafe($p4);
$jk->apply_unsafe($p4);
$Ak->apply_unsafe($v2);
$Ak->apply_unsafe($x2);
$Ak->apply_unsafe($y2);
$Ak->apply_unsafe($z2);
$Ak->apply_unsafe($A2);
$Ak->apply_unsafe($B2);
$Ak->apply_unsafe($C2);
$Ak->apply_unsafe($D2);
$Tk->apply_unsafe($q4);
$dl->apply_unsafe($q4);
$ul->apply_unsafe($q4);
$Pl->apply_unsafe($q4);
$Yl->apply_unsafe($q4);
$rm->apply_unsafe($q4);
$Rm->apply_unsafe($r4);
$Zm->apply_unsafe($r4);
$kn->apply_unsafe($r4);
$zn->apply_unsafe($r4);
$zn->apply_unsafe($s4);
$zn->apply_unsafe($t4);
$zn->apply_unsafe($v4);
$zn->apply_unsafe($w4);
$Kn->apply_unsafe($r4);
$Kn->apply_unsafe($s4);
$Kn->apply_unsafe($t4);
$Kn->apply_unsafe($v4);
$Kn->apply_unsafe($w4);
$co->apply_unsafe($r4);
$Fo->apply_unsafe($s4);
$No->apply_unsafe($s4);
$Vo->apply_unsafe($s4);
$kp->apply_unsafe($s4);
$Ip->apply_unsafe($t4);
$Qp->apply_unsafe($t4);
$dq->apply_unsafe($t4);
$Mq->apply_unsafe($v4);
$Xq->apply_unsafe($v4);
$mr->apply_unsafe($v4);
$xr->apply_unsafe($v4);
$Lr->apply_unsafe($v4);
$ps->apply_unsafe($w4);
$xs->apply_unsafe($w4);
$Gs->apply_unsafe($w4);
$Rs->apply_unsafe($w4);
$At->apply_unsafe($x4);
$It->apply_unsafe($x4);
$Xt->apply_unsafe($x4);
$ni::self=$jv;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($V)for@$w;
&$_($Z)for@$w;
&$_($f1)for@$H;
&$_($n1)for@$H;
&$_($v1)for@$w;
&$_($z1)for@$H;
&$_($H1)for@$w;
&$_($L1)for@$H;
&$_($P1)for@$w;
&$_($T1)for@$w;
&$_($X1)for@$w;
&$_($d2)for@$H;
&$_($T2)for@$w;
&$_($W2)for@$w;
&$_($c3)for@$f3;
&$_($i3)for@$w;
&$_($k3)for@$w;
&$_($n3)for@$q3;
&$_($u3)for@$w;
&$_($x3)for@$z3;
&$_($D3)for@$w;
&$_($G3)for@$I3;
&$_($M3)for@$w;
&$_($P3)for@$R3;
&$_($T3)for@$U3;
&$_($X3)for@$w;
&$_($c4)for@$w;
&$_($f4)for@$h4;
&$_($C4)for@$w;
&$_($F4)for@$H4;
&$_($J4)for@$K4;
&$_($Q4)for@$w;
&$_($T4)for@$V4;
&$_($X4)for@$Y4;
&$_($h5)for@$w;
&$_($k5)for@$m5;
&$_($q5)for@$w;
&$_($t5)for@$w;
&$_($w5)for@$y5;
&$_($C5)for@$w;
&$_($F5)for@$H5;
&$_($L5)for@$w;
&$_($O5)for@$Q5;
&$_($U5)for@$w;
&$_($X5)for@$Z5;
&$_($d6)for@$e6;
&$_($g6)for@$h6;
&$_($l6)for@$w;
&$_($o6)for@$w;
&$_($r6)for@$t6;
&$_($x6)for@$w;
&$_($A6)for@$C6;
&$_($E6)for@$F6;
&$_($P6)for@$Q6;
&$_($U6)for@$V6;
&$_($X6)for@$Y6;
&$_($c7)for@$d7;
&$_($m7)for@$w;
&$_($p7)for@$q7;
&$_($s7)for@$t7;
&$_($z7)for@$A7;
&$_($I7)for@$w;
&$_($L7)for@$M7;
&$_($P7)for@$w;
&$_($S7)for@$T7;
&$_($V7)for@$W7;
&$_($d8)for@$e8;
&$_($o8)for@$w;
&$_($r8)for@$s8;
&$_($v8)for@$w;
&$_($y8)for@$z8;
&$_($D8)for@$w;
&$_($G8)for@$H8;
&$_($K8)for@$w;
&$_($N8)for@$w;
&$_($Q8)for@$R8;
&$_($T8)for@$U8;
&$_($Z8)for@$c9;
&$_($n9)for@$w;
&$_($q9)for@$w;
&$_($s9)for@$w;
&$_($v9)for@$w9;
&$_($A9)for@$w;
&$_($D9)for@$w;
&$_($H9)for@$w;
&$_($K9)for@$L9;
&$_($P9)for@$w;
&$_($S9)for@$w;
&$_($V9)for@$W9;
&$_($da)for@$w;
&$_($ga)for@$ha;
&$_($ja)for@$ka;
&$_($pa)for@$qa;
&$_($Ba)for@$w;
&$_($Ea)for@$Ga;
&$_($Na)for@$w;
&$_($Qa)for@$Ra;
&$_($Wa)for@$w;
&$_($cb)for@$w;
&$_($gb)for@$w;
&$_($kb)for@$w;
&$_($ob)for@$w;
&$_($sb)for@$w;
&$_($wb)for@$w;
&$_($Ab)for@$w;
&$_($Eb)for@$w;
&$_($Ib)for@$w;
&$_($Mb)for@$w;
&$_($Qb)for@$w;
&$_($Ub)for@$w;
&$_($Yb)for@$w;
&$_($ec)for@$w;
&$_($ic)for@$w;
&$_($mc)for@$w;
&$_($qc)for@$w;
&$_($tc)for@$uc;
&$_($wc)for@$xc;
&$_($Cc)for@$Dc;
&$_($Nc)for@$w;
&$_($Rc)for@$w;
&$_($Vc)for@$w;
&$_($Zc)for@$w;
&$_($fd)for@$w;
&$_($id)for@$kd;
&$_($wd)for@$w;
&$_($Ad)for@$w;
&$_($Ed)for@$w;
&$_($Hd)for@$Id;
&$_($Nd)for@$w;
&$_($Rd)for@$w;
&$_($Ud)for@$Vd;
&$_($ce)for@$w;
&$_($ge)for@$w;
&$_($ke)for@$w;
&$_($oe)for@$w;
&$_($se)for@$w;
&$_($ve)for@$we;
&$_($Ae)for@$w;
&$_($Ee)for@$w;
&$_($He)for@$Ie;
&$_($Ke)for@$Le;
&$_($Qe)for@$Re;
&$_($df)for@$w;
&$_($hf)for@$w;
&$_($lf)for@$w;
&$_($pf)for@$w;
&$_($tf)for@$w;
&$_($xf)for@$w;
&$_($Bf)for@$w;
&$_($Ff)for@$w;
&$_($Jf)for@$w;
&$_($Nf)for@$w;
&$_($Rf)for@$w;
&$_($Vf)for@$w;
&$_($Yf)for@$Zf;
&$_($jg)for@$w;
&$_($lg)for@$w;
&$_($sg)for@$tg;
&$_($wg)for@$w;
&$_($zg)for@$Ag;
&$_($Eg)for@$w;
&$_($Hg)for@$Ig;
&$_($Kg)for@$Lg;
&$_($Rg)for@$Sg;
&$_($Zg)for@$w;
&$_($gh)for@$w;
&$_($jh)for@$kh;
&$_($rh)for@$w;
&$_($uh)for@$vh;
&$_($yh)for@$w;
&$_($Bh)for@$Ch;
&$_($Eh)for@$Fh;
&$_($Lh)for@$Mh;
&$_($Uh)for@$w;
&$_($Xh)for@$Yh;
&$_($fi)for@$w;
&$_($ji)for@$w;
&$_($mi)for@$ni;
&$_($ri)for@$w;
&$_($ui)for@$vi;
&$_($yi)for@$zi;
&$_($Fi)for@$Gi;
&$_($Oi)for@$Pi;
&$_($Ui)for@$Vi;
&$_($jj)for@$w;
&$_($mj)for@$nj;
&$_($sj)for@$w;
&$_($vj)for@$wj;
&$_($Bj)for@$w;
&$_($Ej)for@$Fj;
&$_($Kj)for@$w;
&$_($Nj)for@$Oj;
&$_($Qj)for@$Rj;
&$_($Vj)for@$w;
&$_($Yj)for@$Zj;
&$_($gk)for@$w;
&$_($jk)for@$kk;
&$_($mk)for@$nk;
&$_($xk)for@$w;
&$_($Ak)for@$Bk;
&$_($Dk)for@$Ek;
&$_($Gk)for@$Hk;
&$_($Qk)for@$w;
&$_($Tk)for@$Uk;
&$_($Yk)for@$w;
&$_($dl)for@$el;
&$_($jl)for@$w;
&$_($nl)for@$w;
&$_($rl)for@$w;
&$_($ul)for@$vl;
&$_($Al)for@$w;
&$_($El)for@$w;
&$_($Il)for@$w;
&$_($Ml)for@$w;
&$_($Pl)for@$Ql;
&$_($Vl)for@$w;
&$_($Yl)for@$Zl;
&$_($gm)for@$w;
&$_($km)for@$w;
&$_($om)for@$w;
&$_($rm)for@$sm;
&$_($um)for@$vm;
&$_($Am)for@$Bm;
&$_($Om)for@$w;
&$_($Rm)for@$Sm;
&$_($Wm)for@$w;
&$_($Zm)for@$cn;
&$_($hn)for@$w;
&$_($kn)for@$ln;
&$_($sn)for@$w;
&$_($wn)for@$w;
&$_($zn)for@$An;
&$_($En)for@$w;
&$_($Hn)for@$w;
&$_($Kn)for@$Ln;
&$_($Nn)for@$On;
&$_($Tn)for@$w;
&$_($Xn)for@$w;
&$_($co)for@$do;
&$_($fo)for@$go;
&$_($lo)for@$mo;
&$_($zo)for@$w;
&$_($Co)for@$w;
&$_($Fo)for@$Go;
&$_($Ko)for@$w;
&$_($No)for@$Oo;
&$_($So)for@$w;
&$_($Vo)for@$Wo;
&$_($dp)for@$w;
&$_($hp)for@$w;
&$_($kp)for@$lp;
&$_($np)for@$op;
&$_($tp)for@$up;
&$_($Fp)for@$w;
&$_($Ip)for@$Jp;
&$_($Np)for@$w;
&$_($Qp)for@$Rp;
&$_($Vp)for@$w;
&$_($Yp)for@$w;
&$_($dq)for@$eq;
&$_($gq)for@$hq;
&$_($mq)for@$nq;
&$_($Fq)for@$w;
&$_($Jq)for@$w;
&$_($Mq)for@$Nq;
&$_($Rq)for@$w;
&$_($Uq)for@$w;
&$_($Xq)for@$Yq;
&$_($fr)for@$w;
&$_($jr)for@$w;
&$_($mr)for@$nr;
&$_($rr)for@$w;
&$_($ur)for@$w;
&$_($xr)for@$yr;
&$_($Cr)for@$w;
&$_($Er)for@$w;
&$_($Gr)for@$w;
&$_($Ir)for@$w;
&$_($Lr)for@$Mr;
&$_($Or)for@$Pr;
&$_($Ur)for@$Vr;
&$_($js)for@$w;
&$_($ms)for@$w;
&$_($ps)for@$qs;
&$_($us)for@$w;
&$_($xs)for@$ys;
&$_($Ds)for@$w;
&$_($Gs)for@$Hs;
&$_($Ls)for@$w;
&$_($Os)for@$w;
&$_($Rs)for@$Ss;
&$_($Us)for@$Vs;
&$_($ct)for@$dt;
&$_($pt)for@$w;
&$_($tt)for@$w;
&$_($xt)for@$w;
&$_($At)for@$Bt;
&$_($Ft)for@$w;
&$_($It)for@$Jt;
&$_($Nt)for@$w;
&$_($Rt)for@$w;
&$_($Ut)for@$w;
&$_($Xt)for@$Yt;
&$_($cu)for@$du;
&$_($iu)for@$ju;
&$_($qu)for@$ru;
&$_($Lu)for@$Mu;
&$_($Ou)for@$ru;
&$_($Tu)for@$w;
&$_($Xu)for@$w;
&$_($dv)for@$w;
&$_($hv)for@$w;
&$_($jv)for@$kv;
ni->run(@ARGV);
__DATA__
