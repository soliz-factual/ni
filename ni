#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q'applied_to';
$d=q'metaclass.c';
$e={$d,1};
$f=q'name';
$g=q'slices';
$h=q'class.c';
$i={$h,1};
$j=q'module.c';
$k={$h,1,$j,1};
$l=q'lib/behavior.c';
$m=q'lib/branch.c';
$n=q'lib/dataslice.c';
$o=q'lib/doc.c';
$p=q'lib/fn.c';
$q=q'lib/image.c';
$r=q'lib/ni.c';
$s=q'lib/slice.c';
$t=q'lib/tag.c';
$u=q'lib/test_value.c';
$v=q'object.c';
$w=q'unix/cat.c';
$x=q'unix/fd.c';
$y=q'unix/fifo.c';
$z=q'unix/file.c';
$A=q'unix/io.c';
$B=q'unix/pid.c';
$C=q'unix/pipeline.c';
$D=q'unix/str.c';
$E={$h,1,$l,1,$m,1,$n,1,$o,1,$p,1,$q,1,$r,1,$s,1,$t,1,$u,1,$j,1,$v,1,$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$F=[undef];
$G=q'metaclass';
$H=bless({$c,$E,$f,$v,$g,$F},$G);
$I=q'metaclass::ctors';
$J={$s,1};
$K={$h,1,$l,1,$m,1,$n,1,$s,1,$t,1,$j,1};
$L=[$H];
$M=bless({$c,$K,$f,$l,$g,$L},$G);
$N=q'metaclass::ctors';
$O=[$M];
$P=bless({$c,$J,$f,$s,$g,$O},$G);
$Q=q'metaclass::ctors';
$R=q'lib/slice';
$S={$R,1};
$T=q'class';
$U=q'lib/behavior';
$V=q'lib/branch';
$W=q'lib/dataslice';
$X=q'lib/tag';
$Y=q'lib/test_value.c';
$Z=q'module';
$c1={$T,1,$h,1,$U,1,$l,1,$V,1,$m,1,$W,1,$n,1,$o,1,$p,1,$q,1,$r,1,$R,1,$s,1,$X,1,$t,1,$Y,1,$G,1,$d,1,$Z,1,$j,1,$v,1,$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$d1=q'lib/doc';
$e1=q'lib/fn';
$f1=q'lib/image';
$g1=q'lib/ni';
$h1=q'lib/test_value';
$i1=q'lib/test_value.c';
$j1=q'object';
$k1=q'unix/cat';
$l1=q'unix/fd';
$m1=q'unix/fifo';
$n1=q'unix/file';
$o1=q'unix/io';
$p1=q'unix/pid';
$q1=q'unix/pipeline';
$r1=q'unix/str';
$s1={$T,1,$h,1,$U,1,$l,1,$V,1,$m,1,$W,1,$n,1,$d1,1,$o,1,$e1,1,$p,1,$f1,1,$q,1,$g1,1,$r,1,$R,1,$s,1,$X,1,$t,1,$h1,1,$i1,1,$G,1,$d,1,$Z,1,$j,1,$j1,1,$v,1,$k1,1,$w,1,$l1,1,$x,1,$m1,1,$y,1,$n1,1,$z,1,$o1,1,$A,1,$p1,1,$B,1,$q1,1,$C,1,$r1,1,$D,1};
$t1={};
$u1=q'ctor';
$v1=undef;
$w1=q'dtor';
$x1=q'methods';
$y1={$p,1};
$z1=[$H];
$A1=bless({$c,$y1,$f,$p,$g,$z1},$G);
$B1=q'metaclass::ctors';
$C1={$e1,1};
$D1={};
$E1=q'code';
$F1=q'shift->compile';
$G1=q'proto';
$H1=q'';
$I1=bless({$E1,$F1,$G1,$H1},$e1);
$J1=q'lib/fn::ctors';
$K1=q'compile';
$L1=q'local $@;
my $self = shift;
$$self{proto} ||= \'\';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};';
$M1=bless({$E1,$L1,$G1,$H1},$e1);
$N1=q'instantiate';
$O1=q'my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : \'\';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};';
$P1=bless({$E1,$O1,$G1,$H1},$e1);
$Q1={$K1,$M1,$N1,$P1};
$R1=q'lib/fn_init.b';
$S1=bless({$c,$D1,$u1,$I1,$w1,$v1,$x1,$Q1,$f,$R1},$R);
$T1=q'lib/slice::ctors';
$U1={};
$V1=q'annotations';
$W1=[];
$X1=q'shift->{\'annotations\'}';
$Y1=bless({$V1,$W1,$E1,$X1,$G1,$H1},$e1);
$Z1=[];
$c2=q'shift->{\'code\'}';
$d2=bless({$V1,$Z1,$E1,$c2,$G1,$H1},$e1);
$e2=q'fn';
$f2=[];
$g2=q'shift->{\'fn\'}';
$h2=bless({$V1,$f2,$E1,$g2,$G1,$H1},$e1);
$i2={$V1,$Y1,$E1,$d2,$e2,$h2};
$j2=q'lib/fn_ro.b';
$k2=bless({$c,$U1,$u1,$v1,$w1,$v1,$x1,$i2,$f,$j2},$R);
$l2=q'lib/slice::ctors';
$m2={};
$n2=q'(""';
$o2=[];
$p2=q'shift->{code}';
$q2=bless({$V1,$o2,$E1,$p2,$G1,$H1},$e1);
$r2=q'(eq';
$s2=[];
$t2=q'ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])';
$u2=bless({$V1,$s2,$E1,$t2,$G1,$H1},$e1);
$v2={$n2,$q2,$r2,$u2};
$w2=q'lib/fn_ops.b';
$x2=bless({$c,$m2,$u1,$v1,$w1,$v1,$x1,$v2,$f,$w2},$R);
$y2=q'lib/slice::ctors';
$z2={};
$A2=q'serialize';
$B2=[];
$C2=q'local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = \' \' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);';
$D2=bless({$V1,$B2,$E1,$C2,$G1,$H1},$e1);
$E2={$A2,$D2};
$F2=q'lib/fn_serialize.b';
$G2=bless({$c,$z2,$u1,$v1,$w1,$v1,$x1,$E2,$f,$F2},$R);
$H2=q'lib/slice::ctors';
$I2=[undef,undef,$S1,$k2,$x2,$G2];
$J2=bless({$c,$C1,$f,$e1,$g,$I2},$p);
$K2=q'lib/fn.c::ctors';
$L2=q'ni \'ni:\' . ref shift';
$M2=bless({$E1,$L2,$G1,$H1},$e1);
$N2={$T,$M2};
$O2=q'lib/instance.b';
$P2=bless({$c,$t1,$u1,$v1,$w1,$v1,$x1,$N2,$f,$O2},$R);
$Q2=q'lib/test_value.c';
$R2=q'lib/slice::ctors';
$S2=[$P2];
$T2=bless({$c,$s1,$f,$j1,$g,$S2},$v);
$U2=q'object.c::ctors';
$V2={};
$W2=q'doc';
$X2=q'my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can(\'exists\') && ni->exists("ni.doc:$name");
ni(\'ni:lib/doc\')->new($name);';
$Y2=bless({$E1,$X2,$G1,$H1},$e1);
$Z2={$W2,$Y2};
$c3=q'lib/documentable.b';
$d3=bless({$c,$V2,$u1,$v1,$w1,$v1,$x1,$Z2,$f,$c3},$R);
$e3=q'lib/test_value.c';
$f3=q'lib/slice::ctors';
$g3=[$T2,$d3];
$h3=bless({$c,$c1,$f,$U,$g,$g3},$l);
$i3=q'lib/behavior.c::ctors';
$j3={};
$k3=q'my $s = shift; ni->def($s->name, $s)';
$l3=bless({$E1,$k3,$G1,$H1},$e1);
$m3=q'$_[0]->namespace . ":" . $_[0]->{name}';
$n3=bless({$E1,$m3,$G1,$H1},$e1);
$o3={$f,$n3};
$p3=q'lib/named.b';
$q3=bless({$c,$j3,$u1,$l3,$w1,$v1,$x1,$o3,$f,$p3},$R);
$r3=q'lib/test_value.c';
$s3=q'lib/slice::ctors';
$t3=q'local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);';
$u3=bless({$E1,$t3,$G1,$H1},$e1);
$v3=q'local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;';
$w3=bless({$E1,$v3,$G1,$H1},$e1);
$x3=q'lib/slice::apply';
$y3=q'lib/slice::apply_unsafe';
$z3={};
$A3=q'apply';
$B3=q'apply_unsafe';
$C3={$A3,$u3,$B3,$w3};
$D3=q'lib/slice.b';
$E3=bless({$c,$z3,$x1,$C3,$f,$D3},$R);
$F3=q'lib/slice::ctors';
$G3={};
$H3=q'my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};';
$I3=bless({$E1,$H3,$G1,$H1},$e1);
$J3={$N1,$I3};
$K3=q'lib/slice_init.b';
$L3=bless({$c,$G3,$x1,$J3,$f,$K3},$R);
$M3=q'lib/slice::ctors';
$N3={};
$O3=[];
$P3=q'local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq \'ni:lib/slice.b\') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      \'*\' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;';
$Q3=bless({$V1,$O3,$E1,$P3,$G1,$H1},$e1);
$R3={$A2,$Q3};
$S3=q'lib/slice_serialize.b';
$T3=bless({$c,$N3,$u1,$v1,$w1,$v1,$x1,$R3,$f,$S3},$R);
$U3=q'lib/slice::ctors';
$V3=[$h3,$q3,$E3,$L3,$T3];
$W3=bless({$c,$S,$f,$R,$g,$V3},$s);
$X3=q'lib/slice.c::ctors';
$Y3={};
$Z3=q'DESTROY';
$c4=q'local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};';
$d4=bless({$E1,$c4,$G1,$H1},$e1);
$e4=q'new';
$f4=q'local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;';
$g4=bless({$E1,$f4,$G1,$H1},$e1);
$h4={$Z3,$d4,$e4,$g4};
$i4=q'lib/instantiable.b';
$j4=bless({$c,$Y3,$x1,$h4,$f,$i4},$R);
$k4=q'lib/test_value.c';
$l4=q'lib/slice::ctors';
$m4=[$H,$j4,$M];
$n4=bless({$c,$k,$f,$j,$g,$m4},$G);
$o4=q'metaclass::ctors';
$p4=[$n4];
$q4=bless({$c,$i,$f,$h,$g,$p4},$G);
$r4=q'metaclass::ctors';
$s4=q'lib/test_value.c';
$t4={$T,1,$h,1,$l,1,$m,1,$n,1,$o,1,$p,1,$q,1,$r,1,$s,1,$t,1,$s4,1,$d,1,$j,1,$v,1,$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$u4=q'lib/test_value.c';
$v4={$T,1,$h,1,$l,1,$m,1,$n,1,$o,1,$p,1,$q,1,$r,1,$s,1,$t,1,$u4,1,$G,1,$d,1,$Z,1,$j,1,$v,1,$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$w4={$t,1};
$x4=[$M];
$y4=bless({$c,$w4,$f,$t,$g,$x4},$G);
$z4=q'metaclass::ctors';
$A4={$X,1};
$B4={};
$C4=q'local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;';
$D4=bless({$E1,$C4,$G1,$H1},$e1);
$E4={$A3,$D4};
$F4=q'lib/tag.b';
$G4=bless({$c,$B4,$u1,$v1,$w1,$v1,$x1,$E4,$f,$F4},$R);
$H4=q'lib/slice::ctors';
$I4={};
$J4=q'local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};';
$K4=bless({$E1,$J4,$G1,$H1},$e1);
$L4={$N1,$K4};
$M4=q'lib/tag_init.b';
$N4=bless({$c,$I4,$u1,$v1,$w1,$v1,$x1,$L4,$f,$M4},$R);
$O4=q'lib/slice::ctors';
$P4=[$h3,$q3,$G4,$N4];
$Q4=bless({$c,$A4,$f,$X,$g,$P4},$t);
$R4=q'lib/tag.c::ctors';
$S4=q'lib/perlbranch.b';
$T4={};
$U4=q'add';
$V4=q'local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;';
$W4=bless({$E1,$V4,$G1,$H1},$e1);
$X4=q'local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;';
$Y4=bless({$E1,$X4,$G1,$H1},$e1);
$Z4={$U4,$W4,$A3,$Y4};
$c5=q'lib/branch.b';
$d5=bless({$c,$T4,$u1,$v1,$w1,$v1,$x1,$Z4,$f,$c5},$R);
$e5=q'lib/test_value.c';
$f5=q'lib/slice::ctors';
$g5={};
$h5=q'namespace';
$i5=q'\'ni\'';
$j5=bless({$E1,$i5,$G1,$H1},$e1);
$k5={$h5,$j5};
$l5=q'lib/named_in_ni.b';
$m5=bless({$c,$g5,$u1,$v1,$w1,$v1,$x1,$k5,$f,$l5},$R);
$n5=q'lib/test_value.c';
$o5=q'lib/slice::ctors';
$p5={};
$q5=q'package';
$r5=q'shift->{name}';
$s5=bless({$E1,$r5,$G1,$H1},$e1);
$t5={$q5,$s5};
$u5=q'lib/namespaced.b';
$v5=bless({$c,$p5,$u1,$v1,$w1,$v1,$x1,$t5,$f,$u5},$R);
$w5=q'lib/test_value.c';
$x5=q'lib/slice::ctors';
$y5={};
$z5=q'resolve';
$A5=q'ref $_[1] ? $_[1] : ni"ni:$_[1]"';
$B5=bless({$E1,$A5,$G1,$H1},$e1);
$C5={$z5,$B5};
$D5=q'lib/resolver.b';
$E5=bless({$c,$y5,$u1,$v1,$w1,$v1,$x1,$C5,$f,$D5},$R);
$F5=q'lib/test_value.c';
$G5=q'lib/slice::ctors';
$H5=[$d5,$q3,$m5,$v5,$E5];
$I5=bless({$f,$S4,$g,$H5},$X);
$J5=q'lib/tag::ctors';
$K5={};
$L5=q'my $s = shift; $s->apply($s->package)';
$M5=bless({$E1,$L5,$G1,$H1},$e1);
$N5=q'local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};';
$O5=bless({$E1,$N5,$G1,$H1},$e1);
$P5={$N1,$O5};
$Q5=q'lib/class_init.b';
$R5=bless({$c,$K5,$u1,$M5,$w1,$v1,$x1,$P5,$f,$Q5},$R);
$S5=q'lib/test_value.c';
$T5=q'lib/slice::ctors';
$U5={$m,1};
$V5=[$M];
$W5=bless({$c,$U5,$f,$m,$g,$V5},$G);
$X5=q'metaclass::ctors';
$Y5={$V,1};
$Z5={};
$c6=q'local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};';
$d6=bless({$E1,$c6,$G1,$H1},$e1);
$e6={$N1,$d6};
$f6=q'lib/branch_init.b';
$g6=bless({$c,$Z5,$u1,$v1,$w1,$v1,$x1,$e6,$f,$f6},$R);
$h6=q'lib/slice::ctors';
$i6=[$h3,$q3,$d5,$g6,undef];
$j6=bless({$c,$Y5,$f,$V,$g,$i6},$m);
$k6=q'lib/branch.c::ctors';
$l6=q'lib/test_value.c';
$m6={$T,1,$h,1,$l,1,$V,1,$m,1,$n,1,$o,1,$p,1,$q,1,$r,1,$s,1,$t,1,$l6,1,$G,1,$d,1,$Z,1,$j,1,$v,1,$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$n6=q'lib/definition.b';
$o6={};
$p6=q'def';
$q6=q'shift->add(ni(\'ni:lib/slice\')->new(@_))';
$r6=bless({$E1,$q6,$G1,$H1},$e1);
$s6={$p6,$r6};
$t6=q'lib/definition_def.b';
$u6=bless({$c,$o6,$u1,$v1,$w1,$v1,$x1,$s6,$f,$t6},$R);
$v6=q'lib/test_value.c';
$w6=q'lib/slice::ctors';
$x6={};
$y6=q'ro';
$z6=q'my ($self, $slice, @rs) = @_;
$self->add(ni(\'ni:lib/slice\')->new(
  $slice,
  map +($_ => fn qq{shift->{\'$_\'}}), @rs));';
$A6=bless({$E1,$z6,$G1,$H1},$e1);
$B6=q'rw';
$C6=q'my ($self, $slice, @as) = @_;
$self->add(ni(\'ni:lib/slice\')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{\'$_\'} = \\$_[1] : shift->{\'$_\'}}), @as));';
$D6=bless({$E1,$C6,$G1,$H1},$e1);
$E6={$y6,$A6,$B6,$D6};
$F6=q'lib/accessor.b';
$G6=bless({$c,$x6,$u1,$v1,$w1,$v1,$x1,$E6,$f,$F6},$R);
$H6=q'lib/test_value.c';
$I6=q'lib/slice::ctors';
$J6={};
$K6=q'shift->name';
$L6=bless({$E1,$K6,$G1,$H1},$e1);
$M6={$n2,$L6};
$N6=q'lib/name_as_string.b';
$O6=bless({$c,$J6,$u1,$v1,$w1,$v1,$x1,$M6,$f,$N6},$R);
$P6=q'lib/test_value.c';
$Q6=q'lib/slice::ctors';
$R6={};
$S6=q'ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);';
$T6=bless({$E1,$S6,$G1,$H1},$e1);
$U6={$r2,$T6};
$V6=q'lib/ref_eq.b';
$W6=bless({$c,$R6,$u1,$v1,$w1,$v1,$x1,$U6,$f,$V6},$R);
$X6=q'lib/test_value.c';
$Y6=q'lib/slice::ctors';
$Z6={};
$c7=q'defdata';
$d7=q'shift->add(ni(\'ni:lib/dataslice\')->new(@_))';
$e7=bless({$E1,$d7,$G1,$H1},$e1);
$f7={$c7,$e7};
$g7=q'lib/definition_defdata.b';
$h7=bless({$c,$Z6,$u1,$v1,$w1,$v1,$x1,$f7,$f,$g7},$R);
$i7=q'lib/test_value.c';
$j7=q'lib/slice::ctors';
$k7=[$u6,$G6,$O6,$W6,$h7];
$l7=bless({$c,$m6,$f,$n6,$g,$k7},$V);
$m7=q'lib/branch::ctors';
$n7=[$I5,$R5,$T2,$h3,$l7];
$o7=bless({$c,$v4,$f,$Z,$g,$n7},$j);
$p7=q'module.c::ctors';
$q7={};
$r7=q'child';
$s7=q'my ($self, $name, @slices) = @_;
ni("ni:metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);';
$t7=bless({$E1,$s7,$G1,$H1},$e1);
$u7={$r7,$t7};
$v7=q'lib/subclass.b';
$w7=bless({$c,$q7,$u1,$v1,$w1,$v1,$x1,$u7,$f,$v7},$R);
$x7=q'lib/test_value.c';
$y7=q'lib/slice::ctors';
$z7=[$o7,$j4,$R5,$o7,$w7];
$A7=bless({$c,$t4,$f,$T,$g,$z7},$h);
$B7=q'class.c::ctors';
$C7=[$A7];
$D7=bless({$c,$e,$f,$d,$g,$C7},$G);
$E7=q'metaclass::ctors';
$F7={$G,1};
$G7=[$I5,$j4,$R5,$o7];
$H7=bless({$c,$F7,$f,$G,$g,$G7},$d);
$I7=q'metaclass.c::ctors';
$J7={$r,1};
$K7=[$H];
$L7=bless({$c,$J7,$f,$r,$g,$K7},$G);
$M7=q'metaclass::ctors';
$N7={$g1,1};
$O7={};
$P7=q'is_mutable';
$Q7=[];
$R7=q'$0 ne "-" && -w $0';
$S7=bless({$V1,$Q7,$E1,$R7,$G1,$H1},$e1);
$T7=q'modify';
$U7=[];
$V7=q'my ($self, $fn) = @_;
# TODO: replace all of this with a generalized "atomic-update" function
# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join \'/\', @r;
open my $w, \'>\', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";';
$W7=bless({$V1,$U7,$E1,$V7,$G1,$H1},$e1);
$X7={$P7,$S7,$T7,$W7};
$Y7=q'lib/ni_self.b';
$Z7=bless({$c,$O7,$u1,$v1,$w1,$v1,$x1,$X7,$f,$Y7},$R);
$c8=q'lib/slice::ctors';
$d8={};
$e8=q'exists';
$f8=[];
$g8=q'exists $_[0]->{named}{$_[1]}';
$h8=bless({$V1,$f8,$E1,$g8,$G1,$H1},$e1);
$i8=q'quoted';
$j8=[];
$k8=q'my $self = shift;
my $q = ni(\'ni:lib/image\')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;';
$l8=bless({$V1,$j8,$E1,$k8,$G1,$H1},$e1);
$m8={$e8,$h8,$i8,$l8};
$n8=q'lib/ni_image.b';
$o8=bless({$c,$d8,$u1,$v1,$w1,$v1,$x1,$m8,$f,$n8},$R);
$p8=q'lib/slice::ctors';
$q8={};
$r8=q'--internal/+=';
$s8=[];
$t8=q'my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
  die "ni: failed to run $_: $!" unless $r;
}
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;';
$u8=bless({$V1,$s8,$E1,$t8,$G1,$H1},$e1);
$v8=q'--internal/eval';
$w8=[];
$x8=q'my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;';
$y8=bless({$V1,$w8,$E1,$x8,$G1,$H1},$e1);
$z8=q'--internal/image';
$A8=[];
$B8=q'shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;';
$C8=bless({$V1,$A8,$E1,$B8,$G1,$H1},$e1);
$D8=q'--internal/test';
$E8=[];
$F8=q'my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL: $@ in $t\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL: $r\\n";
  }
}
my $passed = @tests - $fails;
print "$passed test(s) passed\\n";
!!$fails;';
$G8=bless({$V1,$E8,$E1,$F8,$G1,$H1},$e1);
$H8=q'run';
$I8=[];
$J8=q'my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);';
$K8=bless({$V1,$I8,$E1,$J8,$G1,$H1},$e1);
$L8={$r8,$u8,$v8,$y8,$z8,$C8,$D8,$G8,$H8,$K8};
$M8=q'lib/ni_main.b';
$N8=bless({$c,$q8,$u1,$v1,$w1,$v1,$x1,$L8,$f,$M8},$R);
$O8=q'lib/slice::ctors';
$P8={};
$Q8=[];
$R8=q'my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";';
$S8=bless({$V1,$Q8,$E1,$R8,$G1,$H1},$e1);
$T8=q'resolver_for';
$U8=[];
$V8=q'my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;';
$W8=bless({$V1,$U8,$E1,$V8,$G1,$H1},$e1);
$X8={$z5,$S8,$T8,$W8};
$Y8=q'lib/ni_resolver.b';
$Z8=bless({$c,$P8,$u1,$v1,$w1,$v1,$x1,$X8,$f,$Y8},$R);
$c9=q'lib/slice::ctors';
$d9=[$T2,$Z7,$o8,$N8,$Z8];
$e9=bless({$c,$N7,$f,$g1,$g,$d9},$r);
$f9=q'lib/ni.c::ctors';
$g9=q'named';
$h9=q'ni.doc:class';
$i9={$o,1};
$j9=[$H];
$k9=bless({$c,$i9,$f,$o,$g,$j9},$G);
$l9=q'metaclass::ctors';
$m9={$d1,1};
$n9={};
$o9=q'shift; +{name => shift, doc => []}';
$p9=bless({$E1,$o9,$G1,$H1},$e1);
$q9={$N1,$p9};
$r9=q'lib/doc_init.b';
$s9=bless({$c,$n9,$u1,$v1,$w1,$v1,$x1,$q9,$f,$r9},$R);
$t9=q'lib/slice::ctors';
$u9={};
$v9=q'\'ni.doc\'';
$w9=bless({$E1,$v9,$G1,$H1},$e1);
$x9={$h5,$w9};
$y9=q'lib/doc_namespace.b';
$z9=bless({$c,$u9,$u1,$v1,$w1,$v1,$x1,$x9,$f,$y9},$R);
$A9=q'lib/slice::ctors';
$B9={};
$C9=q'AUTOLOAD';
$D9=q'my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;';
$E9=bless({$E1,$D9,$G1,$H1},$e1);
$F9={$C9,$E9};
$G9=q'lib/doc_define.b';
$H9=bless({$c,$B9,$u1,$v1,$w1,$v1,$x1,$F9,$f,$G9},$R);
$I9=q'lib/slice::ctors';
$J9={};
$K9=q'eg';
$L9=q'my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;';
$M9=bless({$E1,$L9,$G1,$H1},$e1);
$N9=q'tests';
$O9=q'my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq \'eg\';
}
@tests;';
$P9=bless({$E1,$O9,$G1,$H1},$e1);
$Q9={$K9,$M9,$N9,$P9};
$R9=q'lib/doc_test.b';
$S9=bless({$c,$J9,$u1,$v1,$w1,$v1,$x1,$Q9,$f,$R9},$R);
$T9=q'lib/slice::ctors';
$U9=[$T2,$q3,$s9,$z9,$H9,$S9];
$V9=bless({$c,$m9,$f,$d1,$g,$U9},$o);
$W9=q'lib/doc.c::ctors';
$X9=q'synopsis';
$Y9=q'
    ni(\'ni:object\')->child(\'message\')
      ->add(\'behaviorname.b\')           # add existing behavior
      ->def(\'message_init.b\',           # define new slice behavior
        instantiate => fn q{            # called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       # return object to be blessed
        })
      ->def(\'behaviorname.b\',           # define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! \'" . $$self{message} . "\'\\n";
        });
    ni(\'ni:child\')->new(\'hello world!\')->method1;
  ';
$Z9=[$X9,$Y9];
$ca=q'description';
$da=q'ni:class is at the core of ni\'s object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you\'d expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.';
$ea=[$ca,$da];
$fa=q'behaviors';
$ga=q'ni\'s objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:lib/slice, which represents a set of methods you can add to a
      package.';
$ha=[];
$ia=q'my $fn = fn q{"hi"};
my $slice = ni(\'ni:lib/slice\')->new(\'myslice\', f => $fn);
$slice->apply(\'foo\');
now foo->f == \'hi\';';
$ja=bless({$V1,$ha,$E1,$ia,$G1,$H1},$e1);
$ka=q'TODO...';
$la=[$fa,$ga,$K9,$ja,$ka];
$ma=q'classes';
$na=q'ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni\'s classes are slice unions and as such don\'t
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn\'t in the picture,
      which makes multiple inheritance straightforward to implement.';
$oa=[$ma,$na,$ka];
$pa=[$Z9,$ea,$la,$oa];
$qa=bless({$W2,$pa,$f,$T},$d1);
$ra=q'lib/doc::ctors';
$sa=q'ni.doc:lib/doc';
$ta=q'
    ni("ni:some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...';
$ua=[$X9,$ta];
$va=q'Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class\'s code without bringing along all of
      its documentation and unit tests.';
$wa=q'Documentation objects are internally represented as arrays of quoted
      method calls:';
$xa=[];
$ya=q'my $doc = ni("ni:lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];';
$za=bless({$V1,$xa,$E1,$ya,$G1,$H1},$e1);
$Aa=q'This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":';
$Ba=[];
$Ca=q'my $doc = ni("ni:lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];';
$Da=bless({$V1,$Ba,$E1,$Ca,$G1,$H1},$e1);
$Ea=[$ca,$va,$wa,$K9,$za,$Aa,$K9,$Da];
$Fa=[$ua,$Ea];
$Ga=bless({$W2,$Fa,$f,$d1},$d1);
$Ha=q'ni.doc:unix/cat';
$Ia=q'
    my $combined = ni(\'ni:unix/cat\')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  ';
$Ja=[$X9,$Ia];
$Ka=q'Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.';
$La=[$ca,$Ka];
$Ma=[];
$Na=q'my $cat = ni("str:foo") + ni("str:bar");
$cat->into(ni(\'ni:unix/str\')->new(my $data = ""));
now $data == "foo\\nbar\\n";';
$Oa=bless({$V1,$Ma,$E1,$Na,$G1,$H1},$e1);
$Pa=[$K9,$Oa];
$Qa=[$Ja,$La,$Pa];
$Ra=bless({$W2,$Qa,$f,$k1},$d1);
$Sa=q'ni.doc:unix/pid';
$Ta=q'
    my $pid = ni::fork {something};
    my $pid = ni::fork_with(stdin => $mypipe, ..., sub {something});
    my $pid = ni::fork_exec("ls", "-l")';
$Ua=[$X9,$Ta];
$Va=[];
$Wa=q'my $pid = ni("sh:seq 4");
$pid->into(ni("ni:unix/str")->new(my $data));
now $pid->await == 0;
now $data == "1\\n2\\n3\\n4\\n";';
$Xa=bless({$V1,$Va,$E1,$Wa,$G1,$H1},$e1);
$Ya=[$K9,$Xa];
$Za=[];
$cb=q'my $pid = ni("sh:seq 10");
my $filter = ni::fork_with stdin => $pid->stdout,
  sub {exec \'egrep\', \'[13579]$\'};
$filter->into(ni("ni:unix/str")->new(my $data));
now [$pid->await, $filter->await, $data] == [0, 0, "1\\n3\\n5\\n7\\n9\\n"];';
$db=bless({$V1,$Za,$E1,$cb,$G1,$H1},$e1);
$eb=[$K9,$db];
$fb=[$Ua,$Ya,$eb];
$gb=bless({$W2,$fb,$f,$p1},$d1);
$hb=q'ni:class';
$ib=q'ni:class.c';
$jb=q'ni:lib/accessor.b';
$kb=q'ni:lib/behavior';
$lb=q'ni:lib/behavior.c';
$mb=q'ni:lib/branch';
$nb=q'ni:lib/branch.b';
$ob=q'ni:lib/branch.c';
$pb=q'ni:lib/branch_init.b';
$qb=q'ni:lib/class_init.b';
$rb=q'ni:lib/dataslice';
$sb={$n,1};
$tb=[$M];
$ub=bless({$c,$sb,$f,$n,$g,$tb},$G);
$vb=q'metaclass::ctors';
$wb={$W,1};
$xb={};
$yb=q'my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};';
$zb=bless({$E1,$yb,$G1,$H1},$e1);
$Ab={$N1,$zb};
$Bb=q'lib/dataslice_init.b';
$Cb=bless({$c,$xb,$u1,$v1,$w1,$v1,$x1,$Ab,$f,$Bb},$R);
$Db=q'lib/slice::ctors';
$Eb={};
$Fb=q'local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;';
$Gb=bless({$E1,$Fb,$G1,$H1},$e1);
$Hb={$A3,$Gb};
$Ib=q'lib/dataslice_apply.b';
$Jb=bless({$c,$Eb,$u1,$v1,$w1,$v1,$x1,$Hb,$f,$Ib},$R);
$Kb=q'lib/slice::ctors';
$Lb=[$h3,$Cb,$Jb];
$Mb=bless({$c,$wb,$f,$W,$g,$Lb},$n);
$Nb=q'lib/dataslice.c::ctors';
$Ob=q'ni:lib/dataslice.c';
$Pb=q'ni:lib/dataslice_apply.b';
$Qb=q'ni:lib/dataslice_init.b';
$Rb=q'ni:lib/definition.b';
$Sb=q'ni:lib/definition_def.b';
$Tb=q'ni:lib/definition_defdata.b';
$Ub=q'ni:lib/doc';
$Vb=q'ni:lib/doc.c';
$Wb=q'ni:lib/doc_define.b';
$Xb=q'ni:lib/doc_init.b';
$Yb=q'ni:lib/doc_namespace.b';
$Zb=q'ni:lib/doc_test.b';
$cc=q'ni:lib/documentable.b';
$dc=q'ni:lib/fn';
$ec=q'ni:lib/fn.c';
$fc=q'ni:lib/fn_init.b';
$gc=q'ni:lib/fn_ops.b';
$hc=q'ni:lib/fn_ro.b';
$ic=q'ni:lib/fn_serialize.b';
$jc=q'ni:lib/global_static_test.b';
$kc={};
$lc=q'now';
$mc=[];
$nc=q'ni(\'ni:lib/test_value\')->new(shift)';
$oc=q'($)';
$pc=bless({$V1,$mc,$E1,$nc,$G1,$oc},$e1);
$qc={$lc,$pc};
$rc=q'lib/global_static_test.b';
$sc=bless({$c,$kc,$u1,$v1,$w1,$v1,$x1,$qc,$f,$rc},$R);
$tc=q'main';
$uc=q'lib/slice::ctors';
$vc=q'ni:lib/image';
$wc={$q,1};
$xc=[$H];
$yc=bless({$c,$wc,$f,$q,$g,$xc},$G);
$zc=q'metaclass::ctors';
$Ac={$f1,1};
$Bc={};
$Cc=[];
$Dc=q'my $class = shift;
my %args  = (
  include_shebang => 1,
  include_license => 1,
  include_boot    => 1,
  include_classes => 1,
  include_run     => 1,
  local_vars      => 0,
  use_newlines    => 0,
  @_);

+{include_shebang => $args{include_shebang},
  include_license => $args{include_license},
  include_boot    => $args{include_boot},
  include_classes => $args{include_classes},
  include_run     => $args{include_run},
  local_vars      => $args{local_vars},
  use_newlines    => $args{use_newlines},

  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};';
$Ec=bless({$V1,$Cc,$E1,$Dc,$G1,$H1},$e1);
$Fc={$N1,$Ec};
$Gc=q'lib/image_init.b';
$Hc=bless({$c,$Bc,$u1,$v1,$w1,$v1,$x1,$Fc,$f,$Gc},$R);
$Ic=q'lib/slice::ctors';
$Jc={};
$Kc=q'address';
$Lc=[];
$Mc=q'return \'undef\' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 16;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);';
$Nc=bless({$V1,$Lc,$E1,$Mc,$G1,$H1},$e1);
$Oc=q'allocate_gensym';
$Pc=[];
$Qc=q'my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;';
$Rc=bless({$V1,$Pc,$E1,$Qc,$G1,$H1},$e1);
$Sc=q'boot_side_effect';
$Tc=[];
$Uc=q'unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]';
$Vc=bless({$V1,$Tc,$E1,$Uc,$G1,$H1},$e1);
$Wc=q'circular_links';
$Xc=[];
$Yc=q'local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};';
$Zc=bless({$V1,$Xc,$E1,$Yc,$G1,$H1},$e1);
$cd=q'finalizer';
$dd=[];
$ed=q'push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]';
$fd=bless({$V1,$dd,$E1,$ed,$G1,$H1},$e1);
$gd=q'gensym';
$hd=[];
$id=q'my $n = shift->{gensym_n}++;
my $s = \'$\' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;';
$jd=bless({$V1,$hd,$E1,$id,$G1,$H1},$e1);
$kd=q'is_circular';
$ld=[];
$md=q'my $self = shift;
ref $$self{visited}{$self->address($_[0])};';
$nd=bless({$V1,$ld,$E1,$md,$G1,$H1},$e1);
$od=q'quote';
$pd=[];
$qd=q'my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? \'undef\' : $v if defined $v;
$$self{visited}{$a} = \\\'undef\';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));';
$rd=bless({$V1,$pd,$E1,$qd,$G1,$H1},$e1);
$sd=q'quote_array';
$td=[];
$ud=q'local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_])
  && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
for 0..$#{$v};
\'[\' . join(\',\', map $self->quote($_), @$v) . \']\';';
$vd=bless({$V1,$td,$E1,$ud,$G1,$H1},$e1);
$wd=q'quote_blessed';
$xd=[];
$yd=q'my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq \'HASH\' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";';
$zd=bless({$V1,$xd,$E1,$yd,$G1,$H1},$e1);
$Ad=q'quote_class';
$Bd=[];
$Cd=q'my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");';
$Dd=bless({$V1,$Bd,$E1,$Cd,$G1,$H1},$e1);
$Ed=q'quote_hash';
$Fd=[];
$Gd=q'local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  push @{$$self{circular}}, [$a, "{" . $self->quote($k) . "}",
                                 $self->address($$v{$k})]
  if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
\'{\' . join(",", @qs) . \'}\';';
$Hd=bless({$V1,$Fd,$E1,$Gd,$G1,$H1},$e1);
$Id=q'quote_object';
$Jd=[];
$Kd=q'my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can(\'serialize\') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;';
$Ld=bless({$V1,$Jd,$E1,$Kd,$G1,$H1},$e1);
$Md=q'quote_scalar';
$Nd=[];
$Od=q'my $v = $_[1];
return \'undef\' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\'])/\\\\$1/g;
"q\'$v\'";';
$Pd=bless({$V1,$Nd,$E1,$Od,$G1,$H1},$e1);
$Qd=q'quote_value';
$Rd=[];
$Sd=q'my $self = shift;
return $self->quote_scalar($_[0]) unless ref $_[0];
return $self->quote_array($_[0])  if \'ARRAY\' eq ref $_[0];
return $self->quote_hash($_[0])   if \'HASH\'  eq ref $_[0];
die "cannot serialize $_[0]"      if \'CODE\'  eq ref $_[0];
$self->quote_object($_[0]);';
$Td=bless({$V1,$Rd,$E1,$Sd,$G1,$H1},$e1);
$Ud=q'reconstruction';
$Vd=[];
$Wd=q'my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});';
$Xd=bless({$V1,$Vd,$E1,$Wd,$G1,$H1},$e1);
$Yd=q'side_effect';
$Zd=[];
$ce=q'push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]';
$de=bless({$V1,$Zd,$E1,$ce,$G1,$H1},$e1);
$ee=q'write';
$fe=[];
$ge=q'local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  ($$self{include_shebang} ? ("#!/usr/bin/env perl\\n") : ()),
  ($$self{include_license} ? ("chomp(\\$ni::license=<<\'_\');\\n", $ni::license, "\\n_\\n") : ()),
  ($$self{include_boot}    ? ("BEGIN{eval(\\$ni::boot=<<\'_\')}\\n", $ni::boot, "\\n_\\n") : ()),
  ($$self{use_newlines}    ? map("$_\\n", $self->reconstruction) : $self->reconstruction),
  ($$self{include_run}     ? ("ni->run(\\@ARGV);", "\\n__DATA__\\n") : ());';
$he=bless({$V1,$fe,$E1,$ge,$G1,$H1},$e1);
$ie={$Kc,$Nc,$Oc,$Rc,$Sc,$Vc,$Wc,$Zc,$cd,$fd,$gd,$jd,$kd,$nd,$od,$rd,$sd,$vd,$wd,$zd,$Ad,$Dd,$Ed,$Hd,$Id,$Ld,$Md,$Pd,$Qd,$Td,$Ud,$Xd,$Yd,$de,$ee,$he};
$je=q'lib/image_quoting.b';
$ke=bless({$c,$Jc,$u1,$v1,$w1,$v1,$x1,$ie,$f,$je},$R);
$le=q'lib/slice::ctors';
$me=[$T2,$Hc,$ke];
$ne=bless({$c,$Ac,$f,$f1,$g,$me},$q);
$oe=q'lib/image.c::ctors';
$pe=q'ni:lib/image.c';
$qe=q'ni:lib/image_init.b';
$re=q'ni:lib/image_quoting.b';
$se=q'ni:lib/instance.b';
$te=q'ni:lib/instantiable.b';
$ue=q'ni:lib/json.b';
$ve={};
$we=q'json_decode';
$xe=[];
$ye=q'local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];';
$ze=bless({$V1,$xe,$E1,$ye,$G1,$oc},$e1);
$Ae=q'json_encode';
$Be=[];
$Ce=q'local $_;
my ($v) = @_;
return "[" . join(\',\', map ni::json_encode($_), @$v) . "]" if \'ARRAY\' eq ref $v;
return "{" . join(\',\', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if \'HASH\' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : \'null\';';
$De=bless({$V1,$Be,$E1,$Ce,$G1,$oc},$e1);
$Ee=q'json_escape';
$Fe=[];
$Ge=q'(my $x = $_[0]) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . $ni::json_escapes{$1}/eg;
"\\"$x\\"";';
$He=bless({$V1,$Fe,$E1,$Ge,$G1,$oc},$e1);
$Ie=q'json_unescape';
$Je=[];
$Ke=q'my $x = substr $_[0], 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;';
$Le=bless({$V1,$Je,$E1,$Ke,$G1,$oc},$e1);
$Me=q'json_unescape_one';
$Ne=[];
$Oe=q'$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1';
$Pe=bless({$V1,$Ne,$E1,$Oe,$G1,$oc},$e1);
$Qe={$we,$ze,$Ae,$De,$Ee,$He,$Ie,$Le,$Me,$Pe};
$Re=q'lib/json.b';
$Se=bless({$c,$ve,$u1,$v1,$w1,$v1,$x1,$Qe,$f,$Re},$R);
$Te=q'ni';
$Ue=q'lib/slice::ctors';
$Ve=q'ni:lib/name_as_string.b';
$We=q'ni:lib/named.b';
$Xe=q'ni:lib/named_in_ni.b';
$Ye=q'ni:lib/namespaced.b';
$Ze=q'ni:lib/ni';
$cf=q'ni:lib/ni.c';
$df=q'ni:lib/ni_fork.b';
$ef={};
$ff=q'fork';
$gf=[];
$hf=q'ni::fork_with(shift)';
$if=q'(&)';
$jf=bless({$V1,$gf,$E1,$hf,$G1,$if},$e1);
$kf=q'fork_with';
$lf=[];
$mf=q'my $fn     = pop;
my %pipes  = @_;
my $stdin  = $pipes{stdin}  || ni(\'ni:unix/fifo\')->new;
my $stdout = $pipes{stdout} || ni(\'ni:unix/fifo\')->new;
my $stderr = $pipes{stderr} || ni(\'ni:unix/fifo\')->new;
my $pid    = fork;
die "ni:unix/pid.c: failed to fork: $!" unless defined $pid;

return ni(\'ni:unix/pid\')->new($pid,
  exists $pipes{stdin}  ? undef : $stdin->write_side,
  exists $pipes{stdout} ? undef : $stdout->read_side,
  exists $pipes{stderr} ? undef : $stderr->read_side) if $pid;

exists $pipes{stdin}  ? $stdin->be_stdin   : $stdin->read_side->be_stdin;
exists $pipes{stdout} ? $stdout->be_stdout : $stdout->write_side->be_stdout;
exists $pipes{stderr} ? $stderr->be_stderr : $stderr->write_side->be_stderr;
exit &$fn($stdin, $stdout, $stderr);';
$nf=bless({$V1,$lf,$E1,$mf,$G1,$H1},$e1);
$of={$ff,$jf,$kf,$nf};
$pf=q'lib/ni_fork.b';
$qf=bless({$c,$ef,$u1,$v1,$w1,$v1,$x1,$of,$f,$pf},$R);
$rf=q'lib/slice::ctors';
$sf=q'ni:lib/ni_fork_exec.b';
$tf={};
$uf=q'fork_exec';
$vf=[];
$wf=q'my @argv = @_;
ni::fork {exec @argv or die "ni:unix/pid.c: failed to exec @argv: $!"};';
$xf=bless({$V1,$vf,$E1,$wf,$G1,$H1},$e1);
$yf={$uf,$xf};
$zf=q'lib/ni_fork_exec.b';
$Af=bless({$c,$tf,$u1,$v1,$w1,$v1,$x1,$yf,$f,$zf},$R);
$Bf=q'lib/slice::ctors';
$Cf=q'ni:lib/ni_image.b';
$Df=q'ni:lib/ni_main.b';
$Ef=q'ni:lib/ni_resolver.b';
$Ff=q'ni:lib/ni_self.b';
$Gf=q'ni:lib/ni_static_util.b';
$Hf={};
$If=q'abbrev';
$Jf=[];
$Kf=q'length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . \'...\'';
$Lf=bless({$V1,$Jf,$E1,$Kf,$G1,$H1},$e1);
$Mf=q'dor';
$Nf=[];
$Of=q'defined $_[0] ? $_[0] : $_[1]';
$Pf=bless({$V1,$Nf,$E1,$Of,$G1,$H1},$e1);
$Qf=q'indent';
$Rf=[];
$Sf=q'my ($s, $indent) = (@_, 2);
join "\\n", map \' \' x $indent . $_, split /\\n/, $s;';
$Tf=bless({$V1,$Rf,$E1,$Sf,$G1,$H1},$e1);
$Uf=q'max';
$Vf=[];
$Wf=q'local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m';
$Xf=bless({$V1,$Vf,$E1,$Wf,$G1,$H1},$e1);
$Yf=q'maxstr';
$Zf=[];
$cg=q'local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m';
$dg=bless({$V1,$Zf,$E1,$cg,$G1,$H1},$e1);
$eg=q'mean';
$fg=[];
$gg=q'sum(@_) / (@_ || 1)';
$hg=bless({$V1,$fg,$E1,$gg,$G1,$H1},$e1);
$ig=q'min';
$jg=[];
$kg=q'local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m';
$lg=bless({$V1,$jg,$E1,$kg,$G1,$H1},$e1);
$mg=q'minstr';
$ng=[];
$og=q'local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m';
$pg=bless({$V1,$ng,$E1,$og,$G1,$H1},$e1);
$qg=q'sgr';
$rg=[];
$sg=q'(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x';
$tg=bless({$V1,$rg,$E1,$sg,$G1,$H1},$e1);
$ug=q'sr';
$vg=[];
$wg=q'(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x';
$xg=bless({$V1,$vg,$E1,$wg,$G1,$H1},$e1);
$yg=q'sum';
$zg=[];
$Ag=q'local $_; my $x = 0; $x += $_ for @_; $x';
$Bg=bless({$V1,$zg,$E1,$Ag,$G1,$H1},$e1);
$Cg=q'swap';
$Dg=[];
$Eg=q'@_[0, 1] = @_[1, 0]';
$Fg=bless({$V1,$Dg,$E1,$Eg,$G1,$H1},$e1);
$Gg={$If,$Lf,$Mf,$Pf,$Qf,$Tf,$Uf,$Xf,$Yf,$dg,$eg,$hg,$ig,$lg,$mg,$pg,$qg,$tg,$ug,$xg,$yg,$Bg,$Cg,$Fg};
$Hg=q'lib/ni_static_util.b';
$Ig=bless({$c,$Hf,$u1,$v1,$w1,$v1,$x1,$Gg,$f,$Hg},$R);
$Jg=q'lib/slice::ctors';
$Kg=q'ni:lib/perlbranch.b';
$Lg=q'ni:lib/ref_eq.b';
$Mg=q'ni:lib/resolver.b';
$Ng=q'ni:lib/slice';
$Og=q'ni:lib/slice.b';
$Pg=q'ni:lib/slice.c';
$Qg=q'ni:lib/slice_init.b';
$Rg=q'ni:lib/slice_serialize.b';
$Sg=q'ni:lib/static_fn.b';
$Tg={};
$Ug=[];
$Vg=q'ni(\'ni:lib/fn\')->new(@_)';
$Wg=bless({$V1,$Ug,$E1,$Vg,$G1,$oc},$e1);
$Xg=q'fp';
$Yg=[];
$Zg=q'ni(\'ni:lib/fn\')->new(@_)';
$ch=q'($$)';
$dh=bless({$V1,$Yg,$E1,$Zg,$G1,$ch},$e1);
$eh={$e2,$Wg,$Xg,$dh};
$fh=q'lib/static_fn.b';
$gh=bless({$c,$Tg,$u1,$v1,$w1,$v1,$x1,$eh,$f,$fh},$R);
$hh=q'lib/slice::ctors';
$ih=q'ni:lib/subclass.b';
$jh=q'ni:lib/tag';
$kh=q'ni:lib/tag.b';
$lh=q'ni:lib/tag.c';
$mh=q'ni:lib/tag_init.b';
$nh=q'ni:lib/test_value';
$oh=q'lib/test_value.c';
$ph={$oh,1};
$qh=q'lib/test_value.c';
$rh=[$H];
$sh=bless({$c,$ph,$f,$qh,$g,$rh},$G);
$th=q'metaclass::ctors';
$uh={$h1,1};
$vh={};
$wh=[];
$xh=q'\\$_[1]';
$yh=bless({$V1,$wh,$E1,$xh,$G1,$H1},$e1);
$zh={$N1,$yh};
$Ah=q'lib/test_value_init.b';
$Bh=bless({$c,$vh,$u1,$v1,$w1,$v1,$x1,$zh,$f,$Ah},$R);
$Ch=q'lib/slice::ctors';
$Dh={};
$Eh=q'(==';
$Fh=[];
$Gh=q'my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;';
$Hh=bless({$V1,$Fh,$E1,$Gh,$G1,$H1},$e1);
$Ih=q'diff';
$Jh=[];
$Kh=q'my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq \'HASH\') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq \'ARRAY\') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq \'SCALAR\') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;';
$Lh=bless({$V1,$Jh,$E1,$Kh,$G1,$H1},$e1);
$Mh={$Eh,$Hh,$Ih,$Lh};
$Nh=q'lib/test_value_eq.b';
$Oh=bless({$c,$Dh,$u1,$v1,$w1,$v1,$x1,$Mh,$f,$Nh},$R);
$Ph=q'lib/slice::ctors';
$Qh={};
$Rh=[];
$Sh=q'ni::json_encode ${$_[0]}';
$Th=bless({$V1,$Rh,$E1,$Sh,$G1,$H1},$e1);
$Uh={$n2,$Th};
$Vh=q'lib/test_value_str.b';
$Wh=bless({$c,$Qh,$u1,$v1,$w1,$v1,$x1,$Uh,$f,$Vh},$R);
$Xh=q'lib/slice::ctors';
$Yh=[$T2,$Bh,$Oh,$Wh];
$Zh=q'lib/test_value.c';
$ci=bless({$c,$uh,$f,$h1,$g,$Yh},$Zh);
$di=q'lib/test_value.c::ctors';
$ei=q'ni:lib/test_value.c';
$fi=q'ni:lib/test_value_eq.b';
$gi=q'ni:lib/test_value_init.b';
$hi=q'ni:lib/test_value_str.b';
$ii=q'ni:main';
$ji={$tc,1};
$ki=[$gh,$sc];
$li=bless({$c,$ji,$f,$tc,$g,$ki},$Z);
$mi=q'module::ctors';
$ni=q'ni:metaclass';
$oi=q'ni:metaclass.c';
$pi=q'ni:module';
$qi=q'ni:module.c';
$ri=q'ni:ni';
$si={$Te,1};
$ti={$Te,1};
$ui=q'data';
$vi=q'json_escapes';
$wi=q'';
$xi=q'b';
$yi=q'	';
$zi=q't';
$Ai=q'
';
$Bi=q'n';
$Ci=q'';
$Di=q'r';
$Ei=q'"';
$Fi=q'/';
$Gi=q'\\';
$Hi={$wi,$xi,$yi,$zi,$Ai,$Bi,$Ci,$Di,$Ei,$Ei,$Fi,$Fi,$Gi,$Gi};
$Ii=q'json_unescapes';
$Ji={$Ei,$Ei,$Fi,$Fi,$Gi,$Gi,$xi,$wi,$Bi,$Ai,$Di,$Ci,$zi,$yi};
$Ki={$vi,$Hi,$Ii,$Ji};
$Li=q'lib/json_data.b';
$Mi=bless({$c,$ti,$ui,$Ki,$f,$Li},$W);
$Ni=q'lib/dataslice::ctors';
$Oi=[$Mi,$Se,$Ig,$qf,$Af];
$Pi=bless({$c,$si,$f,$Te,$g,$Oi},$Z);
$Qi=q'ni:object';
$Ri=q'ni:object.c';
$Si=q'ni:unix/cat';
$Ti={$w,1};
$Ui={$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$Vi=[$H];
$Wi=bless({$c,$Ui,$f,$A,$g,$Vi},$G);
$Xi=q'metaclass::ctors';
$Yi=[$Wi];
$Zi=bless({$c,$Ti,$f,$w,$g,$Yi},$G);
$cj=q'metaclass::ctors';
$dj={$k1,1};
$ej={$k1,1,$l1,1,$m1,1,$n1,1,$o1,1,$p1,1,$q1,1,$r1,1};
$fj={};
$gj=q'into';
$hj=[];
$ij=q'local $_;
my ($self, $dest, $each) = @_;
my $block_size = $self->can(\'read_size\') ? $self->read_size : 8192;
while ($self->read($_, $block_size)) {
  &$each($_) if defined $each;
  $dest->write($_);
}';
$jj=bless({$V1,$hj,$E1,$ij,$G1,$H1},$e1);
$kj={$gj,$jj};
$lj=q'unix/io_stream.b';
$mj=bless({$c,$fj,$u1,$v1,$w1,$v1,$x1,$kj,$f,$lj},$R);
$nj=q'lib/slice::ctors';
$oj={};
$pj=q'(+';
$qj=[];
$rj=q'ni(\'ni:unix/cat\')->new(@_[0, 1])';
$sj=bless({$V1,$qj,$E1,$rj,$G1,$H1},$e1);
$tj={$pj,$sj};
$uj=q'unix/io_constructors.b';
$vj=bless({$c,$oj,$u1,$v1,$w1,$v1,$x1,$tj,$f,$uj},$R);
$wj=q'lib/slice::ctors';
$xj={};
$yj=q'(<>';
$zj=[];
$Aj=q'my $fh = shift->read_fh;
# TODO: buffered line reading with a pushback queue';
$Bj=bless({$V1,$zj,$E1,$Aj,$G1,$H1},$e1);
$Cj=q'(@{}';
$Dj=[];
$Ej=q'my $self = shift; [<$self>]';
$Fj=bless({$V1,$Dj,$E1,$Ej,$G1,$H1},$e1);
$Gj={$yj,$Bj,$Cj,$Fj};
$Hj=q'unix/io_readers.b';
$Ij=bless({$c,$xj,$u1,$v1,$w1,$v1,$x1,$Gj,$f,$Hj},$R);
$Jj=q'lib/slice::ctors';
$Kj=[$T2,$mj,$vj,$Ij];
$Lj=bless({$c,$ej,$f,$o1,$g,$Kj},$A);
$Mj=q'unix/io.c::ctors';
$Nj={};
$Oj=[];
$Pj=q'shift; +{fs => [@_]}';
$Qj=bless({$V1,$Oj,$E1,$Pj,$G1,$H1},$e1);
$Rj={$N1,$Qj};
$Sj=q'unix/cat_init.b';
$Tj=bless({$c,$Nj,$u1,$v1,$w1,$v1,$x1,$Rj,$f,$Sj},$R);
$Uj=q'lib/slice::ctors';
$Vj={};
$Wj=q'read';
$Xj=[];
$Yj=q'my $fs = shift->{fs};
my $n;
shift @$fs until !@$fs or $n = $$fs[0]->read(@_);
return $n;';
$Zj=bless({$V1,$Xj,$E1,$Yj,$G1,$H1},$e1);
$ck={$Wj,$Zj};
$dk=q'unix/cat_read.b';
$ek=bless({$c,$Vj,$u1,$v1,$w1,$v1,$x1,$ck,$f,$dk},$R);
$fk=q'lib/slice::ctors';
$gk=[$Lj,$Tj,$ek];
$hk=bless({$c,$dj,$f,$k1,$g,$gk},$w);
$ik=q'unix/cat.c::ctors';
$jk=q'ni:unix/cat.c';
$kk=q'ni:unix/cat_init.b';
$lk=q'ni:unix/cat_read.b';
$mk=q'ni:unix/fd';
$nk={$x,1};
$ok=[$Wi];
$pk=bless({$c,$nk,$f,$x,$g,$ok},$G);
$qk=q'metaclass::ctors';
$rk={$l1,1};
$sk={};
$tk=q'fd';
$uk=[];
$vk=q'shift->{\'fd\'}';
$wk=bless({$V1,$uk,$E1,$vk,$G1,$H1},$e1);
$xk={$tk,$wk};
$yk=q'unix/fd_readers.b';
$zk=bless({$c,$sk,$u1,$v1,$w1,$v1,$x1,$xk,$f,$yk},$R);
$Ak=q'lib/slice::ctors';
$Bk={};
$Ck=[];
$Dk=q'my ($class, $fd) = @_;
+{fd => $fd, fh => undef};';
$Ek=bless({$V1,$Ck,$E1,$Dk,$G1,$H1},$e1);
$Fk={$N1,$Ek};
$Gk=q'unix/fd_init.b';
$Hk=bless({$c,$Bk,$u1,$v1,$w1,$v1,$x1,$Fk,$f,$Gk},$R);
$Ik=q'lib/slice::ctors';
$Jk={};
$Kk=q'move_to';
$Lk=[];
$Mk=q'use POSIX qw/dup2/;
my ($self, $new) = @_;
return $self if $new == $$self{fd};
close $$self{fh} if Scalar::Util::openhandle $$self{fh};
dup2 $$self{fd}, $new or die "ni:unix/fd: dup2($$self{fd}, $new): $!";
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;';
$Nk=bless({$V1,$Lk,$E1,$Mk,$G1,$H1},$e1);
$Ok={$Kk,$Nk};
$Pk=q'unix/fd_shell.b';
$Qk=bless({$c,$Jk,$u1,$v1,$w1,$v1,$x1,$Ok,$f,$Pk},$R);
$Rk=q'lib/slice::ctors';
$Sk={$l1,1,$m1,1,$n1,1,$p1,1,$q1,1};
$Tk=q'unix/has_fd.b';
$Uk={};
$Vk=q'be_stderr';
$Wk=[];
$Xk=q'ni("ni:unix/fd")->new(fileno shift->write_fh)->move_to(2)';
$Yk=bless({$V1,$Wk,$E1,$Xk,$G1,$H1},$e1);
$Zk=q'be_stdin';
$cl=[];
$dl=q'ni("ni:unix/fd")->new(fileno shift->read_fh)->move_to(0)';
$el=bless({$V1,$cl,$E1,$dl,$G1,$H1},$e1);
$fl=q'be_stdout';
$gl=[];
$hl=q'ni("ni:unix/fd")->new(fileno shift->write_fh)->move_to(1)';
$il=bless({$V1,$gl,$E1,$hl,$G1,$H1},$e1);
$jl={$Vk,$Yk,$Zk,$el,$fl,$il};
$kl=q'unix/fd_stdio.b';
$ll=bless({$c,$Uk,$u1,$v1,$w1,$v1,$x1,$jl,$f,$kl},$R);
$ml=q'lib/slice::ctors';
$nl={};
$ol=[];
$pl=q'no warnings \'io\';
use Errno qw/EINTR/;
my $fh = shift->read_fh;
my $n;
do {
  return $n if defined($n = read $fh, $_[0], $_[1], $_[2] || 0);
} while $!{EINTR};
return undef;';
$ql=bless({$V1,$ol,$E1,$pl,$G1,$H1},$e1);
$rl=[];
$sl=q'my $fh = shift->write_fh;
my $n;
do {
  return $n if defined($n = syswrite $fh, $_[0]);
} while $!{EINTR};
return undef;';
$tl=bless({$V1,$rl,$E1,$sl,$G1,$H1},$e1);
$ul={$Wj,$ql,$ee,$tl};
$vl=q'unix/fd_safeio.b';
$wl=bless({$c,$nl,$u1,$v1,$w1,$v1,$x1,$ul,$f,$vl},$R);
$xl=q'lib/slice::ctors';
$yl=[$ll,$wl];
$zl=bless({$c,$Sk,$f,$Tk,$g,$yl},$V);
$Al=q'lib/branch::ctors';
$Bl={};
$Cl=q'read_fh';
$Dl=[];
$El=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'<&=\', $self->{fd}
  or die "ni:unix/fd $self->{fd} failed to read: $!";
$self->{fh} = $fh;';
$Fl=bless({$V1,$Dl,$E1,$El,$G1,$H1},$e1);
$Gl=q'write_fh';
$Hl=[];
$Il=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'>&=\', $self->{fd}
  or die "ni:unix/file $self->{fd} failed to write: $!";
$self->{fh} = $fh;';
$Jl=bless({$V1,$Hl,$E1,$Il,$G1,$H1},$e1);
$Kl={$Cl,$Fl,$Gl,$Jl};
$Ll=q'unix/fd_io.b';
$Ml=bless({$c,$Bl,$u1,$v1,$w1,$v1,$x1,$Kl,$f,$Ll},$R);
$Nl=q'lib/slice::ctors';
$Ol=[$Lj,$zk,$Hk,$Qk,$zl,$Ml];
$Pl=bless({$c,$rk,$f,$l1,$g,$Ol},$x);
$Ql=q'unix/fd.c::ctors';
$Rl=q'ni:unix/fd.c';
$Sl=q'ni:unix/fd_init.b';
$Tl=q'ni:unix/fd_io.b';
$Ul=q'ni:unix/fd_readers.b';
$Vl=q'ni:unix/fd_safeio.b';
$Wl=q'ni:unix/fd_shell.b';
$Xl=q'ni:unix/fd_stdio.b';
$Yl=q'ni:unix/fifo';
$Zl={$y,1};
$cm=[$Wi];
$dm=bless({$c,$Zl,$f,$y,$g,$cm},$G);
$em=q'metaclass::ctors';
$fm={$m1,1};
$gm={};
$hm=[];
$im=q'shift->{\'read_fh\'}';
$jm=bless({$V1,$hm,$E1,$im,$G1,$H1},$e1);
$km=[];
$lm=q'shift->{\'write_fh\'}';
$mm=bless({$V1,$km,$E1,$lm,$G1,$H1},$e1);
$nm={$Cl,$jm,$Gl,$mm};
$om=q'unix/fifo_io.b';
$pm=bless({$c,$gm,$u1,$v1,$w1,$v1,$x1,$nm,$f,$om},$R);
$qm=q'lib/slice::ctors';
$rm={};
$sm=[];
$tm=q'my ($class) = @_;
pipe my ($r, $w) or die "ni:unix/fifo failed: $!";
+{read_fh => $r, write_fh => $w};';
$um=bless({$V1,$sm,$E1,$tm,$G1,$H1},$e1);
$vm={$N1,$um};
$wm=q'unix/fifo_init.b';
$xm=bless({$c,$rm,$u1,$v1,$w1,$v1,$x1,$vm,$f,$wm},$R);
$ym=q'lib/slice::ctors';
$zm={};
$Am=q'read_side';
$Bm=[];
$Cm=q'my $self = shift;
close $$self{write_fh};
ni("ni:unix/fd")->new(fileno $$self{read_fh});';
$Dm=bless({$V1,$Bm,$E1,$Cm,$G1,$H1},$e1);
$Em=q'write_side';
$Fm=[];
$Gm=q'my $self = shift;
close $$self{read_fh};
ni("ni:unix/fd")->new(fileno $$self{write_fh});';
$Hm=bless({$V1,$Fm,$E1,$Gm,$G1,$H1},$e1);
$Im={$Am,$Dm,$Em,$Hm};
$Jm=q'unix/fifo_direction.b';
$Km=bless({$c,$zm,$u1,$v1,$w1,$v1,$x1,$Im,$f,$Jm},$R);
$Lm=q'lib/slice::ctors';
$Mm=[$Lj,$pm,$xm,$zl,$Km];
$Nm=bless({$c,$fm,$f,$m1,$g,$Mm},$y);
$Om=q'unix/fifo.c::ctors';
$Pm=q'ni:unix/fifo.c';
$Qm=q'ni:unix/fifo_direction.b';
$Rm=q'ni:unix/fifo_init.b';
$Sm=q'ni:unix/fifo_io.b';
$Tm=q'ni:unix/file';
$Um={$z,1};
$Vm=[$Wi];
$Wm=bless({$c,$Um,$f,$z,$g,$Vm},$G);
$Xm=q'metaclass::ctors';
$Ym={$n1,1};
$Zm={};
$cn=[];
$dn=q'shift->{\'name\'}';
$en=bless({$V1,$cn,$E1,$dn,$G1,$H1},$e1);
$fn={$f,$en};
$gn=q'unix/file_readers.b';
$hn=bless({$c,$Zm,$u1,$v1,$w1,$v1,$x1,$fn,$f,$gn},$R);
$in=q'lib/slice::ctors';
$jn={};
$kn=[];
$ln=q'my ($class, $name) = @_;
+{name => $name, fh => undef};';
$mn=bless({$V1,$kn,$E1,$ln,$G1,$H1},$e1);
$nn={$N1,$mn};
$on=q'unix/file_init.b';
$pn=bless({$c,$jn,$u1,$v1,$w1,$v1,$x1,$nn,$f,$on},$R);
$qn=q'lib/slice::ctors';
$rn={};
$sn=[];
$tn=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'<\', $self->{name}
  or die "ni:unix/file $self->{name} failed to read: $!";
$self->{fh} = $fh;';
$un=bless({$V1,$sn,$E1,$tn,$G1,$H1},$e1);
$vn=[];
$wn=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'>\', $self->{name}
  or die "ni:unix/file $self->{name} failed to write: $!";
$self->{fh} = $fh;';
$xn=bless({$V1,$vn,$E1,$wn,$G1,$H1},$e1);
$yn={$Cl,$un,$Gl,$xn};
$zn=q'unix/file_io.b';
$An=bless({$c,$rn,$u1,$v1,$w1,$v1,$x1,$yn,$f,$zn},$R);
$Bn=q'lib/slice::ctors';
$Cn=[$Lj,$hn,$pn,$zl,$An];
$Dn=bless({$c,$Ym,$f,$n1,$g,$Cn},$z);
$En=q'unix/file.c::ctors';
$Fn=q'ni:unix/file.c';
$Gn=q'ni:unix/file_init.b';
$Hn=q'ni:unix/file_io.b';
$In=q'ni:unix/file_readers.b';
$Jn=q'ni:unix/has_fd.b';
$Kn=q'ni:unix/io';
$Ln=q'ni:unix/io.c';
$Mn=q'ni:unix/io_constructors.b';
$Nn=q'ni:unix/io_readers.b';
$On=q'ni:unix/io_stream.b';
$Pn=q'ni:unix/pid';
$Qn={$B,1};
$Rn=[$Wi];
$Sn=bless({$c,$Qn,$f,$B,$g,$Rn},$G);
$Tn=q'metaclass::ctors';
$Un={$p1,1};
$Vn={};
$Wn=q'pid';
$Xn=[];
$Yn=q'shift->{\'pid\'}';
$Zn=bless({$V1,$Xn,$E1,$Yn,$G1,$H1},$e1);
$co=q'stderr';
$do=[];
$eo=q'shift->{\'stderr\'}';
$fo=bless({$V1,$do,$E1,$eo,$G1,$H1},$e1);
$go=q'stdin';
$ho=[];
$io=q'shift->{\'stdin\'}';
$jo=bless({$V1,$ho,$E1,$io,$G1,$H1},$e1);
$ko=q'stdout';
$lo=[];
$mo=q'shift->{\'stdout\'}';
$no=bless({$V1,$lo,$E1,$mo,$G1,$H1},$e1);
$oo={$Wn,$Zn,$co,$fo,$go,$jo,$ko,$no};
$po=q'unix/pid_readers.b';
$qo=bless({$c,$Vn,$u1,$v1,$w1,$v1,$x1,$oo,$f,$po},$R);
$ro=q'lib/slice::ctors';
$so={};
$to=[];
$uo=q'shift->await';
$vo=bless({$V1,$to,$E1,$uo,$G1,$H1},$e1);
$wo=[];
$xo=q'my ($class, $pid, $i, $o, $e) = @_;
+{pid    => $pid,
  stdin  => $i,
  stdout => $o,
  stderr => $e,
  status => undef};';
$yo=bless({$V1,$wo,$E1,$xo,$G1,$H1},$e1);
$zo={$N1,$yo};
$Ao=q'unix/pid_init.b';
$Bo=bless({$c,$so,$u1,$v1,$w1,$vo,$x1,$zo,$f,$Ao},$R);
$Co=q'lib/slice::ctors';
$Do={};
$Eo=q'await';
$Fo=[];
$Go=q'my $self = shift;
return $$self{status} if defined $$self{status};
$$self{status} = $? if waitpid $$self{pid}, 0;';
$Ho=bless({$V1,$Fo,$E1,$Go,$G1,$H1},$e1);
$Io={$Eo,$Ho};
$Jo=q'unix/pid_wait.b';
$Ko=bless({$c,$Do,$u1,$v1,$w1,$v1,$x1,$Io,$f,$Jo},$R);
$Lo=q'lib/slice::ctors';
$Mo={};
$No=[];
$Oo=q'shift->{stdout}->read_fh';
$Po=bless({$V1,$No,$E1,$Oo,$G1,$H1},$e1);
$Qo=[];
$Ro=q'shift->{stdin}->write_fh';
$So=bless({$V1,$Qo,$E1,$Ro,$G1,$H1},$e1);
$To={$Cl,$Po,$Gl,$So};
$Uo=q'unix/pid_io.b';
$Vo=bless({$c,$Mo,$u1,$v1,$w1,$v1,$x1,$To,$f,$Uo},$R);
$Wo=q'lib/slice::ctors';
$Xo=[$Lj,$qo,$Bo,$Ko,$zl,$Vo];
$Yo=bless({$c,$Un,$f,$p1,$g,$Xo},$B);
$Zo=q'unix/pid.c::ctors';
$cp=q'ni:unix/pid.c';
$dp=q'ni:unix/pid_init.b';
$ep=q'ni:unix/pid_io.b';
$fp=q'ni:unix/pid_readers.b';
$gp=q'ni:unix/pid_wait.b';
$hp=q'ni:unix/pipeline';
$ip={$C,1};
$jp=[$Wi];
$kp=bless({$c,$ip,$f,$C,$g,$jp},$G);
$lp=q'metaclass::ctors';
$mp={$q1,1};
$np={};
$op=[];
$pp=q'shift->{\'stdin\'}';
$qp=bless({$V1,$op,$E1,$pp,$G1,$H1},$e1);
$rp=[];
$sp=q'shift->{\'stdout\'}';
$tp=bless({$V1,$rp,$E1,$sp,$G1,$H1},$e1);
$up={$go,$qp,$ko,$tp};
$vp=q'unix/pipeline_ro.b';
$wp=bless({$c,$np,$u1,$v1,$w1,$v1,$x1,$up,$f,$vp},$R);
$xp=q'lib/slice::ctors';
$yp={};
$zp=[];
$Ap=q'my $class  = shift;
my $stdin  = ni(\'ni:unix/fifo\')->new;
my $stdout = ni(\'ni:unix/fifo\')->new;
# TODO: stderr and multiplexing, which probably happens here

my @rs = ($stdin, @_);
my @ws = (@_, $stdout);
my $rv; vec($rv, fileno $_->read_fh,  1) = 1 for @rs;
my $wv; vec($wv, fileno $_->write_fh, 1) = 1 for @ws;

+{ps     => [@_],
  stdin  => $stdin,
  stdout => $stdout,
  rs => \\@rs, rv => $rv,
  ws => \\@ws, wv => $wv};';
$Bp=bless({$V1,$zp,$E1,$Ap,$G1,$H1},$e1);
$Cp={$N1,$Bp};
$Dp=q'unix/pipeline_init.b';
$Ep=bless({$c,$yp,$u1,$v1,$w1,$v1,$x1,$Cp,$f,$Dp},$R);
$Fp=q'lib/slice::ctors';
$Gp={};
$Hp=q'async_step';
$Ip=[];
$Jp=q'local $_;
my $self = shift;
my $rv = $$self{rv};
my $wv = $$self{wv};
my $ev = $$self{ev};
return $self unless select $rv, $wv, $ev, 0;
for my $i (0..$#{$$self{rs}}) {
  my $rfh = $$self{rs}[$i]->read_fh;
  my $wfh = $$self{ws}[$i]->write_fh;
  next unless vec $rv, fileno $rfh, 1 and vec $wv, fileno $wfh, 1;
  $$self{rs}[$i]->read($_, 8192);
  $$self{ws}[$i]->write($_);
}
$self;';
$Kp=bless({$V1,$Ip,$E1,$Jp,$G1,$H1},$e1);
$Lp={$Hp,$Kp};
$Mp=q'unix/pipeline_async.b';
$Np=bless({$c,$Gp,$u1,$v1,$w1,$v1,$x1,$Lp,$f,$Mp},$R);
$Op=q'lib/slice::ctors';
$Pp={};
$Qp=[];
$Rp=q'shift->{stdout}->read_fh';
$Sp=bless({$V1,$Qp,$E1,$Rp,$G1,$H1},$e1);
$Tp=[];
$Up=q'shift->{stdin}->write_fh';
$Vp=bless({$V1,$Tp,$E1,$Up,$G1,$H1},$e1);
$Wp={$Cl,$Sp,$Gl,$Vp};
$Xp=q'unix/pipeline_io.b';
$Yp=bless({$c,$Pp,$u1,$v1,$w1,$v1,$x1,$Wp,$f,$Xp},$R);
$Zp=q'lib/slice::ctors';
$cq=[$Lj,$wp,$Ep,$Np,$zl,$Yp];
$dq=bless({$c,$mp,$f,$q1,$g,$cq},$C);
$eq=q'unix/pipeline.c::ctors';
$fq=q'ni:unix/pipeline.c';
$gq=q'ni:unix/pipeline_async.b';
$hq=q'ni:unix/pipeline_init.b';
$iq=q'ni:unix/pipeline_io.b';
$jq=q'ni:unix/pipeline_ro.b';
$kq=q'ni:unix/str';
$lq={$D,1};
$mq=[$Wi];
$nq=bless({$c,$lq,$f,$D,$g,$mq},$G);
$oq=q'metaclass::ctors';
$pq={$r1,1};
$qq={};
$rq=[];
$sq=q'shift->{\'data\'}';
$tq=bless({$V1,$rq,$E1,$sq,$G1,$H1},$e1);
$uq=q'end';
$vq=[];
$wq=q'shift->{\'end\'}';
$xq=bless({$V1,$vq,$E1,$wq,$G1,$H1},$e1);
$yq=q'start';
$zq=[];
$Aq=q'shift->{\'start\'}';
$Bq=bless({$V1,$zq,$E1,$Aq,$G1,$H1},$e1);
$Cq={$ui,$tq,$uq,$xq,$yq,$Bq};
$Dq=q'unix/str_ro.b';
$Eq=bless({$c,$qq,$u1,$v1,$w1,$v1,$x1,$Cq,$f,$Dq},$R);
$Fq=q'lib/slice::ctors';
$Gq={};
$Hq=[];
$Iq=q'my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};';
$Jq=bless({$V1,$Hq,$E1,$Iq,$G1,$H1},$e1);
$Kq={$N1,$Jq};
$Lq=q'unix/str_init.b';
$Mq=bless({$c,$Gq,$u1,$v1,$w1,$v1,$x1,$Kq,$f,$Lq},$R);
$Nq=q'lib/slice::ctors';
$Oq={};
$Pq=[];
$Qq=q'my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;';
$Rq=bless({$V1,$Pq,$E1,$Qq,$G1,$H1},$e1);
$Sq=q'remaining';
$Tq=[];
$Uq=q'my $self = shift; $$self{end} - $$self{start}';
$Vq=bless({$V1,$Tq,$E1,$Uq,$G1,$H1},$e1);
$Wq=[];
$Xq=q'my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];';
$Yq=bless({$V1,$Wq,$E1,$Xq,$G1,$H1},$e1);
$Zq={$Wj,$Rq,$Sq,$Vq,$ee,$Yq};
$cr=q'unix/str_io.b';
$dr=bless({$c,$Oq,$u1,$v1,$w1,$v1,$x1,$Zq,$f,$cr},$R);
$er=q'lib/slice::ctors';
$fr=[$Lj,$Eq,$Mq,$dr];
$gr=bless({$c,$pq,$f,$r1,$g,$fr},$D);
$hr=q'unix/str.c::ctors';
$ir=q'ni:unix/str.c';
$jr=q'ni:unix/str_init.b';
$kr=q'ni:unix/str_io.b';
$lr=q'ni:unix/str_ro.b';
$mr={$h9,$qa,$sa,$Ga,$Ha,$Ra,$Sa,$gb,$hb,$A7,$ib,$q4,$jb,$G6,$kb,$h3,$lb,$M,$mb,$j6,$nb,$d5,$ob,$W5,$pb,$g6,$qb,$R5,$rb,$Mb,$Ob,$ub,$Pb,$Jb,$Qb,$Cb,$Rb,$l7,$Sb,$u6,$Tb,$h7,$Ub,$V9,$Vb,$k9,$Wb,$H9,$Xb,$s9,$Yb,$z9,$Zb,$S9,$cc,$d3,$dc,$J2,$ec,$A1,$fc,$S1,$gc,$x2,$hc,$k2,$ic,$G2,$jc,$sc,$vc,$ne,$pe,$yc,$qe,$Hc,$re,$ke,$se,$P2,$te,$j4,$ue,$Se,$Ve,$O6,$We,$q3,$Xe,$m5,$Ye,$v5,$Ze,$e9,$cf,$L7,$df,$qf,$sf,$Af,$Cf,$o8,$Df,$N8,$Ef,$Z8,$Ff,$Z7,$Gf,$Ig,$Kg,$I5,$Lg,$W6,$Mg,$E5,$Ng,$W3,$Og,$E3,$Pg,$P,$Qg,$L3,$Rg,$T3,$Sg,$gh,$ih,$w7,$jh,$Q4,$kh,$G4,$lh,$y4,$mh,$N4,$nh,$ci,$ei,$sh,$fi,$Oh,$gi,$Bh,$hi,$Wh,$ii,$li,$ni,$H7,$oi,$D7,$pi,$o7,$qi,$n4,$ri,$Pi,$Qi,$T2,$Ri,$H,$Si,$hk,$jk,$Zi,$kk,$Tj,$lk,$ek,$mk,$Pl,$Rl,$pk,$Sl,$Hk,$Tl,$Ml,$Ul,$zk,$Vl,$wl,$Wl,$Qk,$Xl,$ll,$Yl,$Nm,$Pm,$dm,$Qm,$Km,$Rm,$xm,$Sm,$pm,$Tm,$Dn,$Fn,$Wm,$Gn,$pn,$Hn,$An,$In,$hn,$Jn,$zl,$Kn,$Lj,$Ln,$Wi,$Mn,$vj,$Nn,$Ij,$On,$mj,$Pn,$Yo,$cp,$Sn,$dp,$Bo,$ep,$Vo,$fp,$qo,$gp,$Ko,$hp,$dq,$fq,$kp,$gq,$Np,$hq,$Ep,$iq,$Yp,$jq,$wp,$kq,$gr,$ir,$nq,$jr,$Mq,$kr,$dr,$lr,$Eq};
$nr=q'resolvers';
$or=[];
$pr=q'my $f = shift;
$f =~ s/^fd:(?:\\/\\/)?//;
ni(\'ni:unix/fd\')->new($f);';
$qr=bless({$V1,$or,$E1,$pr,$G1,$H1},$e1);
$rr=q'file';
$sr=[];
$tr=q'my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni(\'ni:unix/file\')->new($f);';
$ur=bless({$V1,$sr,$E1,$tr,$G1,$H1},$e1);
$vr=q'sh';
$wr=[];
$xr=q'ni::fork_exec \'/bin/sh\', \'-c\', substr shift, 3';
$yr=bless({$V1,$wr,$E1,$xr,$G1,$H1},$e1);
$zr=q'str';
$Ar=[];
$Br=q'my $s = shift;
ni(\'ni:unix/str\')->new(substr($s, 4) . "\\n");';
$Cr=bless({$V1,$Ar,$E1,$Br,$G1,$H1},$e1);
$Dr={$tk,$qr,$rr,$ur,$vr,$yr,$zr,$Cr};
$Er=bless({$g9,$mr,$nr,$Dr},$g1);
$Fr=q'lib/ni::ctors';
$$F[0]=$A7;
$$I2[0]=$T2;
$$I2[1]=$j4;
$$i6[4]=$l7;
*$y3=\&$w3;
*$x3=\&$u3;
$S1->apply_unsafe($e1);
$k2->apply_unsafe($e1);
$x2->apply_unsafe($e1);
$G2->apply_unsafe($e1);
$P2->apply_unsafe($T);
$P2->apply_unsafe($h);
$P2->apply_unsafe($U);
$P2->apply_unsafe($l);
$P2->apply_unsafe($V);
$P2->apply_unsafe($m);
$P2->apply_unsafe($W);
$P2->apply_unsafe($n);
$P2->apply_unsafe($d1);
$P2->apply_unsafe($o);
$P2->apply_unsafe($e1);
$P2->apply_unsafe($p);
$P2->apply_unsafe($f1);
$P2->apply_unsafe($q);
$P2->apply_unsafe($g1);
$P2->apply_unsafe($r);
$P2->apply_unsafe($R);
$P2->apply_unsafe($s);
$P2->apply_unsafe($X);
$P2->apply_unsafe($t);
$P2->apply_unsafe($h1);
$P2->apply_unsafe($Q2);
$P2->apply_unsafe($G);
$P2->apply_unsafe($d);
$P2->apply_unsafe($Z);
$P2->apply_unsafe($j);
$P2->apply_unsafe($j1);
$P2->apply_unsafe($v);
$P2->apply_unsafe($k1);
$P2->apply_unsafe($w);
$P2->apply_unsafe($l1);
$P2->apply_unsafe($x);
$P2->apply_unsafe($m1);
$P2->apply_unsafe($y);
$P2->apply_unsafe($n1);
$P2->apply_unsafe($z);
$P2->apply_unsafe($o1);
$P2->apply_unsafe($A);
$P2->apply_unsafe($p1);
$P2->apply_unsafe($B);
$P2->apply_unsafe($q1);
$P2->apply_unsafe($C);
$P2->apply_unsafe($r1);
$P2->apply_unsafe($D);
$d3->apply_unsafe($T);
$d3->apply_unsafe($h);
$d3->apply_unsafe($U);
$d3->apply_unsafe($l);
$d3->apply_unsafe($V);
$d3->apply_unsafe($m);
$d3->apply_unsafe($W);
$d3->apply_unsafe($n);
$d3->apply_unsafe($o);
$d3->apply_unsafe($p);
$d3->apply_unsafe($q);
$d3->apply_unsafe($r);
$d3->apply_unsafe($R);
$d3->apply_unsafe($s);
$d3->apply_unsafe($X);
$d3->apply_unsafe($t);
$d3->apply_unsafe($e3);
$d3->apply_unsafe($G);
$d3->apply_unsafe($d);
$d3->apply_unsafe($Z);
$d3->apply_unsafe($j);
$d3->apply_unsafe($v);
$d3->apply_unsafe($w);
$d3->apply_unsafe($x);
$d3->apply_unsafe($y);
$d3->apply_unsafe($z);
$d3->apply_unsafe($A);
$d3->apply_unsafe($B);
$d3->apply_unsafe($C);
$d3->apply_unsafe($D);
$q3->apply_unsafe($T);
$q3->apply_unsafe($h);
$q3->apply_unsafe($l);
$q3->apply_unsafe($V);
$q3->apply_unsafe($m);
$q3->apply_unsafe($n);
$q3->apply_unsafe($d1);
$q3->apply_unsafe($o);
$q3->apply_unsafe($p);
$q3->apply_unsafe($q);
$q3->apply_unsafe($r);
$q3->apply_unsafe($R);
$q3->apply_unsafe($s);
$q3->apply_unsafe($X);
$q3->apply_unsafe($t);
$q3->apply_unsafe($r3);
$q3->apply_unsafe($G);
$q3->apply_unsafe($d);
$q3->apply_unsafe($Z);
$q3->apply_unsafe($j);
$q3->apply_unsafe($v);
$q3->apply_unsafe($w);
$q3->apply_unsafe($x);
$q3->apply_unsafe($y);
$q3->apply_unsafe($z);
$q3->apply_unsafe($A);
$q3->apply_unsafe($B);
$q3->apply_unsafe($C);
$q3->apply_unsafe($D);
$E3->apply_unsafe($R);
$L3->apply_unsafe($R);
$T3->apply_unsafe($R);
$j4->apply_unsafe($T);
$j4->apply_unsafe($h);
$j4->apply_unsafe($l);
$j4->apply_unsafe($m);
$j4->apply_unsafe($n);
$j4->apply_unsafe($o);
$j4->apply_unsafe($e1);
$j4->apply_unsafe($p);
$j4->apply_unsafe($q);
$j4->apply_unsafe($r);
$j4->apply_unsafe($R);
$j4->apply_unsafe($s);
$j4->apply_unsafe($X);
$j4->apply_unsafe($t);
$j4->apply_unsafe($k4);
$j4->apply_unsafe($G);
$j4->apply_unsafe($d);
$j4->apply_unsafe($j);
$j4->apply_unsafe($v);
$j4->apply_unsafe($w);
$j4->apply_unsafe($x);
$j4->apply_unsafe($y);
$j4->apply_unsafe($z);
$j4->apply_unsafe($A);
$j4->apply_unsafe($B);
$j4->apply_unsafe($C);
$j4->apply_unsafe($D);
$G4->apply_unsafe($X);
$N4->apply_unsafe($X);
$d5->apply_unsafe($T);
$d5->apply_unsafe($h);
$d5->apply_unsafe($l);
$d5->apply_unsafe($V);
$d5->apply_unsafe($m);
$d5->apply_unsafe($n);
$d5->apply_unsafe($o);
$d5->apply_unsafe($p);
$d5->apply_unsafe($q);
$d5->apply_unsafe($r);
$d5->apply_unsafe($s);
$d5->apply_unsafe($t);
$d5->apply_unsafe($e5);
$d5->apply_unsafe($G);
$d5->apply_unsafe($d);
$d5->apply_unsafe($Z);
$d5->apply_unsafe($j);
$d5->apply_unsafe($v);
$d5->apply_unsafe($w);
$d5->apply_unsafe($x);
$d5->apply_unsafe($y);
$d5->apply_unsafe($z);
$d5->apply_unsafe($A);
$d5->apply_unsafe($B);
$d5->apply_unsafe($C);
$d5->apply_unsafe($D);
$m5->apply_unsafe($T);
$m5->apply_unsafe($h);
$m5->apply_unsafe($l);
$m5->apply_unsafe($V);
$m5->apply_unsafe($m);
$m5->apply_unsafe($n);
$m5->apply_unsafe($o);
$m5->apply_unsafe($p);
$m5->apply_unsafe($q);
$m5->apply_unsafe($r);
$m5->apply_unsafe($R);
$m5->apply_unsafe($s);
$m5->apply_unsafe($X);
$m5->apply_unsafe($t);
$m5->apply_unsafe($n5);
$m5->apply_unsafe($G);
$m5->apply_unsafe($d);
$m5->apply_unsafe($Z);
$m5->apply_unsafe($j);
$m5->apply_unsafe($v);
$m5->apply_unsafe($w);
$m5->apply_unsafe($x);
$m5->apply_unsafe($y);
$m5->apply_unsafe($z);
$m5->apply_unsafe($A);
$m5->apply_unsafe($B);
$m5->apply_unsafe($C);
$m5->apply_unsafe($D);
$v5->apply_unsafe($T);
$v5->apply_unsafe($h);
$v5->apply_unsafe($l);
$v5->apply_unsafe($V);
$v5->apply_unsafe($m);
$v5->apply_unsafe($n);
$v5->apply_unsafe($o);
$v5->apply_unsafe($p);
$v5->apply_unsafe($q);
$v5->apply_unsafe($r);
$v5->apply_unsafe($R);
$v5->apply_unsafe($s);
$v5->apply_unsafe($X);
$v5->apply_unsafe($t);
$v5->apply_unsafe($w5);
$v5->apply_unsafe($G);
$v5->apply_unsafe($d);
$v5->apply_unsafe($Z);
$v5->apply_unsafe($j);
$v5->apply_unsafe($v);
$v5->apply_unsafe($w);
$v5->apply_unsafe($x);
$v5->apply_unsafe($y);
$v5->apply_unsafe($z);
$v5->apply_unsafe($A);
$v5->apply_unsafe($B);
$v5->apply_unsafe($C);
$v5->apply_unsafe($D);
$E5->apply_unsafe($T);
$E5->apply_unsafe($h);
$E5->apply_unsafe($l);
$E5->apply_unsafe($V);
$E5->apply_unsafe($m);
$E5->apply_unsafe($n);
$E5->apply_unsafe($o);
$E5->apply_unsafe($p);
$E5->apply_unsafe($q);
$E5->apply_unsafe($r);
$E5->apply_unsafe($s);
$E5->apply_unsafe($X);
$E5->apply_unsafe($t);
$E5->apply_unsafe($F5);
$E5->apply_unsafe($G);
$E5->apply_unsafe($d);
$E5->apply_unsafe($Z);
$E5->apply_unsafe($j);
$E5->apply_unsafe($v);
$E5->apply_unsafe($w);
$E5->apply_unsafe($x);
$E5->apply_unsafe($y);
$E5->apply_unsafe($z);
$E5->apply_unsafe($A);
$E5->apply_unsafe($B);
$E5->apply_unsafe($C);
$E5->apply_unsafe($D);
$R5->apply_unsafe($T);
$R5->apply_unsafe($h);
$R5->apply_unsafe($l);
$R5->apply_unsafe($m);
$R5->apply_unsafe($n);
$R5->apply_unsafe($o);
$R5->apply_unsafe($p);
$R5->apply_unsafe($q);
$R5->apply_unsafe($r);
$R5->apply_unsafe($s);
$R5->apply_unsafe($t);
$R5->apply_unsafe($S5);
$R5->apply_unsafe($G);
$R5->apply_unsafe($d);
$R5->apply_unsafe($Z);
$R5->apply_unsafe($j);
$R5->apply_unsafe($v);
$R5->apply_unsafe($w);
$R5->apply_unsafe($x);
$R5->apply_unsafe($y);
$R5->apply_unsafe($z);
$R5->apply_unsafe($A);
$R5->apply_unsafe($B);
$R5->apply_unsafe($C);
$R5->apply_unsafe($D);
$g6->apply_unsafe($V);
$u6->apply_unsafe($T);
$u6->apply_unsafe($h);
$u6->apply_unsafe($l);
$u6->apply_unsafe($V);
$u6->apply_unsafe($m);
$u6->apply_unsafe($n);
$u6->apply_unsafe($o);
$u6->apply_unsafe($p);
$u6->apply_unsafe($q);
$u6->apply_unsafe($r);
$u6->apply_unsafe($s);
$u6->apply_unsafe($t);
$u6->apply_unsafe($v6);
$u6->apply_unsafe($G);
$u6->apply_unsafe($d);
$u6->apply_unsafe($Z);
$u6->apply_unsafe($j);
$u6->apply_unsafe($v);
$u6->apply_unsafe($w);
$u6->apply_unsafe($x);
$u6->apply_unsafe($y);
$u6->apply_unsafe($z);
$u6->apply_unsafe($A);
$u6->apply_unsafe($B);
$u6->apply_unsafe($C);
$u6->apply_unsafe($D);
$G6->apply_unsafe($T);
$G6->apply_unsafe($h);
$G6->apply_unsafe($l);
$G6->apply_unsafe($V);
$G6->apply_unsafe($m);
$G6->apply_unsafe($n);
$G6->apply_unsafe($o);
$G6->apply_unsafe($p);
$G6->apply_unsafe($q);
$G6->apply_unsafe($r);
$G6->apply_unsafe($s);
$G6->apply_unsafe($t);
$G6->apply_unsafe($H6);
$G6->apply_unsafe($G);
$G6->apply_unsafe($d);
$G6->apply_unsafe($Z);
$G6->apply_unsafe($j);
$G6->apply_unsafe($v);
$G6->apply_unsafe($w);
$G6->apply_unsafe($x);
$G6->apply_unsafe($y);
$G6->apply_unsafe($z);
$G6->apply_unsafe($A);
$G6->apply_unsafe($B);
$G6->apply_unsafe($C);
$G6->apply_unsafe($D);
$O6->apply_unsafe($T);
$O6->apply_unsafe($h);
$O6->apply_unsafe($l);
$O6->apply_unsafe($V);
$O6->apply_unsafe($m);
$O6->apply_unsafe($n);
$O6->apply_unsafe($o);
$O6->apply_unsafe($p);
$O6->apply_unsafe($q);
$O6->apply_unsafe($r);
$O6->apply_unsafe($s);
$O6->apply_unsafe($t);
$O6->apply_unsafe($P6);
$O6->apply_unsafe($G);
$O6->apply_unsafe($d);
$O6->apply_unsafe($Z);
$O6->apply_unsafe($j);
$O6->apply_unsafe($v);
$O6->apply_unsafe($w);
$O6->apply_unsafe($x);
$O6->apply_unsafe($y);
$O6->apply_unsafe($z);
$O6->apply_unsafe($A);
$O6->apply_unsafe($B);
$O6->apply_unsafe($C);
$O6->apply_unsafe($D);
$W6->apply_unsafe($T);
$W6->apply_unsafe($h);
$W6->apply_unsafe($l);
$W6->apply_unsafe($V);
$W6->apply_unsafe($m);
$W6->apply_unsafe($n);
$W6->apply_unsafe($o);
$W6->apply_unsafe($p);
$W6->apply_unsafe($q);
$W6->apply_unsafe($r);
$W6->apply_unsafe($s);
$W6->apply_unsafe($t);
$W6->apply_unsafe($X6);
$W6->apply_unsafe($G);
$W6->apply_unsafe($d);
$W6->apply_unsafe($Z);
$W6->apply_unsafe($j);
$W6->apply_unsafe($v);
$W6->apply_unsafe($w);
$W6->apply_unsafe($x);
$W6->apply_unsafe($y);
$W6->apply_unsafe($z);
$W6->apply_unsafe($A);
$W6->apply_unsafe($B);
$W6->apply_unsafe($C);
$W6->apply_unsafe($D);
$h7->apply_unsafe($T);
$h7->apply_unsafe($h);
$h7->apply_unsafe($l);
$h7->apply_unsafe($V);
$h7->apply_unsafe($m);
$h7->apply_unsafe($n);
$h7->apply_unsafe($o);
$h7->apply_unsafe($p);
$h7->apply_unsafe($q);
$h7->apply_unsafe($r);
$h7->apply_unsafe($s);
$h7->apply_unsafe($t);
$h7->apply_unsafe($i7);
$h7->apply_unsafe($G);
$h7->apply_unsafe($d);
$h7->apply_unsafe($Z);
$h7->apply_unsafe($j);
$h7->apply_unsafe($v);
$h7->apply_unsafe($w);
$h7->apply_unsafe($x);
$h7->apply_unsafe($y);
$h7->apply_unsafe($z);
$h7->apply_unsafe($A);
$h7->apply_unsafe($B);
$h7->apply_unsafe($C);
$h7->apply_unsafe($D);
$w7->apply_unsafe($T);
$w7->apply_unsafe($h);
$w7->apply_unsafe($l);
$w7->apply_unsafe($m);
$w7->apply_unsafe($n);
$w7->apply_unsafe($o);
$w7->apply_unsafe($p);
$w7->apply_unsafe($q);
$w7->apply_unsafe($r);
$w7->apply_unsafe($s);
$w7->apply_unsafe($t);
$w7->apply_unsafe($x7);
$w7->apply_unsafe($d);
$w7->apply_unsafe($j);
$w7->apply_unsafe($v);
$w7->apply_unsafe($w);
$w7->apply_unsafe($x);
$w7->apply_unsafe($y);
$w7->apply_unsafe($z);
$w7->apply_unsafe($A);
$w7->apply_unsafe($B);
$w7->apply_unsafe($C);
$w7->apply_unsafe($D);
$Z7->apply_unsafe($g1);
$o8->apply_unsafe($g1);
$N8->apply_unsafe($g1);
$Z8->apply_unsafe($g1);
$s9->apply_unsafe($d1);
$z9->apply_unsafe($d1);
$H9->apply_unsafe($d1);
$S9->apply_unsafe($d1);
$Cb->apply_unsafe($W);
$Jb->apply_unsafe($W);
$sc->apply_unsafe($tc);
$Hc->apply_unsafe($f1);
$ke->apply_unsafe($f1);
$Se->apply_unsafe($Te);
$qf->apply_unsafe($Te);
$Af->apply_unsafe($Te);
$Ig->apply_unsafe($Te);
$gh->apply_unsafe($tc);
$Bh->apply_unsafe($h1);
$Oh->apply_unsafe($h1);
$Wh->apply_unsafe($h1);
$mj->apply_unsafe($k1);
$mj->apply_unsafe($l1);
$mj->apply_unsafe($m1);
$mj->apply_unsafe($n1);
$mj->apply_unsafe($o1);
$mj->apply_unsafe($p1);
$mj->apply_unsafe($q1);
$mj->apply_unsafe($r1);
$vj->apply_unsafe($k1);
$vj->apply_unsafe($l1);
$vj->apply_unsafe($m1);
$vj->apply_unsafe($n1);
$vj->apply_unsafe($o1);
$vj->apply_unsafe($p1);
$vj->apply_unsafe($q1);
$vj->apply_unsafe($r1);
$Ij->apply_unsafe($k1);
$Ij->apply_unsafe($l1);
$Ij->apply_unsafe($m1);
$Ij->apply_unsafe($n1);
$Ij->apply_unsafe($o1);
$Ij->apply_unsafe($p1);
$Ij->apply_unsafe($q1);
$Ij->apply_unsafe($r1);
$Tj->apply_unsafe($k1);
$ek->apply_unsafe($k1);
$zk->apply_unsafe($l1);
$Hk->apply_unsafe($l1);
$Qk->apply_unsafe($l1);
$ll->apply_unsafe($l1);
$ll->apply_unsafe($m1);
$ll->apply_unsafe($n1);
$ll->apply_unsafe($p1);
$ll->apply_unsafe($q1);
$wl->apply_unsafe($l1);
$wl->apply_unsafe($m1);
$wl->apply_unsafe($n1);
$wl->apply_unsafe($p1);
$wl->apply_unsafe($q1);
$Ml->apply_unsafe($l1);
$pm->apply_unsafe($m1);
$xm->apply_unsafe($m1);
$Km->apply_unsafe($m1);
$hn->apply_unsafe($n1);
$pn->apply_unsafe($n1);
$An->apply_unsafe($n1);
$qo->apply_unsafe($p1);
$Bo->apply_unsafe($p1);
$Ko->apply_unsafe($p1);
$Vo->apply_unsafe($p1);
$wp->apply_unsafe($q1);
$Ep->apply_unsafe($q1);
$Np->apply_unsafe($q1);
$Yp->apply_unsafe($q1);
$Eq->apply_unsafe($r1);
$Mq->apply_unsafe($r1);
$dr->apply_unsafe($r1);
$ni::self=$Er;
&$_($H)for@$I;
&$_($M)for@$N;
&$_($P)for@$Q;
&$_($A1)for@$B1;
&$_($I1)for@$J1;
&$_($M1)for@$J1;
&$_($P1)for@$J1;
&$_($S1)for@$T1;
&$_($Y1)for@$J1;
&$_($d2)for@$J1;
&$_($h2)for@$J1;
&$_($k2)for@$l2;
&$_($q2)for@$J1;
&$_($u2)for@$J1;
&$_($x2)for@$y2;
&$_($D2)for@$J1;
&$_($G2)for@$H2;
&$_($J2)for@$K2;
&$_($M2)for@$J1;
&$_($P2)for@$R2;
&$_($T2)for@$U2;
&$_($Y2)for@$J1;
&$_($d3)for@$f3;
&$_($h3)for@$i3;
&$_($l3)for@$J1;
&$_($n3)for@$J1;
&$_($q3)for@$s3;
&$_($u3)for@$J1;
&$_($w3)for@$J1;
&$_($E3)for@$F3;
&$_($I3)for@$J1;
&$_($L3)for@$M3;
&$_($Q3)for@$J1;
&$_($T3)for@$U3;
&$_($W3)for@$X3;
&$_($d4)for@$J1;
&$_($g4)for@$J1;
&$_($j4)for@$l4;
&$_($n4)for@$o4;
&$_($q4)for@$r4;
&$_($y4)for@$z4;
&$_($D4)for@$J1;
&$_($G4)for@$H4;
&$_($K4)for@$J1;
&$_($N4)for@$O4;
&$_($Q4)for@$R4;
&$_($W4)for@$J1;
&$_($Y4)for@$J1;
&$_($d5)for@$f5;
&$_($j5)for@$J1;
&$_($m5)for@$o5;
&$_($s5)for@$J1;
&$_($v5)for@$x5;
&$_($B5)for@$J1;
&$_($E5)for@$G5;
&$_($I5)for@$J5;
&$_($M5)for@$J1;
&$_($O5)for@$J1;
&$_($R5)for@$T5;
&$_($W5)for@$X5;
&$_($d6)for@$J1;
&$_($g6)for@$h6;
&$_($j6)for@$k6;
&$_($r6)for@$J1;
&$_($u6)for@$w6;
&$_($A6)for@$J1;
&$_($D6)for@$J1;
&$_($G6)for@$I6;
&$_($L6)for@$J1;
&$_($O6)for@$Q6;
&$_($T6)for@$J1;
&$_($W6)for@$Y6;
&$_($e7)for@$J1;
&$_($h7)for@$j7;
&$_($l7)for@$m7;
&$_($o7)for@$p7;
&$_($t7)for@$J1;
&$_($w7)for@$y7;
&$_($A7)for@$B7;
&$_($D7)for@$E7;
&$_($H7)for@$I7;
&$_($L7)for@$M7;
&$_($S7)for@$J1;
&$_($W7)for@$J1;
&$_($Z7)for@$c8;
&$_($h8)for@$J1;
&$_($l8)for@$J1;
&$_($o8)for@$p8;
&$_($u8)for@$J1;
&$_($y8)for@$J1;
&$_($C8)for@$J1;
&$_($G8)for@$J1;
&$_($K8)for@$J1;
&$_($N8)for@$O8;
&$_($S8)for@$J1;
&$_($W8)for@$J1;
&$_($Z8)for@$c9;
&$_($e9)for@$f9;
&$_($k9)for@$l9;
&$_($p9)for@$J1;
&$_($s9)for@$t9;
&$_($w9)for@$J1;
&$_($z9)for@$A9;
&$_($E9)for@$J1;
&$_($H9)for@$I9;
&$_($M9)for@$J1;
&$_($P9)for@$J1;
&$_($S9)for@$T9;
&$_($V9)for@$W9;
&$_($ja)for@$J1;
&$_($qa)for@$ra;
&$_($za)for@$J1;
&$_($Da)for@$J1;
&$_($Ga)for@$ra;
&$_($Oa)for@$J1;
&$_($Ra)for@$ra;
&$_($Xa)for@$J1;
&$_($db)for@$J1;
&$_($gb)for@$ra;
&$_($ub)for@$vb;
&$_($zb)for@$J1;
&$_($Cb)for@$Db;
&$_($Gb)for@$J1;
&$_($Jb)for@$Kb;
&$_($Mb)for@$Nb;
&$_($pc)for@$J1;
&$_($sc)for@$uc;
&$_($yc)for@$zc;
&$_($Ec)for@$J1;
&$_($Hc)for@$Ic;
&$_($Nc)for@$J1;
&$_($Rc)for@$J1;
&$_($Vc)for@$J1;
&$_($Zc)for@$J1;
&$_($fd)for@$J1;
&$_($jd)for@$J1;
&$_($nd)for@$J1;
&$_($rd)for@$J1;
&$_($vd)for@$J1;
&$_($zd)for@$J1;
&$_($Dd)for@$J1;
&$_($Hd)for@$J1;
&$_($Ld)for@$J1;
&$_($Pd)for@$J1;
&$_($Td)for@$J1;
&$_($Xd)for@$J1;
&$_($de)for@$J1;
&$_($he)for@$J1;
&$_($ke)for@$le;
&$_($ne)for@$oe;
&$_($ze)for@$J1;
&$_($De)for@$J1;
&$_($He)for@$J1;
&$_($Le)for@$J1;
&$_($Pe)for@$J1;
&$_($Se)for@$Ue;
&$_($jf)for@$J1;
&$_($nf)for@$J1;
&$_($qf)for@$rf;
&$_($xf)for@$J1;
&$_($Af)for@$Bf;
&$_($Lf)for@$J1;
&$_($Pf)for@$J1;
&$_($Tf)for@$J1;
&$_($Xf)for@$J1;
&$_($dg)for@$J1;
&$_($hg)for@$J1;
&$_($lg)for@$J1;
&$_($pg)for@$J1;
&$_($tg)for@$J1;
&$_($xg)for@$J1;
&$_($Bg)for@$J1;
&$_($Fg)for@$J1;
&$_($Ig)for@$Jg;
&$_($Wg)for@$J1;
&$_($dh)for@$J1;
&$_($gh)for@$hh;
&$_($sh)for@$th;
&$_($yh)for@$J1;
&$_($Bh)for@$Ch;
&$_($Hh)for@$J1;
&$_($Lh)for@$J1;
&$_($Oh)for@$Ph;
&$_($Th)for@$J1;
&$_($Wh)for@$Xh;
&$_($ci)for@$di;
&$_($li)for@$mi;
&$_($Mi)for@$Ni;
&$_($Pi)for@$mi;
&$_($Wi)for@$Xi;
&$_($Zi)for@$cj;
&$_($jj)for@$J1;
&$_($mj)for@$nj;
&$_($sj)for@$J1;
&$_($vj)for@$wj;
&$_($Bj)for@$J1;
&$_($Fj)for@$J1;
&$_($Ij)for@$Jj;
&$_($Lj)for@$Mj;
&$_($Qj)for@$J1;
&$_($Tj)for@$Uj;
&$_($Zj)for@$J1;
&$_($ek)for@$fk;
&$_($hk)for@$ik;
&$_($pk)for@$qk;
&$_($wk)for@$J1;
&$_($zk)for@$Ak;
&$_($Ek)for@$J1;
&$_($Hk)for@$Ik;
&$_($Nk)for@$J1;
&$_($Qk)for@$Rk;
&$_($Yk)for@$J1;
&$_($el)for@$J1;
&$_($il)for@$J1;
&$_($ll)for@$ml;
&$_($ql)for@$J1;
&$_($tl)for@$J1;
&$_($wl)for@$xl;
&$_($zl)for@$Al;
&$_($Fl)for@$J1;
&$_($Jl)for@$J1;
&$_($Ml)for@$Nl;
&$_($Pl)for@$Ql;
&$_($dm)for@$em;
&$_($jm)for@$J1;
&$_($mm)for@$J1;
&$_($pm)for@$qm;
&$_($um)for@$J1;
&$_($xm)for@$ym;
&$_($Dm)for@$J1;
&$_($Hm)for@$J1;
&$_($Km)for@$Lm;
&$_($Nm)for@$Om;
&$_($Wm)for@$Xm;
&$_($en)for@$J1;
&$_($hn)for@$in;
&$_($mn)for@$J1;
&$_($pn)for@$qn;
&$_($un)for@$J1;
&$_($xn)for@$J1;
&$_($An)for@$Bn;
&$_($Dn)for@$En;
&$_($Sn)for@$Tn;
&$_($Zn)for@$J1;
&$_($fo)for@$J1;
&$_($jo)for@$J1;
&$_($no)for@$J1;
&$_($qo)for@$ro;
&$_($vo)for@$J1;
&$_($yo)for@$J1;
&$_($Bo)for@$Co;
&$_($Ho)for@$J1;
&$_($Ko)for@$Lo;
&$_($Po)for@$J1;
&$_($So)for@$J1;
&$_($Vo)for@$Wo;
&$_($Yo)for@$Zo;
&$_($kp)for@$lp;
&$_($qp)for@$J1;
&$_($tp)for@$J1;
&$_($wp)for@$xp;
&$_($Bp)for@$J1;
&$_($Ep)for@$Fp;
&$_($Kp)for@$J1;
&$_($Np)for@$Op;
&$_($Sp)for@$J1;
&$_($Vp)for@$J1;
&$_($Yp)for@$Zp;
&$_($dq)for@$eq;
&$_($nq)for@$oq;
&$_($tq)for@$J1;
&$_($xq)for@$J1;
&$_($Bq)for@$J1;
&$_($Eq)for@$Fq;
&$_($Jq)for@$J1;
&$_($Mq)for@$Nq;
&$_($Rq)for@$J1;
&$_($Vq)for@$J1;
&$_($Yq)for@$J1;
&$_($dr)for@$er;
&$_($gr)for@$hr;
&$_($qr)for@$J1;
&$_($ur)for@$J1;
&$_($yr)for@$J1;
&$_($Cr)for@$J1;
&$_($Er)for@$Fr;
ni->run(@ARGV);
__DATA__
