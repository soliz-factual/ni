#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use POSIX;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/io#;
$P=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$Q=[$i,$P];
$R=[$Q];
$S=q#/io#;
$T=bless({$e,$R,$D,$S},$F);
$U=q#ni.doc:/io/cat#;
$V=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  #;
$W=[$f,$V];
$X=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$Y=[$i,$X];
$Z=[];
$c1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$d1=bless({$o,$Z,$q,$c1,$s,$t},$u);
$e1=[$n,$d1];
$f1=[$W,$Y,$e1];
$g1=q#/io/cat#;
$h1=bless({$e,$f1,$D,$g1},$F);
$i1=q#ni.doc:/io/pid#;
$j1=[];
$k1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$l1=bless({$o,$j1,$q,$k1,$s,$t},$u);
$m1=[$n,$l1];
$n1=[];
$o1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$p1=bless({$o,$n1,$q,$o1,$s,$t},$u);
$q1=[$n,$p1];
$r1=[];
$s1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->fds(0 => $seq->stdout)
  ->fork;
now $grep->read_all == "1\\n3\\n5\\n7\\n9\\n";
now $seq->await == 0;
now $grep->await == 0;#;
$t1=bless({$o,$r1,$q,$s1,$s,$t},$u);
$u1=[$n,$t1];
$v1=[$m1,$q1,$u1];
$w1=q#/io/pid#;
$x1=bless({$e,$v1,$D,$w1},$F);
$y1=q#ni.doc:/lib/doc#;
$z1=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$A1=[$f,$z1];
$B1=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$C1=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$D1=[];
$E1=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$F1=bless({$o,$D1,$q,$E1,$s,$t},$u);
$G1=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$H1=[];
$I1=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$J1=bless({$o,$H1,$q,$I1,$s,$t},$u);
$K1=[$i,$B1,$C1,$n,$F1,$G1,$n,$J1];
$L1=[$A1,$K1];
$M1=q#/lib/doc#;
$N1=bless({$e,$L1,$D,$M1},$F);
$O1=q#ni:/class#;
$P1=q#applied_to#;
$Q1=q#class#;
$R1=q#class.c#;
$S1=q#io/cat.c#;
$T1=q#io/fd.c#;
$U1=q#io/file.c#;
$V1=q#io/object.c#;
$W1=q#io/pid.c#;
$X1=q#io/str.c#;
$Y1=q#lib/behavior.c#;
$Z1=q#lib/branch.c#;
$c2=q#lib/dataslice.c#;
$d2=q#lib/doc.c#;
$e2=q#lib/fn.c#;
$f2=q#lib/image.c#;
$g2=q#lib/ni.c#;
$h2=q#lib/slice.c#;
$i2=q#lib/tag.c#;
$j2=q#lib/test_value.c#;
$k2=q#metaclass.c#;
$l2=q#module.c#;
$m2=q#object.c#;
$n2={$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1,$Z1,1,$c2,1,$d2,1,$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1};
$o2=q#slices#;
$p2=q#lib/test_value.c#;
$q2=q#metaclass#;
$r2=q#module#;
$s2={$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1,$Z1,1,$c2,1,$d2,1,$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$p2,1,$q2,1,$k2,1,$r2,1,$l2,1,$m2,1};
$t2=q#/module#;
$u2=q#/lib/perlbranch.b#;
$v2={};
$w2=q#ctor#;
$x2=undef;
$y2=q#dtor#;
$z2=q#methods#;
$A2=q#add#;
$B2=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$C2=bless({$q,$B2,$s,$t},$u);
$D2=q#apply#;
$E2=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$F2=bless({$q,$E2,$s,$t},$u);
$G2={$A2,$C2,$D2,$F2};
$H2=q#/lib/branch.b#;
$I2=q#lib/slice#;
$J2=bless({$P1,$v2,$w2,$x2,$y2,$x2,$z2,$G2,$D,$H2},$I2);
$K2=q#lib/branch#;
$L2=q#lib/test_value.c#;
$M2=q#lib/slice::ctors#;
$N2={};
$O2=q#my $s = shift; ni->def($s->name, $s)#;
$P2=bless({$q,$O2,$s,$t},$u);
$Q2=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$R2=bless({$q,$Q2,$s,$t},$u);
$S2={$D,$R2};
$T2=q#/lib/named.b#;
$U2=bless({$P1,$N2,$w2,$P2,$y2,$x2,$z2,$S2,$D,$T2},$I2);
$V2=q#lib/tag#;
$W2=q#lib/test_value.c#;
$X2=q#lib/slice::ctors#;
$Y2={};
$Z2=q#namespace#;
$c3=q#'ni'#;
$d3=bless({$q,$c3,$s,$t},$u);
$e3={$Z2,$d3};
$f3=q#/lib/named_in_ni.b#;
$g3=bless({$P1,$Y2,$w2,$x2,$y2,$x2,$z2,$e3,$D,$f3},$I2);
$h3=q#lib/test_value.c#;
$i3=q#lib/slice::ctors#;
$j3={};
$k3=q#package#;
$l3=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$m3=bless({$q,$l3,$s,$t},$u);
$n3={$k3,$m3};
$o3=q#/lib/namespaced.b#;
$p3=bless({$P1,$j3,$w2,$x2,$y2,$x2,$z2,$n3,$D,$o3},$I2);
$q3=q#lib/test_value.c#;
$r3=q#lib/slice::ctors#;
$s3={};
$t3=q#resolve#;
$u3=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$v3=bless({$q,$u3,$s,$t},$u);
$w3={$t3,$v3};
$x3=q#/lib/resolver.b#;
$y3=bless({$P1,$s3,$w2,$x2,$y2,$x2,$z2,$w3,$D,$x3},$I2);
$z3=q#lib/test_value.c#;
$A3=q#lib/slice::ctors#;
$B3=[$J2,$U2,$g3,$p3,$y3];
$C3=bless({$D,$u2,$o2,$B3},$V2);
$D3=q#lib/tag::ctors#;
$E3={};
$F3=q#my $s = shift; $s->apply($s->package)#;
$G3=bless({$q,$F3,$s,$t},$u);
$H3=q#instantiate#;
$I3=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$J3=bless({$q,$I3,$s,$t},$u);
$K3={$H3,$J3};
$L3=q#/lib/class_init.b#;
$M3=bless({$P1,$E3,$w2,$G3,$y2,$x2,$z2,$K3,$D,$L3},$I2);
$N3=q#lib/test_value.c#;
$O3=q#lib/slice::ctors#;
$P3=q#io/cat#;
$Q3=q#io/fd#;
$R3=q#io/file#;
$S3=q#io/object#;
$T3=q#io/pid#;
$U3=q#io/str#;
$V3=q#lib/behavior#;
$W3=q#lib/dataslice#;
$X3=q#lib/image#;
$Y3=q#lib/ni#;
$Z3=q#lib/test_value#;
$c4=q#lib/test_value.c#;
$d4=q#object#;
$e4={$Q1,1,$R1,1,$P3,1,$S1,1,$Q3,1,$T1,1,$R3,1,$U1,1,$S3,1,$V1,1,$T3,1,$W1,1,$U3,1,$X1,1,$V3,1,$Y1,1,$K2,1,$Z1,1,$W3,1,$c2,1,$F,1,$d2,1,$u,1,$e2,1,$X3,1,$f2,1,$Y3,1,$g2,1,$I2,1,$h2,1,$V2,1,$i2,1,$Z3,1,$c4,1,$q2,1,$k2,1,$r2,1,$l2,1,$d4,1,$m2,1};
$f4=q#/object#;
$g4={};
$h4=q#ni 'ni:/' . ref shift#;
$i4=bless({$q,$h4,$s,$t},$u);
$j4={$Q1,$i4};
$k4=q#/lib/instance.b#;
$l4=bless({$P1,$g4,$w2,$x2,$y2,$x2,$z2,$j4,$D,$k4},$I2);
$m4=q#lib/test_value.c#;
$n4=q#lib/slice::ctors#;
$o4=[$l4];
$p4=bless({$P1,$e4,$D,$f4,$o2,$o4},$m2);
$q4=q#object.c::ctors#;
$r4=q#lib/test_value.c#;
$s4={$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$V3,1,$Y1,1,$K2,1,$Z1,1,$W3,1,$c2,1,$d2,1,$e2,1,$f2,1,$g2,1,$I2,1,$h2,1,$V2,1,$i2,1,$r4,1,$q2,1,$k2,1,$r2,1,$l2,1,$m2,1};
$t4=q#/lib/behavior#;
$u4={};
$v4=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$w4=bless({$q,$v4,$s,$t},$u);
$x4={$e,$w4};
$y4=q#/lib/documentable.b#;
$z4=bless({$P1,$u4,$w2,$x2,$y2,$x2,$z2,$x4,$D,$y4},$I2);
$A4=q#lib/test_value.c#;
$B4=q#lib/slice::ctors#;
$C4=[$p4,$z4];
$D4=bless({$P1,$s4,$D,$t4,$o2,$C4},$Y1);
$E4=q#lib/behavior.c::ctors#;
$F4=q#lib/test_value.c#;
$G4={$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1,$K2,1,$Z1,1,$c2,1,$d2,1,$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$F4,1,$q2,1,$k2,1,$r2,1,$l2,1,$m2,1};
$H4=q#/lib/definition.b#;
$I4={};
$J4=q#def#;
$K4=q#shift->add(ni('ni:/lib/slice')->new(@_))#;
$L4=bless({$q,$K4,$s,$t},$u);
$M4={$J4,$L4};
$N4=q#/lib/definition_def.b#;
$O4=bless({$P1,$I4,$w2,$x2,$y2,$x2,$z2,$M4,$D,$N4},$I2);
$P4=q#lib/test_value.c#;
$Q4=q#lib/slice::ctors#;
$R4={};
$S4=q#ro#;
$T4=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$U4=bless({$q,$T4,$s,$t},$u);
$V4=q#rw#;
$W4=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$X4=bless({$q,$W4,$s,$t},$u);
$Y4={$S4,$U4,$V4,$X4};
$Z4=q#/lib/accessor.b#;
$c5=bless({$P1,$R4,$w2,$x2,$y2,$x2,$z2,$Y4,$D,$Z4},$I2);
$d5=q#lib/test_value.c#;
$e5=q#lib/slice::ctors#;
$f5={};
$g5=q#(""#;
$h5=q#shift->name#;
$i5=bless({$q,$h5,$s,$t},$u);
$j5={$g5,$i5};
$k5=q#/lib/name_as_string.b#;
$l5=bless({$P1,$f5,$w2,$x2,$y2,$x2,$z2,$j5,$D,$k5},$I2);
$m5=q#lib/test_value.c#;
$n5=q#lib/slice::ctors#;
$o5={};
$p5=q#(eq#;
$q5=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$r5=bless({$q,$q5,$s,$t},$u);
$s5={$p5,$r5};
$t5=q#/lib/ref_eq.b#;
$u5=bless({$P1,$o5,$w2,$x2,$y2,$x2,$z2,$s5,$D,$t5},$I2);
$v5=q#lib/test_value.c#;
$w5=q#lib/slice::ctors#;
$x5={};
$y5=q#defdata#;
$z5=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$A5=bless({$q,$z5,$s,$t},$u);
$B5={$y5,$A5};
$C5=q#/lib/definition_defdata.b#;
$D5=bless({$P1,$x5,$w2,$x2,$y2,$x2,$z2,$B5,$D,$C5},$I2);
$E5=q#lib/test_value.c#;
$F5=q#lib/slice::ctors#;
$G5=[$O4,$c5,$l5,$u5,$D5];
$H5=bless({$P1,$G4,$D,$H4,$o2,$G5},$K2);
$I5=q#lib/branch::ctors#;
$J5=[$C3,$M3,$p4,$D4,$H5];
$K5=bless({$P1,$s2,$D,$t2,$o2,$J5},$l2);
$L5=q#module.c::ctors#;
$M5={};
$N5=q#DESTROY#;
$O5=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$P5=bless({$q,$O5,$s,$t},$u);
$Q5=q#new#;
$R5=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$S5=bless({$q,$R5,$s,$t},$u);
$T5={$N5,$P5,$Q5,$S5};
$U5=q#/lib/instantiable.b#;
$V5=bless({$P1,$M5,$z2,$T5,$D,$U5},$I2);
$W5=q#lib/test_value.c#;
$X5=q#lib/slice::ctors#;
$Y5={};
$Z5=q#child#;
$c6=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$d6=bless({$q,$c6,$s,$t},$u);
$e6={$Z5,$d6};
$f6=q#/lib/subclass.b#;
$g6=bless({$P1,$Y5,$w2,$x2,$y2,$x2,$z2,$e6,$D,$f6},$I2);
$h6=q#lib/test_value.c#;
$i6=q#lib/slice::ctors#;
$j6=[$K5,$V5,$M3,$K5,$g6];
$k6=bless({$P1,$n2,$D,$E,$o2,$j6},$R1);
$l6=q#class.c::ctors#;
$m6=q#ni:/class.c#;
$n6={$R1,1};
$o6=q#/class.c#;
$p6={$R1,1,$l2,1};
$q6=q#/module.c#;
$r6=q#lib/test_value.c#;
$s6={$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1,$Z1,1,$c2,1,$d2,1,$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$r6,1,$l2,1,$m2,1};
$t6=q#/object.c#;
$u6=[$k6];
$v6=bless({$P1,$s6,$D,$t6,$o2,$u6},$q2);
$w6=q#metaclass::ctors#;
$x6={$R1,1,$Y1,1,$Z1,1,$c2,1,$h2,1,$i2,1,$l2,1};
$y6=q#/lib/behavior.c#;
$z6=[$v6];
$A6=bless({$P1,$x6,$D,$y6,$o2,$z6},$q2);
$B6=q#metaclass::ctors#;
$C6=[$v6,$V5,$A6];
$D6=bless({$P1,$p6,$D,$q6,$o2,$C6},$q2);
$E6=q#metaclass::ctors#;
$F6=[$D6];
$G6=bless({$P1,$n6,$D,$o6,$o2,$F6},$q2);
$H6=q#metaclass::ctors#;
$I6=q#ni:/io/cat#;
$J6={$P3,1};
$K6={$P3,1,$Q3,1,$R3,1,$S3,1,$T3,1,$U3,1};
$L6=q#/io/object#;
$M6={};
$N6=q#(bool#;
$O6=[];
$P6=bless({$o,$O6,$q,1,$s,$t},$u);
$Q6={$N6,$P6};
$R6=q#/io/object_ops.b#;
$S6=bless({$P1,$M6,$w2,$x2,$y2,$x2,$z2,$Q6,$D,$R6},$I2);
$T6=q#lib/slice::ctors#;
$U6={};
$V6=q#into#;
$W6=[];
$X6=q#local $_;
my ($self, $dest, $each) = @_;
my $block_size = $self->can('read_size') ? $self->read_size : 32768;
while ($self->read($_, $block_size)) {
  $dest->write($_);
  &$each($_) && return if defined $each;
}#;
$Y6=bless({$o,$W6,$q,$X6,$s,$t},$u);
$Z6={$V6,$Y6};
$c7=q#/io/object_stream.b#;
$d7=bless({$P1,$U6,$w2,$x2,$y2,$x2,$z2,$Z6,$D,$c7},$I2);
$e7=q#lib/slice::ctors#;
$f7={};
$g7=q#io_check#;
$h7=[];
$i7=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($!) unless &$check($r);
$r;#;
$j7=bless({$o,$h7,$q,$i7,$s,$t},$u);
$k7=q#io_check_defined#;
$l7=[];
$m7=q#shift->io_check(\\&defined, @_)#;
$n7=bless({$o,$l7,$q,$m7,$s,$t},$u);
$o7=q#io_check_true#;
$p7=[];
$q7=q#shift->io_check(sub {shift}, @_)#;
$r7=bless({$o,$p7,$q,$q7,$s,$t},$u);
$s7={$g7,$j7,$k7,$n7,$o7,$r7};
$t7=q#/io/object_checks.b#;
$u7=bless({$P1,$f7,$w2,$x2,$y2,$x2,$z2,$s7,$D,$t7},$I2);
$v7=q#lib/slice::ctors#;
$w7={};
$x7=q#(+#;
$y7=[];
$z7=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$A7=bless({$o,$y7,$q,$z7,$s,$t},$u);
$B7={$x7,$A7};
$C7=q#/io/object_constructors.b#;
$D7=bless({$P1,$w7,$w2,$x2,$y2,$x2,$z2,$B7,$D,$C7},$I2);
$E7=q#lib/slice::ctors#;
$F7={};
$G7=q#read_all#;
$H7=[];
$I7=q#shift->into(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$J7=bless({$o,$H7,$q,$I7,$s,$t},$u);
$K7={$G7,$J7};
$L7=q#/io/object_memory.b#;
$M7=bless({$P1,$F7,$w2,$x2,$y2,$x2,$z2,$K7,$D,$L7},$I2);
$N7=q#lib/slice::ctors#;
$O7=[$p4,$S6,$d7,$u7,$D7,$M7];
$P7=bless({$P1,$K6,$D,$L6,$o2,$O7},$V1);
$Q7=q#io/object.c::ctors#;
$R7={};
$S7=[];
$T7=q#shift; +{fs => [@_]}#;
$U7=bless({$o,$S7,$q,$T7,$s,$t},$u);
$V7={$H3,$U7};
$W7=q#/io/cat_init.b#;
$X7=bless({$P1,$R7,$w2,$x2,$y2,$x2,$z2,$V7,$D,$W7},$I2);
$Y7=q#lib/slice::ctors#;
$Z7={};
$c8=q#read#;
$d8=[];
$e8=q#my $fs = shift->{fs};
my $n;
until (!@$fs or $n = $$fs[0]->read(@_)) {
  return $n unless defined $n;
  shift @$fs;
}
return $n;#;
$f8=bless({$o,$d8,$q,$e8,$s,$t},$u);
$g8={$c8,$f8};
$h8=q#/io/cat_read.b#;
$i8=bless({$P1,$Z7,$w2,$x2,$y2,$x2,$z2,$g8,$D,$h8},$I2);
$j8=q#lib/slice::ctors#;
$k8=[$P7,$X7,$i8];
$l8=bless({$P1,$J6,$D,$g1,$o2,$k8},$S1);
$m8=q#io/cat.c::ctors#;
$n8=q#ni:/io/cat.c#;
$o8={$S1,1};
$p8=q#/io/cat.c#;
$q8={$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1};
$r8=q#/io/object.c#;
$s8=[$v6];
$t8=bless({$P1,$q8,$D,$r8,$o2,$s8},$q2);
$u8=q#metaclass::ctors#;
$v8=[$t8];
$w8=bless({$P1,$o8,$D,$p8,$o2,$v8},$q2);
$x8=q#metaclass::ctors#;
$y8=q#ni:/io/cat_init.b#;
$z8=q#ni:/io/cat_read.b#;
$A8=q#ni:/io/fd#;
$B8={$Q3,1};
$C8=q#/io/fd#;
$D8={};
$E8=q#fd#;
$F8=[];
$G8=q#shift->{'fd'}#;
$H8=bless({$o,$F8,$q,$G8,$s,$t},$u);
$I8={$E8,$H8};
$J8=q#/io/fd_readers.b#;
$K8=bless({$P1,$D8,$w2,$x2,$y2,$x2,$z2,$I8,$D,$J8},$I2);
$L8=q#lib/slice::ctors#;
$M8={};
$N8=[];
$O8=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$P8=bless({$o,$N8,$q,$O8,$s,$t},$u);
$Q8={$H3,$P8};
$R8=q#/io/fd_init.b#;
$S8=bless({$P1,$M8,$w2,$x2,$y2,$x2,$z2,$Q8,$D,$R8},$I2);
$T8=q#lib/slice::ctors#;
$U8={};
$V8=q#be#;
$W8=[];
$X8=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
$$self{rfh} = $$self{wfh} = undef;
$self->io_check_defined(\\&POSIX::dup2, $$self{fd}, $new);
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$Y8=bless({$o,$W8,$q,$X8,$s,$t},$u);
$Z8={$V8,$Y8};
$c9=q#/io/fd_shell.b#;
$d9=bless({$P1,$U8,$w2,$x2,$y2,$x2,$z2,$Z8,$D,$c9},$I2);
$e9=q#lib/slice::ctors#;
$f9={};
$g9=q#cloexec#;
$h9=[];
$i9=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$j9=bless({$o,$h9,$q,$i9,$s,$t},$u);
$k9=q#fcntl_flag#;
$l9=[];
$m9=q#my ($self, $flag, $value) = @_;
$self->errno_if_undef(\\&open, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->errno_if_false(
  \\&fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  shift ? $flags |= $flag : $flags &= ~$flag;
  $self->errno_if_false(\\&fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$n9=bless({$o,$l9,$q,$m9,$s,$t},$u);
$o9=q#nonblock#;
$p9=[];
$q9=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$r9=bless({$o,$p9,$q,$q9,$s,$t},$u);
$s9={$g9,$j9,$k9,$n9,$o9,$r9};
$t9=q#/io/fd_fcntl.b#;
$u9=bless({$P1,$f9,$w2,$x2,$y2,$x2,$z2,$s9,$D,$t9},$I2);
$v9=q#lib/slice::ctors#;
$w9={};
$x9=[];
$y9=q#shift->close#;
$z9=bless({$o,$x9,$q,$y9,$s,$t},$u);
$A9=q#close#;
$B9=[];
$C9=q#my $self = shift;
return $self if $$self{closed};
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$D9=bless({$o,$B9,$q,$C9,$s,$t},$u);
$E9={$A9,$D9};
$F9=q#/io/fd_gc.b#;
$G9=bless({$P1,$w9,$w2,$x2,$y2,$z9,$z2,$E9,$D,$F9},$I2);
$H9=q#lib/slice::ctors#;
$I9={};
$J9=[];
$K9=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
my $r;
do {
  return $r if defined($r = sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$L9=bless({$o,$J9,$q,$K9,$s,$t},$u);
$M9=q#write#;
$N9=[];
$O9=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
my $r;
do {
  return $r if defined($r = syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$P9=bless({$o,$N9,$q,$O9,$s,$t},$u);
$Q9={$c8,$L9,$M9,$P9};
$R9=q#/io/fd_perlio.b#;
$S9=bless({$P1,$I9,$w2,$x2,$y2,$x2,$z2,$Q9,$D,$R9},$I2);
$T9=q#lib/slice::ctors#;
$U9=[$P7,$K8,$S8,$d9,$u9,$G9,$S9];
$V9=bless({$P1,$B8,$D,$C8,$o2,$U9},$T1);
$W9=q#io/fd.c::ctors#;
$X9=q#ni:/io/fd.c#;
$Y9={$T1,1};
$Z9=q#/io/fd.c#;
$ca=[$t8];
$da=bless({$P1,$Y9,$D,$Z9,$o2,$ca},$q2);
$ea=q#metaclass::ctors#;
$fa=q#ni:/io/fd_fcntl.b#;
$ga=q#ni:/io/fd_gc.b#;
$ha=q#ni:/io/fd_init.b#;
$ia=q#ni:/io/fd_perlio.b#;
$ja=q#ni:/io/fd_readers.b#;
$ka=q#ni:/io/fd_shell.b#;
$la=q#ni:/io/file#;
$ma={$R3,1};
$na=q#/io/file#;
$oa={};
$pa=[];
$qa=q#shift->{'name'}#;
$ra=bless({$o,$pa,$q,$qa,$s,$t},$u);
$sa={$D,$ra};
$ta=q#/io/file_readers.b#;
$ua=bless({$P1,$oa,$w2,$x2,$y2,$x2,$z2,$sa,$D,$ta},$I2);
$va=q#lib/slice::ctors#;
$wa={};
$xa=q#mode#;
$ya=[];
$za=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$Aa=bless({$o,$ya,$q,$za,$s,$t},$u);
$Ba={$xa,$Aa};
$Ca=q#/io/file_accessors.b#;
$Da=bless({$P1,$wa,$w2,$x2,$y2,$x2,$z2,$Ba,$D,$Ca},$I2);
$Ea=q#lib/slice::ctors#;
$Fa={};
$Ga=[];
$Ha=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$Ia=bless({$o,$Ga,$q,$Ha,$s,$t},$u);
$Ja={$H3,$Ia};
$Ka=q#/io/file_init.b#;
$La=bless({$P1,$Fa,$w2,$x2,$y2,$x2,$z2,$Ja,$D,$Ka},$I2);
$Ma=q#lib/slice::ctors#;
$Na={};
$Oa=q#r#;
$Pa=[];
$Qa=q#my $self = shift;
return $$self{r} if defined $$self{r};
$$self{r} = ni('ni:/io/fd')->new(
  $self->io_check_defined(
    \\&POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$Ra=bless({$o,$Pa,$q,$Qa,$s,$t},$u);
$Sa=[];
$Ta=q#shift->r->read(@_)#;
$Ua=bless({$o,$Sa,$q,$Ta,$s,$t},$u);
$Va=q#w#;
$Wa=[];
$Xa=q#my $self = shift;
return $$self{w} if defined $$self{w};
$$self{w} = ni('ni:/io/fd')->new(
  $self->io_check_defined(
    \\&POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$Ya=bless({$o,$Wa,$q,$Xa,$s,$t},$u);
$Za=[];
$cb=q#shift->w->write(@_)#;
$db=bless({$o,$Za,$q,$cb,$s,$t},$u);
$eb={$Oa,$Ra,$c8,$Ua,$Va,$Ya,$M9,$db};
$fb=q#/io/file_io.b#;
$gb=bless({$P1,$Na,$w2,$x2,$y2,$x2,$z2,$eb,$D,$fb},$I2);
$hb=q#lib/slice::ctors#;
$ib=[$P7,$ua,$Da,$La,$gb];
$jb=bless({$P1,$ma,$D,$na,$o2,$ib},$U1);
$kb=q#io/file.c::ctors#;
$lb=q#ni:/io/file.c#;
$mb={$U1,1};
$nb=q#/io/file.c#;
$ob=[$t8];
$pb=bless({$P1,$mb,$D,$nb,$o2,$ob},$q2);
$qb=q#metaclass::ctors#;
$rb=q#ni:/io/file_accessors.b#;
$sb=q#ni:/io/file_init.b#;
$tb=q#ni:/io/file_io.b#;
$ub=q#ni:/io/file_readers.b#;
$vb=q#ni:/io/object#;
$wb=q#ni:/io/object.c#;
$xb=q#ni:/io/object_checks.b#;
$yb=q#ni:/io/object_constructors.b#;
$zb=q#ni:/io/object_memory.b#;
$Ab=q#ni:/io/object_ops.b#;
$Bb=q#ni:/io/object_stream.b#;
$Cb=q#ni:/io/pid#;
$Db={$T3,1};
$Eb={};
$Fb=q#pid#;
$Gb=[];
$Hb=q#shift->{'pid'}#;
$Ib=bless({$o,$Gb,$q,$Hb,$s,$t},$u);
$Jb=q#status#;
$Kb=[];
$Lb=q#shift->{'status'}#;
$Mb=bless({$o,$Kb,$q,$Lb,$s,$t},$u);
$Nb={$Fb,$Ib,$Jb,$Mb};
$Ob=q#/io/pid_readers.b#;
$Pb=bless({$P1,$Eb,$w2,$x2,$y2,$x2,$z2,$Nb,$D,$Ob},$I2);
$Qb=q#lib/slice::ctors#;
$Rb={};
$Sb=[];
$Tb=q#shift->await#;
$Ub=bless({$o,$Sb,$q,$Tb,$s,$t},$u);
$Vb=[];
$Wb=q#my ($class, $pid, %external_fds) = @_;
+{pid          => $pid,
  external_fds => \\%external_fds,
  status       => undef};#;
$Xb=bless({$o,$Vb,$q,$Wb,$s,$t},$u);
$Yb={$H3,$Xb};
$Zb=q#/io/pid_init.b#;
$cc=bless({$P1,$Rb,$w2,$x2,$y2,$Ub,$z2,$Yb,$D,$Zb},$I2);
$dc=q#lib/slice::ctors#;
$ec={};
$fc=q#await#;
$gc=[];
$hc=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(\\&waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$ic=bless({$o,$gc,$q,$hc,$s,$t},$u);
$jc=q#running#;
$kc=[];
$lc=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$mc=bless({$o,$kc,$q,$lc,$s,$t},$u);
$nc={$fc,$ic,$jc,$mc};
$oc=q#/io/pid_wait.b#;
$pc=bless({$P1,$ec,$w2,$x2,$y2,$x2,$z2,$nc,$D,$oc},$I2);
$qc=q#lib/slice::ctors#;
$rc={};
$sc=[];
$tc=q#shift->stdout->read(@_)#;
$uc=bless({$o,$sc,$q,$tc,$s,$t},$u);
$vc=[];
$wc=q#shift->stdin->write(@_)#;
$xc=bless({$o,$vc,$q,$wc,$s,$t},$u);
$yc={$c8,$uc,$M9,$xc};
$zc=q#/io/pid_io.b#;
$Ac=bless({$P1,$rc,$w2,$x2,$y2,$x2,$z2,$yc,$D,$zc},$I2);
$Bc=q#lib/slice::ctors#;
$Cc={};
$Dc=[];
$Ec=q#$_[0]->{external_fds}{$_[1]}#;
$Fc=bless({$o,$Dc,$q,$Ec,$s,$t},$u);
$Gc=q#stderr#;
$Hc=[];
$Ic=q#shift->fd(2)#;
$Jc=bless({$o,$Hc,$q,$Ic,$s,$t},$u);
$Kc=q#stdin#;
$Lc=[];
$Mc=q#shift->fd(0)#;
$Nc=bless({$o,$Lc,$q,$Mc,$s,$t},$u);
$Oc=q#stdout#;
$Pc=[];
$Qc=q#shift->fd(1)#;
$Rc=bless({$o,$Pc,$q,$Qc,$s,$t},$u);
$Sc={$E8,$Fc,$Gc,$Jc,$Kc,$Nc,$Oc,$Rc};
$Tc=q#/io/pid_accessors.b#;
$Uc=bless({$P1,$Cc,$w2,$x2,$y2,$x2,$z2,$Sc,$D,$Tc},$I2);
$Vc=q#lib/slice::ctors#;
$Wc=[$P7,$Pb,$cc,$pc,$Ac,$Uc];
$Xc=bless({$P1,$Db,$D,$w1,$o2,$Wc},$W1);
$Yc=q#io/pid.c::ctors#;
$Zc=q#ni:/io/pid.c#;
$cd={$W1,1};
$dd=q#/io/pid.c#;
$ed=[$t8];
$fd=bless({$P1,$cd,$D,$dd,$o2,$ed},$q2);
$gd=q#metaclass::ctors#;
$hd=q#ni:/io/pid_accessors.b#;
$id=q#ni:/io/pid_init.b#;
$jd=q#ni:/io/pid_io.b#;
$kd=q#ni:/io/pid_readers.b#;
$ld=q#ni:/io/pid_wait.b#;
$md=q#ni:/io/str#;
$nd={$U3,1};
$od=q#/io/str#;
$pd={};
$qd=q#data#;
$rd=[];
$sd=q#shift->{'data'}#;
$td=bless({$o,$rd,$q,$sd,$s,$t},$u);
$ud=q#end#;
$vd=[];
$wd=q#shift->{'end'}#;
$xd=bless({$o,$vd,$q,$wd,$s,$t},$u);
$yd=q#start#;
$zd=[];
$Ad=q#shift->{'start'}#;
$Bd=bless({$o,$zd,$q,$Ad,$s,$t},$u);
$Cd={$qd,$td,$ud,$xd,$yd,$Bd};
$Dd=q#/io/str_ro.b#;
$Ed=bless({$P1,$pd,$w2,$x2,$y2,$x2,$z2,$Cd,$D,$Dd},$I2);
$Fd=q#lib/slice::ctors#;
$Gd={};
$Hd=[];
$Id=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$Jd=bless({$o,$Hd,$q,$Id,$s,$t},$u);
$Kd={$H3,$Jd};
$Ld=q#/io/str_init.b#;
$Md=bless({$P1,$Gd,$w2,$x2,$y2,$x2,$z2,$Kd,$D,$Ld},$I2);
$Nd=q#lib/slice::ctors#;
$Od={};
$Pd=[];
$Qd=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$Rd=bless({$o,$Pd,$q,$Qd,$s,$t},$u);
$Sd=q#remaining#;
$Td=[];
$Ud=q#my $self = shift; $$self{end} - $$self{start}#;
$Vd=bless({$o,$Td,$q,$Ud,$s,$t},$u);
$Wd=[];
$Xd=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$Yd=bless({$o,$Wd,$q,$Xd,$s,$t},$u);
$Zd={$c8,$Rd,$Sd,$Vd,$M9,$Yd};
$ce=q#/io/str_io.b#;
$de=bless({$P1,$Od,$w2,$x2,$y2,$x2,$z2,$Zd,$D,$ce},$I2);
$ee=q#lib/slice::ctors#;
$fe=[$P7,$Ed,$Md,$de];
$ge=bless({$P1,$nd,$D,$od,$o2,$fe},$X1);
$he=q#io/str.c::ctors#;
$ie=q#ni:/io/str.c#;
$je={$X1,1};
$ke=q#/io/str.c#;
$le=[$t8];
$me=bless({$P1,$je,$D,$ke,$o2,$le},$q2);
$ne=q#metaclass::ctors#;
$oe=q#ni:/io/str_init.b#;
$pe=q#ni:/io/str_io.b#;
$qe=q#ni:/io/str_ro.b#;
$re=q#ni:/lib/accessor.b#;
$se=q#ni:/lib/behavior#;
$te=q#ni:/lib/behavior.c#;
$ue=q#ni:/lib/branch#;
$ve={$K2,1};
$we=q#/lib/branch#;
$xe={};
$ye=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$ze=bless({$q,$ye,$s,$t},$u);
$Ae={$H3,$ze};
$Be=q#/lib/branch_init.b#;
$Ce=bless({$P1,$xe,$w2,$x2,$y2,$x2,$z2,$Ae,$D,$Be},$I2);
$De=q#lib/slice::ctors#;
$Ee=[$D4,$U2,$J2,$Ce,$H5];
$Fe=bless({$P1,$ve,$D,$we,$o2,$Ee},$Z1);
$Ge=q#lib/branch.c::ctors#;
$He=q#ni:/lib/branch.b#;
$Ie=q#ni:/lib/branch.c#;
$Je={$Z1,1};
$Ke=q#/lib/branch.c#;
$Le=[$A6];
$Me=bless({$P1,$Je,$D,$Ke,$o2,$Le},$q2);
$Ne=q#metaclass::ctors#;
$Oe=q#ni:/lib/branch_init.b#;
$Pe=q#ni:/lib/class_init.b#;
$Qe=q#ni:/lib/dataslice#;
$Re={$W3,1};
$Se=q#/lib/dataslice#;
$Te={};
$Ue=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$Ve=bless({$q,$Ue,$s,$t},$u);
$We={$H3,$Ve};
$Xe=q#/lib/dataslice_init.b#;
$Ye=bless({$P1,$Te,$w2,$x2,$y2,$x2,$z2,$We,$D,$Xe},$I2);
$Ze=q#lib/slice::ctors#;
$cf={};
$df=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$ef=bless({$q,$df,$s,$t},$u);
$ff={$D2,$ef};
$gf=q#/lib/dataslice_apply.b#;
$hf=bless({$P1,$cf,$w2,$x2,$y2,$x2,$z2,$ff,$D,$gf},$I2);
$if=q#lib/slice::ctors#;
$jf=[$D4,$Ye,$hf];
$kf=bless({$P1,$Re,$D,$Se,$o2,$jf},$c2);
$lf=q#lib/dataslice.c::ctors#;
$mf=q#ni:/lib/dataslice.c#;
$nf={$c2,1};
$of=q#/lib/dataslice.c#;
$pf=[$A6];
$qf=bless({$P1,$nf,$D,$of,$o2,$pf},$q2);
$rf=q#metaclass::ctors#;
$sf=q#ni:/lib/dataslice_apply.b#;
$tf=q#ni:/lib/dataslice_init.b#;
$uf=q#ni:/lib/definition.b#;
$vf=q#ni:/lib/definition_def.b#;
$wf=q#ni:/lib/definition_defdata.b#;
$xf=q#ni:/lib/doc#;
$yf={$F,1};
$zf={};
$Af=q#shift; +{name => shift, doc => []}#;
$Bf=bless({$q,$Af,$s,$t},$u);
$Cf={$H3,$Bf};
$Df=q#/lib/doc_init.b#;
$Ef=bless({$P1,$zf,$w2,$x2,$y2,$x2,$z2,$Cf,$D,$Df},$I2);
$Ff=q#lib/slice::ctors#;
$Gf={};
$Hf=q#'ni.doc'#;
$If=bless({$q,$Hf,$s,$t},$u);
$Jf={$Z2,$If};
$Kf=q#/lib/doc_namespace.b#;
$Lf=bless({$P1,$Gf,$w2,$x2,$y2,$x2,$z2,$Jf,$D,$Kf},$I2);
$Mf=q#lib/slice::ctors#;
$Nf={};
$Of=q#AUTOLOAD#;
$Pf=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$Qf=bless({$q,$Pf,$s,$t},$u);
$Rf={$Of,$Qf};
$Sf=q#/lib/doc_define.b#;
$Tf=bless({$P1,$Nf,$w2,$x2,$y2,$x2,$z2,$Rf,$D,$Sf},$I2);
$Uf=q#lib/slice::ctors#;
$Vf={};
$Wf=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$Xf=bless({$q,$Wf,$s,$t},$u);
$Yf=q#tests#;
$Zf=q#my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$cg=bless({$q,$Zf,$s,$t},$u);
$dg={$n,$Xf,$Yf,$cg};
$eg=q#/lib/doc_test.b#;
$fg=bless({$P1,$Vf,$w2,$x2,$y2,$x2,$z2,$dg,$D,$eg},$I2);
$gg=q#lib/slice::ctors#;
$hg=[$p4,$U2,$Ef,$Lf,$Tf,$fg];
$ig=bless({$P1,$yf,$D,$M1,$o2,$hg},$d2);
$jg=q#lib/doc.c::ctors#;
$kg=q#ni:/lib/doc.c#;
$lg={$d2,1};
$mg=q#/lib/doc.c#;
$ng=[$v6];
$og=bless({$P1,$lg,$D,$mg,$o2,$ng},$q2);
$pg=q#metaclass::ctors#;
$qg=q#ni:/lib/doc_define.b#;
$rg=q#ni:/lib/doc_init.b#;
$sg=q#ni:/lib/doc_namespace.b#;
$tg=q#ni:/lib/doc_test.b#;
$ug=q#ni:/lib/documentable.b#;
$vg=q#ni:/lib/fn#;
$wg={$u,1};
$xg=q#/lib/fn#;
$yg={};
$zg=q#shift->compile#;
$Ag=bless({$q,$zg,$s,$t},$u);
$Bg=q#compile#;
$Cg=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$Dg=bless({$q,$Cg,$s,$t},$u);
$Eg=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$Fg=bless({$q,$Eg,$s,$t},$u);
$Gg={$Bg,$Dg,$H3,$Fg};
$Hg=q#/lib/fn_init.b#;
$Ig=bless({$P1,$yg,$w2,$Ag,$y2,$x2,$z2,$Gg,$D,$Hg},$I2);
$Jg=q#lib/slice::ctors#;
$Kg={};
$Lg=[];
$Mg=q#shift->{'annotations'}#;
$Ng=bless({$o,$Lg,$q,$Mg,$s,$t},$u);
$Og=[];
$Pg=q#shift->{'code'}#;
$Qg=bless({$o,$Og,$q,$Pg,$s,$t},$u);
$Rg=q#fn#;
$Sg=[];
$Tg=q#shift->{'fn'}#;
$Ug=bless({$o,$Sg,$q,$Tg,$s,$t},$u);
$Vg={$o,$Ng,$q,$Qg,$Rg,$Ug};
$Wg=q#/lib/fn_ro.b#;
$Xg=bless({$P1,$Kg,$w2,$x2,$y2,$x2,$z2,$Vg,$D,$Wg},$I2);
$Yg=q#lib/slice::ctors#;
$Zg={};
$ch=[];
$dh=q#shift->{code}#;
$eh=bless({$o,$ch,$q,$dh,$s,$t},$u);
$fh=[];
$gh=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$hh=bless({$o,$fh,$q,$gh,$s,$t},$u);
$ih={$g5,$eh,$p5,$hh};
$jh=q#/lib/fn_ops.b#;
$kh=bless({$P1,$Zg,$w2,$x2,$y2,$x2,$z2,$ih,$D,$jh},$I2);
$lh=q#lib/slice::ctors#;
$mh={};
$nh=q#serialize#;
$oh=[];
$ph=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$qh=bless({$o,$oh,$q,$ph,$s,$t},$u);
$rh={$nh,$qh};
$sh=q#/lib/fn_serialize.b#;
$th=bless({$P1,$mh,$w2,$x2,$y2,$x2,$z2,$rh,$D,$sh},$I2);
$uh=q#lib/slice::ctors#;
$vh=[$p4,$V5,$Ig,$Xg,$kh,$th];
$wh=bless({$P1,$wg,$D,$xg,$o2,$vh},$e2);
$xh=q#lib/fn.c::ctors#;
$yh=q#ni:/lib/fn.c#;
$zh={$e2,1};
$Ah=q#/lib/fn.c#;
$Bh=[$v6];
$Ch=bless({$P1,$zh,$D,$Ah,$o2,$Bh},$q2);
$Dh=q#metaclass::ctors#;
$Eh=q#ni:/lib/fn_init.b#;
$Fh=q#ni:/lib/fn_ops.b#;
$Gh=q#ni:/lib/fn_ro.b#;
$Hh=q#ni:/lib/fn_serialize.b#;
$Ih=q#ni:/lib/global_static_test.b#;
$Jh={};
$Kh=q#now#;
$Lh=[];
$Mh=q#ni('ni:/lib/test_value')->new(shift)#;
$Nh=q#($)#;
$Oh=bless({$o,$Lh,$q,$Mh,$s,$Nh},$u);
$Ph={$Kh,$Oh};
$Qh=q#/lib/global_static_test.b#;
$Rh=bless({$P1,$Jh,$w2,$x2,$y2,$x2,$z2,$Ph,$D,$Qh},$I2);
$Sh=q#main#;
$Th=q#lib/slice::ctors#;
$Uh=q#ni:/lib/image#;
$Vh={$X3,1};
$Wh=q#/lib/image#;
$Xh={};
$Yh=[];
$Zh=q#my $class = shift;
my %args  = (
  include_shebang => 1,
  include_license => 1,
  include_boot    => 1,
  include_classes => 1,
  include_run     => 1,
  local_vars      => 0,
  use_newlines    => 0,
  @_);

+{include_shebang => $args{include_shebang},
  include_license => $args{include_license},
  include_boot    => $args{include_boot},
  include_classes => $args{include_classes},
  include_run     => $args{include_run},
  local_vars      => $args{local_vars},
  use_newlines    => $args{use_newlines},

  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$ci=bless({$o,$Yh,$q,$Zh,$s,$t},$u);
$di={$H3,$ci};
$ei=q#/lib/image_init.b#;
$fi=bless({$P1,$Xh,$w2,$x2,$y2,$x2,$z2,$di,$D,$ei},$I2);
$gi=q#lib/slice::ctors#;
$hi={};
$ii=q#address#;
$ji=[];
$ki=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 16;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$li=bless({$o,$ji,$q,$ki,$s,$t},$u);
$mi=q#allocate_gensym#;
$ni=[];
$oi=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$pi=bless({$o,$ni,$q,$oi,$s,$t},$u);
$qi=q#boot_side_effect#;
$ri=[];
$si=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$ti=bless({$o,$ri,$q,$si,$s,$t},$u);
$ui=q#circular_links#;
$vi=[];
$wi=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$xi=bless({$o,$vi,$q,$wi,$s,$t},$u);
$yi=q#finalizer#;
$zi=[];
$Ai=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$Bi=bless({$o,$zi,$q,$Ai,$s,$t},$u);
$Ci=q#gensym#;
$Di=[];
$Ei=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$Fi=bless({$o,$Di,$q,$Ei,$s,$t},$u);
$Gi=q#is_circular#;
$Hi=[];
$Ii=q#my $self = shift;
ref $$self{visited}{$self->address($_[0])};#;
$Ji=bless({$o,$Hi,$q,$Ii,$s,$t},$u);
$Ki=q#quote#;
$Li=[];
$Mi=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? 'undef' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$Ni=bless({$o,$Li,$q,$Mi,$s,$t},$u);
$Oi=q#quote_array#;
$Pi=[];
$Qi=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_])
  && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$Ri=bless({$o,$Pi,$q,$Qi,$s,$t},$u);
$Si=q#quote_blessed#;
$Ti=[];
$Ui=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$Vi=bless({$o,$Ti,$q,$Ui,$s,$t},$u);
$Wi=q#quote_class#;
$Xi=[];
$Yi=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$Zi=bless({$o,$Xi,$q,$Yi,$s,$t},$u);
$cj=q#quote_hash#;
$dj=[];
$ej=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  push @{$$self{circular}}, [$a, "{" . $self->quote($k) . "}",
                                 $self->address($$v{$k})]
  if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$fj=bless({$o,$dj,$q,$ej,$s,$t},$u);
$gj=q#quote_object#;
$hj=[];
$ij=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$jj=bless({$o,$hj,$q,$ij,$s,$t},$u);
$kj=q#quote_scalar#;
$lj=[];
$mj=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$nj=bless({$o,$lj,$q,$mj,$s,$t},$u);
$oj=q#quote_value#;
$pj=[];
$qj=q#my $self = shift;
return $self->quote_scalar($_[0]) unless ref $_[0];
return $self->quote_array($_[0])  if 'ARRAY' eq ref $_[0];
return $self->quote_hash($_[0])   if 'HASH'  eq ref $_[0];
die "cannot serialize $_[0]"      if 'CODE'  eq ref $_[0];
$self->quote_object($_[0]);#;
$rj=bless({$o,$pj,$q,$qj,$s,$t},$u);
$sj=q#reconstruction#;
$tj=[];
$uj=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$vj=bless({$o,$tj,$q,$uj,$s,$t},$u);
$wj=q#side_effect#;
$xj=[];
$yj=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$zj=bless({$o,$xj,$q,$yj,$s,$t},$u);
$Aj=[];
$Bj=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  ($$self{include_shebang} ? ("\#!/usr/bin/env perl\\n") : ()),
  ($$self{include_license} ? ("chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n") : ()),
  ($$self{include_boot}    ? ("BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n") : ()),
  ($$self{use_newlines}    ? map("$_\\n", $self->reconstruction) : $self->reconstruction),
  ($$self{include_run}     ? ("ni->run(\\@ARGV);", "\\n__DATA__\\n") : ());#;
$Cj=bless({$o,$Aj,$q,$Bj,$s,$t},$u);
$Dj={$ii,$li,$mi,$pi,$qi,$ti,$ui,$xi,$yi,$Bi,$Ci,$Fi,$Gi,$Ji,$Ki,$Ni,$Oi,$Ri,$Si,$Vi,$Wi,$Zi,$cj,$fj,$gj,$jj,$kj,$nj,$oj,$rj,$sj,$vj,$wj,$zj,$M9,$Cj};
$Ej=q#/lib/image_quoting.b#;
$Fj=bless({$P1,$hi,$w2,$x2,$y2,$x2,$z2,$Dj,$D,$Ej},$I2);
$Gj=q#lib/slice::ctors#;
$Hj=[$p4,$fi,$Fj];
$Ij=bless({$P1,$Vh,$D,$Wh,$o2,$Hj},$f2);
$Jj=q#lib/image.c::ctors#;
$Kj=q#ni:/lib/image.c#;
$Lj={$f2,1};
$Mj=q#/lib/image.c#;
$Nj=[$v6];
$Oj=bless({$P1,$Lj,$D,$Mj,$o2,$Nj},$q2);
$Pj=q#metaclass::ctors#;
$Qj=q#ni:/lib/image_init.b#;
$Rj=q#ni:/lib/image_quoting.b#;
$Sj=q#ni:/lib/instance.b#;
$Tj=q#ni:/lib/instantiable.b#;
$Uj=q#ni:/lib/json.b#;
$Vj={};
$Wj=q#json_decode#;
$Xj=[];
$Yj=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$Zj=bless({$o,$Xj,$q,$Yj,$s,$Nh},$u);
$ck=q#json_encode#;
$dk=[];
$ek=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$fk=bless({$o,$dk,$q,$ek,$s,$Nh},$u);
$gk=q#json_escape#;
$hk=[];
$ik=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$jk=bless({$o,$hk,$q,$ik,$s,$Nh},$u);
$kk=q#json_unescape#;
$lk=[];
$mk=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$nk=bless({$o,$lk,$q,$mk,$s,$Nh},$u);
$ok=q#json_unescape_one#;
$pk=[];
$qk=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$rk=bless({$o,$pk,$q,$qk,$s,$Nh},$u);
$sk={$Wj,$Zj,$ck,$fk,$gk,$jk,$kk,$nk,$ok,$rk};
$tk=q#/lib/json.b#;
$uk=bless({$P1,$Vj,$w2,$x2,$y2,$x2,$z2,$sk,$D,$tk},$I2);
$vk=q#ni#;
$wk=q#lib/slice::ctors#;
$xk=q#ni:/lib/name_as_string.b#;
$yk=q#ni:/lib/named.b#;
$zk=q#ni:/lib/named_in_ni.b#;
$Ak=q#ni:/lib/namespaced.b#;
$Bk=q#ni:/lib/ni#;
$Ck={$Y3,1};
$Dk=q#/lib/ni#;
$Ek={};
$Fk=q#extend#;
$Gk=[];
$Hk=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$Ik=bless({$o,$Gk,$q,$Hk,$s,$t},$u);
$Jk=q#is_mutable#;
$Kk=[];
$Lk=q#$0 ne "-" && -w $0#;
$Mk=bless({$o,$Kk,$q,$Lk,$s,$t},$u);
$Nk=q#modify#;
$Ok=[];
$Pk=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$Qk=bless({$o,$Ok,$q,$Pk,$s,$t},$u);
$Rk={$Fk,$Ik,$Jk,$Mk,$Nk,$Qk};
$Sk=q#/lib/ni_self.b#;
$Tk=bless({$P1,$Ek,$w2,$x2,$y2,$x2,$z2,$Rk,$D,$Sk},$I2);
$Uk=q#lib/slice::ctors#;
$Vk={};
$Wk=q#exists#;
$Xk=[];
$Yk=q#exists $_[0]->{named}{$_[1]}#;
$Zk=bless({$o,$Xk,$q,$Yk,$s,$t},$u);
$cl=q#quoted#;
$dl=[];
$el=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$fl=bless({$o,$dl,$q,$el,$s,$t},$u);
$gl={$Wk,$Zk,$cl,$fl};
$hl=q#/lib/ni_image.b#;
$il=bless({$P1,$Vk,$w2,$x2,$y2,$x2,$z2,$gl,$D,$hl},$I2);
$jl=q#lib/slice::ctors#;
$kl={};
$ll=q#--internal/+=#;
$ml=[];
$nl=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$ol=bless({$o,$ml,$q,$nl,$s,$t},$u);
$pl=q#--internal/eval#;
$ql=[];
$rl=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$sl=bless({$o,$ql,$q,$rl,$s,$t},$u);
$tl=q#--internal/image#;
$ul=[];
$vl=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$wl=bless({$o,$ul,$q,$vl,$s,$t},$u);
$xl=q#--internal/test#;
$yl=[];
$zl=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$Al=bless({$o,$yl,$q,$zl,$s,$t},$u);
$Bl=q#run#;
$Cl=[];
$Dl=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$El=bless({$o,$Cl,$q,$Dl,$s,$t},$u);
$Fl={$ll,$ol,$pl,$sl,$tl,$wl,$xl,$Al,$Bl,$El};
$Gl=q#/lib/ni_main.b#;
$Hl=bless({$P1,$kl,$w2,$x2,$y2,$x2,$z2,$Fl,$D,$Gl},$I2);
$Il=q#lib/slice::ctors#;
$Jl={};
$Kl=[];
$Ll=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$Ml=bless({$o,$Kl,$q,$Ll,$s,$t},$u);
$Nl=q#resolver_for#;
$Ol=[];
$Pl=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$Ql=bless({$o,$Ol,$q,$Pl,$s,$t},$u);
$Rl={$t3,$Ml,$Nl,$Ql};
$Sl=q#/lib/ni_resolver.b#;
$Tl=bless({$P1,$Jl,$w2,$x2,$y2,$x2,$z2,$Rl,$D,$Sl},$I2);
$Ul=q#lib/slice::ctors#;
$Vl=[$p4,$Tk,$il,$Hl,$Tl];
$Wl=bless({$P1,$Ck,$D,$Dk,$o2,$Vl},$g2);
$Xl=q#lib/ni.c::ctors#;
$Yl=q#ni:/lib/ni.c#;
$Zl={$g2,1};
$cm=q#/lib/ni.c#;
$dm=[$v6];
$em=bless({$P1,$Zl,$D,$cm,$o2,$dm},$q2);
$fm=q#metaclass::ctors#;
$gm=q#ni:/lib/ni_image.b#;
$hm=q#ni:/lib/ni_main.b#;
$im=q#ni:/lib/ni_resolver.b#;
$jm=q#ni:/lib/ni_self.b#;
$km=q#ni:/lib/ni_static_util.b#;
$lm={};
$mm=q#abbrev#;
$nm=[];
$om=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$pm=bless({$o,$nm,$q,$om,$s,$t},$u);
$qm=q#dor#;
$rm=[];
$sm=q#defined $_[0] ? $_[0] : $_[1]#;
$tm=bless({$o,$rm,$q,$sm,$s,$t},$u);
$um=q#indent#;
$vm=[];
$wm=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$xm=bless({$o,$vm,$q,$wm,$s,$t},$u);
$ym=q#max#;
$zm=[];
$Am=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$Bm=bless({$o,$zm,$q,$Am,$s,$t},$u);
$Cm=q#maxstr#;
$Dm=[];
$Em=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$Fm=bless({$o,$Dm,$q,$Em,$s,$t},$u);
$Gm=q#mean#;
$Hm=[];
$Im=q#sum(@_) / (@_ || 1)#;
$Jm=bless({$o,$Hm,$q,$Im,$s,$t},$u);
$Km=q#min#;
$Lm=[];
$Mm=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$Nm=bless({$o,$Lm,$q,$Mm,$s,$t},$u);
$Om=q#minstr#;
$Pm=[];
$Qm=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$Rm=bless({$o,$Pm,$q,$Qm,$s,$t},$u);
$Sm=q#sgr#;
$Tm=[];
$Um=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$Vm=bless({$o,$Tm,$q,$Um,$s,$t},$u);
$Wm=q#sr#;
$Xm=[];
$Ym=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$Zm=bless({$o,$Xm,$q,$Ym,$s,$t},$u);
$cn=q#sum#;
$dn=[];
$en=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$fn=bless({$o,$dn,$q,$en,$s,$t},$u);
$gn=q#swap#;
$hn=[];
$in=q#@_[0, 1] = @_[1, 0]#;
$jn=bless({$o,$hn,$q,$in,$s,$t},$u);
$kn={$mm,$pm,$qm,$tm,$um,$xm,$ym,$Bm,$Cm,$Fm,$Gm,$Jm,$Km,$Nm,$Om,$Rm,$Sm,$Vm,$Wm,$Zm,$cn,$fn,$gn,$jn};
$ln=q#/lib/ni_static_util.b#;
$mn=bless({$P1,$lm,$w2,$x2,$y2,$x2,$z2,$kn,$D,$ln},$I2);
$nn=q#lib/slice::ctors#;
$on=q#ni:/lib/perlbranch.b#;
$pn=q#ni:/lib/ref_eq.b#;
$qn=q#ni:/lib/resolver.b#;
$rn=q#ni:/lib/slice#;
$sn={$I2,1};
$tn=q#/lib/slice#;
$un=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$vn=bless({$q,$un,$s,$t},$u);
$wn=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$xn=bless({$q,$wn,$s,$t},$u);
$yn=q#lib/slice::apply#;
$zn=q#lib/slice::apply_unsafe#;
$An={};
$Bn=q#apply_unsafe#;
$Cn={$D2,$vn,$Bn,$xn};
$Dn=q#/lib/slice.b#;
$En=bless({$P1,$An,$z2,$Cn,$D,$Dn},$I2);
$Fn=q#lib/slice::ctors#;
$Gn={};
$Hn=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$In=bless({$q,$Hn,$s,$t},$u);
$Jn={$H3,$In};
$Kn=q#/lib/slice_init.b#;
$Ln=bless({$P1,$Gn,$z2,$Jn,$D,$Kn},$I2);
$Mn=q#lib/slice::ctors#;
$Nn={};
$On=[];
$Pn=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$Qn=bless({$o,$On,$q,$Pn,$s,$t},$u);
$Rn={$nh,$Qn};
$Sn=q#/lib/slice_serialize.b#;
$Tn=bless({$P1,$Nn,$w2,$x2,$y2,$x2,$z2,$Rn,$D,$Sn},$I2);
$Un=q#lib/slice::ctors#;
$Vn=[$D4,$U2,$En,$Ln,$Tn];
$Wn=bless({$P1,$sn,$D,$tn,$o2,$Vn},$h2);
$Xn=q#lib/slice.c::ctors#;
$Yn=q#ni:/lib/slice.b#;
$Zn=q#ni:/lib/slice.c#;
$co={$h2,1};
$do=q#/lib/slice.c#;
$eo=[$A6];
$fo=bless({$P1,$co,$D,$do,$o2,$eo},$q2);
$go=q#metaclass::ctors#;
$ho=q#ni:/lib/slice_init.b#;
$io=q#ni:/lib/slice_serialize.b#;
$jo=q#ni:/lib/static_fn.b#;
$ko={};
$lo=[];
$mo=q#ni('ni:/lib/fn')->new(@_)#;
$no=bless({$o,$lo,$q,$mo,$s,$Nh},$u);
$oo=q#fp#;
$po=[];
$qo=q#ni('ni:/lib/fn')->new(@_)#;
$ro=q#($$)#;
$so=bless({$o,$po,$q,$qo,$s,$ro},$u);
$to={$Rg,$no,$oo,$so};
$uo=q#/lib/static_fn.b#;
$vo=bless({$P1,$ko,$w2,$x2,$y2,$x2,$z2,$to,$D,$uo},$I2);
$wo=q#lib/slice::ctors#;
$xo=q#ni:/lib/subclass.b#;
$yo=q#ni:/lib/tag#;
$zo={$V2,1};
$Ao=q#/lib/tag#;
$Bo={};
$Co=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$Do=bless({$q,$Co,$s,$t},$u);
$Eo={$D2,$Do};
$Fo=q#/lib/tag.b#;
$Go=bless({$P1,$Bo,$w2,$x2,$y2,$x2,$z2,$Eo,$D,$Fo},$I2);
$Ho=q#lib/slice::ctors#;
$Io={};
$Jo=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$Ko=bless({$q,$Jo,$s,$t},$u);
$Lo={$H3,$Ko};
$Mo=q#/lib/tag_init.b#;
$No=bless({$P1,$Io,$w2,$x2,$y2,$x2,$z2,$Lo,$D,$Mo},$I2);
$Oo=q#lib/slice::ctors#;
$Po=[$D4,$U2,$Go,$No];
$Qo=bless({$P1,$zo,$D,$Ao,$o2,$Po},$i2);
$Ro=q#lib/tag.c::ctors#;
$So=q#ni:/lib/tag.b#;
$To=q#ni:/lib/tag.c#;
$Uo={$i2,1};
$Vo=q#/lib/tag.c#;
$Wo=[$A6];
$Xo=bless({$P1,$Uo,$D,$Vo,$o2,$Wo},$q2);
$Yo=q#metaclass::ctors#;
$Zo=q#ni:/lib/tag_init.b#;
$cp=q#ni:/lib/test_value#;
$dp={$Z3,1};
$ep=q#/lib/test_value#;
$fp={};
$gp=[];
$hp=q#\\$_[1]#;
$ip=bless({$o,$gp,$q,$hp,$s,$t},$u);
$jp={$H3,$ip};
$kp=q#/lib/test_value_init.b#;
$lp=bless({$P1,$fp,$w2,$x2,$y2,$x2,$z2,$jp,$D,$kp},$I2);
$mp=q#lib/slice::ctors#;
$np={};
$op=q#(==#;
$pp=[];
$qp=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$rp=bless({$o,$pp,$q,$qp,$s,$t},$u);
$sp=q#diff#;
$tp=[];
$up=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$vp=bless({$o,$tp,$q,$up,$s,$t},$u);
$wp={$op,$rp,$sp,$vp};
$xp=q#/lib/test_value_eq.b#;
$yp=bless({$P1,$np,$w2,$x2,$y2,$x2,$z2,$wp,$D,$xp},$I2);
$zp=q#lib/slice::ctors#;
$Ap={};
$Bp=[];
$Cp=q#ni::json_encode ${$_[0]}#;
$Dp=bless({$o,$Bp,$q,$Cp,$s,$t},$u);
$Ep={$g5,$Dp};
$Fp=q#/lib/test_value_str.b#;
$Gp=bless({$P1,$Ap,$w2,$x2,$y2,$x2,$z2,$Ep,$D,$Fp},$I2);
$Hp=q#lib/slice::ctors#;
$Ip=[$p4,$lp,$yp,$Gp];
$Jp=q#lib/test_value.c#;
$Kp=bless({$P1,$dp,$D,$ep,$o2,$Ip},$Jp);
$Lp=q#lib/test_value.c::ctors#;
$Mp=q#ni:/lib/test_value.c#;
$Np=q#lib/test_value.c#;
$Op={$Np,1};
$Pp=q#/lib/test_value.c#;
$Qp=[$v6];
$Rp=bless({$P1,$Op,$D,$Pp,$o2,$Qp},$q2);
$Sp=q#metaclass::ctors#;
$Tp=q#ni:/lib/test_value_eq.b#;
$Up=q#ni:/lib/test_value_init.b#;
$Vp=q#ni:/lib/test_value_str.b#;
$Wp=q#ni:/metaclass#;
$Xp={$q2,1};
$Yp=q#/metaclass#;
$Zp=[$C3,$V5,$M3,$K5];
$cq=bless({$P1,$Xp,$D,$Yp,$o2,$Zp},$k2);
$dq=q#metaclass.c::ctors#;
$eq=q#ni:/metaclass.c#;
$fq={$k2,1};
$gq=q#/metaclass.c#;
$hq=[$k6];
$iq=bless({$P1,$fq,$D,$gq,$o2,$hq},$q2);
$jq=q#metaclass::ctors#;
$kq=q#ni:/module#;
$lq=q#ni:/module.c#;
$mq=q#ni:/object#;
$nq=q#ni:/object.c#;
$oq=q#ni:main#;
$pq={$Sh,1};
$qq=[$vo,$Rh];
$rq=bless({$P1,$pq,$D,$Sh,$o2,$qq},$r2);
$sq=q#module::ctors#;
$tq=q#ni:ni#;
$uq={$vk,1};
$vq={$vk,1};
$wq=q#json_escapes#;
$xq=q##;
$yq=q#b#;
$zq=q#	#;
$Aq=q#t#;
$Bq=q#
#;
$Cq=q#n#;
$Dq=q##;
$Eq=q#"#;
$Fq=q#/#;
$Gq=q#\\#;
$Hq={$xq,$yq,$zq,$Aq,$Bq,$Cq,$Dq,$Oa,$Eq,$Eq,$Fq,$Fq,$Gq,$Gq};
$Iq=q#json_unescapes#;
$Jq={$Eq,$Eq,$Fq,$Fq,$Gq,$Gq,$yq,$xq,$Cq,$Bq,$Oa,$Dq,$Aq,$zq};
$Kq={$wq,$Hq,$Iq,$Jq};
$Lq=q#/lib/json_data.b#;
$Mq=bless({$P1,$vq,$qd,$Kq,$D,$Lq},$W3);
$Nq=q#lib/dataslice::ctors#;
$Oq=[$Mq,$uk,$mn];
$Pq=bless({$P1,$uq,$D,$vk,$o2,$Oq},$r2);
$Qq={$d,$G,$I,$N,$O,$T,$U,$h1,$i1,$x1,$y1,$N1,$O1,$k6,$m6,$G6,$I6,$l8,$n8,$w8,$y8,$X7,$z8,$i8,$A8,$V9,$X9,$da,$fa,$u9,$ga,$G9,$ha,$S8,$ia,$S9,$ja,$K8,$ka,$d9,$la,$jb,$lb,$pb,$rb,$Da,$sb,$La,$tb,$gb,$ub,$ua,$vb,$P7,$wb,$t8,$xb,$u7,$yb,$D7,$zb,$M7,$Ab,$S6,$Bb,$d7,$Cb,$Xc,$Zc,$fd,$hd,$Uc,$id,$cc,$jd,$Ac,$kd,$Pb,$ld,$pc,$md,$ge,$ie,$me,$oe,$Md,$pe,$de,$qe,$Ed,$re,$c5,$se,$D4,$te,$A6,$ue,$Fe,$He,$J2,$Ie,$Me,$Oe,$Ce,$Pe,$M3,$Qe,$kf,$mf,$qf,$sf,$hf,$tf,$Ye,$uf,$H5,$vf,$O4,$wf,$D5,$xf,$ig,$kg,$og,$qg,$Tf,$rg,$Ef,$sg,$Lf,$tg,$fg,$ug,$z4,$vg,$wh,$yh,$Ch,$Eh,$Ig,$Fh,$kh,$Gh,$Xg,$Hh,$th,$Ih,$Rh,$Uh,$Ij,$Kj,$Oj,$Qj,$fi,$Rj,$Fj,$Sj,$l4,$Tj,$V5,$Uj,$uk,$xk,$l5,$yk,$U2,$zk,$g3,$Ak,$p3,$Bk,$Wl,$Yl,$em,$gm,$il,$hm,$Hl,$im,$Tl,$jm,$Tk,$km,$mn,$on,$C3,$pn,$u5,$qn,$y3,$rn,$Wn,$Yn,$En,$Zn,$fo,$ho,$Ln,$io,$Tn,$jo,$vo,$xo,$g6,$yo,$Qo,$So,$Go,$To,$Xo,$Zo,$No,$cp,$Kp,$Mp,$Rp,$Tp,$yp,$Up,$lp,$Vp,$Gp,$Wp,$cq,$eq,$iq,$kq,$K5,$lq,$D6,$mq,$p4,$nq,$v6,$oq,$rq,$tq,$Pq};
$Rq=q#resolvers#;
$Sq=[];
$Tq=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$Uq=bless({$o,$Sq,$q,$Tq,$s,$t},$u);
$Vq=q#file#;
$Wq=[];
$Xq=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$Yq=bless({$o,$Wq,$q,$Xq,$s,$t},$u);
$Zq=q#sh#;
$cr=[];
$dr=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$er=bless({$o,$cr,$q,$dr,$s,$t},$u);
$fr=q#str#;
$gr=[];
$hr=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$ir=bless({$o,$gr,$q,$hr,$s,$t},$u);
$jr={$E8,$Uq,$Vq,$Yq,$Zq,$er,$fr,$ir};
$kr=bless({$c,$Qq,$Rq,$jr},$Y3);
$lr=q#lib/ni::ctors#;
*$zn=\&$xn;
*$yn=\&$vn;
$J2->apply_unsafe($Q1);
$J2->apply_unsafe($R1);
$J2->apply_unsafe($S1);
$J2->apply_unsafe($T1);
$J2->apply_unsafe($U1);
$J2->apply_unsafe($V1);
$J2->apply_unsafe($W1);
$J2->apply_unsafe($X1);
$J2->apply_unsafe($Y1);
$J2->apply_unsafe($K2);
$J2->apply_unsafe($Z1);
$J2->apply_unsafe($c2);
$J2->apply_unsafe($d2);
$J2->apply_unsafe($e2);
$J2->apply_unsafe($f2);
$J2->apply_unsafe($g2);
$J2->apply_unsafe($h2);
$J2->apply_unsafe($i2);
$J2->apply_unsafe($L2);
$J2->apply_unsafe($q2);
$J2->apply_unsafe($k2);
$J2->apply_unsafe($r2);
$J2->apply_unsafe($l2);
$J2->apply_unsafe($m2);
$U2->apply_unsafe($Q1);
$U2->apply_unsafe($R1);
$U2->apply_unsafe($S1);
$U2->apply_unsafe($T1);
$U2->apply_unsafe($U1);
$U2->apply_unsafe($V1);
$U2->apply_unsafe($W1);
$U2->apply_unsafe($X1);
$U2->apply_unsafe($Y1);
$U2->apply_unsafe($K2);
$U2->apply_unsafe($Z1);
$U2->apply_unsafe($c2);
$U2->apply_unsafe($F);
$U2->apply_unsafe($d2);
$U2->apply_unsafe($e2);
$U2->apply_unsafe($f2);
$U2->apply_unsafe($g2);
$U2->apply_unsafe($I2);
$U2->apply_unsafe($h2);
$U2->apply_unsafe($V2);
$U2->apply_unsafe($i2);
$U2->apply_unsafe($W2);
$U2->apply_unsafe($q2);
$U2->apply_unsafe($k2);
$U2->apply_unsafe($r2);
$U2->apply_unsafe($l2);
$U2->apply_unsafe($m2);
$g3->apply_unsafe($Q1);
$g3->apply_unsafe($R1);
$g3->apply_unsafe($S1);
$g3->apply_unsafe($T1);
$g3->apply_unsafe($U1);
$g3->apply_unsafe($V1);
$g3->apply_unsafe($W1);
$g3->apply_unsafe($X1);
$g3->apply_unsafe($Y1);
$g3->apply_unsafe($K2);
$g3->apply_unsafe($Z1);
$g3->apply_unsafe($c2);
$g3->apply_unsafe($d2);
$g3->apply_unsafe($e2);
$g3->apply_unsafe($f2);
$g3->apply_unsafe($g2);
$g3->apply_unsafe($I2);
$g3->apply_unsafe($h2);
$g3->apply_unsafe($V2);
$g3->apply_unsafe($i2);
$g3->apply_unsafe($h3);
$g3->apply_unsafe($q2);
$g3->apply_unsafe($k2);
$g3->apply_unsafe($r2);
$g3->apply_unsafe($l2);
$g3->apply_unsafe($m2);
$p3->apply_unsafe($Q1);
$p3->apply_unsafe($R1);
$p3->apply_unsafe($S1);
$p3->apply_unsafe($T1);
$p3->apply_unsafe($U1);
$p3->apply_unsafe($V1);
$p3->apply_unsafe($W1);
$p3->apply_unsafe($X1);
$p3->apply_unsafe($Y1);
$p3->apply_unsafe($K2);
$p3->apply_unsafe($Z1);
$p3->apply_unsafe($c2);
$p3->apply_unsafe($d2);
$p3->apply_unsafe($e2);
$p3->apply_unsafe($f2);
$p3->apply_unsafe($g2);
$p3->apply_unsafe($I2);
$p3->apply_unsafe($h2);
$p3->apply_unsafe($V2);
$p3->apply_unsafe($i2);
$p3->apply_unsafe($q3);
$p3->apply_unsafe($q2);
$p3->apply_unsafe($k2);
$p3->apply_unsafe($r2);
$p3->apply_unsafe($l2);
$p3->apply_unsafe($m2);
$y3->apply_unsafe($Q1);
$y3->apply_unsafe($R1);
$y3->apply_unsafe($S1);
$y3->apply_unsafe($T1);
$y3->apply_unsafe($U1);
$y3->apply_unsafe($V1);
$y3->apply_unsafe($W1);
$y3->apply_unsafe($X1);
$y3->apply_unsafe($Y1);
$y3->apply_unsafe($K2);
$y3->apply_unsafe($Z1);
$y3->apply_unsafe($c2);
$y3->apply_unsafe($d2);
$y3->apply_unsafe($e2);
$y3->apply_unsafe($f2);
$y3->apply_unsafe($g2);
$y3->apply_unsafe($h2);
$y3->apply_unsafe($V2);
$y3->apply_unsafe($i2);
$y3->apply_unsafe($z3);
$y3->apply_unsafe($q2);
$y3->apply_unsafe($k2);
$y3->apply_unsafe($r2);
$y3->apply_unsafe($l2);
$y3->apply_unsafe($m2);
$M3->apply_unsafe($Q1);
$M3->apply_unsafe($R1);
$M3->apply_unsafe($S1);
$M3->apply_unsafe($T1);
$M3->apply_unsafe($U1);
$M3->apply_unsafe($V1);
$M3->apply_unsafe($W1);
$M3->apply_unsafe($X1);
$M3->apply_unsafe($Y1);
$M3->apply_unsafe($Z1);
$M3->apply_unsafe($c2);
$M3->apply_unsafe($d2);
$M3->apply_unsafe($e2);
$M3->apply_unsafe($f2);
$M3->apply_unsafe($g2);
$M3->apply_unsafe($h2);
$M3->apply_unsafe($i2);
$M3->apply_unsafe($N3);
$M3->apply_unsafe($q2);
$M3->apply_unsafe($k2);
$M3->apply_unsafe($r2);
$M3->apply_unsafe($l2);
$M3->apply_unsafe($m2);
$l4->apply_unsafe($Q1);
$l4->apply_unsafe($R1);
$l4->apply_unsafe($P3);
$l4->apply_unsafe($S1);
$l4->apply_unsafe($Q3);
$l4->apply_unsafe($T1);
$l4->apply_unsafe($R3);
$l4->apply_unsafe($U1);
$l4->apply_unsafe($S3);
$l4->apply_unsafe($V1);
$l4->apply_unsafe($T3);
$l4->apply_unsafe($W1);
$l4->apply_unsafe($U3);
$l4->apply_unsafe($X1);
$l4->apply_unsafe($V3);
$l4->apply_unsafe($Y1);
$l4->apply_unsafe($K2);
$l4->apply_unsafe($Z1);
$l4->apply_unsafe($W3);
$l4->apply_unsafe($c2);
$l4->apply_unsafe($F);
$l4->apply_unsafe($d2);
$l4->apply_unsafe($u);
$l4->apply_unsafe($e2);
$l4->apply_unsafe($X3);
$l4->apply_unsafe($f2);
$l4->apply_unsafe($Y3);
$l4->apply_unsafe($g2);
$l4->apply_unsafe($I2);
$l4->apply_unsafe($h2);
$l4->apply_unsafe($V2);
$l4->apply_unsafe($i2);
$l4->apply_unsafe($Z3);
$l4->apply_unsafe($m4);
$l4->apply_unsafe($q2);
$l4->apply_unsafe($k2);
$l4->apply_unsafe($r2);
$l4->apply_unsafe($l2);
$l4->apply_unsafe($d4);
$l4->apply_unsafe($m2);
$z4->apply_unsafe($Q1);
$z4->apply_unsafe($R1);
$z4->apply_unsafe($S1);
$z4->apply_unsafe($T1);
$z4->apply_unsafe($U1);
$z4->apply_unsafe($V1);
$z4->apply_unsafe($W1);
$z4->apply_unsafe($X1);
$z4->apply_unsafe($V3);
$z4->apply_unsafe($Y1);
$z4->apply_unsafe($K2);
$z4->apply_unsafe($Z1);
$z4->apply_unsafe($W3);
$z4->apply_unsafe($c2);
$z4->apply_unsafe($d2);
$z4->apply_unsafe($e2);
$z4->apply_unsafe($f2);
$z4->apply_unsafe($g2);
$z4->apply_unsafe($I2);
$z4->apply_unsafe($h2);
$z4->apply_unsafe($V2);
$z4->apply_unsafe($i2);
$z4->apply_unsafe($A4);
$z4->apply_unsafe($q2);
$z4->apply_unsafe($k2);
$z4->apply_unsafe($r2);
$z4->apply_unsafe($l2);
$z4->apply_unsafe($m2);
$O4->apply_unsafe($Q1);
$O4->apply_unsafe($R1);
$O4->apply_unsafe($S1);
$O4->apply_unsafe($T1);
$O4->apply_unsafe($U1);
$O4->apply_unsafe($V1);
$O4->apply_unsafe($W1);
$O4->apply_unsafe($X1);
$O4->apply_unsafe($Y1);
$O4->apply_unsafe($K2);
$O4->apply_unsafe($Z1);
$O4->apply_unsafe($c2);
$O4->apply_unsafe($d2);
$O4->apply_unsafe($e2);
$O4->apply_unsafe($f2);
$O4->apply_unsafe($g2);
$O4->apply_unsafe($h2);
$O4->apply_unsafe($i2);
$O4->apply_unsafe($P4);
$O4->apply_unsafe($q2);
$O4->apply_unsafe($k2);
$O4->apply_unsafe($r2);
$O4->apply_unsafe($l2);
$O4->apply_unsafe($m2);
$c5->apply_unsafe($Q1);
$c5->apply_unsafe($R1);
$c5->apply_unsafe($S1);
$c5->apply_unsafe($T1);
$c5->apply_unsafe($U1);
$c5->apply_unsafe($V1);
$c5->apply_unsafe($W1);
$c5->apply_unsafe($X1);
$c5->apply_unsafe($Y1);
$c5->apply_unsafe($K2);
$c5->apply_unsafe($Z1);
$c5->apply_unsafe($c2);
$c5->apply_unsafe($d2);
$c5->apply_unsafe($e2);
$c5->apply_unsafe($f2);
$c5->apply_unsafe($g2);
$c5->apply_unsafe($h2);
$c5->apply_unsafe($i2);
$c5->apply_unsafe($d5);
$c5->apply_unsafe($q2);
$c5->apply_unsafe($k2);
$c5->apply_unsafe($r2);
$c5->apply_unsafe($l2);
$c5->apply_unsafe($m2);
$l5->apply_unsafe($Q1);
$l5->apply_unsafe($R1);
$l5->apply_unsafe($S1);
$l5->apply_unsafe($T1);
$l5->apply_unsafe($U1);
$l5->apply_unsafe($V1);
$l5->apply_unsafe($W1);
$l5->apply_unsafe($X1);
$l5->apply_unsafe($Y1);
$l5->apply_unsafe($K2);
$l5->apply_unsafe($Z1);
$l5->apply_unsafe($c2);
$l5->apply_unsafe($d2);
$l5->apply_unsafe($e2);
$l5->apply_unsafe($f2);
$l5->apply_unsafe($g2);
$l5->apply_unsafe($h2);
$l5->apply_unsafe($i2);
$l5->apply_unsafe($m5);
$l5->apply_unsafe($q2);
$l5->apply_unsafe($k2);
$l5->apply_unsafe($r2);
$l5->apply_unsafe($l2);
$l5->apply_unsafe($m2);
$u5->apply_unsafe($Q1);
$u5->apply_unsafe($R1);
$u5->apply_unsafe($S1);
$u5->apply_unsafe($T1);
$u5->apply_unsafe($U1);
$u5->apply_unsafe($V1);
$u5->apply_unsafe($W1);
$u5->apply_unsafe($X1);
$u5->apply_unsafe($Y1);
$u5->apply_unsafe($K2);
$u5->apply_unsafe($Z1);
$u5->apply_unsafe($c2);
$u5->apply_unsafe($d2);
$u5->apply_unsafe($e2);
$u5->apply_unsafe($f2);
$u5->apply_unsafe($g2);
$u5->apply_unsafe($h2);
$u5->apply_unsafe($i2);
$u5->apply_unsafe($v5);
$u5->apply_unsafe($q2);
$u5->apply_unsafe($k2);
$u5->apply_unsafe($r2);
$u5->apply_unsafe($l2);
$u5->apply_unsafe($m2);
$D5->apply_unsafe($Q1);
$D5->apply_unsafe($R1);
$D5->apply_unsafe($S1);
$D5->apply_unsafe($T1);
$D5->apply_unsafe($U1);
$D5->apply_unsafe($V1);
$D5->apply_unsafe($W1);
$D5->apply_unsafe($X1);
$D5->apply_unsafe($Y1);
$D5->apply_unsafe($K2);
$D5->apply_unsafe($Z1);
$D5->apply_unsafe($c2);
$D5->apply_unsafe($d2);
$D5->apply_unsafe($e2);
$D5->apply_unsafe($f2);
$D5->apply_unsafe($g2);
$D5->apply_unsafe($h2);
$D5->apply_unsafe($i2);
$D5->apply_unsafe($E5);
$D5->apply_unsafe($q2);
$D5->apply_unsafe($k2);
$D5->apply_unsafe($r2);
$D5->apply_unsafe($l2);
$D5->apply_unsafe($m2);
$V5->apply_unsafe($Q1);
$V5->apply_unsafe($R1);
$V5->apply_unsafe($S1);
$V5->apply_unsafe($T1);
$V5->apply_unsafe($U1);
$V5->apply_unsafe($V1);
$V5->apply_unsafe($W1);
$V5->apply_unsafe($X1);
$V5->apply_unsafe($Y1);
$V5->apply_unsafe($Z1);
$V5->apply_unsafe($c2);
$V5->apply_unsafe($d2);
$V5->apply_unsafe($u);
$V5->apply_unsafe($e2);
$V5->apply_unsafe($f2);
$V5->apply_unsafe($g2);
$V5->apply_unsafe($I2);
$V5->apply_unsafe($h2);
$V5->apply_unsafe($V2);
$V5->apply_unsafe($i2);
$V5->apply_unsafe($W5);
$V5->apply_unsafe($q2);
$V5->apply_unsafe($k2);
$V5->apply_unsafe($l2);
$V5->apply_unsafe($m2);
$g6->apply_unsafe($Q1);
$g6->apply_unsafe($R1);
$g6->apply_unsafe($S1);
$g6->apply_unsafe($T1);
$g6->apply_unsafe($U1);
$g6->apply_unsafe($V1);
$g6->apply_unsafe($W1);
$g6->apply_unsafe($X1);
$g6->apply_unsafe($Y1);
$g6->apply_unsafe($Z1);
$g6->apply_unsafe($c2);
$g6->apply_unsafe($d2);
$g6->apply_unsafe($e2);
$g6->apply_unsafe($f2);
$g6->apply_unsafe($g2);
$g6->apply_unsafe($h2);
$g6->apply_unsafe($i2);
$g6->apply_unsafe($h6);
$g6->apply_unsafe($k2);
$g6->apply_unsafe($l2);
$g6->apply_unsafe($m2);
$S6->apply_unsafe($P3);
$S6->apply_unsafe($Q3);
$S6->apply_unsafe($R3);
$S6->apply_unsafe($S3);
$S6->apply_unsafe($T3);
$S6->apply_unsafe($U3);
$d7->apply_unsafe($P3);
$d7->apply_unsafe($Q3);
$d7->apply_unsafe($R3);
$d7->apply_unsafe($S3);
$d7->apply_unsafe($T3);
$d7->apply_unsafe($U3);
$u7->apply_unsafe($P3);
$u7->apply_unsafe($Q3);
$u7->apply_unsafe($R3);
$u7->apply_unsafe($S3);
$u7->apply_unsafe($T3);
$u7->apply_unsafe($U3);
$D7->apply_unsafe($P3);
$D7->apply_unsafe($Q3);
$D7->apply_unsafe($R3);
$D7->apply_unsafe($S3);
$D7->apply_unsafe($T3);
$D7->apply_unsafe($U3);
$M7->apply_unsafe($P3);
$M7->apply_unsafe($Q3);
$M7->apply_unsafe($R3);
$M7->apply_unsafe($S3);
$M7->apply_unsafe($T3);
$M7->apply_unsafe($U3);
$X7->apply_unsafe($P3);
$i8->apply_unsafe($P3);
$K8->apply_unsafe($Q3);
$S8->apply_unsafe($Q3);
$d9->apply_unsafe($Q3);
$u9->apply_unsafe($Q3);
$G9->apply_unsafe($Q3);
$S9->apply_unsafe($Q3);
$ua->apply_unsafe($R3);
$Da->apply_unsafe($R3);
$La->apply_unsafe($R3);
$gb->apply_unsafe($R3);
$Pb->apply_unsafe($T3);
$cc->apply_unsafe($T3);
$pc->apply_unsafe($T3);
$Ac->apply_unsafe($T3);
$Uc->apply_unsafe($T3);
$Ed->apply_unsafe($U3);
$Md->apply_unsafe($U3);
$de->apply_unsafe($U3);
$Ce->apply_unsafe($K2);
$Ye->apply_unsafe($W3);
$hf->apply_unsafe($W3);
$Ef->apply_unsafe($F);
$Lf->apply_unsafe($F);
$Tf->apply_unsafe($F);
$fg->apply_unsafe($F);
$Ig->apply_unsafe($u);
$Xg->apply_unsafe($u);
$kh->apply_unsafe($u);
$th->apply_unsafe($u);
$Rh->apply_unsafe($Sh);
$fi->apply_unsafe($X3);
$Fj->apply_unsafe($X3);
$uk->apply_unsafe($vk);
$Tk->apply_unsafe($Y3);
$il->apply_unsafe($Y3);
$Hl->apply_unsafe($Y3);
$Tl->apply_unsafe($Y3);
$mn->apply_unsafe($vk);
$En->apply_unsafe($I2);
$Ln->apply_unsafe($I2);
$Tn->apply_unsafe($I2);
$vo->apply_unsafe($Sh);
$Go->apply_unsafe($V2);
$No->apply_unsafe($V2);
$lp->apply_unsafe($Z3);
$yp->apply_unsafe($Z3);
$Gp->apply_unsafe($Z3);
$ni::self=$kr;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($T)for@$H;
&$_($d1)for@$w;
&$_($h1)for@$H;
&$_($l1)for@$w;
&$_($p1)for@$w;
&$_($t1)for@$w;
&$_($x1)for@$H;
&$_($F1)for@$w;
&$_($J1)for@$w;
&$_($N1)for@$H;
&$_($C2)for@$w;
&$_($F2)for@$w;
&$_($J2)for@$M2;
&$_($P2)for@$w;
&$_($R2)for@$w;
&$_($U2)for@$X2;
&$_($d3)for@$w;
&$_($g3)for@$i3;
&$_($m3)for@$w;
&$_($p3)for@$r3;
&$_($v3)for@$w;
&$_($y3)for@$A3;
&$_($C3)for@$D3;
&$_($G3)for@$w;
&$_($J3)for@$w;
&$_($M3)for@$O3;
&$_($i4)for@$w;
&$_($l4)for@$n4;
&$_($p4)for@$q4;
&$_($w4)for@$w;
&$_($z4)for@$B4;
&$_($D4)for@$E4;
&$_($L4)for@$w;
&$_($O4)for@$Q4;
&$_($U4)for@$w;
&$_($X4)for@$w;
&$_($c5)for@$e5;
&$_($i5)for@$w;
&$_($l5)for@$n5;
&$_($r5)for@$w;
&$_($u5)for@$w5;
&$_($A5)for@$w;
&$_($D5)for@$F5;
&$_($H5)for@$I5;
&$_($K5)for@$L5;
&$_($P5)for@$w;
&$_($S5)for@$w;
&$_($V5)for@$X5;
&$_($d6)for@$w;
&$_($g6)for@$i6;
&$_($k6)for@$l6;
&$_($v6)for@$w6;
&$_($A6)for@$B6;
&$_($D6)for@$E6;
&$_($G6)for@$H6;
&$_($P6)for@$w;
&$_($S6)for@$T6;
&$_($Y6)for@$w;
&$_($d7)for@$e7;
&$_($j7)for@$w;
&$_($n7)for@$w;
&$_($r7)for@$w;
&$_($u7)for@$v7;
&$_($A7)for@$w;
&$_($D7)for@$E7;
&$_($J7)for@$w;
&$_($M7)for@$N7;
&$_($P7)for@$Q7;
&$_($U7)for@$w;
&$_($X7)for@$Y7;
&$_($f8)for@$w;
&$_($i8)for@$j8;
&$_($l8)for@$m8;
&$_($t8)for@$u8;
&$_($w8)for@$x8;
&$_($H8)for@$w;
&$_($K8)for@$L8;
&$_($P8)for@$w;
&$_($S8)for@$T8;
&$_($Y8)for@$w;
&$_($d9)for@$e9;
&$_($j9)for@$w;
&$_($n9)for@$w;
&$_($r9)for@$w;
&$_($u9)for@$v9;
&$_($z9)for@$w;
&$_($D9)for@$w;
&$_($G9)for@$H9;
&$_($L9)for@$w;
&$_($P9)for@$w;
&$_($S9)for@$T9;
&$_($V9)for@$W9;
&$_($da)for@$ea;
&$_($ra)for@$w;
&$_($ua)for@$va;
&$_($Aa)for@$w;
&$_($Da)for@$Ea;
&$_($Ia)for@$w;
&$_($La)for@$Ma;
&$_($Ra)for@$w;
&$_($Ua)for@$w;
&$_($Ya)for@$w;
&$_($db)for@$w;
&$_($gb)for@$hb;
&$_($jb)for@$kb;
&$_($pb)for@$qb;
&$_($Ib)for@$w;
&$_($Mb)for@$w;
&$_($Pb)for@$Qb;
&$_($Ub)for@$w;
&$_($Xb)for@$w;
&$_($cc)for@$dc;
&$_($ic)for@$w;
&$_($mc)for@$w;
&$_($pc)for@$qc;
&$_($uc)for@$w;
&$_($xc)for@$w;
&$_($Ac)for@$Bc;
&$_($Fc)for@$w;
&$_($Jc)for@$w;
&$_($Nc)for@$w;
&$_($Rc)for@$w;
&$_($Uc)for@$Vc;
&$_($Xc)for@$Yc;
&$_($fd)for@$gd;
&$_($td)for@$w;
&$_($xd)for@$w;
&$_($Bd)for@$w;
&$_($Ed)for@$Fd;
&$_($Jd)for@$w;
&$_($Md)for@$Nd;
&$_($Rd)for@$w;
&$_($Vd)for@$w;
&$_($Yd)for@$w;
&$_($de)for@$ee;
&$_($ge)for@$he;
&$_($me)for@$ne;
&$_($ze)for@$w;
&$_($Ce)for@$De;
&$_($Fe)for@$Ge;
&$_($Me)for@$Ne;
&$_($Ve)for@$w;
&$_($Ye)for@$Ze;
&$_($ef)for@$w;
&$_($hf)for@$if;
&$_($kf)for@$lf;
&$_($qf)for@$rf;
&$_($Bf)for@$w;
&$_($Ef)for@$Ff;
&$_($If)for@$w;
&$_($Lf)for@$Mf;
&$_($Qf)for@$w;
&$_($Tf)for@$Uf;
&$_($Xf)for@$w;
&$_($cg)for@$w;
&$_($fg)for@$gg;
&$_($ig)for@$jg;
&$_($og)for@$pg;
&$_($Ag)for@$w;
&$_($Dg)for@$w;
&$_($Fg)for@$w;
&$_($Ig)for@$Jg;
&$_($Ng)for@$w;
&$_($Qg)for@$w;
&$_($Ug)for@$w;
&$_($Xg)for@$Yg;
&$_($eh)for@$w;
&$_($hh)for@$w;
&$_($kh)for@$lh;
&$_($qh)for@$w;
&$_($th)for@$uh;
&$_($wh)for@$xh;
&$_($Ch)for@$Dh;
&$_($Oh)for@$w;
&$_($Rh)for@$Th;
&$_($ci)for@$w;
&$_($fi)for@$gi;
&$_($li)for@$w;
&$_($pi)for@$w;
&$_($ti)for@$w;
&$_($xi)for@$w;
&$_($Bi)for@$w;
&$_($Fi)for@$w;
&$_($Ji)for@$w;
&$_($Ni)for@$w;
&$_($Ri)for@$w;
&$_($Vi)for@$w;
&$_($Zi)for@$w;
&$_($fj)for@$w;
&$_($jj)for@$w;
&$_($nj)for@$w;
&$_($rj)for@$w;
&$_($vj)for@$w;
&$_($zj)for@$w;
&$_($Cj)for@$w;
&$_($Fj)for@$Gj;
&$_($Ij)for@$Jj;
&$_($Oj)for@$Pj;
&$_($Zj)for@$w;
&$_($fk)for@$w;
&$_($jk)for@$w;
&$_($nk)for@$w;
&$_($rk)for@$w;
&$_($uk)for@$wk;
&$_($Ik)for@$w;
&$_($Mk)for@$w;
&$_($Qk)for@$w;
&$_($Tk)for@$Uk;
&$_($Zk)for@$w;
&$_($fl)for@$w;
&$_($il)for@$jl;
&$_($ol)for@$w;
&$_($sl)for@$w;
&$_($wl)for@$w;
&$_($Al)for@$w;
&$_($El)for@$w;
&$_($Hl)for@$Il;
&$_($Ml)for@$w;
&$_($Ql)for@$w;
&$_($Tl)for@$Ul;
&$_($Wl)for@$Xl;
&$_($em)for@$fm;
&$_($pm)for@$w;
&$_($tm)for@$w;
&$_($xm)for@$w;
&$_($Bm)for@$w;
&$_($Fm)for@$w;
&$_($Jm)for@$w;
&$_($Nm)for@$w;
&$_($Rm)for@$w;
&$_($Vm)for@$w;
&$_($Zm)for@$w;
&$_($fn)for@$w;
&$_($jn)for@$w;
&$_($mn)for@$nn;
&$_($vn)for@$w;
&$_($xn)for@$w;
&$_($En)for@$Fn;
&$_($In)for@$w;
&$_($Ln)for@$Mn;
&$_($Qn)for@$w;
&$_($Tn)for@$Un;
&$_($Wn)for@$Xn;
&$_($fo)for@$go;
&$_($no)for@$w;
&$_($so)for@$w;
&$_($vo)for@$wo;
&$_($Do)for@$w;
&$_($Go)for@$Ho;
&$_($Ko)for@$w;
&$_($No)for@$Oo;
&$_($Qo)for@$Ro;
&$_($Xo)for@$Yo;
&$_($ip)for@$w;
&$_($lp)for@$mp;
&$_($rp)for@$w;
&$_($vp)for@$w;
&$_($yp)for@$zp;
&$_($Dp)for@$w;
&$_($Gp)for@$Hp;
&$_($Kp)for@$Lp;
&$_($Rp)for@$Sp;
&$_($cq)for@$dq;
&$_($iq)for@$jq;
&$_($rq)for@$sq;
&$_($Mq)for@$Nq;
&$_($Pq)for@$sq;
&$_($Uq)for@$w;
&$_($Yq)for@$w;
&$_($er)for@$w;
&$_($ir)for@$w;
&$_($kr)for@$lr;
ni->run(@ARGV);
__DATA__
