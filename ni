#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use POSIX;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/io#;
$P=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$Q=[$i,$P];
$R=[$Q];
$S=q#/io#;
$T=bless({$e,$R,$D,$S},$F);
$U=q#ni.doc:/io/cat#;
$V=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  #;
$W=[$f,$V];
$X=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$Y=[$i,$X];
$Z=[];
$c1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$d1=bless({$o,$Z,$q,$c1,$s,$t},$u);
$e1=[$n,$d1];
$f1=[$W,$Y,$e1];
$g1=q#/io/cat#;
$h1=bless({$e,$f1,$D,$g1},$F);
$i1=q#ni.doc:/io/exec#;
$j1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->connect(1 => ni("file:foo")->w)
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$k1=[$f,$j1];
$l1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$m1=[$i,$l1];
$n1=[];
$o1=q#my $e   = ni('ni:/io/exec')->new('echo', 'hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$p1=bless({$o,$n1,$q,$o1,$s,$t},$u);
$q1=[$n,$p1];
$r1=[$k1,$m1,$q1];
$s1=q#/io/exec#;
$t1=bless({$e,$r1,$D,$s1},$F);
$u1=q#ni.doc:/io/pid#;
$v1=[];
$w1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$x1=bless({$o,$v1,$q,$w1,$s,$t},$u);
$y1=[$n,$x1];
$z1=[];
$A1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$B1=bless({$o,$z1,$q,$A1,$s,$t},$u);
$C1=[$n,$B1];
$D1=[];
$E1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->connect(0 => $seq->stdout)
  ->fork;
now $grep->read_all == "1\\n3\\n5\\n7\\n9\\n";
now $seq->await == 0;
now $grep->await == 0;#;
$F1=bless({$o,$D1,$q,$E1,$s,$t},$u);
$G1=[$n,$F1];
$H1=[$y1,$C1,$G1];
$I1=q#/io/pid#;
$J1=bless({$e,$H1,$D,$I1},$F);
$K1=q#ni.doc:/lib/doc#;
$L1=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$M1=[$f,$L1];
$N1=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$O1=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$P1=[];
$Q1=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$R1=bless({$o,$P1,$q,$Q1,$s,$t},$u);
$S1=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$T1=[];
$U1=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$V1=bless({$o,$T1,$q,$U1,$s,$t},$u);
$W1=[$i,$N1,$O1,$n,$R1,$S1,$n,$V1];
$X1=[$M1,$W1];
$Y1=q#/lib/doc#;
$Z1=bless({$e,$X1,$D,$Y1},$F);
$c2=q#ni:/class#;
$d2=q#applied_to#;
$e2=q#class#;
$f2=q#class.c#;
$g2=q#io/cat.c#;
$h2=q#io/exec.c#;
$i2=q#io/fd.c#;
$j2=q#io/file.c#;
$k2=q#io/null.c#;
$l2=q#io/object.c#;
$m2=q#io/pid.c#;
$n2=q#io/str.c#;
$o2=q#lib/behavior.c#;
$p2=q#lib/branch.c#;
$q2=q#lib/dataslice.c#;
$r2=q#lib/doc.c#;
$s2=q#lib/fn.c#;
$t2=q#lib/image.c#;
$u2=q#lib/ni.c#;
$v2=q#lib/slice.c#;
$w2=q#lib/tag.c#;
$x2=q#lib/test_value.c#;
$y2=q#metaclass.c#;
$z2=q#module.c#;
$A2=q#object.c#;
$B2={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$y2,1,$z2,1,$A2,1};
$C2=q#slices#;
$D2=q#lib/test_value.c#;
$E2=q#metaclass#;
$F2=q#module#;
$G2={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$D2,1,$E2,1,$y2,1,$F2,1,$z2,1,$A2,1};
$H2=q#/module#;
$I2=q#/lib/perlbranch.b#;
$J2={};
$K2=q#ctor#;
$L2=undef;
$M2=q#dtor#;
$N2=q#methods#;
$O2=q#add#;
$P2=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$Q2=bless({$q,$P2,$s,$t},$u);
$R2=q#apply#;
$S2=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$T2=bless({$q,$S2,$s,$t},$u);
$U2={$O2,$Q2,$R2,$T2};
$V2=q#/lib/branch.b#;
$W2=q#lib/slice#;
$X2=bless({$d2,$J2,$K2,$L2,$M2,$L2,$N2,$U2,$D,$V2},$W2);
$Y2=q#lib/branch#;
$Z2=q#lib/test_value.c#;
$c3=q#lib/slice::ctors#;
$d3={};
$e3=q#my $s = shift; ni->def($s->name, $s)#;
$f3=bless({$q,$e3,$s,$t},$u);
$g3=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$h3=bless({$q,$g3,$s,$t},$u);
$i3={$D,$h3};
$j3=q#/lib/named.b#;
$k3=bless({$d2,$d3,$K2,$f3,$M2,$L2,$N2,$i3,$D,$j3},$W2);
$l3=q#lib/tag#;
$m3=q#lib/test_value.c#;
$n3=q#lib/slice::ctors#;
$o3={};
$p3=q#namespace#;
$q3=q#'ni'#;
$r3=bless({$q,$q3,$s,$t},$u);
$s3={$p3,$r3};
$t3=q#/lib/named_in_ni.b#;
$u3=bless({$d2,$o3,$K2,$L2,$M2,$L2,$N2,$s3,$D,$t3},$W2);
$v3=q#lib/test_value.c#;
$w3=q#lib/slice::ctors#;
$x3={};
$y3=q#package#;
$z3=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$A3=bless({$q,$z3,$s,$t},$u);
$B3={$y3,$A3};
$C3=q#/lib/namespaced.b#;
$D3=bless({$d2,$x3,$K2,$L2,$M2,$L2,$N2,$B3,$D,$C3},$W2);
$E3=q#lib/test_value.c#;
$F3=q#lib/slice::ctors#;
$G3={};
$H3=q#resolve#;
$I3=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$J3=bless({$q,$I3,$s,$t},$u);
$K3={$H3,$J3};
$L3=q#/lib/resolver.b#;
$M3=bless({$d2,$G3,$K2,$L2,$M2,$L2,$N2,$K3,$D,$L3},$W2);
$N3=q#lib/test_value.c#;
$O3=q#lib/slice::ctors#;
$P3=[$X2,$k3,$u3,$D3,$M3];
$Q3=bless({$D,$I2,$C2,$P3},$l3);
$R3=q#lib/tag::ctors#;
$S3={};
$T3=q#my $s = shift; $s->apply($s->package)#;
$U3=bless({$q,$T3,$s,$t},$u);
$V3=q#instantiate#;
$W3=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$X3=bless({$q,$W3,$s,$t},$u);
$Y3={$V3,$X3};
$Z3=q#/lib/class_init.b#;
$c4=bless({$d2,$S3,$K2,$U3,$M2,$L2,$N2,$Y3,$D,$Z3},$W2);
$d4=q#lib/test_value.c#;
$e4=q#lib/slice::ctors#;
$f4=q#io/cat#;
$g4=q#io/exec#;
$h4=q#io/fd#;
$i4=q#io/file#;
$j4=q#io/null#;
$k4=q#io/object#;
$l4=q#io/pid#;
$m4=q#io/str#;
$n4=q#lib/behavior#;
$o4=q#lib/dataslice#;
$p4=q#lib/image#;
$q4=q#lib/ni#;
$r4=q#lib/test_value#;
$s4=q#lib/test_value.c#;
$t4=q#object#;
$u4={$e2,1,$f2,1,$f4,1,$g2,1,$g4,1,$h2,1,$h4,1,$i2,1,$i4,1,$j2,1,$j4,1,$k2,1,$k4,1,$l2,1,$l4,1,$m2,1,$m4,1,$n2,1,$n4,1,$o2,1,$Y2,1,$p2,1,$o4,1,$q2,1,$F,1,$r2,1,$u,1,$s2,1,$p4,1,$t2,1,$q4,1,$u2,1,$W2,1,$v2,1,$l3,1,$w2,1,$r4,1,$s4,1,$E2,1,$y2,1,$F2,1,$z2,1,$t4,1,$A2,1};
$v4=q#/object#;
$w4={};
$x4=q#ni 'ni:/' . ref shift#;
$y4=bless({$q,$x4,$s,$t},$u);
$z4={$e2,$y4};
$A4=q#/lib/instance.b#;
$B4=bless({$d2,$w4,$K2,$L2,$M2,$L2,$N2,$z4,$D,$A4},$W2);
$C4=q#lib/test_value.c#;
$D4=q#lib/slice::ctors#;
$E4=[$B4];
$F4=bless({$d2,$u4,$D,$v4,$C2,$E4},$A2);
$G4=q#object.c::ctors#;
$H4=q#lib/test_value.c#;
$I4={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$n4,1,$o2,1,$Y2,1,$p2,1,$o4,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$W2,1,$v2,1,$l3,1,$w2,1,$H4,1,$E2,1,$y2,1,$F2,1,$z2,1,$A2,1};
$J4=q#/lib/behavior#;
$K4={};
$L4=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$M4=bless({$q,$L4,$s,$t},$u);
$N4={$e,$M4};
$O4=q#/lib/documentable.b#;
$P4=bless({$d2,$K4,$K2,$L2,$M2,$L2,$N2,$N4,$D,$O4},$W2);
$Q4=q#lib/test_value.c#;
$R4=q#lib/slice::ctors#;
$S4=[$F4,$P4];
$T4=bless({$d2,$I4,$D,$J4,$C2,$S4},$o2);
$U4=q#lib/behavior.c::ctors#;
$V4=q#lib/test_value.c#;
$W4={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$Y2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$V4,1,$E2,1,$y2,1,$F2,1,$z2,1,$A2,1};
$X4=q#/lib/definition.b#;
$Y4={};
$Z4=q#def#;
$c5=q#shift->add(ni('ni:/lib/slice')->new(@_))#;
$d5=bless({$q,$c5,$s,$t},$u);
$e5={$Z4,$d5};
$f5=q#/lib/definition_def.b#;
$g5=bless({$d2,$Y4,$K2,$L2,$M2,$L2,$N2,$e5,$D,$f5},$W2);
$h5=q#lib/test_value.c#;
$i5=q#lib/slice::ctors#;
$j5={};
$k5=q#ro#;
$l5=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$m5=bless({$q,$l5,$s,$t},$u);
$n5=q#rw#;
$o5=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$p5=bless({$q,$o5,$s,$t},$u);
$q5={$k5,$m5,$n5,$p5};
$r5=q#/lib/accessor.b#;
$s5=bless({$d2,$j5,$K2,$L2,$M2,$L2,$N2,$q5,$D,$r5},$W2);
$t5=q#lib/test_value.c#;
$u5=q#lib/slice::ctors#;
$v5={};
$w5=q#(""#;
$x5=q#shift->name#;
$y5=bless({$q,$x5,$s,$t},$u);
$z5={$w5,$y5};
$A5=q#/lib/name_as_string.b#;
$B5=bless({$d2,$v5,$K2,$L2,$M2,$L2,$N2,$z5,$D,$A5},$W2);
$C5=q#lib/test_value.c#;
$D5=q#lib/slice::ctors#;
$E5={};
$F5=q#(eq#;
$G5=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$H5=bless({$q,$G5,$s,$t},$u);
$I5={$F5,$H5};
$J5=q#/lib/ref_eq.b#;
$K5=bless({$d2,$E5,$K2,$L2,$M2,$L2,$N2,$I5,$D,$J5},$W2);
$L5=q#lib/test_value.c#;
$M5=q#lib/slice::ctors#;
$N5={};
$O5=q#defdata#;
$P5=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$Q5=bless({$q,$P5,$s,$t},$u);
$R5={$O5,$Q5};
$S5=q#/lib/definition_defdata.b#;
$T5=bless({$d2,$N5,$K2,$L2,$M2,$L2,$N2,$R5,$D,$S5},$W2);
$U5=q#lib/test_value.c#;
$V5=q#lib/slice::ctors#;
$W5=[$g5,$s5,$B5,$K5,$T5];
$X5=bless({$d2,$W4,$D,$X4,$C2,$W5},$Y2);
$Y5=q#lib/branch::ctors#;
$Z5=[$Q3,$c4,$F4,$T4,$X5];
$c6=bless({$d2,$G2,$D,$H2,$C2,$Z5},$z2);
$d6=q#module.c::ctors#;
$e6={};
$f6=q#DESTROY#;
$g6=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$h6=bless({$q,$g6,$s,$t},$u);
$i6=q#new#;
$j6=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$k6=bless({$q,$j6,$s,$t},$u);
$l6={$f6,$h6,$i6,$k6};
$m6=q#/lib/instantiable.b#;
$n6=bless({$d2,$e6,$N2,$l6,$D,$m6},$W2);
$o6=q#lib/test_value.c#;
$p6=q#lib/slice::ctors#;
$q6={};
$r6=q#child#;
$s6=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$t6=bless({$q,$s6,$s,$t},$u);
$u6={$r6,$t6};
$v6=q#/lib/subclass.b#;
$w6=bless({$d2,$q6,$K2,$L2,$M2,$L2,$N2,$u6,$D,$v6},$W2);
$x6=q#lib/test_value.c#;
$y6=q#lib/slice::ctors#;
$z6=[$c6,$n6,$c4,$c6,$w6];
$A6=bless({$d2,$B2,$D,$E,$C2,$z6},$f2);
$B6=q#class.c::ctors#;
$C6=q#ni:/class.c#;
$D6={$f2,1};
$E6=q#/class.c#;
$F6={$f2,1,$z2,1};
$G6=q#/module.c#;
$H6=q#lib/test_value.c#;
$I6={$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$H6,1,$z2,1,$A2,1};
$J6=q#/object.c#;
$K6=[$A6];
$L6=bless({$d2,$I6,$D,$J6,$C2,$K6},$E2);
$M6=q#metaclass::ctors#;
$N6={$f2,1,$o2,1,$p2,1,$q2,1,$v2,1,$w2,1,$z2,1};
$O6=q#/lib/behavior.c#;
$P6=[$L6];
$Q6=bless({$d2,$N6,$D,$O6,$C2,$P6},$E2);
$R6=q#metaclass::ctors#;
$S6=[$L6,$n6,$Q6];
$T6=bless({$d2,$F6,$D,$G6,$C2,$S6},$E2);
$U6=q#metaclass::ctors#;
$V6=[$T6];
$W6=bless({$d2,$D6,$D,$E6,$C2,$V6},$E2);
$X6=q#metaclass::ctors#;
$Y6=q#ni:/io/cat#;
$Z6={$f4,1};
$c7={$f4,1,$g4,1,$h4,1,$i4,1,$j4,1,$k4,1,$l4,1,$m4,1};
$d7=q#/io/object#;
$e7={};
$f7=q#(bool#;
$g7=[];
$h7=bless({$o,$g7,$q,1,$s,$t},$u);
$i7={$f7,$h7};
$j7=q#/io/object_ops.b#;
$k7=bless({$d2,$e7,$K2,$L2,$M2,$L2,$N2,$i7,$D,$j7},$W2);
$l7=q#lib/slice::ctors#;
$m7={};
$n7=q#into#;
$o7=[];
$p7=q#local $_;
my ($self, $dest, $each) = @_;
my $n;
my $block_size = $self->can('read_size') ? $self->read_size : 32768;
while (($n = $self->read($_, $block_size)) > 0) {
  $dest->write($_);
  &$each($_, $n) && return if defined $each;
}
$self;#;
$q7=bless({$o,$o7,$q,$p7,$s,$t},$u);
$r7={$n7,$q7};
$s7=q#/io/object_stream.b#;
$t7=bless({$d2,$m7,$K2,$L2,$M2,$L2,$N2,$r7,$D,$s7},$W2);
$u7=q#lib/slice::ctors#;
$v7={};
$w7=q#die#;
$x7=[];
$y7=q#shift; die join " ", @_#;
$z7=bless({$o,$x7,$q,$y7,$s,$t},$u);
$A7=q#io_check#;
$B7=[];
$C7=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($fn, $!) unless &$check($r);
$r;#;
$D7=bless({$o,$B7,$q,$C7,$s,$t},$u);
$E7=q#io_check_defined#;
$F7=[];
$G7=q#shift->io_check(sub {defined shift}, @_)#;
$H7=bless({$o,$F7,$q,$G7,$s,$t},$u);
$I7=q#io_check_true#;
$J7=[];
$K7=q#shift->io_check(sub {shift}, @_)#;
$L7=bless({$o,$J7,$q,$K7,$s,$t},$u);
$M7={$w7,$z7,$A7,$D7,$E7,$H7,$I7,$L7};
$N7=q#/io/object_checks.b#;
$O7=bless({$d2,$v7,$K2,$L2,$M2,$L2,$N2,$M7,$D,$N7},$W2);
$P7=q#lib/slice::ctors#;
$Q7={};
$R7=q#(+#;
$S7=[];
$T7=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$U7=bless({$o,$S7,$q,$T7,$s,$t},$u);
$V7={$R7,$U7};
$W7=q#/io/object_constructors.b#;
$X7=bless({$d2,$Q7,$K2,$L2,$M2,$L2,$N2,$V7,$D,$W7},$W2);
$Y7=q#lib/slice::ctors#;
$Z7={};
$c8=q#read_all#;
$d8=[];
$e8=q#shift->into(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$f8=bless({$o,$d8,$q,$e8,$s,$t},$u);
$g8={$c8,$f8};
$h8=q#/io/object_memory.b#;
$i8=bless({$d2,$Z7,$K2,$L2,$M2,$L2,$N2,$g8,$D,$h8},$W2);
$j8=q#lib/slice::ctors#;
$k8=[$F4,$k7,$t7,$O7,$X7,$i8];
$l8=bless({$d2,$c7,$D,$d7,$C2,$k8},$l2);
$m8=q#io/object.c::ctors#;
$n8={};
$o8=[];
$p8=q#shift; +{fs => [@_]}#;
$q8=bless({$o,$o8,$q,$p8,$s,$t},$u);
$r8={$V3,$q8};
$s8=q#/io/cat_init.b#;
$t8=bless({$d2,$n8,$K2,$L2,$M2,$L2,$N2,$r8,$D,$s8},$W2);
$u8=q#lib/slice::ctors#;
$v8={};
$w8=q#read#;
$x8=[];
$y8=q#my $fs = shift->{fs};
my $n;
until (!@$fs or $n = $$fs[0]->read(@_)) {
  return $n unless defined $n;
  shift @$fs;
}
return $n;#;
$z8=bless({$o,$x8,$q,$y8,$s,$t},$u);
$A8={$w8,$z8};
$B8=q#/io/cat_read.b#;
$C8=bless({$d2,$v8,$K2,$L2,$M2,$L2,$N2,$A8,$D,$B8},$W2);
$D8=q#lib/slice::ctors#;
$E8=[$l8,$t8,$C8];
$F8=bless({$d2,$Z6,$D,$g1,$C2,$E8},$g2);
$G8=q#io/cat.c::ctors#;
$H8=q#ni:/io/cat.c#;
$I8={$g2,1};
$J8=q#/io/cat.c#;
$K8={$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1};
$L8=q#/io/object.c#;
$M8=[$L6];
$N8=bless({$d2,$K8,$D,$L8,$C2,$M8},$E2);
$O8=q#metaclass::ctors#;
$P8=[$N8];
$Q8=bless({$d2,$I8,$D,$J8,$C2,$P8},$E2);
$R8=q#metaclass::ctors#;
$S8=q#ni:/io/cat_init.b#;
$T8=q#ni:/io/cat_read.b#;
$U8=q#ni:/io/exec#;
$V8={$g4,1};
$W8={};
$X8=q#argv#;
$Y8=[];
$Z8=q#shift->{'argv'}#;
$c9=bless({$o,$Y8,$q,$Z8,$s,$t},$u);
$d9={$X8,$c9};
$e9=q#/io/exec_ro.b#;
$f9=bless({$d2,$W8,$K2,$L2,$M2,$L2,$N2,$d9,$D,$e9},$W2);
$g9=q#lib/slice::ctors#;
$h9={};
$i9=[];
$j9=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$k9=bless({$o,$i9,$q,$j9,$s,$t},$u);
$l9={$V3,$k9};
$m9=q#/io/exec_init.b#;
$n9=bless({$d2,$h9,$K2,$L2,$M2,$L2,$N2,$l9,$D,$m9},$W2);
$o9=q#lib/slice::ctors#;
$p9={};
$q9=q#connect#;
$r9=[];
$s9=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$t9=bless({$o,$r9,$q,$s9,$s,$t},$u);
$u9=q#in_pipe#;
$v9=[];
$w9=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$x9=bless({$o,$v9,$q,$w9,$s,$t},$u);
$y9=q#out_pipe#;
$z9=[];
$A9=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$B9=bless({$o,$z9,$q,$A9,$s,$t},$u);
$C9=q#setup_stdio#;
$D9=[];
$E9=q#my $self = shift;
$self->connect(0 => ni('null:')->fd->cloexec(0)) unless $self->binds_fd(0);
$self->out_pipe(1) unless $self->binds_fd(1);
$self->out_pipe(2) unless $self->binds_fd(2);
$self;#;
$F9=bless({$o,$D9,$q,$E9,$s,$t},$u);
$G9={$q9,$t9,$u9,$x9,$y9,$B9,$C9,$F9};
$H9=q#/io/exec_io_setup.b#;
$I9=bless({$d2,$p9,$K2,$L2,$M2,$L2,$N2,$G9,$D,$H9},$W2);
$J9=q#lib/slice::ctors#;
$K9={};
$L9=q#binds_fd#;
$M9=[];
$N9=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$O9=bless({$o,$M9,$q,$N9,$s,$t},$u);
$P9=q#fd#;
$Q9=[];
$R9=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$S9=bless({$o,$Q9,$q,$R9,$s,$t},$u);
$T9=q#stderr#;
$U9=[];
$V9=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$W9=bless({$o,$U9,$q,$V9,$s,$t},$u);
$X9=q#stdin#;
$Y9=[];
$Z9=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$ca=bless({$o,$Y9,$q,$Z9,$s,$t},$u);
$da=q#stdout#;
$ea=[];
$fa=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$ga=bless({$o,$ea,$q,$fa,$s,$t},$u);
$ha={$L9,$O9,$P9,$S9,$T9,$W9,$X9,$ca,$da,$ga};
$ia=q#/io/exec_io_accessors.b#;
$ja=bless({$d2,$K9,$K2,$L2,$M2,$L2,$N2,$ha,$D,$ia},$W2);
$ka=q#lib/slice::ctors#;
$la={};
$ma=q#env#;
$na=[];
$oa=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$pa=bless({$o,$na,$q,$oa,$s,$t},$u);
$qa={$ma,$pa};
$ra=q#/io/exec_env.b#;
$sa=bless({$d2,$la,$K2,$L2,$M2,$L2,$N2,$qa,$D,$ra},$W2);
$ta=q#lib/slice::ctors#;
$ua={};
$va=q#exec#;
$wa=[];
$xa=q#my $self = shift->setup_stdio->move_fds;
my @argv = (@{$$self{argv}}, @_);
$_->close for values %{$$self{external_fds}};
local %ENV = %{$$self{env}};
{ exec @argv };
$self->stderr("exec failed", $!);
1;#;
$ya=bless({$o,$wa,$q,$xa,$s,$t},$u);
$za=q#fork#;
$Aa=[];
$Ba=q#my $self = shift->setup_stdio;
my $pid  = $self->io_check_defined(*CORE::fork);
exit $self->exec(@_) unless $pid;
$_->close for values %{$$self{internal_fds}};
delete $$self{internal_fds};
ni('ni:/io/pid')->new(
  $pid,
  [@{$$self{argv}}, @_],
  $$self{env},
  %{$$self{external_fds}});#;
$Ca=bless({$o,$Aa,$q,$Ba,$s,$t},$u);
$Da=q#move_fds#;
$Ea=[];
$Fa=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{internal_fds}};
$self;#;
$Ga=bless({$o,$Ea,$q,$Fa,$s,$t},$u);
$Ha={$va,$ya,$za,$Ca,$Da,$Ga};
$Ia=q#/io/exec_fork.b#;
$Ja=bless({$d2,$ua,$K2,$L2,$M2,$L2,$N2,$Ha,$D,$Ia},$W2);
$Ka=q#lib/slice::ctors#;
$La=[$l8,$f9,$n9,$I9,$ja,$sa,$Ja];
$Ma=bless({$d2,$V8,$D,$s1,$C2,$La},$h2);
$Na=q#io/exec.c::ctors#;
$Oa=q#ni:/io/exec.c#;
$Pa={$h2,1};
$Qa=q#/io/exec.c#;
$Ra=[$N8];
$Sa=bless({$d2,$Pa,$D,$Qa,$C2,$Ra},$E2);
$Ta=q#metaclass::ctors#;
$Ua=q#ni:/io/exec_env.b#;
$Va=q#ni:/io/exec_fork.b#;
$Wa=q#ni:/io/exec_init.b#;
$Xa=q#ni:/io/exec_io_accessors.b#;
$Ya=q#ni:/io/exec_io_setup.b#;
$Za=q#ni:/io/exec_ro.b#;
$cb=q#ni:/io/fd#;
$db={$h4,1};
$eb=q#/io/fd#;
$fb={};
$gb=[];
$hb=q#shift->{'fd'}#;
$ib=bless({$o,$gb,$q,$hb,$s,$t},$u);
$jb={$P9,$ib};
$kb=q#/io/fd_readers.b#;
$lb=bless({$d2,$fb,$K2,$L2,$M2,$L2,$N2,$jb,$D,$kb},$W2);
$mb=q#lib/slice::ctors#;
$nb={};
$ob=[];
$pb=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$qb=bless({$o,$ob,$q,$pb,$s,$t},$u);
$rb={$V3,$qb};
$sb=q#/io/fd_init.b#;
$tb=bless({$d2,$nb,$K2,$L2,$M2,$L2,$N2,$rb,$D,$sb},$W2);
$ub=q#lib/slice::ctors#;
$vb={};
$wb=q#be#;
$xb=[];
$yb=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
$self->io_check_defined(*POSIX::dup2, $$self{fd}, $new);
$$self{rfh} = $$self{wfh} = undef;
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$zb=bless({$o,$xb,$q,$yb,$s,$t},$u);
$Ab={$wb,$zb};
$Bb=q#/io/fd_shell.b#;
$Cb=bless({$d2,$vb,$K2,$L2,$M2,$L2,$N2,$Ab,$D,$Bb},$W2);
$Db=q#lib/slice::ctors#;
$Eb={};
$Fb=q#cloexec#;
$Gb=[];
$Hb=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$Ib=bless({$o,$Gb,$q,$Hb,$s,$t},$u);
$Jb=q#fcntl_flag#;
$Kb=[];
$Lb=q#my ($self, $flag, $value) = @_;
$self->io_check_true(*CORE::open, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->io_check_true(
  \\&CORE::fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  shift ? $flags |= $flag : $flags &= ~$flag;
  $self->io_check_true(*CORE::fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$Mb=bless({$o,$Kb,$q,$Lb,$s,$t},$u);
$Nb=q#nonblock#;
$Ob=[];
$Pb=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$Qb=bless({$o,$Ob,$q,$Pb,$s,$t},$u);
$Rb={$Fb,$Ib,$Jb,$Mb,$Nb,$Qb};
$Sb=q#/io/fd_fcntl.b#;
$Tb=bless({$d2,$Eb,$K2,$L2,$M2,$L2,$N2,$Rb,$D,$Sb},$W2);
$Ub=q#lib/slice::ctors#;
$Vb={};
$Wb=[];
$Xb=q#shift->close#;
$Yb=bless({$o,$Wb,$q,$Xb,$s,$t},$u);
$Zb=q#close#;
$cc=[];
$dc=q#my $self = shift;
return $self if $$self{closed};
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$ec=bless({$o,$cc,$q,$dc,$s,$t},$u);
$fc={$Zb,$ec};
$gc=q#/io/fd_gc.b#;
$hc=bless({$d2,$Vb,$K2,$L2,$M2,$Yb,$N2,$fc,$D,$gc},$W2);
$ic=q#lib/slice::ctors#;
$jc={};
$kc=[];
$lc=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
my $r;
do {
  return $r if defined($r = sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$mc=bless({$o,$kc,$q,$lc,$s,$t},$u);
$nc=q#write#;
$oc=[];
$pc=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
my $r;
do {
  return $r if defined($r = syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$qc=bless({$o,$oc,$q,$pc,$s,$t},$u);
$rc={$w8,$mc,$nc,$qc};
$sc=q#/io/fd_perlio.b#;
$tc=bless({$d2,$jc,$K2,$L2,$M2,$L2,$N2,$rc,$D,$sc},$W2);
$uc=q#lib/slice::ctors#;
$vc=[$l8,$lb,$tb,$Cb,$Tb,$hc,$tc];
$wc=bless({$d2,$db,$D,$eb,$C2,$vc},$i2);
$xc=q#io/fd.c::ctors#;
$yc=q#ni:/io/fd.c#;
$zc={$i2,1};
$Ac=q#/io/fd.c#;
$Bc=[$N8];
$Cc=bless({$d2,$zc,$D,$Ac,$C2,$Bc},$E2);
$Dc=q#metaclass::ctors#;
$Ec=q#ni:/io/fd_fcntl.b#;
$Fc=q#ni:/io/fd_gc.b#;
$Gc=q#ni:/io/fd_init.b#;
$Hc=q#ni:/io/fd_perlio.b#;
$Ic=q#ni:/io/fd_readers.b#;
$Jc=q#ni:/io/fd_shell.b#;
$Kc=q#ni:/io/file#;
$Lc={$i4,1};
$Mc=q#/io/file#;
$Nc={};
$Oc=[];
$Pc=q#shift->{'name'}#;
$Qc=bless({$o,$Oc,$q,$Pc,$s,$t},$u);
$Rc={$D,$Qc};
$Sc=q#/io/file_readers.b#;
$Tc=bless({$d2,$Nc,$K2,$L2,$M2,$L2,$N2,$Rc,$D,$Sc},$W2);
$Uc=q#lib/slice::ctors#;
$Vc={};
$Wc=q#mode#;
$Xc=[];
$Yc=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$Zc=bless({$o,$Xc,$q,$Yc,$s,$t},$u);
$cd={$Wc,$Zc};
$dd=q#/io/file_accessors.b#;
$ed=bless({$d2,$Vc,$K2,$L2,$M2,$L2,$N2,$cd,$D,$dd},$W2);
$fd=q#lib/slice::ctors#;
$gd={};
$hd=[];
$id=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$jd=bless({$o,$hd,$q,$id,$s,$t},$u);
$kd={$V3,$jd};
$ld=q#/io/file_init.b#;
$md=bless({$d2,$gd,$K2,$L2,$M2,$L2,$N2,$kd,$D,$ld},$W2);
$nd=q#lib/slice::ctors#;
$od={};
$pd=q#r#;
$qd=[];
$rd=q#my $self = shift;
$$self{r} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$sd=bless({$o,$qd,$q,$rd,$s,$t},$u);
$td=[];
$ud=q#shift->r->read(@_)#;
$vd=bless({$o,$td,$q,$ud,$s,$t},$u);
$wd=q#w#;
$xd=[];
$yd=q#my $self = shift;
$$self{w} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(
    *POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$zd=bless({$o,$xd,$q,$yd,$s,$t},$u);
$Ad=[];
$Bd=q#shift->w->write(@_)#;
$Cd=bless({$o,$Ad,$q,$Bd,$s,$t},$u);
$Dd={$pd,$sd,$w8,$vd,$wd,$zd,$nc,$Cd};
$Ed=q#/io/file_io.b#;
$Fd=bless({$d2,$od,$K2,$L2,$M2,$L2,$N2,$Dd,$D,$Ed},$W2);
$Gd=q#lib/slice::ctors#;
$Hd=[$l8,$Tc,$ed,$md,$Fd];
$Id=bless({$d2,$Lc,$D,$Mc,$C2,$Hd},$j2);
$Jd=q#io/file.c::ctors#;
$Kd=q#ni:/io/file.c#;
$Ld={$j2,1};
$Md=q#/io/file.c#;
$Nd=[$N8];
$Od=bless({$d2,$Ld,$D,$Md,$C2,$Nd},$E2);
$Pd=q#metaclass::ctors#;
$Qd=q#ni:/io/file_accessors.b#;
$Rd=q#ni:/io/file_init.b#;
$Sd=q#ni:/io/file_io.b#;
$Td=q#ni:/io/file_readers.b#;
$Ud=q#ni:/io/null#;
$Vd={$j4,1};
$Wd=q#/io/null#;
$Xd={};
$Yd=[];
$Zd=q#+{fd => undef}#;
$ce=bless({$o,$Yd,$q,$Zd,$s,$t},$u);
$de={$V3,$ce};
$ee=q#/io/null_init.b#;
$fe=bless({$d2,$Xd,$K2,$L2,$M2,$L2,$N2,$de,$D,$ee},$W2);
$ge=q#lib/slice::ctors#;
$he={};
$ie=[];
$je=q#my $self = shift;
$$self{fd} ||= ni('ni:/io/fd')->new(
  $self->io_check_defined(*POSIX::open, '/dev/null', POSIX::O_RDWR));#;
$ke=bless({$o,$ie,$q,$je,$s,$t},$u);
$le=[];
$me=q#shift->fd->read(@_)#;
$ne=bless({$o,$le,$q,$me,$s,$t},$u);
$oe=[];
$pe=q#shift->fd->write(@_)#;
$qe=bless({$o,$oe,$q,$pe,$s,$t},$u);
$re={$P9,$ke,$w8,$ne,$nc,$qe};
$se=q#/io/null_io.b#;
$te=bless({$d2,$he,$K2,$L2,$M2,$L2,$N2,$re,$D,$se},$W2);
$ue=q#lib/slice::ctors#;
$ve=[$l8,$fe,$te];
$we=bless({$d2,$Vd,$D,$Wd,$C2,$ve},$k2);
$xe=q#io/null.c::ctors#;
$ye=q#ni:/io/null.c#;
$ze={$k2,1};
$Ae=q#/io/null.c#;
$Be=[$N8];
$Ce=bless({$d2,$ze,$D,$Ae,$C2,$Be},$E2);
$De=q#metaclass::ctors#;
$Ee=q#ni:/io/null_init.b#;
$Fe=q#ni:/io/null_io.b#;
$Ge=q#ni:/io/object#;
$He=q#ni:/io/object.c#;
$Ie=q#ni:/io/object_checks.b#;
$Je=q#ni:/io/object_constructors.b#;
$Ke=q#ni:/io/object_memory.b#;
$Le=q#ni:/io/object_ops.b#;
$Me=q#ni:/io/object_stream.b#;
$Ne=q#ni:/io/pid#;
$Oe={$l4,1};
$Pe={};
$Qe=q#pid#;
$Re=[];
$Se=q#shift->{'pid'}#;
$Te=bless({$o,$Re,$q,$Se,$s,$t},$u);
$Ue=q#status#;
$Ve=[];
$We=q#shift->{'status'}#;
$Xe=bless({$o,$Ve,$q,$We,$s,$t},$u);
$Ye={$Qe,$Te,$Ue,$Xe};
$Ze=q#/io/pid_readers.b#;
$cf=bless({$d2,$Pe,$K2,$L2,$M2,$L2,$N2,$Ye,$D,$Ze},$W2);
$df=q#lib/slice::ctors#;
$ef={};
$ff=[];
$gf=q#shift->await#;
$hf=bless({$o,$ff,$q,$gf,$s,$t},$u);
$if=[];
$jf=q#my ($class, $pid, $argv, $env, %external_fds) = @_;
+{pid          => $pid,
  argv         => $argv,
  env          => $env,
  external_fds => \\%external_fds,
  status       => undef};#;
$kf=bless({$o,$if,$q,$jf,$s,$t},$u);
$lf={$V3,$kf};
$mf=q#/io/pid_init.b#;
$nf=bless({$d2,$ef,$K2,$L2,$M2,$hf,$N2,$lf,$D,$mf},$W2);
$of=q#lib/slice::ctors#;
$pf={};
$qf=q#await#;
$rf=[];
$sf=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(*CORE::waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$tf=bless({$o,$rf,$q,$sf,$s,$t},$u);
$uf=q#running#;
$vf=[];
$wf=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$xf=bless({$o,$vf,$q,$wf,$s,$t},$u);
$yf={$qf,$tf,$uf,$xf};
$zf=q#/io/pid_wait.b#;
$Af=bless({$d2,$pf,$K2,$L2,$M2,$L2,$N2,$yf,$D,$zf},$W2);
$Bf=q#lib/slice::ctors#;
$Cf={};
$Df=[];
$Ef=q#shift->stdout->read(@_)#;
$Ff=bless({$o,$Df,$q,$Ef,$s,$t},$u);
$Gf=[];
$Hf=q#shift->stdin->write(@_)#;
$If=bless({$o,$Gf,$q,$Hf,$s,$t},$u);
$Jf={$w8,$Ff,$nc,$If};
$Kf=q#/io/pid_io.b#;
$Lf=bless({$d2,$Cf,$K2,$L2,$M2,$L2,$N2,$Jf,$D,$Kf},$W2);
$Mf=q#lib/slice::ctors#;
$Nf={};
$Of=[];
$Pf=q#$_[0]->{external_fds}{$_[1]}#;
$Qf=bless({$o,$Of,$q,$Pf,$s,$t},$u);
$Rf=[];
$Sf=q#shift->fd(2)#;
$Tf=bless({$o,$Rf,$q,$Sf,$s,$t},$u);
$Uf=[];
$Vf=q#shift->fd(0)#;
$Wf=bless({$o,$Uf,$q,$Vf,$s,$t},$u);
$Xf=[];
$Yf=q#shift->fd(1)#;
$Zf=bless({$o,$Xf,$q,$Yf,$s,$t},$u);
$cg={$P9,$Qf,$T9,$Tf,$X9,$Wf,$da,$Zf};
$dg=q#/io/pid_accessors.b#;
$eg=bless({$d2,$Nf,$K2,$L2,$M2,$L2,$N2,$cg,$D,$dg},$W2);
$fg=q#lib/slice::ctors#;
$gg=[$l8,$cf,$nf,$Af,$Lf,$eg];
$hg=bless({$d2,$Oe,$D,$I1,$C2,$gg},$m2);
$ig=q#io/pid.c::ctors#;
$jg=q#ni:/io/pid.c#;
$kg={$m2,1};
$lg=q#/io/pid.c#;
$mg=[$N8];
$ng=bless({$d2,$kg,$D,$lg,$C2,$mg},$E2);
$og=q#metaclass::ctors#;
$pg=q#ni:/io/pid_accessors.b#;
$qg=q#ni:/io/pid_init.b#;
$rg=q#ni:/io/pid_io.b#;
$sg=q#ni:/io/pid_readers.b#;
$tg=q#ni:/io/pid_wait.b#;
$ug=q#ni:/io/str#;
$vg={$m4,1};
$wg=q#/io/str#;
$xg={};
$yg=q#data#;
$zg=[];
$Ag=q#shift->{'data'}#;
$Bg=bless({$o,$zg,$q,$Ag,$s,$t},$u);
$Cg=q#end#;
$Dg=[];
$Eg=q#shift->{'end'}#;
$Fg=bless({$o,$Dg,$q,$Eg,$s,$t},$u);
$Gg=q#start#;
$Hg=[];
$Ig=q#shift->{'start'}#;
$Jg=bless({$o,$Hg,$q,$Ig,$s,$t},$u);
$Kg={$yg,$Bg,$Cg,$Fg,$Gg,$Jg};
$Lg=q#/io/str_ro.b#;
$Mg=bless({$d2,$xg,$K2,$L2,$M2,$L2,$N2,$Kg,$D,$Lg},$W2);
$Ng=q#lib/slice::ctors#;
$Og={};
$Pg=[];
$Qg=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$Rg=bless({$o,$Pg,$q,$Qg,$s,$t},$u);
$Sg={$V3,$Rg};
$Tg=q#/io/str_init.b#;
$Ug=bless({$d2,$Og,$K2,$L2,$M2,$L2,$N2,$Sg,$D,$Tg},$W2);
$Vg=q#lib/slice::ctors#;
$Wg={};
$Xg=[];
$Yg=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$Zg=bless({$o,$Xg,$q,$Yg,$s,$t},$u);
$ch=q#remaining#;
$dh=[];
$eh=q#my $self = shift; $$self{end} - $$self{start}#;
$fh=bless({$o,$dh,$q,$eh,$s,$t},$u);
$gh=[];
$hh=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$ih=bless({$o,$gh,$q,$hh,$s,$t},$u);
$jh={$w8,$Zg,$ch,$fh,$nc,$ih};
$kh=q#/io/str_io.b#;
$lh=bless({$d2,$Wg,$K2,$L2,$M2,$L2,$N2,$jh,$D,$kh},$W2);
$mh=q#lib/slice::ctors#;
$nh=[$l8,$Mg,$Ug,$lh];
$oh=bless({$d2,$vg,$D,$wg,$C2,$nh},$n2);
$ph=q#io/str.c::ctors#;
$qh=q#ni:/io/str.c#;
$rh={$n2,1};
$sh=q#/io/str.c#;
$th=[$N8];
$uh=bless({$d2,$rh,$D,$sh,$C2,$th},$E2);
$vh=q#metaclass::ctors#;
$wh=q#ni:/io/str_init.b#;
$xh=q#ni:/io/str_io.b#;
$yh=q#ni:/io/str_ro.b#;
$zh=q#ni:/lib/accessor.b#;
$Ah=q#ni:/lib/behavior#;
$Bh=q#ni:/lib/behavior.c#;
$Ch=q#ni:/lib/branch#;
$Dh={$Y2,1};
$Eh=q#/lib/branch#;
$Fh={};
$Gh=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$Hh=bless({$q,$Gh,$s,$t},$u);
$Ih={$V3,$Hh};
$Jh=q#/lib/branch_init.b#;
$Kh=bless({$d2,$Fh,$K2,$L2,$M2,$L2,$N2,$Ih,$D,$Jh},$W2);
$Lh=q#lib/slice::ctors#;
$Mh=[$T4,$k3,$X2,$Kh,$X5];
$Nh=bless({$d2,$Dh,$D,$Eh,$C2,$Mh},$p2);
$Oh=q#lib/branch.c::ctors#;
$Ph=q#ni:/lib/branch.b#;
$Qh=q#ni:/lib/branch.c#;
$Rh={$p2,1};
$Sh=q#/lib/branch.c#;
$Th=[$Q6];
$Uh=bless({$d2,$Rh,$D,$Sh,$C2,$Th},$E2);
$Vh=q#metaclass::ctors#;
$Wh=q#ni:/lib/branch_init.b#;
$Xh=q#ni:/lib/class_init.b#;
$Yh=q#ni:/lib/dataslice#;
$Zh={$o4,1};
$ci=q#/lib/dataslice#;
$di={};
$ei=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$fi=bless({$q,$ei,$s,$t},$u);
$gi={$V3,$fi};
$hi=q#/lib/dataslice_init.b#;
$ii=bless({$d2,$di,$K2,$L2,$M2,$L2,$N2,$gi,$D,$hi},$W2);
$ji=q#lib/slice::ctors#;
$ki={};
$li=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$mi=bless({$q,$li,$s,$t},$u);
$ni={$R2,$mi};
$oi=q#/lib/dataslice_apply.b#;
$pi=bless({$d2,$ki,$K2,$L2,$M2,$L2,$N2,$ni,$D,$oi},$W2);
$qi=q#lib/slice::ctors#;
$ri=[$T4,$ii,$pi];
$si=bless({$d2,$Zh,$D,$ci,$C2,$ri},$q2);
$ti=q#lib/dataslice.c::ctors#;
$ui=q#ni:/lib/dataslice.c#;
$vi={$q2,1};
$wi=q#/lib/dataslice.c#;
$xi=[$Q6];
$yi=bless({$d2,$vi,$D,$wi,$C2,$xi},$E2);
$zi=q#metaclass::ctors#;
$Ai=q#ni:/lib/dataslice_apply.b#;
$Bi=q#ni:/lib/dataslice_init.b#;
$Ci=q#ni:/lib/definition.b#;
$Di=q#ni:/lib/definition_def.b#;
$Ei=q#ni:/lib/definition_defdata.b#;
$Fi=q#ni:/lib/doc#;
$Gi={$F,1};
$Hi={};
$Ii=q#shift; +{name => shift, doc => []}#;
$Ji=bless({$q,$Ii,$s,$t},$u);
$Ki={$V3,$Ji};
$Li=q#/lib/doc_init.b#;
$Mi=bless({$d2,$Hi,$K2,$L2,$M2,$L2,$N2,$Ki,$D,$Li},$W2);
$Ni=q#lib/slice::ctors#;
$Oi={};
$Pi=q#'ni.doc'#;
$Qi=bless({$q,$Pi,$s,$t},$u);
$Ri={$p3,$Qi};
$Si=q#/lib/doc_namespace.b#;
$Ti=bless({$d2,$Oi,$K2,$L2,$M2,$L2,$N2,$Ri,$D,$Si},$W2);
$Ui=q#lib/slice::ctors#;
$Vi={};
$Wi=q#AUTOLOAD#;
$Xi=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$Yi=bless({$q,$Xi,$s,$t},$u);
$Zi={$Wi,$Yi};
$cj=q#/lib/doc_define.b#;
$dj=bless({$d2,$Vi,$K2,$L2,$M2,$L2,$N2,$Zi,$D,$cj},$W2);
$ej=q#lib/slice::ctors#;
$fj={};
$gj=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$hj=bless({$q,$gj,$s,$t},$u);
$ij=q#tests#;
$jj=q#my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$kj=bless({$q,$jj,$s,$t},$u);
$lj={$n,$hj,$ij,$kj};
$mj=q#/lib/doc_test.b#;
$nj=bless({$d2,$fj,$K2,$L2,$M2,$L2,$N2,$lj,$D,$mj},$W2);
$oj=q#lib/slice::ctors#;
$pj=[$F4,$k3,$Mi,$Ti,$dj,$nj];
$qj=bless({$d2,$Gi,$D,$Y1,$C2,$pj},$r2);
$rj=q#lib/doc.c::ctors#;
$sj=q#ni:/lib/doc.c#;
$tj={$r2,1};
$uj=q#/lib/doc.c#;
$vj=[$L6];
$wj=bless({$d2,$tj,$D,$uj,$C2,$vj},$E2);
$xj=q#metaclass::ctors#;
$yj=q#ni:/lib/doc_define.b#;
$zj=q#ni:/lib/doc_init.b#;
$Aj=q#ni:/lib/doc_namespace.b#;
$Bj=q#ni:/lib/doc_test.b#;
$Cj=q#ni:/lib/documentable.b#;
$Dj=q#ni:/lib/fn#;
$Ej={$u,1};
$Fj=q#/lib/fn#;
$Gj={};
$Hj=q#shift->compile#;
$Ij=bless({$q,$Hj,$s,$t},$u);
$Jj=q#compile#;
$Kj=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$Lj=bless({$q,$Kj,$s,$t},$u);
$Mj=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$Nj=bless({$q,$Mj,$s,$t},$u);
$Oj={$Jj,$Lj,$V3,$Nj};
$Pj=q#/lib/fn_init.b#;
$Qj=bless({$d2,$Gj,$K2,$Ij,$M2,$L2,$N2,$Oj,$D,$Pj},$W2);
$Rj=q#lib/slice::ctors#;
$Sj={};
$Tj=[];
$Uj=q#shift->{'annotations'}#;
$Vj=bless({$o,$Tj,$q,$Uj,$s,$t},$u);
$Wj=[];
$Xj=q#shift->{'code'}#;
$Yj=bless({$o,$Wj,$q,$Xj,$s,$t},$u);
$Zj=q#fn#;
$ck=[];
$dk=q#shift->{'fn'}#;
$ek=bless({$o,$ck,$q,$dk,$s,$t},$u);
$fk={$o,$Vj,$q,$Yj,$Zj,$ek};
$gk=q#/lib/fn_ro.b#;
$hk=bless({$d2,$Sj,$K2,$L2,$M2,$L2,$N2,$fk,$D,$gk},$W2);
$ik=q#lib/slice::ctors#;
$jk={};
$kk=[];
$lk=q#shift->{code}#;
$mk=bless({$o,$kk,$q,$lk,$s,$t},$u);
$nk=[];
$ok=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$pk=bless({$o,$nk,$q,$ok,$s,$t},$u);
$qk={$w5,$mk,$F5,$pk};
$rk=q#/lib/fn_ops.b#;
$sk=bless({$d2,$jk,$K2,$L2,$M2,$L2,$N2,$qk,$D,$rk},$W2);
$tk=q#lib/slice::ctors#;
$uk={};
$vk=q#serialize#;
$wk=[];
$xk=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$yk=bless({$o,$wk,$q,$xk,$s,$t},$u);
$zk={$vk,$yk};
$Ak=q#/lib/fn_serialize.b#;
$Bk=bless({$d2,$uk,$K2,$L2,$M2,$L2,$N2,$zk,$D,$Ak},$W2);
$Ck=q#lib/slice::ctors#;
$Dk=[$F4,$n6,$Qj,$hk,$sk,$Bk];
$Ek=bless({$d2,$Ej,$D,$Fj,$C2,$Dk},$s2);
$Fk=q#lib/fn.c::ctors#;
$Gk=q#ni:/lib/fn.c#;
$Hk={$s2,1};
$Ik=q#/lib/fn.c#;
$Jk=[$L6];
$Kk=bless({$d2,$Hk,$D,$Ik,$C2,$Jk},$E2);
$Lk=q#metaclass::ctors#;
$Mk=q#ni:/lib/fn_init.b#;
$Nk=q#ni:/lib/fn_ops.b#;
$Ok=q#ni:/lib/fn_ro.b#;
$Pk=q#ni:/lib/fn_serialize.b#;
$Qk=q#ni:/lib/global_static_test.b#;
$Rk={};
$Sk=q#now#;
$Tk=[];
$Uk=q#ni('ni:/lib/test_value')->new(shift)#;
$Vk=q#($)#;
$Wk=bless({$o,$Tk,$q,$Uk,$s,$Vk},$u);
$Xk={$Sk,$Wk};
$Yk=q#/lib/global_static_test.b#;
$Zk=bless({$d2,$Rk,$K2,$L2,$M2,$L2,$N2,$Xk,$D,$Yk},$W2);
$cl=q#main#;
$dl=q#lib/slice::ctors#;
$el=q#ni:/lib/image#;
$fl={$p4,1};
$gl=q#/lib/image#;
$hl={};
$il=[];
$jl=q#my $class = shift;
my %args  = (
  include_shebang => 1,
  include_license => 1,
  include_boot    => 1,
  include_classes => 1,
  include_run     => 1,
  local_vars      => 0,
  use_newlines    => 0,
  @_);

+{include_shebang => $args{include_shebang},
  include_license => $args{include_license},
  include_boot    => $args{include_boot},
  include_classes => $args{include_classes},
  include_run     => $args{include_run},
  local_vars      => $args{local_vars},
  use_newlines    => $args{use_newlines},

  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$kl=bless({$o,$il,$q,$jl,$s,$t},$u);
$ll={$V3,$kl};
$ml=q#/lib/image_init.b#;
$nl=bless({$d2,$hl,$K2,$L2,$M2,$L2,$N2,$ll,$D,$ml},$W2);
$ol=q#lib/slice::ctors#;
$pl={};
$ql=q#address#;
$rl=[];
$sl=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 16;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$tl=bless({$o,$rl,$q,$sl,$s,$t},$u);
$ul=q#allocate_gensym#;
$vl=[];
$wl=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$xl=bless({$o,$vl,$q,$wl,$s,$t},$u);
$yl=q#boot_side_effect#;
$zl=[];
$Al=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Bl=bless({$o,$zl,$q,$Al,$s,$t},$u);
$Cl=q#circular_links#;
$Dl=[];
$El=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$Fl=bless({$o,$Dl,$q,$El,$s,$t},$u);
$Gl=q#finalizer#;
$Hl=[];
$Il=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$Jl=bless({$o,$Hl,$q,$Il,$s,$t},$u);
$Kl=q#gensym#;
$Ll=[];
$Ml=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$Nl=bless({$o,$Ll,$q,$Ml,$s,$t},$u);
$Ol=q#is_circular#;
$Pl=[];
$Ql=q#my $self = shift;
ref $$self{visited}{$self->address($_[0])};#;
$Rl=bless({$o,$Pl,$q,$Ql,$s,$t},$u);
$Sl=q#quote#;
$Tl=[];
$Ul=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? 'undef' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$Vl=bless({$o,$Tl,$q,$Ul,$s,$t},$u);
$Wl=q#quote_array#;
$Xl=[];
$Yl=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_])
  && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$Zl=bless({$o,$Xl,$q,$Yl,$s,$t},$u);
$cm=q#quote_blessed#;
$dm=[];
$em=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$fm=bless({$o,$dm,$q,$em,$s,$t},$u);
$gm=q#quote_class#;
$hm=[];
$im=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$jm=bless({$o,$hm,$q,$im,$s,$t},$u);
$km=q#quote_hash#;
$lm=[];
$mm=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  push @{$$self{circular}}, [$a, "{" . $self->quote($k) . "}",
                                 $self->address($$v{$k})]
  if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$nm=bless({$o,$lm,$q,$mm,$s,$t},$u);
$om=q#quote_object#;
$pm=[];
$qm=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$rm=bless({$o,$pm,$q,$qm,$s,$t},$u);
$sm=q#quote_scalar#;
$tm=[];
$um=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$vm=bless({$o,$tm,$q,$um,$s,$t},$u);
$wm=q#quote_value#;
$xm=[];
$ym=q#my $self = shift;
return $self->quote_scalar($_[0]) unless ref $_[0];
return $self->quote_array($_[0])  if 'ARRAY' eq ref $_[0];
return $self->quote_hash($_[0])   if 'HASH'  eq ref $_[0];
die "cannot serialize $_[0]"      if 'CODE'  eq ref $_[0];
$self->quote_object($_[0]);#;
$zm=bless({$o,$xm,$q,$ym,$s,$t},$u);
$Am=q#reconstruction#;
$Bm=[];
$Cm=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$Dm=bless({$o,$Bm,$q,$Cm,$s,$t},$u);
$Em=q#side_effect#;
$Fm=[];
$Gm=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Hm=bless({$o,$Fm,$q,$Gm,$s,$t},$u);
$Im=[];
$Jm=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  ($$self{include_shebang} ? ("\#!/usr/bin/env perl\\n") : ()),
  ($$self{include_license} ? ("chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n") : ()),
  ($$self{include_boot}    ? ("BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n") : ()),
  ($$self{use_newlines}    ? map("$_\\n", $self->reconstruction) : $self->reconstruction),
  ($$self{include_run}     ? ("ni->run(\\@ARGV);", "\\n__DATA__\\n") : ());#;
$Km=bless({$o,$Im,$q,$Jm,$s,$t},$u);
$Lm={$ql,$tl,$ul,$xl,$yl,$Bl,$Cl,$Fl,$Gl,$Jl,$Kl,$Nl,$Ol,$Rl,$Sl,$Vl,$Wl,$Zl,$cm,$fm,$gm,$jm,$km,$nm,$om,$rm,$sm,$vm,$wm,$zm,$Am,$Dm,$Em,$Hm,$nc,$Km};
$Mm=q#/lib/image_quoting.b#;
$Nm=bless({$d2,$pl,$K2,$L2,$M2,$L2,$N2,$Lm,$D,$Mm},$W2);
$Om=q#lib/slice::ctors#;
$Pm=[$F4,$nl,$Nm];
$Qm=bless({$d2,$fl,$D,$gl,$C2,$Pm},$t2);
$Rm=q#lib/image.c::ctors#;
$Sm=q#ni:/lib/image.c#;
$Tm={$t2,1};
$Um=q#/lib/image.c#;
$Vm=[$L6];
$Wm=bless({$d2,$Tm,$D,$Um,$C2,$Vm},$E2);
$Xm=q#metaclass::ctors#;
$Ym=q#ni:/lib/image_init.b#;
$Zm=q#ni:/lib/image_quoting.b#;
$cn=q#ni:/lib/instance.b#;
$dn=q#ni:/lib/instantiable.b#;
$en=q#ni:/lib/json.b#;
$fn={};
$gn=q#json_decode#;
$hn=[];
$in=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$jn=bless({$o,$hn,$q,$in,$s,$Vk},$u);
$kn=q#json_encode#;
$ln=[];
$mn=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$nn=bless({$o,$ln,$q,$mn,$s,$Vk},$u);
$on=q#json_escape#;
$pn=[];
$qn=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$rn=bless({$o,$pn,$q,$qn,$s,$Vk},$u);
$sn=q#json_unescape#;
$tn=[];
$un=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$vn=bless({$o,$tn,$q,$un,$s,$Vk},$u);
$wn=q#json_unescape_one#;
$xn=[];
$yn=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$zn=bless({$o,$xn,$q,$yn,$s,$Vk},$u);
$An={$gn,$jn,$kn,$nn,$on,$rn,$sn,$vn,$wn,$zn};
$Bn=q#/lib/json.b#;
$Cn=bless({$d2,$fn,$K2,$L2,$M2,$L2,$N2,$An,$D,$Bn},$W2);
$Dn=q#ni#;
$En=q#lib/slice::ctors#;
$Fn=q#ni:/lib/name_as_string.b#;
$Gn=q#ni:/lib/named.b#;
$Hn=q#ni:/lib/named_in_ni.b#;
$In=q#ni:/lib/namespaced.b#;
$Jn=q#ni:/lib/ni#;
$Kn={$q4,1};
$Ln=q#/lib/ni#;
$Mn={};
$Nn=q#extend#;
$On=[];
$Pn=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$Qn=bless({$o,$On,$q,$Pn,$s,$t},$u);
$Rn=q#is_mutable#;
$Sn=[];
$Tn=q#$0 ne "-" && -w $0#;
$Un=bless({$o,$Sn,$q,$Tn,$s,$t},$u);
$Vn=q#modify#;
$Wn=[];
$Xn=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$Yn=bless({$o,$Wn,$q,$Xn,$s,$t},$u);
$Zn={$Nn,$Qn,$Rn,$Un,$Vn,$Yn};
$co=q#/lib/ni_self.b#;
$do=bless({$d2,$Mn,$K2,$L2,$M2,$L2,$N2,$Zn,$D,$co},$W2);
$eo=q#lib/slice::ctors#;
$fo={};
$go=q#exists#;
$ho=[];
$io=q#exists $_[0]->{named}{$_[1]}#;
$jo=bless({$o,$ho,$q,$io,$s,$t},$u);
$ko=q#quoted#;
$lo=[];
$mo=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$no=bless({$o,$lo,$q,$mo,$s,$t},$u);
$oo={$go,$jo,$ko,$no};
$po=q#/lib/ni_image.b#;
$qo=bless({$d2,$fo,$K2,$L2,$M2,$L2,$N2,$oo,$D,$po},$W2);
$ro=q#lib/slice::ctors#;
$so={};
$to=q#--internal/+=#;
$uo=[];
$vo=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$wo=bless({$o,$uo,$q,$vo,$s,$t},$u);
$xo=q#--internal/eval#;
$yo=[];
$zo=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$Ao=bless({$o,$yo,$q,$zo,$s,$t},$u);
$Bo=q#--internal/image#;
$Co=[];
$Do=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$Eo=bless({$o,$Co,$q,$Do,$s,$t},$u);
$Fo=q#--internal/test#;
$Go=[];
$Ho=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$Io=bless({$o,$Go,$q,$Ho,$s,$t},$u);
$Jo=q#run#;
$Ko=[];
$Lo=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$Mo=bless({$o,$Ko,$q,$Lo,$s,$t},$u);
$No={$to,$wo,$xo,$Ao,$Bo,$Eo,$Fo,$Io,$Jo,$Mo};
$Oo=q#/lib/ni_main.b#;
$Po=bless({$d2,$so,$K2,$L2,$M2,$L2,$N2,$No,$D,$Oo},$W2);
$Qo=q#lib/slice::ctors#;
$Ro={};
$So=[];
$To=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$Uo=bless({$o,$So,$q,$To,$s,$t},$u);
$Vo=q#resolver_for#;
$Wo=[];
$Xo=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$Yo=bless({$o,$Wo,$q,$Xo,$s,$t},$u);
$Zo={$H3,$Uo,$Vo,$Yo};
$cp=q#/lib/ni_resolver.b#;
$dp=bless({$d2,$Ro,$K2,$L2,$M2,$L2,$N2,$Zo,$D,$cp},$W2);
$ep=q#lib/slice::ctors#;
$fp=[$F4,$do,$qo,$Po,$dp];
$gp=bless({$d2,$Kn,$D,$Ln,$C2,$fp},$u2);
$hp=q#lib/ni.c::ctors#;
$ip=q#ni:/lib/ni.c#;
$jp={$u2,1};
$kp=q#/lib/ni.c#;
$lp=[$L6];
$mp=bless({$d2,$jp,$D,$kp,$C2,$lp},$E2);
$np=q#metaclass::ctors#;
$op=q#ni:/lib/ni_image.b#;
$pp=q#ni:/lib/ni_main.b#;
$qp=q#ni:/lib/ni_resolver.b#;
$rp=q#ni:/lib/ni_self.b#;
$sp=q#ni:/lib/ni_static_util.b#;
$tp={};
$up=q#abbrev#;
$vp=[];
$wp=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$xp=bless({$o,$vp,$q,$wp,$s,$t},$u);
$yp=q#dor#;
$zp=[];
$Ap=q#defined $_[0] ? $_[0] : $_[1]#;
$Bp=bless({$o,$zp,$q,$Ap,$s,$t},$u);
$Cp=q#indent#;
$Dp=[];
$Ep=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$Fp=bless({$o,$Dp,$q,$Ep,$s,$t},$u);
$Gp=q#max#;
$Hp=[];
$Ip=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$Jp=bless({$o,$Hp,$q,$Ip,$s,$t},$u);
$Kp=q#maxstr#;
$Lp=[];
$Mp=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$Np=bless({$o,$Lp,$q,$Mp,$s,$t},$u);
$Op=q#mean#;
$Pp=[];
$Qp=q#sum(@_) / (@_ || 1)#;
$Rp=bless({$o,$Pp,$q,$Qp,$s,$t},$u);
$Sp=q#min#;
$Tp=[];
$Up=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$Vp=bless({$o,$Tp,$q,$Up,$s,$t},$u);
$Wp=q#minstr#;
$Xp=[];
$Yp=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$Zp=bless({$o,$Xp,$q,$Yp,$s,$t},$u);
$cq=q#sgr#;
$dq=[];
$eq=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$fq=bless({$o,$dq,$q,$eq,$s,$t},$u);
$gq=q#sr#;
$hq=[];
$iq=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$jq=bless({$o,$hq,$q,$iq,$s,$t},$u);
$kq=q#sum#;
$lq=[];
$mq=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$nq=bless({$o,$lq,$q,$mq,$s,$t},$u);
$oq=q#swap#;
$pq=[];
$qq=q#@_[0, 1] = @_[1, 0]#;
$rq=bless({$o,$pq,$q,$qq,$s,$t},$u);
$sq={$up,$xp,$yp,$Bp,$Cp,$Fp,$Gp,$Jp,$Kp,$Np,$Op,$Rp,$Sp,$Vp,$Wp,$Zp,$cq,$fq,$gq,$jq,$kq,$nq,$oq,$rq};
$tq=q#/lib/ni_static_util.b#;
$uq=bless({$d2,$tp,$K2,$L2,$M2,$L2,$N2,$sq,$D,$tq},$W2);
$vq=q#lib/slice::ctors#;
$wq=q#ni:/lib/perlbranch.b#;
$xq=q#ni:/lib/ref_eq.b#;
$yq=q#ni:/lib/resolver.b#;
$zq=q#ni:/lib/slice#;
$Aq={$W2,1};
$Bq=q#/lib/slice#;
$Cq=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$Dq=bless({$q,$Cq,$s,$t},$u);
$Eq=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$Fq=bless({$q,$Eq,$s,$t},$u);
$Gq=q#lib/slice::apply#;
$Hq=q#lib/slice::apply_unsafe#;
$Iq={};
$Jq=q#apply_unsafe#;
$Kq={$R2,$Dq,$Jq,$Fq};
$Lq=q#/lib/slice.b#;
$Mq=bless({$d2,$Iq,$N2,$Kq,$D,$Lq},$W2);
$Nq=q#lib/slice::ctors#;
$Oq={};
$Pq=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$Qq=bless({$q,$Pq,$s,$t},$u);
$Rq={$V3,$Qq};
$Sq=q#/lib/slice_init.b#;
$Tq=bless({$d2,$Oq,$N2,$Rq,$D,$Sq},$W2);
$Uq=q#lib/slice::ctors#;
$Vq={};
$Wq=[];
$Xq=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$Yq=bless({$o,$Wq,$q,$Xq,$s,$t},$u);
$Zq={$vk,$Yq};
$cr=q#/lib/slice_serialize.b#;
$dr=bless({$d2,$Vq,$K2,$L2,$M2,$L2,$N2,$Zq,$D,$cr},$W2);
$er=q#lib/slice::ctors#;
$fr=[$T4,$k3,$Mq,$Tq,$dr];
$gr=bless({$d2,$Aq,$D,$Bq,$C2,$fr},$v2);
$hr=q#lib/slice.c::ctors#;
$ir=q#ni:/lib/slice.b#;
$jr=q#ni:/lib/slice.c#;
$kr={$v2,1};
$lr=q#/lib/slice.c#;
$mr=[$Q6];
$nr=bless({$d2,$kr,$D,$lr,$C2,$mr},$E2);
$or=q#metaclass::ctors#;
$pr=q#ni:/lib/slice_init.b#;
$qr=q#ni:/lib/slice_serialize.b#;
$rr=q#ni:/lib/static_fn.b#;
$sr={};
$tr=[];
$ur=q#ni('ni:/lib/fn')->new(@_)#;
$vr=bless({$o,$tr,$q,$ur,$s,$Vk},$u);
$wr=q#fp#;
$xr=[];
$yr=q#ni('ni:/lib/fn')->new(@_)#;
$zr=q#($$)#;
$Ar=bless({$o,$xr,$q,$yr,$s,$zr},$u);
$Br={$Zj,$vr,$wr,$Ar};
$Cr=q#/lib/static_fn.b#;
$Dr=bless({$d2,$sr,$K2,$L2,$M2,$L2,$N2,$Br,$D,$Cr},$W2);
$Er=q#lib/slice::ctors#;
$Fr=q#ni:/lib/subclass.b#;
$Gr=q#ni:/lib/tag#;
$Hr={$l3,1};
$Ir=q#/lib/tag#;
$Jr={};
$Kr=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$Lr=bless({$q,$Kr,$s,$t},$u);
$Mr={$R2,$Lr};
$Nr=q#/lib/tag.b#;
$Or=bless({$d2,$Jr,$K2,$L2,$M2,$L2,$N2,$Mr,$D,$Nr},$W2);
$Pr=q#lib/slice::ctors#;
$Qr={};
$Rr=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$Sr=bless({$q,$Rr,$s,$t},$u);
$Tr={$V3,$Sr};
$Ur=q#/lib/tag_init.b#;
$Vr=bless({$d2,$Qr,$K2,$L2,$M2,$L2,$N2,$Tr,$D,$Ur},$W2);
$Wr=q#lib/slice::ctors#;
$Xr=[$T4,$k3,$Or,$Vr];
$Yr=bless({$d2,$Hr,$D,$Ir,$C2,$Xr},$w2);
$Zr=q#lib/tag.c::ctors#;
$cs=q#ni:/lib/tag.b#;
$ds=q#ni:/lib/tag.c#;
$es={$w2,1};
$fs=q#/lib/tag.c#;
$gs=[$Q6];
$hs=bless({$d2,$es,$D,$fs,$C2,$gs},$E2);
$is=q#metaclass::ctors#;
$js=q#ni:/lib/tag_init.b#;
$ks=q#ni:/lib/test_value#;
$ls={$r4,1};
$ms=q#/lib/test_value#;
$ns={};
$os=[];
$ps=q#\\$_[1]#;
$qs=bless({$o,$os,$q,$ps,$s,$t},$u);
$rs={$V3,$qs};
$ss=q#/lib/test_value_init.b#;
$ts=bless({$d2,$ns,$K2,$L2,$M2,$L2,$N2,$rs,$D,$ss},$W2);
$us=q#lib/slice::ctors#;
$vs={};
$ws=q#(==#;
$xs=[];
$ys=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$zs=bless({$o,$xs,$q,$ys,$s,$t},$u);
$As=q#diff#;
$Bs=[];
$Cs=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$Ds=bless({$o,$Bs,$q,$Cs,$s,$t},$u);
$Es={$ws,$zs,$As,$Ds};
$Fs=q#/lib/test_value_eq.b#;
$Gs=bless({$d2,$vs,$K2,$L2,$M2,$L2,$N2,$Es,$D,$Fs},$W2);
$Hs=q#lib/slice::ctors#;
$Is={};
$Js=[];
$Ks=q#ni::json_encode ${$_[0]}#;
$Ls=bless({$o,$Js,$q,$Ks,$s,$t},$u);
$Ms={$w5,$Ls};
$Ns=q#/lib/test_value_str.b#;
$Os=bless({$d2,$Is,$K2,$L2,$M2,$L2,$N2,$Ms,$D,$Ns},$W2);
$Ps=q#lib/slice::ctors#;
$Qs=[$F4,$ts,$Gs,$Os];
$Rs=q#lib/test_value.c#;
$Ss=bless({$d2,$ls,$D,$ms,$C2,$Qs},$Rs);
$Ts=q#lib/test_value.c::ctors#;
$Us=q#ni:/lib/test_value.c#;
$Vs=q#lib/test_value.c#;
$Ws={$Vs,1};
$Xs=q#/lib/test_value.c#;
$Ys=[$L6];
$Zs=bless({$d2,$Ws,$D,$Xs,$C2,$Ys},$E2);
$ct=q#metaclass::ctors#;
$dt=q#ni:/lib/test_value_eq.b#;
$et=q#ni:/lib/test_value_init.b#;
$ft=q#ni:/lib/test_value_str.b#;
$gt=q#ni:/metaclass#;
$ht={$E2,1};
$it=q#/metaclass#;
$jt=[$Q3,$n6,$c4,$c6];
$kt=bless({$d2,$ht,$D,$it,$C2,$jt},$y2);
$lt=q#metaclass.c::ctors#;
$mt=q#ni:/metaclass.c#;
$nt={$y2,1};
$ot=q#/metaclass.c#;
$pt=[$A6];
$qt=bless({$d2,$nt,$D,$ot,$C2,$pt},$E2);
$rt=q#metaclass::ctors#;
$st=q#ni:/module#;
$tt=q#ni:/module.c#;
$ut=q#ni:/object#;
$vt=q#ni:/object.c#;
$wt=q#ni:main#;
$xt={$cl,1};
$yt=[$Dr,$Zk];
$zt=bless({$d2,$xt,$D,$cl,$C2,$yt},$F2);
$At=q#module::ctors#;
$Bt=q#ni:ni#;
$Ct={$Dn,1};
$Dt={$Dn,1};
$Et=q#json_escapes#;
$Ft=q##;
$Gt=q#b#;
$Ht=q#	#;
$It=q#t#;
$Jt=q#
#;
$Kt=q#n#;
$Lt=q##;
$Mt=q#"#;
$Nt=q#/#;
$Ot=q#\\#;
$Pt={$Ft,$Gt,$Ht,$It,$Jt,$Kt,$Lt,$pd,$Mt,$Mt,$Nt,$Nt,$Ot,$Ot};
$Qt=q#json_unescapes#;
$Rt={$Mt,$Mt,$Nt,$Nt,$Ot,$Ot,$Gt,$Ft,$Kt,$Jt,$pd,$Lt,$It,$Ht};
$St={$Et,$Pt,$Qt,$Rt};
$Tt=q#/lib/json_data.b#;
$Ut=bless({$d2,$Dt,$yg,$St,$D,$Tt},$o4);
$Vt=q#lib/dataslice::ctors#;
$Wt=[$Ut,$Cn,$uq];
$Xt=bless({$d2,$Ct,$D,$Dn,$C2,$Wt},$F2);
$Yt={$d,$G,$I,$N,$O,$T,$U,$h1,$i1,$t1,$u1,$J1,$K1,$Z1,$c2,$A6,$C6,$W6,$Y6,$F8,$H8,$Q8,$S8,$t8,$T8,$C8,$U8,$Ma,$Oa,$Sa,$Ua,$sa,$Va,$Ja,$Wa,$n9,$Xa,$ja,$Ya,$I9,$Za,$f9,$cb,$wc,$yc,$Cc,$Ec,$Tb,$Fc,$hc,$Gc,$tb,$Hc,$tc,$Ic,$lb,$Jc,$Cb,$Kc,$Id,$Kd,$Od,$Qd,$ed,$Rd,$md,$Sd,$Fd,$Td,$Tc,$Ud,$we,$ye,$Ce,$Ee,$fe,$Fe,$te,$Ge,$l8,$He,$N8,$Ie,$O7,$Je,$X7,$Ke,$i8,$Le,$k7,$Me,$t7,$Ne,$hg,$jg,$ng,$pg,$eg,$qg,$nf,$rg,$Lf,$sg,$cf,$tg,$Af,$ug,$oh,$qh,$uh,$wh,$Ug,$xh,$lh,$yh,$Mg,$zh,$s5,$Ah,$T4,$Bh,$Q6,$Ch,$Nh,$Ph,$X2,$Qh,$Uh,$Wh,$Kh,$Xh,$c4,$Yh,$si,$ui,$yi,$Ai,$pi,$Bi,$ii,$Ci,$X5,$Di,$g5,$Ei,$T5,$Fi,$qj,$sj,$wj,$yj,$dj,$zj,$Mi,$Aj,$Ti,$Bj,$nj,$Cj,$P4,$Dj,$Ek,$Gk,$Kk,$Mk,$Qj,$Nk,$sk,$Ok,$hk,$Pk,$Bk,$Qk,$Zk,$el,$Qm,$Sm,$Wm,$Ym,$nl,$Zm,$Nm,$cn,$B4,$dn,$n6,$en,$Cn,$Fn,$B5,$Gn,$k3,$Hn,$u3,$In,$D3,$Jn,$gp,$ip,$mp,$op,$qo,$pp,$Po,$qp,$dp,$rp,$do,$sp,$uq,$wq,$Q3,$xq,$K5,$yq,$M3,$zq,$gr,$ir,$Mq,$jr,$nr,$pr,$Tq,$qr,$dr,$rr,$Dr,$Fr,$w6,$Gr,$Yr,$cs,$Or,$ds,$hs,$js,$Vr,$ks,$Ss,$Us,$Zs,$dt,$Gs,$et,$ts,$ft,$Os,$gt,$kt,$mt,$qt,$st,$c6,$tt,$T6,$ut,$F4,$vt,$L6,$wt,$zt,$Bt,$Xt};
$Zt=q#resolvers#;
$cu=[];
$du=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$eu=bless({$o,$cu,$q,$du,$s,$t},$u);
$fu=q#file#;
$gu=[];
$hu=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$iu=bless({$o,$gu,$q,$hu,$s,$t},$u);
$ju=q#null#;
$ku=[];
$lu=q#ni('ni:/io/null')->new#;
$mu=bless({$o,$ku,$q,$lu,$s,$t},$u);
$nu=q#sh#;
$ou=[];
$pu=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$qu=bless({$o,$ou,$q,$pu,$s,$t},$u);
$ru=q#str#;
$su=[];
$tu=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$uu=bless({$o,$su,$q,$tu,$s,$t},$u);
$vu={$P9,$eu,$fu,$iu,$ju,$mu,$nu,$qu,$ru,$uu};
$wu=bless({$c,$Yt,$Zt,$vu},$q4);
$xu=q#lib/ni::ctors#;
*$Hq=\&$Fq;
*$Gq=\&$Dq;
$X2->apply_unsafe($e2);
$X2->apply_unsafe($f2);
$X2->apply_unsafe($g2);
$X2->apply_unsafe($h2);
$X2->apply_unsafe($i2);
$X2->apply_unsafe($j2);
$X2->apply_unsafe($k2);
$X2->apply_unsafe($l2);
$X2->apply_unsafe($m2);
$X2->apply_unsafe($n2);
$X2->apply_unsafe($o2);
$X2->apply_unsafe($Y2);
$X2->apply_unsafe($p2);
$X2->apply_unsafe($q2);
$X2->apply_unsafe($r2);
$X2->apply_unsafe($s2);
$X2->apply_unsafe($t2);
$X2->apply_unsafe($u2);
$X2->apply_unsafe($v2);
$X2->apply_unsafe($w2);
$X2->apply_unsafe($Z2);
$X2->apply_unsafe($E2);
$X2->apply_unsafe($y2);
$X2->apply_unsafe($F2);
$X2->apply_unsafe($z2);
$X2->apply_unsafe($A2);
$k3->apply_unsafe($e2);
$k3->apply_unsafe($f2);
$k3->apply_unsafe($g2);
$k3->apply_unsafe($h2);
$k3->apply_unsafe($i2);
$k3->apply_unsafe($j2);
$k3->apply_unsafe($k2);
$k3->apply_unsafe($l2);
$k3->apply_unsafe($m2);
$k3->apply_unsafe($n2);
$k3->apply_unsafe($o2);
$k3->apply_unsafe($Y2);
$k3->apply_unsafe($p2);
$k3->apply_unsafe($q2);
$k3->apply_unsafe($F);
$k3->apply_unsafe($r2);
$k3->apply_unsafe($s2);
$k3->apply_unsafe($t2);
$k3->apply_unsafe($u2);
$k3->apply_unsafe($W2);
$k3->apply_unsafe($v2);
$k3->apply_unsafe($l3);
$k3->apply_unsafe($w2);
$k3->apply_unsafe($m3);
$k3->apply_unsafe($E2);
$k3->apply_unsafe($y2);
$k3->apply_unsafe($F2);
$k3->apply_unsafe($z2);
$k3->apply_unsafe($A2);
$u3->apply_unsafe($e2);
$u3->apply_unsafe($f2);
$u3->apply_unsafe($g2);
$u3->apply_unsafe($h2);
$u3->apply_unsafe($i2);
$u3->apply_unsafe($j2);
$u3->apply_unsafe($k2);
$u3->apply_unsafe($l2);
$u3->apply_unsafe($m2);
$u3->apply_unsafe($n2);
$u3->apply_unsafe($o2);
$u3->apply_unsafe($Y2);
$u3->apply_unsafe($p2);
$u3->apply_unsafe($q2);
$u3->apply_unsafe($r2);
$u3->apply_unsafe($s2);
$u3->apply_unsafe($t2);
$u3->apply_unsafe($u2);
$u3->apply_unsafe($W2);
$u3->apply_unsafe($v2);
$u3->apply_unsafe($l3);
$u3->apply_unsafe($w2);
$u3->apply_unsafe($v3);
$u3->apply_unsafe($E2);
$u3->apply_unsafe($y2);
$u3->apply_unsafe($F2);
$u3->apply_unsafe($z2);
$u3->apply_unsafe($A2);
$D3->apply_unsafe($e2);
$D3->apply_unsafe($f2);
$D3->apply_unsafe($g2);
$D3->apply_unsafe($h2);
$D3->apply_unsafe($i2);
$D3->apply_unsafe($j2);
$D3->apply_unsafe($k2);
$D3->apply_unsafe($l2);
$D3->apply_unsafe($m2);
$D3->apply_unsafe($n2);
$D3->apply_unsafe($o2);
$D3->apply_unsafe($Y2);
$D3->apply_unsafe($p2);
$D3->apply_unsafe($q2);
$D3->apply_unsafe($r2);
$D3->apply_unsafe($s2);
$D3->apply_unsafe($t2);
$D3->apply_unsafe($u2);
$D3->apply_unsafe($W2);
$D3->apply_unsafe($v2);
$D3->apply_unsafe($l3);
$D3->apply_unsafe($w2);
$D3->apply_unsafe($E3);
$D3->apply_unsafe($E2);
$D3->apply_unsafe($y2);
$D3->apply_unsafe($F2);
$D3->apply_unsafe($z2);
$D3->apply_unsafe($A2);
$M3->apply_unsafe($e2);
$M3->apply_unsafe($f2);
$M3->apply_unsafe($g2);
$M3->apply_unsafe($h2);
$M3->apply_unsafe($i2);
$M3->apply_unsafe($j2);
$M3->apply_unsafe($k2);
$M3->apply_unsafe($l2);
$M3->apply_unsafe($m2);
$M3->apply_unsafe($n2);
$M3->apply_unsafe($o2);
$M3->apply_unsafe($Y2);
$M3->apply_unsafe($p2);
$M3->apply_unsafe($q2);
$M3->apply_unsafe($r2);
$M3->apply_unsafe($s2);
$M3->apply_unsafe($t2);
$M3->apply_unsafe($u2);
$M3->apply_unsafe($v2);
$M3->apply_unsafe($l3);
$M3->apply_unsafe($w2);
$M3->apply_unsafe($N3);
$M3->apply_unsafe($E2);
$M3->apply_unsafe($y2);
$M3->apply_unsafe($F2);
$M3->apply_unsafe($z2);
$M3->apply_unsafe($A2);
$c4->apply_unsafe($e2);
$c4->apply_unsafe($f2);
$c4->apply_unsafe($g2);
$c4->apply_unsafe($h2);
$c4->apply_unsafe($i2);
$c4->apply_unsafe($j2);
$c4->apply_unsafe($k2);
$c4->apply_unsafe($l2);
$c4->apply_unsafe($m2);
$c4->apply_unsafe($n2);
$c4->apply_unsafe($o2);
$c4->apply_unsafe($p2);
$c4->apply_unsafe($q2);
$c4->apply_unsafe($r2);
$c4->apply_unsafe($s2);
$c4->apply_unsafe($t2);
$c4->apply_unsafe($u2);
$c4->apply_unsafe($v2);
$c4->apply_unsafe($w2);
$c4->apply_unsafe($d4);
$c4->apply_unsafe($E2);
$c4->apply_unsafe($y2);
$c4->apply_unsafe($F2);
$c4->apply_unsafe($z2);
$c4->apply_unsafe($A2);
$B4->apply_unsafe($e2);
$B4->apply_unsafe($f2);
$B4->apply_unsafe($f4);
$B4->apply_unsafe($g2);
$B4->apply_unsafe($g4);
$B4->apply_unsafe($h2);
$B4->apply_unsafe($h4);
$B4->apply_unsafe($i2);
$B4->apply_unsafe($i4);
$B4->apply_unsafe($j2);
$B4->apply_unsafe($j4);
$B4->apply_unsafe($k2);
$B4->apply_unsafe($k4);
$B4->apply_unsafe($l2);
$B4->apply_unsafe($l4);
$B4->apply_unsafe($m2);
$B4->apply_unsafe($m4);
$B4->apply_unsafe($n2);
$B4->apply_unsafe($n4);
$B4->apply_unsafe($o2);
$B4->apply_unsafe($Y2);
$B4->apply_unsafe($p2);
$B4->apply_unsafe($o4);
$B4->apply_unsafe($q2);
$B4->apply_unsafe($F);
$B4->apply_unsafe($r2);
$B4->apply_unsafe($u);
$B4->apply_unsafe($s2);
$B4->apply_unsafe($p4);
$B4->apply_unsafe($t2);
$B4->apply_unsafe($q4);
$B4->apply_unsafe($u2);
$B4->apply_unsafe($W2);
$B4->apply_unsafe($v2);
$B4->apply_unsafe($l3);
$B4->apply_unsafe($w2);
$B4->apply_unsafe($r4);
$B4->apply_unsafe($C4);
$B4->apply_unsafe($E2);
$B4->apply_unsafe($y2);
$B4->apply_unsafe($F2);
$B4->apply_unsafe($z2);
$B4->apply_unsafe($t4);
$B4->apply_unsafe($A2);
$P4->apply_unsafe($e2);
$P4->apply_unsafe($f2);
$P4->apply_unsafe($g2);
$P4->apply_unsafe($h2);
$P4->apply_unsafe($i2);
$P4->apply_unsafe($j2);
$P4->apply_unsafe($k2);
$P4->apply_unsafe($l2);
$P4->apply_unsafe($m2);
$P4->apply_unsafe($n2);
$P4->apply_unsafe($n4);
$P4->apply_unsafe($o2);
$P4->apply_unsafe($Y2);
$P4->apply_unsafe($p2);
$P4->apply_unsafe($o4);
$P4->apply_unsafe($q2);
$P4->apply_unsafe($r2);
$P4->apply_unsafe($s2);
$P4->apply_unsafe($t2);
$P4->apply_unsafe($u2);
$P4->apply_unsafe($W2);
$P4->apply_unsafe($v2);
$P4->apply_unsafe($l3);
$P4->apply_unsafe($w2);
$P4->apply_unsafe($Q4);
$P4->apply_unsafe($E2);
$P4->apply_unsafe($y2);
$P4->apply_unsafe($F2);
$P4->apply_unsafe($z2);
$P4->apply_unsafe($A2);
$g5->apply_unsafe($e2);
$g5->apply_unsafe($f2);
$g5->apply_unsafe($g2);
$g5->apply_unsafe($h2);
$g5->apply_unsafe($i2);
$g5->apply_unsafe($j2);
$g5->apply_unsafe($k2);
$g5->apply_unsafe($l2);
$g5->apply_unsafe($m2);
$g5->apply_unsafe($n2);
$g5->apply_unsafe($o2);
$g5->apply_unsafe($Y2);
$g5->apply_unsafe($p2);
$g5->apply_unsafe($q2);
$g5->apply_unsafe($r2);
$g5->apply_unsafe($s2);
$g5->apply_unsafe($t2);
$g5->apply_unsafe($u2);
$g5->apply_unsafe($v2);
$g5->apply_unsafe($w2);
$g5->apply_unsafe($h5);
$g5->apply_unsafe($E2);
$g5->apply_unsafe($y2);
$g5->apply_unsafe($F2);
$g5->apply_unsafe($z2);
$g5->apply_unsafe($A2);
$s5->apply_unsafe($e2);
$s5->apply_unsafe($f2);
$s5->apply_unsafe($g2);
$s5->apply_unsafe($h2);
$s5->apply_unsafe($i2);
$s5->apply_unsafe($j2);
$s5->apply_unsafe($k2);
$s5->apply_unsafe($l2);
$s5->apply_unsafe($m2);
$s5->apply_unsafe($n2);
$s5->apply_unsafe($o2);
$s5->apply_unsafe($Y2);
$s5->apply_unsafe($p2);
$s5->apply_unsafe($q2);
$s5->apply_unsafe($r2);
$s5->apply_unsafe($s2);
$s5->apply_unsafe($t2);
$s5->apply_unsafe($u2);
$s5->apply_unsafe($v2);
$s5->apply_unsafe($w2);
$s5->apply_unsafe($t5);
$s5->apply_unsafe($E2);
$s5->apply_unsafe($y2);
$s5->apply_unsafe($F2);
$s5->apply_unsafe($z2);
$s5->apply_unsafe($A2);
$B5->apply_unsafe($e2);
$B5->apply_unsafe($f2);
$B5->apply_unsafe($g2);
$B5->apply_unsafe($h2);
$B5->apply_unsafe($i2);
$B5->apply_unsafe($j2);
$B5->apply_unsafe($k2);
$B5->apply_unsafe($l2);
$B5->apply_unsafe($m2);
$B5->apply_unsafe($n2);
$B5->apply_unsafe($o2);
$B5->apply_unsafe($Y2);
$B5->apply_unsafe($p2);
$B5->apply_unsafe($q2);
$B5->apply_unsafe($r2);
$B5->apply_unsafe($s2);
$B5->apply_unsafe($t2);
$B5->apply_unsafe($u2);
$B5->apply_unsafe($v2);
$B5->apply_unsafe($w2);
$B5->apply_unsafe($C5);
$B5->apply_unsafe($E2);
$B5->apply_unsafe($y2);
$B5->apply_unsafe($F2);
$B5->apply_unsafe($z2);
$B5->apply_unsafe($A2);
$K5->apply_unsafe($e2);
$K5->apply_unsafe($f2);
$K5->apply_unsafe($g2);
$K5->apply_unsafe($h2);
$K5->apply_unsafe($i2);
$K5->apply_unsafe($j2);
$K5->apply_unsafe($k2);
$K5->apply_unsafe($l2);
$K5->apply_unsafe($m2);
$K5->apply_unsafe($n2);
$K5->apply_unsafe($o2);
$K5->apply_unsafe($Y2);
$K5->apply_unsafe($p2);
$K5->apply_unsafe($q2);
$K5->apply_unsafe($r2);
$K5->apply_unsafe($s2);
$K5->apply_unsafe($t2);
$K5->apply_unsafe($u2);
$K5->apply_unsafe($v2);
$K5->apply_unsafe($w2);
$K5->apply_unsafe($L5);
$K5->apply_unsafe($E2);
$K5->apply_unsafe($y2);
$K5->apply_unsafe($F2);
$K5->apply_unsafe($z2);
$K5->apply_unsafe($A2);
$T5->apply_unsafe($e2);
$T5->apply_unsafe($f2);
$T5->apply_unsafe($g2);
$T5->apply_unsafe($h2);
$T5->apply_unsafe($i2);
$T5->apply_unsafe($j2);
$T5->apply_unsafe($k2);
$T5->apply_unsafe($l2);
$T5->apply_unsafe($m2);
$T5->apply_unsafe($n2);
$T5->apply_unsafe($o2);
$T5->apply_unsafe($Y2);
$T5->apply_unsafe($p2);
$T5->apply_unsafe($q2);
$T5->apply_unsafe($r2);
$T5->apply_unsafe($s2);
$T5->apply_unsafe($t2);
$T5->apply_unsafe($u2);
$T5->apply_unsafe($v2);
$T5->apply_unsafe($w2);
$T5->apply_unsafe($U5);
$T5->apply_unsafe($E2);
$T5->apply_unsafe($y2);
$T5->apply_unsafe($F2);
$T5->apply_unsafe($z2);
$T5->apply_unsafe($A2);
$n6->apply_unsafe($e2);
$n6->apply_unsafe($f2);
$n6->apply_unsafe($g2);
$n6->apply_unsafe($h2);
$n6->apply_unsafe($i2);
$n6->apply_unsafe($j2);
$n6->apply_unsafe($k2);
$n6->apply_unsafe($l2);
$n6->apply_unsafe($m2);
$n6->apply_unsafe($n2);
$n6->apply_unsafe($o2);
$n6->apply_unsafe($p2);
$n6->apply_unsafe($q2);
$n6->apply_unsafe($r2);
$n6->apply_unsafe($u);
$n6->apply_unsafe($s2);
$n6->apply_unsafe($t2);
$n6->apply_unsafe($u2);
$n6->apply_unsafe($W2);
$n6->apply_unsafe($v2);
$n6->apply_unsafe($l3);
$n6->apply_unsafe($w2);
$n6->apply_unsafe($o6);
$n6->apply_unsafe($E2);
$n6->apply_unsafe($y2);
$n6->apply_unsafe($z2);
$n6->apply_unsafe($A2);
$w6->apply_unsafe($e2);
$w6->apply_unsafe($f2);
$w6->apply_unsafe($g2);
$w6->apply_unsafe($h2);
$w6->apply_unsafe($i2);
$w6->apply_unsafe($j2);
$w6->apply_unsafe($k2);
$w6->apply_unsafe($l2);
$w6->apply_unsafe($m2);
$w6->apply_unsafe($n2);
$w6->apply_unsafe($o2);
$w6->apply_unsafe($p2);
$w6->apply_unsafe($q2);
$w6->apply_unsafe($r2);
$w6->apply_unsafe($s2);
$w6->apply_unsafe($t2);
$w6->apply_unsafe($u2);
$w6->apply_unsafe($v2);
$w6->apply_unsafe($w2);
$w6->apply_unsafe($x6);
$w6->apply_unsafe($y2);
$w6->apply_unsafe($z2);
$w6->apply_unsafe($A2);
$k7->apply_unsafe($f4);
$k7->apply_unsafe($g4);
$k7->apply_unsafe($h4);
$k7->apply_unsafe($i4);
$k7->apply_unsafe($j4);
$k7->apply_unsafe($k4);
$k7->apply_unsafe($l4);
$k7->apply_unsafe($m4);
$t7->apply_unsafe($f4);
$t7->apply_unsafe($g4);
$t7->apply_unsafe($h4);
$t7->apply_unsafe($i4);
$t7->apply_unsafe($j4);
$t7->apply_unsafe($k4);
$t7->apply_unsafe($l4);
$t7->apply_unsafe($m4);
$O7->apply_unsafe($f4);
$O7->apply_unsafe($g4);
$O7->apply_unsafe($h4);
$O7->apply_unsafe($i4);
$O7->apply_unsafe($j4);
$O7->apply_unsafe($k4);
$O7->apply_unsafe($l4);
$O7->apply_unsafe($m4);
$X7->apply_unsafe($f4);
$X7->apply_unsafe($g4);
$X7->apply_unsafe($h4);
$X7->apply_unsafe($i4);
$X7->apply_unsafe($j4);
$X7->apply_unsafe($k4);
$X7->apply_unsafe($l4);
$X7->apply_unsafe($m4);
$i8->apply_unsafe($f4);
$i8->apply_unsafe($g4);
$i8->apply_unsafe($h4);
$i8->apply_unsafe($i4);
$i8->apply_unsafe($j4);
$i8->apply_unsafe($k4);
$i8->apply_unsafe($l4);
$i8->apply_unsafe($m4);
$t8->apply_unsafe($f4);
$C8->apply_unsafe($f4);
$f9->apply_unsafe($g4);
$n9->apply_unsafe($g4);
$I9->apply_unsafe($g4);
$ja->apply_unsafe($g4);
$sa->apply_unsafe($g4);
$Ja->apply_unsafe($g4);
$lb->apply_unsafe($h4);
$tb->apply_unsafe($h4);
$Cb->apply_unsafe($h4);
$Tb->apply_unsafe($h4);
$hc->apply_unsafe($h4);
$tc->apply_unsafe($h4);
$Tc->apply_unsafe($i4);
$ed->apply_unsafe($i4);
$md->apply_unsafe($i4);
$Fd->apply_unsafe($i4);
$fe->apply_unsafe($j4);
$te->apply_unsafe($j4);
$cf->apply_unsafe($l4);
$nf->apply_unsafe($l4);
$Af->apply_unsafe($l4);
$Lf->apply_unsafe($l4);
$eg->apply_unsafe($l4);
$Mg->apply_unsafe($m4);
$Ug->apply_unsafe($m4);
$lh->apply_unsafe($m4);
$Kh->apply_unsafe($Y2);
$ii->apply_unsafe($o4);
$pi->apply_unsafe($o4);
$Mi->apply_unsafe($F);
$Ti->apply_unsafe($F);
$dj->apply_unsafe($F);
$nj->apply_unsafe($F);
$Qj->apply_unsafe($u);
$hk->apply_unsafe($u);
$sk->apply_unsafe($u);
$Bk->apply_unsafe($u);
$Zk->apply_unsafe($cl);
$nl->apply_unsafe($p4);
$Nm->apply_unsafe($p4);
$Cn->apply_unsafe($Dn);
$do->apply_unsafe($q4);
$qo->apply_unsafe($q4);
$Po->apply_unsafe($q4);
$dp->apply_unsafe($q4);
$uq->apply_unsafe($Dn);
$Mq->apply_unsafe($W2);
$Tq->apply_unsafe($W2);
$dr->apply_unsafe($W2);
$Dr->apply_unsafe($cl);
$Or->apply_unsafe($l3);
$Vr->apply_unsafe($l3);
$ts->apply_unsafe($r4);
$Gs->apply_unsafe($r4);
$Os->apply_unsafe($r4);
$ni::self=$wu;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($T)for@$H;
&$_($d1)for@$w;
&$_($h1)for@$H;
&$_($p1)for@$w;
&$_($t1)for@$H;
&$_($x1)for@$w;
&$_($B1)for@$w;
&$_($F1)for@$w;
&$_($J1)for@$H;
&$_($R1)for@$w;
&$_($V1)for@$w;
&$_($Z1)for@$H;
&$_($Q2)for@$w;
&$_($T2)for@$w;
&$_($X2)for@$c3;
&$_($f3)for@$w;
&$_($h3)for@$w;
&$_($k3)for@$n3;
&$_($r3)for@$w;
&$_($u3)for@$w3;
&$_($A3)for@$w;
&$_($D3)for@$F3;
&$_($J3)for@$w;
&$_($M3)for@$O3;
&$_($Q3)for@$R3;
&$_($U3)for@$w;
&$_($X3)for@$w;
&$_($c4)for@$e4;
&$_($y4)for@$w;
&$_($B4)for@$D4;
&$_($F4)for@$G4;
&$_($M4)for@$w;
&$_($P4)for@$R4;
&$_($T4)for@$U4;
&$_($d5)for@$w;
&$_($g5)for@$i5;
&$_($m5)for@$w;
&$_($p5)for@$w;
&$_($s5)for@$u5;
&$_($y5)for@$w;
&$_($B5)for@$D5;
&$_($H5)for@$w;
&$_($K5)for@$M5;
&$_($Q5)for@$w;
&$_($T5)for@$V5;
&$_($X5)for@$Y5;
&$_($c6)for@$d6;
&$_($h6)for@$w;
&$_($k6)for@$w;
&$_($n6)for@$p6;
&$_($t6)for@$w;
&$_($w6)for@$y6;
&$_($A6)for@$B6;
&$_($L6)for@$M6;
&$_($Q6)for@$R6;
&$_($T6)for@$U6;
&$_($W6)for@$X6;
&$_($h7)for@$w;
&$_($k7)for@$l7;
&$_($q7)for@$w;
&$_($t7)for@$u7;
&$_($z7)for@$w;
&$_($D7)for@$w;
&$_($H7)for@$w;
&$_($L7)for@$w;
&$_($O7)for@$P7;
&$_($U7)for@$w;
&$_($X7)for@$Y7;
&$_($f8)for@$w;
&$_($i8)for@$j8;
&$_($l8)for@$m8;
&$_($q8)for@$w;
&$_($t8)for@$u8;
&$_($z8)for@$w;
&$_($C8)for@$D8;
&$_($F8)for@$G8;
&$_($N8)for@$O8;
&$_($Q8)for@$R8;
&$_($c9)for@$w;
&$_($f9)for@$g9;
&$_($k9)for@$w;
&$_($n9)for@$o9;
&$_($t9)for@$w;
&$_($x9)for@$w;
&$_($B9)for@$w;
&$_($F9)for@$w;
&$_($I9)for@$J9;
&$_($O9)for@$w;
&$_($S9)for@$w;
&$_($W9)for@$w;
&$_($ca)for@$w;
&$_($ga)for@$w;
&$_($ja)for@$ka;
&$_($pa)for@$w;
&$_($sa)for@$ta;
&$_($ya)for@$w;
&$_($Ca)for@$w;
&$_($Ga)for@$w;
&$_($Ja)for@$Ka;
&$_($Ma)for@$Na;
&$_($Sa)for@$Ta;
&$_($ib)for@$w;
&$_($lb)for@$mb;
&$_($qb)for@$w;
&$_($tb)for@$ub;
&$_($zb)for@$w;
&$_($Cb)for@$Db;
&$_($Ib)for@$w;
&$_($Mb)for@$w;
&$_($Qb)for@$w;
&$_($Tb)for@$Ub;
&$_($Yb)for@$w;
&$_($ec)for@$w;
&$_($hc)for@$ic;
&$_($mc)for@$w;
&$_($qc)for@$w;
&$_($tc)for@$uc;
&$_($wc)for@$xc;
&$_($Cc)for@$Dc;
&$_($Qc)for@$w;
&$_($Tc)for@$Uc;
&$_($Zc)for@$w;
&$_($ed)for@$fd;
&$_($jd)for@$w;
&$_($md)for@$nd;
&$_($sd)for@$w;
&$_($vd)for@$w;
&$_($zd)for@$w;
&$_($Cd)for@$w;
&$_($Fd)for@$Gd;
&$_($Id)for@$Jd;
&$_($Od)for@$Pd;
&$_($ce)for@$w;
&$_($fe)for@$ge;
&$_($ke)for@$w;
&$_($ne)for@$w;
&$_($qe)for@$w;
&$_($te)for@$ue;
&$_($we)for@$xe;
&$_($Ce)for@$De;
&$_($Te)for@$w;
&$_($Xe)for@$w;
&$_($cf)for@$df;
&$_($hf)for@$w;
&$_($kf)for@$w;
&$_($nf)for@$of;
&$_($tf)for@$w;
&$_($xf)for@$w;
&$_($Af)for@$Bf;
&$_($Ff)for@$w;
&$_($If)for@$w;
&$_($Lf)for@$Mf;
&$_($Qf)for@$w;
&$_($Tf)for@$w;
&$_($Wf)for@$w;
&$_($Zf)for@$w;
&$_($eg)for@$fg;
&$_($hg)for@$ig;
&$_($ng)for@$og;
&$_($Bg)for@$w;
&$_($Fg)for@$w;
&$_($Jg)for@$w;
&$_($Mg)for@$Ng;
&$_($Rg)for@$w;
&$_($Ug)for@$Vg;
&$_($Zg)for@$w;
&$_($fh)for@$w;
&$_($ih)for@$w;
&$_($lh)for@$mh;
&$_($oh)for@$ph;
&$_($uh)for@$vh;
&$_($Hh)for@$w;
&$_($Kh)for@$Lh;
&$_($Nh)for@$Oh;
&$_($Uh)for@$Vh;
&$_($fi)for@$w;
&$_($ii)for@$ji;
&$_($mi)for@$w;
&$_($pi)for@$qi;
&$_($si)for@$ti;
&$_($yi)for@$zi;
&$_($Ji)for@$w;
&$_($Mi)for@$Ni;
&$_($Qi)for@$w;
&$_($Ti)for@$Ui;
&$_($Yi)for@$w;
&$_($dj)for@$ej;
&$_($hj)for@$w;
&$_($kj)for@$w;
&$_($nj)for@$oj;
&$_($qj)for@$rj;
&$_($wj)for@$xj;
&$_($Ij)for@$w;
&$_($Lj)for@$w;
&$_($Nj)for@$w;
&$_($Qj)for@$Rj;
&$_($Vj)for@$w;
&$_($Yj)for@$w;
&$_($ek)for@$w;
&$_($hk)for@$ik;
&$_($mk)for@$w;
&$_($pk)for@$w;
&$_($sk)for@$tk;
&$_($yk)for@$w;
&$_($Bk)for@$Ck;
&$_($Ek)for@$Fk;
&$_($Kk)for@$Lk;
&$_($Wk)for@$w;
&$_($Zk)for@$dl;
&$_($kl)for@$w;
&$_($nl)for@$ol;
&$_($tl)for@$w;
&$_($xl)for@$w;
&$_($Bl)for@$w;
&$_($Fl)for@$w;
&$_($Jl)for@$w;
&$_($Nl)for@$w;
&$_($Rl)for@$w;
&$_($Vl)for@$w;
&$_($Zl)for@$w;
&$_($fm)for@$w;
&$_($jm)for@$w;
&$_($nm)for@$w;
&$_($rm)for@$w;
&$_($vm)for@$w;
&$_($zm)for@$w;
&$_($Dm)for@$w;
&$_($Hm)for@$w;
&$_($Km)for@$w;
&$_($Nm)for@$Om;
&$_($Qm)for@$Rm;
&$_($Wm)for@$Xm;
&$_($jn)for@$w;
&$_($nn)for@$w;
&$_($rn)for@$w;
&$_($vn)for@$w;
&$_($zn)for@$w;
&$_($Cn)for@$En;
&$_($Qn)for@$w;
&$_($Un)for@$w;
&$_($Yn)for@$w;
&$_($do)for@$eo;
&$_($jo)for@$w;
&$_($no)for@$w;
&$_($qo)for@$ro;
&$_($wo)for@$w;
&$_($Ao)for@$w;
&$_($Eo)for@$w;
&$_($Io)for@$w;
&$_($Mo)for@$w;
&$_($Po)for@$Qo;
&$_($Uo)for@$w;
&$_($Yo)for@$w;
&$_($dp)for@$ep;
&$_($gp)for@$hp;
&$_($mp)for@$np;
&$_($xp)for@$w;
&$_($Bp)for@$w;
&$_($Fp)for@$w;
&$_($Jp)for@$w;
&$_($Np)for@$w;
&$_($Rp)for@$w;
&$_($Vp)for@$w;
&$_($Zp)for@$w;
&$_($fq)for@$w;
&$_($jq)for@$w;
&$_($nq)for@$w;
&$_($rq)for@$w;
&$_($uq)for@$vq;
&$_($Dq)for@$w;
&$_($Fq)for@$w;
&$_($Mq)for@$Nq;
&$_($Qq)for@$w;
&$_($Tq)for@$Uq;
&$_($Yq)for@$w;
&$_($dr)for@$er;
&$_($gr)for@$hr;
&$_($nr)for@$or;
&$_($vr)for@$w;
&$_($Ar)for@$w;
&$_($Dr)for@$Er;
&$_($Lr)for@$w;
&$_($Or)for@$Pr;
&$_($Sr)for@$w;
&$_($Vr)for@$Wr;
&$_($Yr)for@$Zr;
&$_($hs)for@$is;
&$_($qs)for@$w;
&$_($ts)for@$us;
&$_($zs)for@$w;
&$_($Ds)for@$w;
&$_($Gs)for@$Hs;
&$_($Ls)for@$w;
&$_($Os)for@$Ps;
&$_($Ss)for@$Ts;
&$_($Zs)for@$ct;
&$_($kt)for@$lt;
&$_($qt)for@$rt;
&$_($zt)for@$At;
&$_($Ut)for@$Vt;
&$_($Xt)for@$At;
&$_($eu)for@$w;
&$_($iu)for@$w;
&$_($mu)for@$w;
&$_($qu)for@$w;
&$_($uu)for@$w;
&$_($wu)for@$xu;
ni->run(@ARGV);
__DATA__
