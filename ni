#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q'applied_to';
$d=q'metaclass.c';
$e={$d,1};
$f=q'name';
$g=q'slices';
$h=q'class.c';
$i={$h,1};
$j=q'module.c';
$k={$h,1,$j,1};
$l=q'lib/behavior.c';
$m=q'lib/branch.c';
$n=q'lib/dataslice.c';
$o=q'lib/doc.c';
$p=q'lib/fn.c';
$q=q'lib/image.c';
$r=q'lib/ni.c';
$s=q'lib/slice.c';
$t=q'lib/tag.c';
$u=q'lib/test_value.c';
$v=q'object.c';
$w=q'unix/cat.c';
$x=q'unix/fd.c';
$y=q'unix/fifo.c';
$z=q'unix/file.c';
$A=q'unix/io.c';
$B=q'unix/pid.c';
$C=q'unix/pipeline.c';
$D=q'unix/str.c';
$E={$h,1,$l,1,$m,1,$n,1,$o,1,$p,1,$q,1,$r,1,$s,1,$t,1,$u,1,$j,1,$v,1,$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$F=[undef];
$G=q'metaclass';
$H=bless({$c,$E,$f,$v,$g,$F},$G);
$I=q'metaclass::ctors';
$J={$s,1};
$K={$h,1,$l,1,$m,1,$n,1,$s,1,$t,1,$j,1};
$L=[$H];
$M=bless({$c,$K,$f,$l,$g,$L},$G);
$N=q'metaclass::ctors';
$O=[$M];
$P=bless({$c,$J,$f,$s,$g,$O},$G);
$Q=q'metaclass::ctors';
$R=q'lib/slice';
$S={$R,1};
$T=q'class';
$U=q'lib/behavior';
$V=q'lib/branch';
$W=q'lib/dataslice';
$X=q'lib/tag';
$Y=q'lib/test_value.c';
$Z=q'module';
$c1={$T,1,$h,1,$U,1,$l,1,$V,1,$m,1,$W,1,$n,1,$o,1,$p,1,$q,1,$r,1,$R,1,$s,1,$X,1,$t,1,$Y,1,$G,1,$d,1,$Z,1,$j,1,$v,1,$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$d1=q'lib/doc';
$e1=q'lib/fn';
$f1=q'lib/image';
$g1=q'lib/ni';
$h1=q'lib/test_value';
$i1=q'lib/test_value.c';
$j1=q'object';
$k1=q'unix/cat';
$l1=q'unix/fd';
$m1=q'unix/fifo';
$n1=q'unix/file';
$o1=q'unix/io';
$p1=q'unix/pid';
$q1=q'unix/pipeline';
$r1=q'unix/str';
$s1={$T,1,$h,1,$U,1,$l,1,$V,1,$m,1,$W,1,$n,1,$d1,1,$o,1,$e1,1,$p,1,$f1,1,$q,1,$g1,1,$r,1,$R,1,$s,1,$X,1,$t,1,$h1,1,$i1,1,$G,1,$d,1,$Z,1,$j,1,$j1,1,$v,1,$k1,1,$w,1,$l1,1,$x,1,$m1,1,$y,1,$n1,1,$z,1,$o1,1,$A,1,$p1,1,$B,1,$q1,1,$C,1,$r1,1,$D,1};
$t1={};
$u1=q'ctor';
$v1=undef;
$w1=q'dtor';
$x1=q'methods';
$y1={$p,1};
$z1=[$H];
$A1=bless({$c,$y1,$f,$p,$g,$z1},$G);
$B1=q'metaclass::ctors';
$C1={$e1,1};
$D1={};
$E1=q'code';
$F1=q'shift->compile';
$G1=q'proto';
$H1=q'';
$I1=bless({$E1,$F1,$G1,$H1},$e1);
$J1=q'lib/fn::ctors';
$K1=q'compile';
$L1=q'local $@;
my $self = shift;
$$self{proto} ||= \'\';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};';
$M1=bless({$E1,$L1,$G1,$H1},$e1);
$N1=q'instantiate';
$O1=q'my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : \'\';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};';
$P1=bless({$E1,$O1,$G1,$H1},$e1);
$Q1={$K1,$M1,$N1,$P1};
$R1=q'lib/fn_init.b';
$S1=bless({$c,$D1,$u1,$I1,$w1,$v1,$x1,$Q1,$f,$R1},$R);
$T1=q'lib/slice::ctors';
$U1={};
$V1=q'annotations';
$W1=[];
$X1=q'shift->{\'annotations\'}';
$Y1=bless({$V1,$W1,$E1,$X1,$G1,$H1},$e1);
$Z1=[];
$c2=q'shift->{\'code\'}';
$d2=bless({$V1,$Z1,$E1,$c2,$G1,$H1},$e1);
$e2=q'fn';
$f2=[];
$g2=q'shift->{\'fn\'}';
$h2=bless({$V1,$f2,$E1,$g2,$G1,$H1},$e1);
$i2={$V1,$Y1,$E1,$d2,$e2,$h2};
$j2=q'lib/fn_ro.b';
$k2=bless({$c,$U1,$u1,$v1,$w1,$v1,$x1,$i2,$f,$j2},$R);
$l2=q'lib/slice::ctors';
$m2={};
$n2=q'(""';
$o2=[];
$p2=q'shift->{code}';
$q2=bless({$V1,$o2,$E1,$p2,$G1,$H1},$e1);
$r2=q'(eq';
$s2=[];
$t2=q'ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])';
$u2=bless({$V1,$s2,$E1,$t2,$G1,$H1},$e1);
$v2={$n2,$q2,$r2,$u2};
$w2=q'lib/fn_ops.b';
$x2=bless({$c,$m2,$u1,$v1,$w1,$v1,$x1,$v2,$f,$w2},$R);
$y2=q'lib/slice::ctors';
$z2={};
$A2=q'serialize';
$B2=[];
$C2=q'local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = \' \' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);';
$D2=bless({$V1,$B2,$E1,$C2,$G1,$H1},$e1);
$E2={$A2,$D2};
$F2=q'lib/fn_serialize.b';
$G2=bless({$c,$z2,$u1,$v1,$w1,$v1,$x1,$E2,$f,$F2},$R);
$H2=q'lib/slice::ctors';
$I2=[undef,undef,$S1,$k2,$x2,$G2];
$J2=bless({$c,$C1,$f,$e1,$g,$I2},$p);
$K2=q'lib/fn.c::ctors';
$L2=q'ni \'ni:\' . ref shift';
$M2=bless({$E1,$L2,$G1,$H1},$e1);
$N2={$T,$M2};
$O2=q'lib/instance.b';
$P2=bless({$c,$t1,$u1,$v1,$w1,$v1,$x1,$N2,$f,$O2},$R);
$Q2=q'lib/test_value.c';
$R2=q'lib/slice::ctors';
$S2=[$P2];
$T2=bless({$c,$s1,$f,$j1,$g,$S2},$v);
$U2=q'object.c::ctors';
$V2={};
$W2=q'doc';
$X2=q'my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can(\'exists\') && ni->exists("ni.doc:$name");
ni(\'ni:lib/doc\')->new($name);';
$Y2=bless({$E1,$X2,$G1,$H1},$e1);
$Z2={$W2,$Y2};
$c3=q'lib/documentable.b';
$d3=bless({$c,$V2,$u1,$v1,$w1,$v1,$x1,$Z2,$f,$c3},$R);
$e3=q'lib/test_value.c';
$f3=q'lib/slice::ctors';
$g3=[$T2,$d3];
$h3=bless({$c,$c1,$f,$U,$g,$g3},$l);
$i3=q'lib/behavior.c::ctors';
$j3={};
$k3=q'my $s = shift; ni->def($s->name, $s)';
$l3=bless({$E1,$k3,$G1,$H1},$e1);
$m3=q'$_[0]->namespace . ":" . $_[0]->{name}';
$n3=bless({$E1,$m3,$G1,$H1},$e1);
$o3={$f,$n3};
$p3=q'lib/named.b';
$q3=bless({$c,$j3,$u1,$l3,$w1,$v1,$x1,$o3,$f,$p3},$R);
$r3=q'lib/test_value.c';
$s3=q'lib/slice::ctors';
$t3=q'local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);';
$u3=bless({$E1,$t3,$G1,$H1},$e1);
$v3=q'local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;';
$w3=bless({$E1,$v3,$G1,$H1},$e1);
$x3=q'lib/slice::apply';
$y3=q'lib/slice::apply_unsafe';
$z3={};
$A3=q'apply';
$B3=q'apply_unsafe';
$C3={$A3,$u3,$B3,$w3};
$D3=q'lib/slice.b';
$E3=bless({$c,$z3,$x1,$C3,$f,$D3},$R);
$F3=q'lib/slice::ctors';
$G3={};
$H3=q'my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};';
$I3=bless({$E1,$H3,$G1,$H1},$e1);
$J3={$N1,$I3};
$K3=q'lib/slice_init.b';
$L3=bless({$c,$G3,$x1,$J3,$f,$K3},$R);
$M3=q'lib/slice::ctors';
$N3={};
$O3=[];
$P3=q'local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq \'ni:lib/slice.b\') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      \'*\' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;';
$Q3=bless({$V1,$O3,$E1,$P3,$G1,$H1},$e1);
$R3={$A2,$Q3};
$S3=q'lib/slice_serialize.b';
$T3=bless({$c,$N3,$u1,$v1,$w1,$v1,$x1,$R3,$f,$S3},$R);
$U3=q'lib/slice::ctors';
$V3=[$h3,$q3,$E3,$L3,$T3];
$W3=bless({$c,$S,$f,$R,$g,$V3},$s);
$X3=q'lib/slice.c::ctors';
$Y3={};
$Z3=q'DESTROY';
$c4=q'local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};';
$d4=bless({$E1,$c4,$G1,$H1},$e1);
$e4=q'new';
$f4=q'local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;';
$g4=bless({$E1,$f4,$G1,$H1},$e1);
$h4={$Z3,$d4,$e4,$g4};
$i4=q'lib/instantiable.b';
$j4=bless({$c,$Y3,$x1,$h4,$f,$i4},$R);
$k4=q'lib/test_value.c';
$l4=q'lib/slice::ctors';
$m4=[$H,$j4,$M];
$n4=bless({$c,$k,$f,$j,$g,$m4},$G);
$o4=q'metaclass::ctors';
$p4=[$n4];
$q4=bless({$c,$i,$f,$h,$g,$p4},$G);
$r4=q'metaclass::ctors';
$s4=q'lib/test_value.c';
$t4={$T,1,$h,1,$l,1,$m,1,$n,1,$o,1,$p,1,$q,1,$r,1,$s,1,$t,1,$s4,1,$d,1,$j,1,$v,1,$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$u4=q'lib/test_value.c';
$v4={$T,1,$h,1,$l,1,$m,1,$n,1,$o,1,$p,1,$q,1,$r,1,$s,1,$t,1,$u4,1,$G,1,$d,1,$Z,1,$j,1,$v,1,$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$w4={$t,1};
$x4=[$M];
$y4=bless({$c,$w4,$f,$t,$g,$x4},$G);
$z4=q'metaclass::ctors';
$A4={$X,1};
$B4={};
$C4=q'local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;';
$D4=bless({$E1,$C4,$G1,$H1},$e1);
$E4={$A3,$D4};
$F4=q'lib/tag.b';
$G4=bless({$c,$B4,$u1,$v1,$w1,$v1,$x1,$E4,$f,$F4},$R);
$H4=q'lib/slice::ctors';
$I4={};
$J4=q'local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};';
$K4=bless({$E1,$J4,$G1,$H1},$e1);
$L4={$N1,$K4};
$M4=q'lib/tag_init.b';
$N4=bless({$c,$I4,$u1,$v1,$w1,$v1,$x1,$L4,$f,$M4},$R);
$O4=q'lib/slice::ctors';
$P4=[$h3,$q3,$G4,$N4];
$Q4=bless({$c,$A4,$f,$X,$g,$P4},$t);
$R4=q'lib/tag.c::ctors';
$S4=q'lib/perlbranch.b';
$T4={};
$U4=q'add';
$V4=q'local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;';
$W4=bless({$E1,$V4,$G1,$H1},$e1);
$X4=q'local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;';
$Y4=bless({$E1,$X4,$G1,$H1},$e1);
$Z4={$U4,$W4,$A3,$Y4};
$c5=q'lib/branch.b';
$d5=bless({$c,$T4,$u1,$v1,$w1,$v1,$x1,$Z4,$f,$c5},$R);
$e5=q'lib/test_value.c';
$f5=q'lib/slice::ctors';
$g5={};
$h5=q'namespace';
$i5=q'\'ni\'';
$j5=bless({$E1,$i5,$G1,$H1},$e1);
$k5={$h5,$j5};
$l5=q'lib/named_in_ni.b';
$m5=bless({$c,$g5,$u1,$v1,$w1,$v1,$x1,$k5,$f,$l5},$R);
$n5=q'lib/test_value.c';
$o5=q'lib/slice::ctors';
$p5={};
$q5=q'package';
$r5=q'shift->{name}';
$s5=bless({$E1,$r5,$G1,$H1},$e1);
$t5={$q5,$s5};
$u5=q'lib/namespaced.b';
$v5=bless({$c,$p5,$u1,$v1,$w1,$v1,$x1,$t5,$f,$u5},$R);
$w5=q'lib/test_value.c';
$x5=q'lib/slice::ctors';
$y5={};
$z5=q'resolve';
$A5=q'ref $_[1] ? $_[1] : ni"ni:$_[1]"';
$B5=bless({$E1,$A5,$G1,$H1},$e1);
$C5={$z5,$B5};
$D5=q'lib/resolver.b';
$E5=bless({$c,$y5,$u1,$v1,$w1,$v1,$x1,$C5,$f,$D5},$R);
$F5=q'lib/test_value.c';
$G5=q'lib/slice::ctors';
$H5=[$d5,$q3,$m5,$v5,$E5];
$I5=bless({$f,$S4,$g,$H5},$X);
$J5=q'lib/tag::ctors';
$K5={};
$L5=q'my $s = shift; $s->apply($s->package)';
$M5=bless({$E1,$L5,$G1,$H1},$e1);
$N5=q'local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};';
$O5=bless({$E1,$N5,$G1,$H1},$e1);
$P5={$N1,$O5};
$Q5=q'lib/class_init.b';
$R5=bless({$c,$K5,$u1,$M5,$w1,$v1,$x1,$P5,$f,$Q5},$R);
$S5=q'lib/test_value.c';
$T5=q'lib/slice::ctors';
$U5={$m,1};
$V5=[$M];
$W5=bless({$c,$U5,$f,$m,$g,$V5},$G);
$X5=q'metaclass::ctors';
$Y5={$V,1};
$Z5={};
$c6=q'local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};';
$d6=bless({$E1,$c6,$G1,$H1},$e1);
$e6={$N1,$d6};
$f6=q'lib/branch_init.b';
$g6=bless({$c,$Z5,$u1,$v1,$w1,$v1,$x1,$e6,$f,$f6},$R);
$h6=q'lib/slice::ctors';
$i6=[$h3,$q3,$d5,$g6,undef];
$j6=bless({$c,$Y5,$f,$V,$g,$i6},$m);
$k6=q'lib/branch.c::ctors';
$l6=q'lib/test_value.c';
$m6={$T,1,$h,1,$l,1,$V,1,$m,1,$n,1,$o,1,$p,1,$q,1,$r,1,$s,1,$t,1,$l6,1,$G,1,$d,1,$Z,1,$j,1,$v,1,$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$n6=q'lib/definition.b';
$o6={};
$p6=q'def';
$q6=q'shift->add(ni(\'ni:lib/slice\')->new(@_))';
$r6=bless({$E1,$q6,$G1,$H1},$e1);
$s6={$p6,$r6};
$t6=q'lib/definition_def.b';
$u6=bless({$c,$o6,$u1,$v1,$w1,$v1,$x1,$s6,$f,$t6},$R);
$v6=q'lib/test_value.c';
$w6=q'lib/slice::ctors';
$x6={};
$y6=q'ro';
$z6=q'my ($self, $slice, @rs) = @_;
$self->add(ni(\'ni:lib/slice\')->new(
  $slice,
  map +($_ => fn qq{shift->{\'$_\'}}), @rs));';
$A6=bless({$E1,$z6,$G1,$H1},$e1);
$B6=q'rw';
$C6=q'my ($self, $slice, @as) = @_;
$self->add(ni(\'ni:lib/slice\')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{\'$_\'} = \\$_[1] : shift->{\'$_\'}}), @as));';
$D6=bless({$E1,$C6,$G1,$H1},$e1);
$E6={$y6,$A6,$B6,$D6};
$F6=q'lib/accessor.b';
$G6=bless({$c,$x6,$u1,$v1,$w1,$v1,$x1,$E6,$f,$F6},$R);
$H6=q'lib/test_value.c';
$I6=q'lib/slice::ctors';
$J6={};
$K6=q'shift->name';
$L6=bless({$E1,$K6,$G1,$H1},$e1);
$M6={$n2,$L6};
$N6=q'lib/name_as_string.b';
$O6=bless({$c,$J6,$u1,$v1,$w1,$v1,$x1,$M6,$f,$N6},$R);
$P6=q'lib/test_value.c';
$Q6=q'lib/slice::ctors';
$R6={};
$S6=q'ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);';
$T6=bless({$E1,$S6,$G1,$H1},$e1);
$U6={$r2,$T6};
$V6=q'lib/ref_eq.b';
$W6=bless({$c,$R6,$u1,$v1,$w1,$v1,$x1,$U6,$f,$V6},$R);
$X6=q'lib/test_value.c';
$Y6=q'lib/slice::ctors';
$Z6={};
$c7=q'defdata';
$d7=q'shift->add(ni(\'ni:lib/dataslice\')->new(@_))';
$e7=bless({$E1,$d7,$G1,$H1},$e1);
$f7={$c7,$e7};
$g7=q'lib/definition_defdata.b';
$h7=bless({$c,$Z6,$u1,$v1,$w1,$v1,$x1,$f7,$f,$g7},$R);
$i7=q'lib/test_value.c';
$j7=q'lib/slice::ctors';
$k7=[$u6,$G6,$O6,$W6,$h7];
$l7=bless({$c,$m6,$f,$n6,$g,$k7},$V);
$m7=q'lib/branch::ctors';
$n7=[$I5,$R5,$T2,$h3,$l7];
$o7=bless({$c,$v4,$f,$Z,$g,$n7},$j);
$p7=q'module.c::ctors';
$q7={};
$r7=q'child';
$s7=q'my ($self, $name, @slices) = @_;
ni("ni:metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);';
$t7=bless({$E1,$s7,$G1,$H1},$e1);
$u7={$r7,$t7};
$v7=q'lib/subclass.b';
$w7=bless({$c,$q7,$u1,$v1,$w1,$v1,$x1,$u7,$f,$v7},$R);
$x7=q'lib/test_value.c';
$y7=q'lib/slice::ctors';
$z7=[$o7,$j4,$R5,$o7,$w7];
$A7=bless({$c,$t4,$f,$T,$g,$z7},$h);
$B7=q'class.c::ctors';
$C7=[$A7];
$D7=bless({$c,$e,$f,$d,$g,$C7},$G);
$E7=q'metaclass::ctors';
$F7={$G,1};
$G7=[$I5,$j4,$R5,$o7];
$H7=bless({$c,$F7,$f,$G,$g,$G7},$d);
$I7=q'metaclass.c::ctors';
$J7={$r,1};
$K7=[$H];
$L7=bless({$c,$J7,$f,$r,$g,$K7},$G);
$M7=q'metaclass::ctors';
$N7={$g1,1};
$O7={};
$P7=q'is_mutable';
$Q7=[];
$R7=q'$0 ne "-" && -w $0';
$S7=bless({$V1,$Q7,$E1,$R7,$G1,$H1},$e1);
$T7=q'modify';
$U7=[];
$V7=q'my ($self, $fn) = @_;
# TODO: replace all of this with a generalized "atomic-update" function
# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join \'/\', @r;
open my $w, \'>\', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";';
$W7=bless({$V1,$U7,$E1,$V7,$G1,$H1},$e1);
$X7={$P7,$S7,$T7,$W7};
$Y7=q'lib/ni_self.b';
$Z7=bless({$c,$O7,$u1,$v1,$w1,$v1,$x1,$X7,$f,$Y7},$R);
$c8=q'lib/slice::ctors';
$d8={};
$e8=q'exists';
$f8=[];
$g8=q'exists $_[0]->{named}{$_[1]}';
$h8=bless({$V1,$f8,$E1,$g8,$G1,$H1},$e1);
$i8=q'quoted';
$j8=[];
$k8=q'my $self = shift;
my $q = ni(\'ni:lib/image\')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;';
$l8=bless({$V1,$j8,$E1,$k8,$G1,$H1},$e1);
$m8={$e8,$h8,$i8,$l8};
$n8=q'lib/ni_image.b';
$o8=bless({$c,$d8,$u1,$v1,$w1,$v1,$x1,$m8,$f,$n8},$R);
$p8=q'lib/slice::ctors';
$q8={};
$r8=q'--internal/+=';
$s8=[];
$t8=q'my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
  die "ni: failed to run $_: $!" unless $r;
}
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;';
$u8=bless({$V1,$s8,$E1,$t8,$G1,$H1},$e1);
$v8=q'--internal/eval';
$w8=[];
$x8=q'my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;';
$y8=bless({$V1,$w8,$E1,$x8,$G1,$H1},$e1);
$z8=q'--internal/image';
$A8=[];
$B8=q'shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;';
$C8=bless({$V1,$A8,$E1,$B8,$G1,$H1},$e1);
$D8=q'--internal/test';
$E8=[];
$F8=q'my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL: $@ in $t\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL: $r\\n";
  }
}
my $passed = @tests - $fails;
print "$passed test(s) passed\\n";
!!$fails;';
$G8=bless({$V1,$E8,$E1,$F8,$G1,$H1},$e1);
$H8=q'run';
$I8=[];
$J8=q'my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);';
$K8=bless({$V1,$I8,$E1,$J8,$G1,$H1},$e1);
$L8={$r8,$u8,$v8,$y8,$z8,$C8,$D8,$G8,$H8,$K8};
$M8=q'lib/ni_main.b';
$N8=bless({$c,$q8,$u1,$v1,$w1,$v1,$x1,$L8,$f,$M8},$R);
$O8=q'lib/slice::ctors';
$P8={};
$Q8=[];
$R8=q'my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";';
$S8=bless({$V1,$Q8,$E1,$R8,$G1,$H1},$e1);
$T8=q'resolver_for';
$U8=[];
$V8=q'my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;';
$W8=bless({$V1,$U8,$E1,$V8,$G1,$H1},$e1);
$X8={$z5,$S8,$T8,$W8};
$Y8=q'lib/ni_resolver.b';
$Z8=bless({$c,$P8,$u1,$v1,$w1,$v1,$x1,$X8,$f,$Y8},$R);
$c9=q'lib/slice::ctors';
$d9={};
$e9=q'fork';
$f9=[];
$g9=q'my ($class, $fn) = @_;
my $stdin  = ni(\'ni:unix/fifo\')->new;
my $stdout = ni(\'ni:unix/fifo\')->new;
my $stderr = ni(\'ni:unix/fifo\')->new;
my $pid    = fork;
die "ni:unix/pid.c: failed to fork: $!" unless defined $pid;

return ni(\'ni:unix/pid\')->new($pid,
  $stdin->write_side,
  $stdout->read_side,
  $stderr->read_side) if $pid;

$stdin->read_side;
$stdout->write_side;
$stderr->write_side;
exit &$fn($stdin, $stdout, $stderr);';
$h9=bless({$V1,$f9,$E1,$g9,$G1,$H1},$e1);
$i9=q'fork_exec';
$j9=[];
$k9=q'my ($class, @argv) = @_;
$class->fork(sub {
  my ($stdin, $stdout, $stderr) = @_;
  my $fd0 = ni(\'ni:unix/fd\')->new(fileno $stdin->read_side->read_fh)->move_to(0);
  my $fd1 = ni(\'ni:unix/fd\')->new(fileno $stdout->write_side->write_fh)->move_to(1);
  my $fd2 = ni(\'ni:unix/fd\')->new(fileno $stderr->write_side->write_fh)->move_to(2);
  exec @argv or die "ni:unix/pid.c: failed to exec @argv: $!";
});';
$l9=bless({$V1,$j9,$E1,$k9,$G1,$H1},$e1);
$m9={$e9,$h9,$i9,$l9};
$n9=q'/lib/ni_pid_ctors';
$o9=bless({$c,$d9,$u1,$v1,$w1,$v1,$x1,$m9,$f,$n9},$R);
$p9=q'lib/slice::ctors';
$q9=[$T2,$Z7,$o8,$N8,$Z8,$o9];
$r9=bless({$c,$N7,$f,$g1,$g,$q9},$r);
$s9=q'lib/ni.c::ctors';
$t9=q'named';
$u9=q'ni.doc:class';
$v9={$o,1};
$w9=[$H];
$x9=bless({$c,$v9,$f,$o,$g,$w9},$G);
$y9=q'metaclass::ctors';
$z9={$d1,1};
$A9={};
$B9=q'shift; +{name => shift, doc => []}';
$C9=bless({$E1,$B9,$G1,$H1},$e1);
$D9={$N1,$C9};
$E9=q'lib/doc_init.b';
$F9=bless({$c,$A9,$u1,$v1,$w1,$v1,$x1,$D9,$f,$E9},$R);
$G9=q'lib/slice::ctors';
$H9={};
$I9=q'\'ni.doc\'';
$J9=bless({$E1,$I9,$G1,$H1},$e1);
$K9={$h5,$J9};
$L9=q'lib/doc_namespace.b';
$M9=bless({$c,$H9,$u1,$v1,$w1,$v1,$x1,$K9,$f,$L9},$R);
$N9=q'lib/slice::ctors';
$O9={};
$P9=q'AUTOLOAD';
$Q9=q'my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;';
$R9=bless({$E1,$Q9,$G1,$H1},$e1);
$S9={$P9,$R9};
$T9=q'lib/doc_define.b';
$U9=bless({$c,$O9,$u1,$v1,$w1,$v1,$x1,$S9,$f,$T9},$R);
$V9=q'lib/slice::ctors';
$W9={};
$X9=q'eg';
$Y9=q'my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;';
$Z9=bless({$E1,$Y9,$G1,$H1},$e1);
$ca=q'tests';
$da=q'my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq \'eg\';
}
@tests;';
$ea=bless({$E1,$da,$G1,$H1},$e1);
$fa={$X9,$Z9,$ca,$ea};
$ga=q'lib/doc_test.b';
$ha=bless({$c,$W9,$u1,$v1,$w1,$v1,$x1,$fa,$f,$ga},$R);
$ia=q'lib/slice::ctors';
$ja=[$T2,$q3,$F9,$M9,$U9,$ha];
$ka=bless({$c,$z9,$f,$d1,$g,$ja},$o);
$la=q'lib/doc.c::ctors';
$ma=q'synopsis';
$na=q'
    ni(\'ni:object\')->child(\'message\')
      ->add(\'behaviorname.b\')           # add existing behavior
      ->def(\'message_init.b\',           # define new slice behavior
        instantiate => fn q{            # called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       # return object to be blessed
        })
      ->def(\'behaviorname.b\',           # define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! \'" . $$self{message} . "\'\\n";
        });
    ni(\'ni:child\')->new(\'hello world!\')->method1;
  ';
$oa=[$ma,$na];
$pa=q'description';
$qa=q'ni:class is at the core of ni\'s object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you\'d expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.';
$ra=[$pa,$qa];
$sa=q'behaviors';
$ta=q'ni\'s objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:lib/slice, which represents a set of methods you can add to a
      package.';
$ua=[];
$va=q'my $fn = fn q{"hi"};
my $slice = ni(\'ni:lib/slice\')->new(\'myslice\', f => $fn);
$slice->apply(\'foo\');
now foo->f == \'hi\';';
$wa=bless({$V1,$ua,$E1,$va,$G1,$H1},$e1);
$xa=q'TODO...';
$ya=[$sa,$ta,$X9,$wa,$xa];
$za=q'classes';
$Aa=q'ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni\'s classes are slice unions and as such don\'t
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn\'t in the picture,
      which makes multiple inheritance straightforward to implement.';
$Ba=[$za,$Aa,$xa];
$Ca=[$oa,$ra,$ya,$Ba];
$Da=bless({$W2,$Ca,$f,$T},$d1);
$Ea=q'lib/doc::ctors';
$Fa=q'ni.doc:lib/doc';
$Ga=q'
    ni("ni:some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...';
$Ha=[$ma,$Ga];
$Ia=q'Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class\'s code without bringing along all of
      its documentation and unit tests.';
$Ja=q'Documentation objects are internally represented as arrays of quoted
      method calls:';
$Ka=[];
$La=q'my $doc = ni("ni:lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];';
$Ma=bless({$V1,$Ka,$E1,$La,$G1,$H1},$e1);
$Na=q'This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":';
$Oa=[];
$Pa=q'my $doc = ni("ni:lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];';
$Qa=bless({$V1,$Oa,$E1,$Pa,$G1,$H1},$e1);
$Ra=[$pa,$Ia,$Ja,$X9,$Ma,$Na,$X9,$Qa];
$Sa=[$Ha,$Ra];
$Ta=bless({$W2,$Sa,$f,$d1},$d1);
$Ua=q'ni.doc:unix/cat';
$Va=q'
    my $combined = ni(\'ni:unix/cat\')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  ';
$Wa=[$ma,$Va];
$Xa=q'Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.';
$Ya=[$pa,$Xa];
$Za=[];
$cb=q'my $cat = ni("str:foo") + ni("str:bar");
my $dest = ni(\'ni:unix/str\')->new(my $data = "");
$cat->into($dest);
now ${$dest->data} == "foo\\nbar\\n";';
$db=bless({$V1,$Za,$E1,$cb,$G1,$H1},$e1);
$eb=[$X9,$db];
$fb=[$Wa,$Ya,$eb];
$gb=bless({$W2,$fb,$f,$k1},$d1);
$hb=q'ni:/lib/ni_pid_ctors';
$ib=q'ni:class';
$jb=q'ni:class.c';
$kb=q'ni:lib/accessor.b';
$lb=q'ni:lib/behavior';
$mb=q'ni:lib/behavior.c';
$nb=q'ni:lib/branch';
$ob=q'ni:lib/branch.b';
$pb=q'ni:lib/branch.c';
$qb=q'ni:lib/branch_init.b';
$rb=q'ni:lib/class_init.b';
$sb=q'ni:lib/dataslice';
$tb={$n,1};
$ub=[$M];
$vb=bless({$c,$tb,$f,$n,$g,$ub},$G);
$wb=q'metaclass::ctors';
$xb={$W,1};
$yb={};
$zb=q'my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};';
$Ab=bless({$E1,$zb,$G1,$H1},$e1);
$Bb={$N1,$Ab};
$Cb=q'lib/dataslice_init.b';
$Db=bless({$c,$yb,$u1,$v1,$w1,$v1,$x1,$Bb,$f,$Cb},$R);
$Eb=q'lib/slice::ctors';
$Fb={};
$Gb=q'local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;';
$Hb=bless({$E1,$Gb,$G1,$H1},$e1);
$Ib={$A3,$Hb};
$Jb=q'lib/dataslice_apply.b';
$Kb=bless({$c,$Fb,$u1,$v1,$w1,$v1,$x1,$Ib,$f,$Jb},$R);
$Lb=q'lib/slice::ctors';
$Mb=[$h3,$Db,$Kb];
$Nb=bless({$c,$xb,$f,$W,$g,$Mb},$n);
$Ob=q'lib/dataslice.c::ctors';
$Pb=q'ni:lib/dataslice.c';
$Qb=q'ni:lib/dataslice_apply.b';
$Rb=q'ni:lib/dataslice_init.b';
$Sb=q'ni:lib/definition.b';
$Tb=q'ni:lib/definition_def.b';
$Ub=q'ni:lib/definition_defdata.b';
$Vb=q'ni:lib/doc';
$Wb=q'ni:lib/doc.c';
$Xb=q'ni:lib/doc_define.b';
$Yb=q'ni:lib/doc_init.b';
$Zb=q'ni:lib/doc_namespace.b';
$cc=q'ni:lib/doc_test.b';
$dc=q'ni:lib/documentable.b';
$ec=q'ni:lib/fn';
$fc=q'ni:lib/fn.c';
$gc=q'ni:lib/fn_init.b';
$hc=q'ni:lib/fn_ops.b';
$ic=q'ni:lib/fn_ro.b';
$jc=q'ni:lib/fn_serialize.b';
$kc=q'ni:lib/global_static_test.b';
$lc={};
$mc=q'now';
$nc=[];
$oc=q'ni(\'ni:lib/test_value\')->new(shift)';
$pc=q'($)';
$qc=bless({$V1,$nc,$E1,$oc,$G1,$pc},$e1);
$rc={$mc,$qc};
$sc=q'lib/global_static_test.b';
$tc=bless({$c,$lc,$u1,$v1,$w1,$v1,$x1,$rc,$f,$sc},$R);
$uc=q'main';
$vc=q'lib/slice::ctors';
$wc=q'ni:lib/image';
$xc={$q,1};
$yc=[$H];
$zc=bless({$c,$xc,$f,$q,$g,$yc},$G);
$Ac=q'metaclass::ctors';
$Bc={$f1,1};
$Cc={};
$Dc=[];
$Ec=q'my $class = shift;
my %args  = (
  include_shebang => 1,
  include_license => 1,
  include_boot    => 1,
  include_classes => 1,
  include_run     => 1,
  local_vars      => 0,
  use_newlines    => 0,
  @_);

+{include_shebang => $args{include_shebang},
  include_license => $args{include_license},
  include_boot    => $args{include_boot},
  include_classes => $args{include_classes},
  include_run     => $args{include_run},
  local_vars      => $args{local_vars},
  use_newlines    => $args{use_newlines},

  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};';
$Fc=bless({$V1,$Dc,$E1,$Ec,$G1,$H1},$e1);
$Gc={$N1,$Fc};
$Hc=q'lib/image_init.b';
$Ic=bless({$c,$Cc,$u1,$v1,$w1,$v1,$x1,$Gc,$f,$Hc},$R);
$Jc=q'lib/slice::ctors';
$Kc={};
$Lc=q'address';
$Mc=[];
$Nc=q'return \'undef\' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 16;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);';
$Oc=bless({$V1,$Mc,$E1,$Nc,$G1,$H1},$e1);
$Pc=q'allocate_gensym';
$Qc=[];
$Rc=q'my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;';
$Sc=bless({$V1,$Qc,$E1,$Rc,$G1,$H1},$e1);
$Tc=q'boot_side_effect';
$Uc=[];
$Vc=q'unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]';
$Wc=bless({$V1,$Uc,$E1,$Vc,$G1,$H1},$e1);
$Xc=q'circular_links';
$Yc=[];
$Zc=q'local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};';
$cd=bless({$V1,$Yc,$E1,$Zc,$G1,$H1},$e1);
$dd=q'finalizer';
$ed=[];
$fd=q'push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]';
$gd=bless({$V1,$ed,$E1,$fd,$G1,$H1},$e1);
$hd=q'gensym';
$id=[];
$jd=q'my $n = shift->{gensym_n}++;
my $s = \'$\' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;';
$kd=bless({$V1,$id,$E1,$jd,$G1,$H1},$e1);
$ld=q'is_circular';
$md=[];
$nd=q'my $self = shift;
ref $$self{visited}{$self->address($_[0])};';
$od=bless({$V1,$md,$E1,$nd,$G1,$H1},$e1);
$pd=q'quote';
$qd=[];
$rd=q'my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? \'undef\' : $v if defined $v;
$$self{visited}{$a} = \\\'undef\';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));';
$sd=bless({$V1,$qd,$E1,$rd,$G1,$H1},$e1);
$td=q'quote_array';
$ud=[];
$vd=q'local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_])
  && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
for 0..$#{$v};
\'[\' . join(\',\', map $self->quote($_), @$v) . \']\';';
$wd=bless({$V1,$ud,$E1,$vd,$G1,$H1},$e1);
$xd=q'quote_blessed';
$yd=[];
$zd=q'my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq \'HASH\' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";';
$Ad=bless({$V1,$yd,$E1,$zd,$G1,$H1},$e1);
$Bd=q'quote_class';
$Cd=[];
$Dd=q'my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");';
$Ed=bless({$V1,$Cd,$E1,$Dd,$G1,$H1},$e1);
$Fd=q'quote_hash';
$Gd=[];
$Hd=q'local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  push @{$$self{circular}}, [$a, "{" . $self->quote($k) . "}",
                                 $self->address($$v{$k})]
  if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
\'{\' . join(",", @qs) . \'}\';';
$Id=bless({$V1,$Gd,$E1,$Hd,$G1,$H1},$e1);
$Jd=q'quote_object';
$Kd=[];
$Ld=q'my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can(\'serialize\') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;';
$Md=bless({$V1,$Kd,$E1,$Ld,$G1,$H1},$e1);
$Nd=q'quote_scalar';
$Od=[];
$Pd=q'my $v = $_[1];
return \'undef\' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\'])/\\\\$1/g;
"q\'$v\'";';
$Qd=bless({$V1,$Od,$E1,$Pd,$G1,$H1},$e1);
$Rd=q'quote_value';
$Sd=[];
$Td=q'my $self = shift;
return $self->quote_scalar($_[0]) unless ref $_[0];
return $self->quote_array($_[0])  if \'ARRAY\' eq ref $_[0];
return $self->quote_hash($_[0])   if \'HASH\'  eq ref $_[0];
die "cannot serialize $_[0]"      if \'CODE\'  eq ref $_[0];
$self->quote_object($_[0]);';
$Ud=bless({$V1,$Sd,$E1,$Td,$G1,$H1},$e1);
$Vd=q'reconstruction';
$Wd=[];
$Xd=q'my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});';
$Yd=bless({$V1,$Wd,$E1,$Xd,$G1,$H1},$e1);
$Zd=q'side_effect';
$ce=[];
$de=q'push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]';
$ee=bless({$V1,$ce,$E1,$de,$G1,$H1},$e1);
$fe=q'write';
$ge=[];
$he=q'local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  ($$self{include_shebang} ? ("#!/usr/bin/env perl\\n") : ()),
  ($$self{include_license} ? ("chomp(\\$ni::license=<<\'_\');\\n", $ni::license, "\\n_\\n") : ()),
  ($$self{include_boot}    ? ("BEGIN{eval(\\$ni::boot=<<\'_\')}\\n", $ni::boot, "\\n_\\n") : ()),
  ($$self{use_newlines}    ? map("$_\\n", $self->reconstruction) : $self->reconstruction),
  ($$self{include_run}     ? ("ni->run(\\@ARGV);", "\\n__DATA__\\n") : ());';
$ie=bless({$V1,$ge,$E1,$he,$G1,$H1},$e1);
$je={$Lc,$Oc,$Pc,$Sc,$Tc,$Wc,$Xc,$cd,$dd,$gd,$hd,$kd,$ld,$od,$pd,$sd,$td,$wd,$xd,$Ad,$Bd,$Ed,$Fd,$Id,$Jd,$Md,$Nd,$Qd,$Rd,$Ud,$Vd,$Yd,$Zd,$ee,$fe,$ie};
$ke=q'lib/image_quoting.b';
$le=bless({$c,$Kc,$u1,$v1,$w1,$v1,$x1,$je,$f,$ke},$R);
$me=q'lib/slice::ctors';
$ne=[$T2,$Ic,$le];
$oe=bless({$c,$Bc,$f,$f1,$g,$ne},$q);
$pe=q'lib/image.c::ctors';
$qe=q'ni:lib/image.c';
$re=q'ni:lib/image_init.b';
$se=q'ni:lib/image_quoting.b';
$te=q'ni:lib/instance.b';
$ue=q'ni:lib/instantiable.b';
$ve=q'ni:lib/json.b';
$we={};
$xe=q'json_decode';
$ye=[];
$ze=q'local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];';
$Ae=bless({$V1,$ye,$E1,$ze,$G1,$pc},$e1);
$Be=q'json_encode';
$Ce=[];
$De=q'local $_;
my ($v) = @_;
return "[" . join(\',\', map ni::json_encode($_), @$v) . "]" if \'ARRAY\' eq ref $v;
return "{" . join(\',\', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if \'HASH\' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : \'null\';';
$Ee=bless({$V1,$Ce,$E1,$De,$G1,$pc},$e1);
$Fe=q'json_escape';
$Ge=[];
$He=q'(my $x = $_[0]) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . $ni::json_escapes{$1}/eg;
"\\"$x\\"";';
$Ie=bless({$V1,$Ge,$E1,$He,$G1,$pc},$e1);
$Je=q'json_unescape';
$Ke=[];
$Le=q'my $x = substr $_[0], 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;';
$Me=bless({$V1,$Ke,$E1,$Le,$G1,$pc},$e1);
$Ne=q'json_unescape_one';
$Oe=[];
$Pe=q'$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1';
$Qe=bless({$V1,$Oe,$E1,$Pe,$G1,$pc},$e1);
$Re={$xe,$Ae,$Be,$Ee,$Fe,$Ie,$Je,$Me,$Ne,$Qe};
$Se=q'lib/json.b';
$Te=bless({$c,$we,$u1,$v1,$w1,$v1,$x1,$Re,$f,$Se},$R);
$Ue=q'ni';
$Ve=q'lib/slice::ctors';
$We=q'ni:lib/name_as_string.b';
$Xe=q'ni:lib/named.b';
$Ye=q'ni:lib/named_in_ni.b';
$Ze=q'ni:lib/namespaced.b';
$cf=q'ni:lib/ni';
$df=q'ni:lib/ni.c';
$ef=q'ni:lib/ni_image.b';
$ff=q'ni:lib/ni_main.b';
$gf=q'ni:lib/ni_resolver.b';
$hf=q'ni:lib/ni_self.b';
$if=q'ni:lib/ni_static_util.b';
$jf={};
$kf=q'abbrev';
$lf=[];
$mf=q'length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . \'...\'';
$nf=bless({$V1,$lf,$E1,$mf,$G1,$H1},$e1);
$of=q'dor';
$pf=[];
$qf=q'defined $_[0] ? $_[0] : $_[1]';
$rf=bless({$V1,$pf,$E1,$qf,$G1,$H1},$e1);
$sf=q'indent';
$tf=[];
$uf=q'my ($s, $indent) = (@_, 2);
join "\\n", map \' \' x $indent . $_, split /\\n/, $s;';
$vf=bless({$V1,$tf,$E1,$uf,$G1,$H1},$e1);
$wf=q'max';
$xf=[];
$yf=q'local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m';
$zf=bless({$V1,$xf,$E1,$yf,$G1,$H1},$e1);
$Af=q'maxstr';
$Bf=[];
$Cf=q'local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m';
$Df=bless({$V1,$Bf,$E1,$Cf,$G1,$H1},$e1);
$Ef=q'mean';
$Ff=[];
$Gf=q'sum(@_) / (@_ || 1)';
$Hf=bless({$V1,$Ff,$E1,$Gf,$G1,$H1},$e1);
$If=q'min';
$Jf=[];
$Kf=q'local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m';
$Lf=bless({$V1,$Jf,$E1,$Kf,$G1,$H1},$e1);
$Mf=q'minstr';
$Nf=[];
$Of=q'local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m';
$Pf=bless({$V1,$Nf,$E1,$Of,$G1,$H1},$e1);
$Qf=q'sgr';
$Rf=[];
$Sf=q'(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x';
$Tf=bless({$V1,$Rf,$E1,$Sf,$G1,$H1},$e1);
$Uf=q'sr';
$Vf=[];
$Wf=q'(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x';
$Xf=bless({$V1,$Vf,$E1,$Wf,$G1,$H1},$e1);
$Yf=q'sum';
$Zf=[];
$cg=q'local $_; my $x = 0; $x += $_ for @_; $x';
$dg=bless({$V1,$Zf,$E1,$cg,$G1,$H1},$e1);
$eg=q'swap';
$fg=[];
$gg=q'@_[0, 1] = @_[1, 0]';
$hg=bless({$V1,$fg,$E1,$gg,$G1,$H1},$e1);
$ig={$kf,$nf,$of,$rf,$sf,$vf,$wf,$zf,$Af,$Df,$Ef,$Hf,$If,$Lf,$Mf,$Pf,$Qf,$Tf,$Uf,$Xf,$Yf,$dg,$eg,$hg};
$jg=q'lib/ni_static_util.b';
$kg=bless({$c,$jf,$u1,$v1,$w1,$v1,$x1,$ig,$f,$jg},$R);
$lg=q'lib/slice::ctors';
$mg=q'ni:lib/perlbranch.b';
$ng=q'ni:lib/ref_eq.b';
$og=q'ni:lib/resolver.b';
$pg=q'ni:lib/slice';
$qg=q'ni:lib/slice.b';
$rg=q'ni:lib/slice.c';
$sg=q'ni:lib/slice_init.b';
$tg=q'ni:lib/slice_serialize.b';
$ug=q'ni:lib/static_fn.b';
$vg={};
$wg=[];
$xg=q'ni(\'ni:lib/fn\')->new(@_)';
$yg=bless({$V1,$wg,$E1,$xg,$G1,$pc},$e1);
$zg=q'fp';
$Ag=[];
$Bg=q'ni(\'ni:lib/fn\')->new(@_)';
$Cg=q'($$)';
$Dg=bless({$V1,$Ag,$E1,$Bg,$G1,$Cg},$e1);
$Eg={$e2,$yg,$zg,$Dg};
$Fg=q'lib/static_fn.b';
$Gg=bless({$c,$vg,$u1,$v1,$w1,$v1,$x1,$Eg,$f,$Fg},$R);
$Hg=q'lib/slice::ctors';
$Ig=q'ni:lib/subclass.b';
$Jg=q'ni:lib/tag';
$Kg=q'ni:lib/tag.b';
$Lg=q'ni:lib/tag.c';
$Mg=q'ni:lib/tag_init.b';
$Ng=q'ni:lib/test_value';
$Og=q'lib/test_value.c';
$Pg={$Og,1};
$Qg=q'lib/test_value.c';
$Rg=[$H];
$Sg=bless({$c,$Pg,$f,$Qg,$g,$Rg},$G);
$Tg=q'metaclass::ctors';
$Ug={$h1,1};
$Vg={};
$Wg=[];
$Xg=q'\\$_[1]';
$Yg=bless({$V1,$Wg,$E1,$Xg,$G1,$H1},$e1);
$Zg={$N1,$Yg};
$ch=q'lib/test_value_init.b';
$dh=bless({$c,$Vg,$u1,$v1,$w1,$v1,$x1,$Zg,$f,$ch},$R);
$eh=q'lib/slice::ctors';
$fh={};
$gh=q'(==';
$hh=[];
$ih=q'my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;';
$jh=bless({$V1,$hh,$E1,$ih,$G1,$H1},$e1);
$kh=q'diff';
$lh=[];
$mh=q'my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq \'HASH\') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq \'ARRAY\') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq \'SCALAR\') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;';
$nh=bless({$V1,$lh,$E1,$mh,$G1,$H1},$e1);
$oh={$gh,$jh,$kh,$nh};
$ph=q'lib/test_value_eq.b';
$qh=bless({$c,$fh,$u1,$v1,$w1,$v1,$x1,$oh,$f,$ph},$R);
$rh=q'lib/slice::ctors';
$sh={};
$th=[];
$uh=q'ni::json_encode ${$_[0]}';
$vh=bless({$V1,$th,$E1,$uh,$G1,$H1},$e1);
$wh={$n2,$vh};
$xh=q'lib/test_value_str.b';
$yh=bless({$c,$sh,$u1,$v1,$w1,$v1,$x1,$wh,$f,$xh},$R);
$zh=q'lib/slice::ctors';
$Ah=[$T2,$dh,$qh,$yh];
$Bh=q'lib/test_value.c';
$Ch=bless({$c,$Ug,$f,$h1,$g,$Ah},$Bh);
$Dh=q'lib/test_value.c::ctors';
$Eh=q'ni:lib/test_value.c';
$Fh=q'ni:lib/test_value_eq.b';
$Gh=q'ni:lib/test_value_init.b';
$Hh=q'ni:lib/test_value_str.b';
$Ih=q'ni:main';
$Jh={$uc,1};
$Kh=[$Gg,$tc];
$Lh=bless({$c,$Jh,$f,$uc,$g,$Kh},$Z);
$Mh=q'module::ctors';
$Nh=q'ni:metaclass';
$Oh=q'ni:metaclass.c';
$Ph=q'ni:module';
$Qh=q'ni:module.c';
$Rh=q'ni:ni';
$Sh={$Ue,1};
$Th={$Ue,1};
$Uh=q'data';
$Vh=q'json_escapes';
$Wh=q'';
$Xh=q'b';
$Yh=q'	';
$Zh=q't';
$ci=q'
';
$di=q'n';
$ei=q'';
$fi=q'r';
$gi=q'"';
$hi=q'/';
$ii=q'\\';
$ji={$Wh,$Xh,$Yh,$Zh,$ci,$di,$ei,$fi,$gi,$gi,$hi,$hi,$ii,$ii};
$ki=q'json_unescapes';
$li={$gi,$gi,$hi,$hi,$ii,$ii,$Xh,$Wh,$di,$ci,$fi,$ei,$Zh,$Yh};
$mi={$Vh,$ji,$ki,$li};
$ni=q'lib/json_data.b';
$oi=bless({$c,$Th,$Uh,$mi,$f,$ni},$W);
$pi=q'lib/dataslice::ctors';
$qi=[$oi,$Te,$kg];
$ri=bless({$c,$Sh,$f,$Ue,$g,$qi},$Z);
$si=q'ni:object';
$ti=q'ni:object.c';
$ui=q'ni:unix/cat';
$vi={$w,1};
$wi={$w,1,$x,1,$y,1,$z,1,$A,1,$B,1,$C,1,$D,1};
$xi=[$H];
$yi=bless({$c,$wi,$f,$A,$g,$xi},$G);
$zi=q'metaclass::ctors';
$Ai=[$yi];
$Bi=bless({$c,$vi,$f,$w,$g,$Ai},$G);
$Ci=q'metaclass::ctors';
$Di={$k1,1};
$Ei={$k1,1,$l1,1,$m1,1,$n1,1,$o1,1,$p1,1,$q1,1,$r1,1};
$Fi={};
$Gi=q'into';
$Hi=[];
$Ii=q'local $_;
my ($self, $dest, $each) = @_;
my $block_size = $self->can(\'read_size\') ? $self->read_size : 8192;
while ($self->read($_, $block_size)) {
  &$each($_) if defined $each;
  $dest->write($_);
}';
$Ji=bless({$V1,$Hi,$E1,$Ii,$G1,$H1},$e1);
$Ki={$Gi,$Ji};
$Li=q'unix/io_stream.b';
$Mi=bless({$c,$Fi,$u1,$v1,$w1,$v1,$x1,$Ki,$f,$Li},$R);
$Ni=q'lib/slice::ctors';
$Oi={};
$Pi=q'(+';
$Qi=[];
$Ri=q'ni(\'ni:unix/cat\')->new(@_[0, 1])';
$Si=bless({$V1,$Qi,$E1,$Ri,$G1,$H1},$e1);
$Ti={$Pi,$Si};
$Ui=q'unix/io_constructors.b';
$Vi=bless({$c,$Oi,$u1,$v1,$w1,$v1,$x1,$Ti,$f,$Ui},$R);
$Wi=q'lib/slice::ctors';
$Xi={};
$Yi=q'(<>';
$Zi=[];
$cj=q'my $fh = shift->read_fh;
# TODO: buffered line reading with a pushback queue';
$dj=bless({$V1,$Zi,$E1,$cj,$G1,$H1},$e1);
$ej=q'(@{}';
$fj=[];
$gj=q'my $self = shift; [<$self>]';
$hj=bless({$V1,$fj,$E1,$gj,$G1,$H1},$e1);
$ij={$Yi,$dj,$ej,$hj};
$jj=q'unix/io_readers.b';
$kj=bless({$c,$Xi,$u1,$v1,$w1,$v1,$x1,$ij,$f,$jj},$R);
$lj=q'lib/slice::ctors';
$mj=[$T2,$Mi,$Vi,$kj];
$nj=bless({$c,$Ei,$f,$o1,$g,$mj},$A);
$oj=q'unix/io.c::ctors';
$pj={};
$qj=[];
$rj=q'shift; +{fs => [@_]}';
$sj=bless({$V1,$qj,$E1,$rj,$G1,$H1},$e1);
$tj={$N1,$sj};
$uj=q'unix/cat_init.b';
$vj=bless({$c,$pj,$u1,$v1,$w1,$v1,$x1,$tj,$f,$uj},$R);
$wj=q'lib/slice::ctors';
$xj={};
$yj=q'read';
$zj=[];
$Aj=q'my $fs = shift->{fs};
my $n;
shift @$fs until !@$fs or $n = $$fs[0]->read(@_);
return $n;';
$Bj=bless({$V1,$zj,$E1,$Aj,$G1,$H1},$e1);
$Cj={$yj,$Bj};
$Dj=q'unix/cat_read.b';
$Ej=bless({$c,$xj,$u1,$v1,$w1,$v1,$x1,$Cj,$f,$Dj},$R);
$Fj=q'lib/slice::ctors';
$Gj=[$nj,$vj,$Ej];
$Hj=bless({$c,$Di,$f,$k1,$g,$Gj},$w);
$Ij=q'unix/cat.c::ctors';
$Jj=q'ni:unix/cat.c';
$Kj=q'ni:unix/cat_init.b';
$Lj=q'ni:unix/cat_read.b';
$Mj=q'ni:unix/fd';
$Nj={$x,1};
$Oj=[$yi];
$Pj=bless({$c,$Nj,$f,$x,$g,$Oj},$G);
$Qj=q'metaclass::ctors';
$Rj={$l1,1};
$Sj={};
$Tj=q'fd';
$Uj=[];
$Vj=q'shift->{\'fd\'}';
$Wj=bless({$V1,$Uj,$E1,$Vj,$G1,$H1},$e1);
$Xj={$Tj,$Wj};
$Yj=q'unix/fd_readers.b';
$Zj=bless({$c,$Sj,$u1,$v1,$w1,$v1,$x1,$Xj,$f,$Yj},$R);
$ck=q'lib/slice::ctors';
$dk={};
$ek=[];
$fk=q'my ($class, $fd) = @_;
+{fd => $fd, fh => undef};';
$gk=bless({$V1,$ek,$E1,$fk,$G1,$H1},$e1);
$hk={$N1,$gk};
$ik=q'unix/fd_init.b';
$jk=bless({$c,$dk,$u1,$v1,$w1,$v1,$x1,$hk,$f,$ik},$R);
$kk=q'lib/slice::ctors';
$lk={};
$mk=q'move_to';
$nk=[];
$ok=q'use POSIX qw/dup2/;
my ($self, $new) = @_;
return $self if $new == $$self{fd};
close $$self{fh} if Scalar::Util::openhandle $$self{fh};
dup2 $$self{fd}, $new or die "ni:unix/fd: dup2($$self{fd}, $new): $!";
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;';
$pk=bless({$V1,$nk,$E1,$ok,$G1,$H1},$e1);
$qk={$mk,$pk};
$rk=q'unix/fd_shell.b';
$sk=bless({$c,$lk,$u1,$v1,$w1,$v1,$x1,$qk,$f,$rk},$R);
$tk=q'lib/slice::ctors';
$uk={$l1,1,$m1,1,$n1,1,$p1,1,$q1,1};
$vk=q'unix/has_fd.b';
$wk={};
$xk=[];
$yk=q'no warnings \'io\';
use Errno qw/EINTR/;
my $fh = shift->read_fh;
my $n;
do {
  return $n if defined($n = read $fh, $_[0], $_[1], $_[2] || 0);
} while $!{EINTR};
return undef;';
$zk=bless({$V1,$xk,$E1,$yk,$G1,$H1},$e1);
$Ak=[];
$Bk=q'my $fh = shift->write_fh;
my $n;
do {
  return $n if defined($n = syswrite $fh, $_[0]);
} while $!{EINTR};
return undef;';
$Ck=bless({$V1,$Ak,$E1,$Bk,$G1,$H1},$e1);
$Dk={$yj,$zk,$fe,$Ck};
$Ek=q'unix/fd_safeio.b';
$Fk=bless({$c,$wk,$u1,$v1,$w1,$v1,$x1,$Dk,$f,$Ek},$R);
$Gk=q'lib/slice::ctors';
$Hk=[$Fk];
$Ik=bless({$c,$uk,$f,$vk,$g,$Hk},$V);
$Jk=q'lib/branch::ctors';
$Kk={};
$Lk=q'read_fh';
$Mk=[];
$Nk=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'<&=\', $self->{fd}
  or die "ni:unix/fd $self->{fd} failed to read: $!";
$self->{fh} = $fh;';
$Ok=bless({$V1,$Mk,$E1,$Nk,$G1,$H1},$e1);
$Pk=q'write_fh';
$Qk=[];
$Rk=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'>&=\', $self->{fd}
  or die "ni:unix/file $self->{fd} failed to write: $!";
$self->{fh} = $fh;';
$Sk=bless({$V1,$Qk,$E1,$Rk,$G1,$H1},$e1);
$Tk={$Lk,$Ok,$Pk,$Sk};
$Uk=q'unix/fd_io.b';
$Vk=bless({$c,$Kk,$u1,$v1,$w1,$v1,$x1,$Tk,$f,$Uk},$R);
$Wk=q'lib/slice::ctors';
$Xk=[$nj,$Zj,$jk,$sk,$Ik,$Vk];
$Yk=bless({$c,$Rj,$f,$l1,$g,$Xk},$x);
$Zk=q'unix/fd.c::ctors';
$cl=q'ni:unix/fd.c';
$dl=q'ni:unix/fd_init.b';
$el=q'ni:unix/fd_io.b';
$fl=q'ni:unix/fd_readers.b';
$gl=q'ni:unix/fd_safeio.b';
$hl=q'ni:unix/fd_shell.b';
$il=q'ni:unix/fifo';
$jl={$y,1};
$kl=[$yi];
$ll=bless({$c,$jl,$f,$y,$g,$kl},$G);
$ml=q'metaclass::ctors';
$nl={$m1,1};
$ol={};
$pl=[];
$ql=q'shift->{\'read_fh\'}';
$rl=bless({$V1,$pl,$E1,$ql,$G1,$H1},$e1);
$sl=[];
$tl=q'shift->{\'write_fh\'}';
$ul=bless({$V1,$sl,$E1,$tl,$G1,$H1},$e1);
$vl={$Lk,$rl,$Pk,$ul};
$wl=q'unix/fifo_io.b';
$xl=bless({$c,$ol,$u1,$v1,$w1,$v1,$x1,$vl,$f,$wl},$R);
$yl=q'lib/slice::ctors';
$zl={};
$Al=[];
$Bl=q'my ($class) = @_;
pipe my ($r, $w) or die "ni:unix/fifo failed: $!";
+{read_fh => $r, write_fh => $w};';
$Cl=bless({$V1,$Al,$E1,$Bl,$G1,$H1},$e1);
$Dl={$N1,$Cl};
$El=q'unix/fifo_init.b';
$Fl=bless({$c,$zl,$u1,$v1,$w1,$v1,$x1,$Dl,$f,$El},$R);
$Gl=q'lib/slice::ctors';
$Hl={};
$Il=q'read_side';
$Jl=[];
$Kl=q'my $self = shift; close $$self{write_fh}; $self';
$Ll=bless({$V1,$Jl,$E1,$Kl,$G1,$H1},$e1);
$Ml=q'write_side';
$Nl=[];
$Ol=q'my $self = shift; close $$self{read_fh};  $self';
$Pl=bless({$V1,$Nl,$E1,$Ol,$G1,$H1},$e1);
$Ql={$Il,$Ll,$Ml,$Pl};
$Rl=q'unix/fifo_direction.b';
$Sl=bless({$c,$Hl,$u1,$v1,$w1,$v1,$x1,$Ql,$f,$Rl},$R);
$Tl=q'lib/slice::ctors';
$Ul=[$nj,$xl,$Fl,$Ik,$Sl];
$Vl=bless({$c,$nl,$f,$m1,$g,$Ul},$y);
$Wl=q'unix/fifo.c::ctors';
$Xl=q'ni:unix/fifo.c';
$Yl=q'ni:unix/fifo_direction.b';
$Zl=q'ni:unix/fifo_init.b';
$cm=q'ni:unix/fifo_io.b';
$dm=q'ni:unix/file';
$em={$z,1};
$fm=[$yi];
$gm=bless({$c,$em,$f,$z,$g,$fm},$G);
$hm=q'metaclass::ctors';
$im={$n1,1};
$jm={};
$km=[];
$lm=q'shift->{\'name\'}';
$mm=bless({$V1,$km,$E1,$lm,$G1,$H1},$e1);
$nm={$f,$mm};
$om=q'unix/file_readers.b';
$pm=bless({$c,$jm,$u1,$v1,$w1,$v1,$x1,$nm,$f,$om},$R);
$qm=q'lib/slice::ctors';
$rm={};
$sm=[];
$tm=q'my ($class, $name) = @_;
+{name => $name, fh => undef};';
$um=bless({$V1,$sm,$E1,$tm,$G1,$H1},$e1);
$vm={$N1,$um};
$wm=q'unix/file_init.b';
$xm=bless({$c,$rm,$u1,$v1,$w1,$v1,$x1,$vm,$f,$wm},$R);
$ym=q'lib/slice::ctors';
$zm={};
$Am=[];
$Bm=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'<\', $self->{name}
  or die "ni:unix/file $self->{name} failed to read: $!";
$self->{fh} = $fh;';
$Cm=bless({$V1,$Am,$E1,$Bm,$G1,$H1},$e1);
$Dm=[];
$Em=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'>\', $self->{name}
  or die "ni:unix/file $self->{name} failed to write: $!";
$self->{fh} = $fh;';
$Fm=bless({$V1,$Dm,$E1,$Em,$G1,$H1},$e1);
$Gm={$Lk,$Cm,$Pk,$Fm};
$Hm=q'unix/file_io.b';
$Im=bless({$c,$zm,$u1,$v1,$w1,$v1,$x1,$Gm,$f,$Hm},$R);
$Jm=q'lib/slice::ctors';
$Km=[$nj,$pm,$xm,$Ik,$Im];
$Lm=bless({$c,$im,$f,$n1,$g,$Km},$z);
$Mm=q'unix/file.c::ctors';
$Nm=q'ni:unix/file.c';
$Om=q'ni:unix/file_init.b';
$Pm=q'ni:unix/file_io.b';
$Qm=q'ni:unix/file_readers.b';
$Rm=q'ni:unix/has_fd.b';
$Sm=q'ni:unix/io';
$Tm=q'ni:unix/io.c';
$Um=q'ni:unix/io_constructors.b';
$Vm=q'ni:unix/io_readers.b';
$Wm=q'ni:unix/io_stream.b';
$Xm=q'ni:unix/pid';
$Ym={$B,1};
$Zm=[$yi];
$cn=bless({$c,$Ym,$f,$B,$g,$Zm},$G);
$dn=q'metaclass::ctors';
$en={$p1,1};
$fn={};
$gn=q'pid';
$hn=[];
$in=q'shift->{\'pid\'}';
$jn=bless({$V1,$hn,$E1,$in,$G1,$H1},$e1);
$kn=q'stderr';
$ln=[];
$mn=q'shift->{\'stderr\'}';
$nn=bless({$V1,$ln,$E1,$mn,$G1,$H1},$e1);
$on=q'stdin';
$pn=[];
$qn=q'shift->{\'stdin\'}';
$rn=bless({$V1,$pn,$E1,$qn,$G1,$H1},$e1);
$sn=q'stdout';
$tn=[];
$un=q'shift->{\'stdout\'}';
$vn=bless({$V1,$tn,$E1,$un,$G1,$H1},$e1);
$wn={$gn,$jn,$kn,$nn,$on,$rn,$sn,$vn};
$xn=q'unix/pid_readers.b';
$yn=bless({$c,$fn,$u1,$v1,$w1,$v1,$x1,$wn,$f,$xn},$R);
$zn=q'lib/slice::ctors';
$An={};
$Bn=[];
$Cn=q'my ($class, $pid, $i, $o, $e) = @_;
+{pid    => $pid,
  stdin  => $i,
  stdout => $o,
  stderr => $e};';
$Dn=bless({$V1,$Bn,$E1,$Cn,$G1,$H1},$e1);
$En={$N1,$Dn};
$Fn=q'unix/pid_init.b';
$Gn=bless({$c,$An,$u1,$v1,$w1,$v1,$x1,$En,$f,$Fn},$R);
$Hn=q'lib/slice::ctors';
$In={};
$Jn={};
$Kn=q'unix/pid_wait.b';
$Ln=bless({$c,$In,$u1,$v1,$w1,$v1,$x1,$Jn,$f,$Kn},$R);
$Mn=q'lib/slice::ctors';
$Nn={};
$On=[];
$Pn=q'shift->{stdout}->read_fh';
$Qn=bless({$V1,$On,$E1,$Pn,$G1,$H1},$e1);
$Rn=[];
$Sn=q'shift->{stdin}->write_fh';
$Tn=bless({$V1,$Rn,$E1,$Sn,$G1,$H1},$e1);
$Un={$Lk,$Qn,$Pk,$Tn};
$Vn=q'unix/pid_io.b';
$Wn=bless({$c,$Nn,$u1,$v1,$w1,$v1,$x1,$Un,$f,$Vn},$R);
$Xn=q'lib/slice::ctors';
$Yn=[$nj,$yn,$Gn,$Ln,$Ik,$Wn];
$Zn=bless({$c,$en,$f,$p1,$g,$Yn},$B);
$co=q'unix/pid.c::ctors';
$do=q'ni:unix/pid.c';
$eo=q'ni:unix/pid_init.b';
$fo=q'ni:unix/pid_io.b';
$go=q'ni:unix/pid_readers.b';
$ho=q'ni:unix/pid_wait.b';
$io=q'ni:unix/pipeline';
$jo={$C,1};
$ko=[$yi];
$lo=bless({$c,$jo,$f,$C,$g,$ko},$G);
$mo=q'metaclass::ctors';
$no={$q1,1};
$oo={};
$po=[];
$qo=q'shift->{\'stdin\'}';
$ro=bless({$V1,$po,$E1,$qo,$G1,$H1},$e1);
$so=[];
$to=q'shift->{\'stdout\'}';
$uo=bless({$V1,$so,$E1,$to,$G1,$H1},$e1);
$vo={$on,$ro,$sn,$uo};
$wo=q'unix/pipeline_ro.b';
$xo=bless({$c,$oo,$u1,$v1,$w1,$v1,$x1,$vo,$f,$wo},$R);
$yo=q'lib/slice::ctors';
$zo={};
$Ao=[];
$Bo=q'my $class  = shift;
my $stdin  = ni(\'ni:unix/fifo\')->new;
my $stdout = ni(\'ni:unix/fifo\')->new;
# TODO: stderr and multiplexing, which probably happens here

my @rs = ($stdin, @_);
my @ws = (@_, $stdout);
my $rv; vec($rv, fileno $_->read_fh,  1) = 1 for @rs;
my $wv; vec($wv, fileno $_->write_fh, 1) = 1 for @ws;

+{ps     => [@_],
  stdin  => $stdin,
  stdout => $stdout,
  rs => \\@rs, rv => $rv,
  ws => \\@ws, wv => $wv};';
$Co=bless({$V1,$Ao,$E1,$Bo,$G1,$H1},$e1);
$Do={$N1,$Co};
$Eo=q'unix/pipeline_init.b';
$Fo=bless({$c,$zo,$u1,$v1,$w1,$v1,$x1,$Do,$f,$Eo},$R);
$Go=q'lib/slice::ctors';
$Ho={};
$Io=q'async_step';
$Jo=[];
$Ko=q'local $_;
my $self = shift;
my $rv = $$self{rv};
my $wv = $$self{wv};
my $ev = $$self{ev};
return $self unless select $rv, $wv, $ev, 0;
for my $i (0..$#{$$self{rs}}) {
  my $rfh = $$self{rs}[$i]->read_fh;
  my $wfh = $$self{ws}[$i]->write_fh;
  next unless vec $rv, fileno $rfh, 1 and vec $wv, fileno $wfh, 1;
  $$self{rs}[$i]->read($_, 8192);
  $$self{ws}[$i]->write($_);
}
$self;';
$Lo=bless({$V1,$Jo,$E1,$Ko,$G1,$H1},$e1);
$Mo={$Io,$Lo};
$No=q'unix/pipeline_async.b';
$Oo=bless({$c,$Ho,$u1,$v1,$w1,$v1,$x1,$Mo,$f,$No},$R);
$Po=q'lib/slice::ctors';
$Qo={};
$Ro=[];
$So=q'shift->{stdout}->read_fh';
$To=bless({$V1,$Ro,$E1,$So,$G1,$H1},$e1);
$Uo=[];
$Vo=q'shift->{stdin}->write_fh';
$Wo=bless({$V1,$Uo,$E1,$Vo,$G1,$H1},$e1);
$Xo={$Lk,$To,$Pk,$Wo};
$Yo=q'unix/pipeline_io.b';
$Zo=bless({$c,$Qo,$u1,$v1,$w1,$v1,$x1,$Xo,$f,$Yo},$R);
$cp=q'lib/slice::ctors';
$dp=[$nj,$xo,$Fo,$Oo,$Ik,$Zo];
$ep=bless({$c,$no,$f,$q1,$g,$dp},$C);
$fp=q'unix/pipeline.c::ctors';
$gp=q'ni:unix/pipeline.c';
$hp=q'ni:unix/pipeline_async.b';
$ip=q'ni:unix/pipeline_init.b';
$jp=q'ni:unix/pipeline_io.b';
$kp=q'ni:unix/pipeline_ro.b';
$lp=q'ni:unix/str';
$mp={$D,1};
$np=[$yi];
$op=bless({$c,$mp,$f,$D,$g,$np},$G);
$pp=q'metaclass::ctors';
$qp={$r1,1};
$rp={};
$sp=[];
$tp=q'shift->{\'data\'}';
$up=bless({$V1,$sp,$E1,$tp,$G1,$H1},$e1);
$vp=q'end';
$wp=[];
$xp=q'shift->{\'end\'}';
$yp=bless({$V1,$wp,$E1,$xp,$G1,$H1},$e1);
$zp=q'start';
$Ap=[];
$Bp=q'shift->{\'start\'}';
$Cp=bless({$V1,$Ap,$E1,$Bp,$G1,$H1},$e1);
$Dp={$Uh,$up,$vp,$yp,$zp,$Cp};
$Ep=q'unix/str_ro.b';
$Fp=bless({$c,$rp,$u1,$v1,$w1,$v1,$x1,$Dp,$f,$Ep},$R);
$Gp=q'lib/slice::ctors';
$Hp={};
$Ip=[];
$Jp=q'my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};';
$Kp=bless({$V1,$Ip,$E1,$Jp,$G1,$H1},$e1);
$Lp={$N1,$Kp};
$Mp=q'unix/str_init.b';
$Np=bless({$c,$Hp,$u1,$v1,$w1,$v1,$x1,$Lp,$f,$Mp},$R);
$Op=q'lib/slice::ctors';
$Pp={};
$Qp=[];
$Rp=q'my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;';
$Sp=bless({$V1,$Qp,$E1,$Rp,$G1,$H1},$e1);
$Tp=q'remaining';
$Up=[];
$Vp=q'my $self = shift; $$self{end} - $$self{start}';
$Wp=bless({$V1,$Up,$E1,$Vp,$G1,$H1},$e1);
$Xp=[];
$Yp=q'my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];';
$Zp=bless({$V1,$Xp,$E1,$Yp,$G1,$H1},$e1);
$cq={$yj,$Sp,$Tp,$Wp,$fe,$Zp};
$dq=q'unix/str_io.b';
$eq=bless({$c,$Pp,$u1,$v1,$w1,$v1,$x1,$cq,$f,$dq},$R);
$fq=q'lib/slice::ctors';
$gq=[$nj,$Fp,$Np,$eq];
$hq=bless({$c,$qp,$f,$r1,$g,$gq},$D);
$iq=q'unix/str.c::ctors';
$jq=q'ni:unix/str.c';
$kq=q'ni:unix/str_init.b';
$lq=q'ni:unix/str_io.b';
$mq=q'ni:unix/str_ro.b';
$nq={$u9,$Da,$Fa,$Ta,$Ua,$gb,$hb,$o9,$ib,$A7,$jb,$q4,$kb,$G6,$lb,$h3,$mb,$M,$nb,$j6,$ob,$d5,$pb,$W5,$qb,$g6,$rb,$R5,$sb,$Nb,$Pb,$vb,$Qb,$Kb,$Rb,$Db,$Sb,$l7,$Tb,$u6,$Ub,$h7,$Vb,$ka,$Wb,$x9,$Xb,$U9,$Yb,$F9,$Zb,$M9,$cc,$ha,$dc,$d3,$ec,$J2,$fc,$A1,$gc,$S1,$hc,$x2,$ic,$k2,$jc,$G2,$kc,$tc,$wc,$oe,$qe,$zc,$re,$Ic,$se,$le,$te,$P2,$ue,$j4,$ve,$Te,$We,$O6,$Xe,$q3,$Ye,$m5,$Ze,$v5,$cf,$r9,$df,$L7,$ef,$o8,$ff,$N8,$gf,$Z8,$hf,$Z7,$if,$kg,$mg,$I5,$ng,$W6,$og,$E5,$pg,$W3,$qg,$E3,$rg,$P,$sg,$L3,$tg,$T3,$ug,$Gg,$Ig,$w7,$Jg,$Q4,$Kg,$G4,$Lg,$y4,$Mg,$N4,$Ng,$Ch,$Eh,$Sg,$Fh,$qh,$Gh,$dh,$Hh,$yh,$Ih,$Lh,$Nh,$H7,$Oh,$D7,$Ph,$o7,$Qh,$n4,$Rh,$ri,$si,$T2,$ti,$H,$ui,$Hj,$Jj,$Bi,$Kj,$vj,$Lj,$Ej,$Mj,$Yk,$cl,$Pj,$dl,$jk,$el,$Vk,$fl,$Zj,$gl,$Fk,$hl,$sk,$il,$Vl,$Xl,$ll,$Yl,$Sl,$Zl,$Fl,$cm,$xl,$dm,$Lm,$Nm,$gm,$Om,$xm,$Pm,$Im,$Qm,$pm,$Rm,$Ik,$Sm,$nj,$Tm,$yi,$Um,$Vi,$Vm,$kj,$Wm,$Mi,$Xm,$Zn,$do,$cn,$eo,$Gn,$fo,$Wn,$go,$yn,$ho,$Ln,$io,$ep,$gp,$lo,$hp,$Oo,$ip,$Fo,$jp,$Zo,$kp,$xo,$lp,$hq,$jq,$op,$kq,$Np,$lq,$eq,$mq,$Fp};
$oq=q'resolvers';
$pq=[];
$qq=q'my $f = shift;
$f =~ s/^fd:(?:\\/\\/)?//;
ni(\'ni:unix/fd\')->new($f);';
$rq=bless({$V1,$pq,$E1,$qq,$G1,$H1},$e1);
$sq=q'file';
$tq=[];
$uq=q'my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni(\'ni:unix/file\')->new($f);';
$vq=bless({$V1,$tq,$E1,$uq,$G1,$H1},$e1);
$wq=q'str';
$xq=[];
$yq=q'my $s = shift;
ni(\'ni:unix/str\')->new(substr($s, 4) . "\\n");';
$zq=bless({$V1,$xq,$E1,$yq,$G1,$H1},$e1);
$Aq={$Tj,$rq,$sq,$vq,$wq,$zq};
$Bq=bless({$t9,$nq,$oq,$Aq},$g1);
$Cq=q'lib/ni::ctors';
$$F[0]=$A7;
$$I2[0]=$T2;
$$I2[1]=$j4;
$$i6[4]=$l7;
*$y3=\&$w3;
*$x3=\&$u3;
$S1->apply_unsafe($e1);
$k2->apply_unsafe($e1);
$x2->apply_unsafe($e1);
$G2->apply_unsafe($e1);
$P2->apply_unsafe($T);
$P2->apply_unsafe($h);
$P2->apply_unsafe($U);
$P2->apply_unsafe($l);
$P2->apply_unsafe($V);
$P2->apply_unsafe($m);
$P2->apply_unsafe($W);
$P2->apply_unsafe($n);
$P2->apply_unsafe($d1);
$P2->apply_unsafe($o);
$P2->apply_unsafe($e1);
$P2->apply_unsafe($p);
$P2->apply_unsafe($f1);
$P2->apply_unsafe($q);
$P2->apply_unsafe($g1);
$P2->apply_unsafe($r);
$P2->apply_unsafe($R);
$P2->apply_unsafe($s);
$P2->apply_unsafe($X);
$P2->apply_unsafe($t);
$P2->apply_unsafe($h1);
$P2->apply_unsafe($Q2);
$P2->apply_unsafe($G);
$P2->apply_unsafe($d);
$P2->apply_unsafe($Z);
$P2->apply_unsafe($j);
$P2->apply_unsafe($j1);
$P2->apply_unsafe($v);
$P2->apply_unsafe($k1);
$P2->apply_unsafe($w);
$P2->apply_unsafe($l1);
$P2->apply_unsafe($x);
$P2->apply_unsafe($m1);
$P2->apply_unsafe($y);
$P2->apply_unsafe($n1);
$P2->apply_unsafe($z);
$P2->apply_unsafe($o1);
$P2->apply_unsafe($A);
$P2->apply_unsafe($p1);
$P2->apply_unsafe($B);
$P2->apply_unsafe($q1);
$P2->apply_unsafe($C);
$P2->apply_unsafe($r1);
$P2->apply_unsafe($D);
$d3->apply_unsafe($T);
$d3->apply_unsafe($h);
$d3->apply_unsafe($U);
$d3->apply_unsafe($l);
$d3->apply_unsafe($V);
$d3->apply_unsafe($m);
$d3->apply_unsafe($W);
$d3->apply_unsafe($n);
$d3->apply_unsafe($o);
$d3->apply_unsafe($p);
$d3->apply_unsafe($q);
$d3->apply_unsafe($r);
$d3->apply_unsafe($R);
$d3->apply_unsafe($s);
$d3->apply_unsafe($X);
$d3->apply_unsafe($t);
$d3->apply_unsafe($e3);
$d3->apply_unsafe($G);
$d3->apply_unsafe($d);
$d3->apply_unsafe($Z);
$d3->apply_unsafe($j);
$d3->apply_unsafe($v);
$d3->apply_unsafe($w);
$d3->apply_unsafe($x);
$d3->apply_unsafe($y);
$d3->apply_unsafe($z);
$d3->apply_unsafe($A);
$d3->apply_unsafe($B);
$d3->apply_unsafe($C);
$d3->apply_unsafe($D);
$q3->apply_unsafe($T);
$q3->apply_unsafe($h);
$q3->apply_unsafe($l);
$q3->apply_unsafe($V);
$q3->apply_unsafe($m);
$q3->apply_unsafe($n);
$q3->apply_unsafe($d1);
$q3->apply_unsafe($o);
$q3->apply_unsafe($p);
$q3->apply_unsafe($q);
$q3->apply_unsafe($r);
$q3->apply_unsafe($R);
$q3->apply_unsafe($s);
$q3->apply_unsafe($X);
$q3->apply_unsafe($t);
$q3->apply_unsafe($r3);
$q3->apply_unsafe($G);
$q3->apply_unsafe($d);
$q3->apply_unsafe($Z);
$q3->apply_unsafe($j);
$q3->apply_unsafe($v);
$q3->apply_unsafe($w);
$q3->apply_unsafe($x);
$q3->apply_unsafe($y);
$q3->apply_unsafe($z);
$q3->apply_unsafe($A);
$q3->apply_unsafe($B);
$q3->apply_unsafe($C);
$q3->apply_unsafe($D);
$E3->apply_unsafe($R);
$L3->apply_unsafe($R);
$T3->apply_unsafe($R);
$j4->apply_unsafe($T);
$j4->apply_unsafe($h);
$j4->apply_unsafe($l);
$j4->apply_unsafe($m);
$j4->apply_unsafe($n);
$j4->apply_unsafe($o);
$j4->apply_unsafe($e1);
$j4->apply_unsafe($p);
$j4->apply_unsafe($q);
$j4->apply_unsafe($r);
$j4->apply_unsafe($R);
$j4->apply_unsafe($s);
$j4->apply_unsafe($X);
$j4->apply_unsafe($t);
$j4->apply_unsafe($k4);
$j4->apply_unsafe($G);
$j4->apply_unsafe($d);
$j4->apply_unsafe($j);
$j4->apply_unsafe($v);
$j4->apply_unsafe($w);
$j4->apply_unsafe($x);
$j4->apply_unsafe($y);
$j4->apply_unsafe($z);
$j4->apply_unsafe($A);
$j4->apply_unsafe($B);
$j4->apply_unsafe($C);
$j4->apply_unsafe($D);
$G4->apply_unsafe($X);
$N4->apply_unsafe($X);
$d5->apply_unsafe($T);
$d5->apply_unsafe($h);
$d5->apply_unsafe($l);
$d5->apply_unsafe($V);
$d5->apply_unsafe($m);
$d5->apply_unsafe($n);
$d5->apply_unsafe($o);
$d5->apply_unsafe($p);
$d5->apply_unsafe($q);
$d5->apply_unsafe($r);
$d5->apply_unsafe($s);
$d5->apply_unsafe($t);
$d5->apply_unsafe($e5);
$d5->apply_unsafe($G);
$d5->apply_unsafe($d);
$d5->apply_unsafe($Z);
$d5->apply_unsafe($j);
$d5->apply_unsafe($v);
$d5->apply_unsafe($w);
$d5->apply_unsafe($x);
$d5->apply_unsafe($y);
$d5->apply_unsafe($z);
$d5->apply_unsafe($A);
$d5->apply_unsafe($B);
$d5->apply_unsafe($C);
$d5->apply_unsafe($D);
$m5->apply_unsafe($T);
$m5->apply_unsafe($h);
$m5->apply_unsafe($l);
$m5->apply_unsafe($V);
$m5->apply_unsafe($m);
$m5->apply_unsafe($n);
$m5->apply_unsafe($o);
$m5->apply_unsafe($p);
$m5->apply_unsafe($q);
$m5->apply_unsafe($r);
$m5->apply_unsafe($R);
$m5->apply_unsafe($s);
$m5->apply_unsafe($X);
$m5->apply_unsafe($t);
$m5->apply_unsafe($n5);
$m5->apply_unsafe($G);
$m5->apply_unsafe($d);
$m5->apply_unsafe($Z);
$m5->apply_unsafe($j);
$m5->apply_unsafe($v);
$m5->apply_unsafe($w);
$m5->apply_unsafe($x);
$m5->apply_unsafe($y);
$m5->apply_unsafe($z);
$m5->apply_unsafe($A);
$m5->apply_unsafe($B);
$m5->apply_unsafe($C);
$m5->apply_unsafe($D);
$v5->apply_unsafe($T);
$v5->apply_unsafe($h);
$v5->apply_unsafe($l);
$v5->apply_unsafe($V);
$v5->apply_unsafe($m);
$v5->apply_unsafe($n);
$v5->apply_unsafe($o);
$v5->apply_unsafe($p);
$v5->apply_unsafe($q);
$v5->apply_unsafe($r);
$v5->apply_unsafe($R);
$v5->apply_unsafe($s);
$v5->apply_unsafe($X);
$v5->apply_unsafe($t);
$v5->apply_unsafe($w5);
$v5->apply_unsafe($G);
$v5->apply_unsafe($d);
$v5->apply_unsafe($Z);
$v5->apply_unsafe($j);
$v5->apply_unsafe($v);
$v5->apply_unsafe($w);
$v5->apply_unsafe($x);
$v5->apply_unsafe($y);
$v5->apply_unsafe($z);
$v5->apply_unsafe($A);
$v5->apply_unsafe($B);
$v5->apply_unsafe($C);
$v5->apply_unsafe($D);
$E5->apply_unsafe($T);
$E5->apply_unsafe($h);
$E5->apply_unsafe($l);
$E5->apply_unsafe($V);
$E5->apply_unsafe($m);
$E5->apply_unsafe($n);
$E5->apply_unsafe($o);
$E5->apply_unsafe($p);
$E5->apply_unsafe($q);
$E5->apply_unsafe($r);
$E5->apply_unsafe($s);
$E5->apply_unsafe($X);
$E5->apply_unsafe($t);
$E5->apply_unsafe($F5);
$E5->apply_unsafe($G);
$E5->apply_unsafe($d);
$E5->apply_unsafe($Z);
$E5->apply_unsafe($j);
$E5->apply_unsafe($v);
$E5->apply_unsafe($w);
$E5->apply_unsafe($x);
$E5->apply_unsafe($y);
$E5->apply_unsafe($z);
$E5->apply_unsafe($A);
$E5->apply_unsafe($B);
$E5->apply_unsafe($C);
$E5->apply_unsafe($D);
$R5->apply_unsafe($T);
$R5->apply_unsafe($h);
$R5->apply_unsafe($l);
$R5->apply_unsafe($m);
$R5->apply_unsafe($n);
$R5->apply_unsafe($o);
$R5->apply_unsafe($p);
$R5->apply_unsafe($q);
$R5->apply_unsafe($r);
$R5->apply_unsafe($s);
$R5->apply_unsafe($t);
$R5->apply_unsafe($S5);
$R5->apply_unsafe($G);
$R5->apply_unsafe($d);
$R5->apply_unsafe($Z);
$R5->apply_unsafe($j);
$R5->apply_unsafe($v);
$R5->apply_unsafe($w);
$R5->apply_unsafe($x);
$R5->apply_unsafe($y);
$R5->apply_unsafe($z);
$R5->apply_unsafe($A);
$R5->apply_unsafe($B);
$R5->apply_unsafe($C);
$R5->apply_unsafe($D);
$g6->apply_unsafe($V);
$u6->apply_unsafe($T);
$u6->apply_unsafe($h);
$u6->apply_unsafe($l);
$u6->apply_unsafe($V);
$u6->apply_unsafe($m);
$u6->apply_unsafe($n);
$u6->apply_unsafe($o);
$u6->apply_unsafe($p);
$u6->apply_unsafe($q);
$u6->apply_unsafe($r);
$u6->apply_unsafe($s);
$u6->apply_unsafe($t);
$u6->apply_unsafe($v6);
$u6->apply_unsafe($G);
$u6->apply_unsafe($d);
$u6->apply_unsafe($Z);
$u6->apply_unsafe($j);
$u6->apply_unsafe($v);
$u6->apply_unsafe($w);
$u6->apply_unsafe($x);
$u6->apply_unsafe($y);
$u6->apply_unsafe($z);
$u6->apply_unsafe($A);
$u6->apply_unsafe($B);
$u6->apply_unsafe($C);
$u6->apply_unsafe($D);
$G6->apply_unsafe($T);
$G6->apply_unsafe($h);
$G6->apply_unsafe($l);
$G6->apply_unsafe($V);
$G6->apply_unsafe($m);
$G6->apply_unsafe($n);
$G6->apply_unsafe($o);
$G6->apply_unsafe($p);
$G6->apply_unsafe($q);
$G6->apply_unsafe($r);
$G6->apply_unsafe($s);
$G6->apply_unsafe($t);
$G6->apply_unsafe($H6);
$G6->apply_unsafe($G);
$G6->apply_unsafe($d);
$G6->apply_unsafe($Z);
$G6->apply_unsafe($j);
$G6->apply_unsafe($v);
$G6->apply_unsafe($w);
$G6->apply_unsafe($x);
$G6->apply_unsafe($y);
$G6->apply_unsafe($z);
$G6->apply_unsafe($A);
$G6->apply_unsafe($B);
$G6->apply_unsafe($C);
$G6->apply_unsafe($D);
$O6->apply_unsafe($T);
$O6->apply_unsafe($h);
$O6->apply_unsafe($l);
$O6->apply_unsafe($V);
$O6->apply_unsafe($m);
$O6->apply_unsafe($n);
$O6->apply_unsafe($o);
$O6->apply_unsafe($p);
$O6->apply_unsafe($q);
$O6->apply_unsafe($r);
$O6->apply_unsafe($s);
$O6->apply_unsafe($t);
$O6->apply_unsafe($P6);
$O6->apply_unsafe($G);
$O6->apply_unsafe($d);
$O6->apply_unsafe($Z);
$O6->apply_unsafe($j);
$O6->apply_unsafe($v);
$O6->apply_unsafe($w);
$O6->apply_unsafe($x);
$O6->apply_unsafe($y);
$O6->apply_unsafe($z);
$O6->apply_unsafe($A);
$O6->apply_unsafe($B);
$O6->apply_unsafe($C);
$O6->apply_unsafe($D);
$W6->apply_unsafe($T);
$W6->apply_unsafe($h);
$W6->apply_unsafe($l);
$W6->apply_unsafe($V);
$W6->apply_unsafe($m);
$W6->apply_unsafe($n);
$W6->apply_unsafe($o);
$W6->apply_unsafe($p);
$W6->apply_unsafe($q);
$W6->apply_unsafe($r);
$W6->apply_unsafe($s);
$W6->apply_unsafe($t);
$W6->apply_unsafe($X6);
$W6->apply_unsafe($G);
$W6->apply_unsafe($d);
$W6->apply_unsafe($Z);
$W6->apply_unsafe($j);
$W6->apply_unsafe($v);
$W6->apply_unsafe($w);
$W6->apply_unsafe($x);
$W6->apply_unsafe($y);
$W6->apply_unsafe($z);
$W6->apply_unsafe($A);
$W6->apply_unsafe($B);
$W6->apply_unsafe($C);
$W6->apply_unsafe($D);
$h7->apply_unsafe($T);
$h7->apply_unsafe($h);
$h7->apply_unsafe($l);
$h7->apply_unsafe($V);
$h7->apply_unsafe($m);
$h7->apply_unsafe($n);
$h7->apply_unsafe($o);
$h7->apply_unsafe($p);
$h7->apply_unsafe($q);
$h7->apply_unsafe($r);
$h7->apply_unsafe($s);
$h7->apply_unsafe($t);
$h7->apply_unsafe($i7);
$h7->apply_unsafe($G);
$h7->apply_unsafe($d);
$h7->apply_unsafe($Z);
$h7->apply_unsafe($j);
$h7->apply_unsafe($v);
$h7->apply_unsafe($w);
$h7->apply_unsafe($x);
$h7->apply_unsafe($y);
$h7->apply_unsafe($z);
$h7->apply_unsafe($A);
$h7->apply_unsafe($B);
$h7->apply_unsafe($C);
$h7->apply_unsafe($D);
$w7->apply_unsafe($T);
$w7->apply_unsafe($h);
$w7->apply_unsafe($l);
$w7->apply_unsafe($m);
$w7->apply_unsafe($n);
$w7->apply_unsafe($o);
$w7->apply_unsafe($p);
$w7->apply_unsafe($q);
$w7->apply_unsafe($r);
$w7->apply_unsafe($s);
$w7->apply_unsafe($t);
$w7->apply_unsafe($x7);
$w7->apply_unsafe($d);
$w7->apply_unsafe($j);
$w7->apply_unsafe($v);
$w7->apply_unsafe($w);
$w7->apply_unsafe($x);
$w7->apply_unsafe($y);
$w7->apply_unsafe($z);
$w7->apply_unsafe($A);
$w7->apply_unsafe($B);
$w7->apply_unsafe($C);
$w7->apply_unsafe($D);
$Z7->apply_unsafe($g1);
$o8->apply_unsafe($g1);
$N8->apply_unsafe($g1);
$Z8->apply_unsafe($g1);
$o9->apply_unsafe($g1);
$F9->apply_unsafe($d1);
$M9->apply_unsafe($d1);
$U9->apply_unsafe($d1);
$ha->apply_unsafe($d1);
$Db->apply_unsafe($W);
$Kb->apply_unsafe($W);
$tc->apply_unsafe($uc);
$Ic->apply_unsafe($f1);
$le->apply_unsafe($f1);
$Te->apply_unsafe($Ue);
$kg->apply_unsafe($Ue);
$Gg->apply_unsafe($uc);
$dh->apply_unsafe($h1);
$qh->apply_unsafe($h1);
$yh->apply_unsafe($h1);
$Mi->apply_unsafe($k1);
$Mi->apply_unsafe($l1);
$Mi->apply_unsafe($m1);
$Mi->apply_unsafe($n1);
$Mi->apply_unsafe($o1);
$Mi->apply_unsafe($p1);
$Mi->apply_unsafe($q1);
$Mi->apply_unsafe($r1);
$Vi->apply_unsafe($k1);
$Vi->apply_unsafe($l1);
$Vi->apply_unsafe($m1);
$Vi->apply_unsafe($n1);
$Vi->apply_unsafe($o1);
$Vi->apply_unsafe($p1);
$Vi->apply_unsafe($q1);
$Vi->apply_unsafe($r1);
$kj->apply_unsafe($k1);
$kj->apply_unsafe($l1);
$kj->apply_unsafe($m1);
$kj->apply_unsafe($n1);
$kj->apply_unsafe($o1);
$kj->apply_unsafe($p1);
$kj->apply_unsafe($q1);
$kj->apply_unsafe($r1);
$vj->apply_unsafe($k1);
$Ej->apply_unsafe($k1);
$Zj->apply_unsafe($l1);
$jk->apply_unsafe($l1);
$sk->apply_unsafe($l1);
$Fk->apply_unsafe($l1);
$Fk->apply_unsafe($m1);
$Fk->apply_unsafe($n1);
$Fk->apply_unsafe($p1);
$Fk->apply_unsafe($q1);
$Vk->apply_unsafe($l1);
$xl->apply_unsafe($m1);
$Fl->apply_unsafe($m1);
$Sl->apply_unsafe($m1);
$pm->apply_unsafe($n1);
$xm->apply_unsafe($n1);
$Im->apply_unsafe($n1);
$yn->apply_unsafe($p1);
$Gn->apply_unsafe($p1);
$Ln->apply_unsafe($p1);
$Wn->apply_unsafe($p1);
$xo->apply_unsafe($q1);
$Fo->apply_unsafe($q1);
$Oo->apply_unsafe($q1);
$Zo->apply_unsafe($q1);
$Fp->apply_unsafe($r1);
$Np->apply_unsafe($r1);
$eq->apply_unsafe($r1);
$ni::self=$Bq;
&$_($H)for@$I;
&$_($M)for@$N;
&$_($P)for@$Q;
&$_($A1)for@$B1;
&$_($I1)for@$J1;
&$_($M1)for@$J1;
&$_($P1)for@$J1;
&$_($S1)for@$T1;
&$_($Y1)for@$J1;
&$_($d2)for@$J1;
&$_($h2)for@$J1;
&$_($k2)for@$l2;
&$_($q2)for@$J1;
&$_($u2)for@$J1;
&$_($x2)for@$y2;
&$_($D2)for@$J1;
&$_($G2)for@$H2;
&$_($J2)for@$K2;
&$_($M2)for@$J1;
&$_($P2)for@$R2;
&$_($T2)for@$U2;
&$_($Y2)for@$J1;
&$_($d3)for@$f3;
&$_($h3)for@$i3;
&$_($l3)for@$J1;
&$_($n3)for@$J1;
&$_($q3)for@$s3;
&$_($u3)for@$J1;
&$_($w3)for@$J1;
&$_($E3)for@$F3;
&$_($I3)for@$J1;
&$_($L3)for@$M3;
&$_($Q3)for@$J1;
&$_($T3)for@$U3;
&$_($W3)for@$X3;
&$_($d4)for@$J1;
&$_($g4)for@$J1;
&$_($j4)for@$l4;
&$_($n4)for@$o4;
&$_($q4)for@$r4;
&$_($y4)for@$z4;
&$_($D4)for@$J1;
&$_($G4)for@$H4;
&$_($K4)for@$J1;
&$_($N4)for@$O4;
&$_($Q4)for@$R4;
&$_($W4)for@$J1;
&$_($Y4)for@$J1;
&$_($d5)for@$f5;
&$_($j5)for@$J1;
&$_($m5)for@$o5;
&$_($s5)for@$J1;
&$_($v5)for@$x5;
&$_($B5)for@$J1;
&$_($E5)for@$G5;
&$_($I5)for@$J5;
&$_($M5)for@$J1;
&$_($O5)for@$J1;
&$_($R5)for@$T5;
&$_($W5)for@$X5;
&$_($d6)for@$J1;
&$_($g6)for@$h6;
&$_($j6)for@$k6;
&$_($r6)for@$J1;
&$_($u6)for@$w6;
&$_($A6)for@$J1;
&$_($D6)for@$J1;
&$_($G6)for@$I6;
&$_($L6)for@$J1;
&$_($O6)for@$Q6;
&$_($T6)for@$J1;
&$_($W6)for@$Y6;
&$_($e7)for@$J1;
&$_($h7)for@$j7;
&$_($l7)for@$m7;
&$_($o7)for@$p7;
&$_($t7)for@$J1;
&$_($w7)for@$y7;
&$_($A7)for@$B7;
&$_($D7)for@$E7;
&$_($H7)for@$I7;
&$_($L7)for@$M7;
&$_($S7)for@$J1;
&$_($W7)for@$J1;
&$_($Z7)for@$c8;
&$_($h8)for@$J1;
&$_($l8)for@$J1;
&$_($o8)for@$p8;
&$_($u8)for@$J1;
&$_($y8)for@$J1;
&$_($C8)for@$J1;
&$_($G8)for@$J1;
&$_($K8)for@$J1;
&$_($N8)for@$O8;
&$_($S8)for@$J1;
&$_($W8)for@$J1;
&$_($Z8)for@$c9;
&$_($h9)for@$J1;
&$_($l9)for@$J1;
&$_($o9)for@$p9;
&$_($r9)for@$s9;
&$_($x9)for@$y9;
&$_($C9)for@$J1;
&$_($F9)for@$G9;
&$_($J9)for@$J1;
&$_($M9)for@$N9;
&$_($R9)for@$J1;
&$_($U9)for@$V9;
&$_($Z9)for@$J1;
&$_($ea)for@$J1;
&$_($ha)for@$ia;
&$_($ka)for@$la;
&$_($wa)for@$J1;
&$_($Da)for@$Ea;
&$_($Ma)for@$J1;
&$_($Qa)for@$J1;
&$_($Ta)for@$Ea;
&$_($db)for@$J1;
&$_($gb)for@$Ea;
&$_($vb)for@$wb;
&$_($Ab)for@$J1;
&$_($Db)for@$Eb;
&$_($Hb)for@$J1;
&$_($Kb)for@$Lb;
&$_($Nb)for@$Ob;
&$_($qc)for@$J1;
&$_($tc)for@$vc;
&$_($zc)for@$Ac;
&$_($Fc)for@$J1;
&$_($Ic)for@$Jc;
&$_($Oc)for@$J1;
&$_($Sc)for@$J1;
&$_($Wc)for@$J1;
&$_($cd)for@$J1;
&$_($gd)for@$J1;
&$_($kd)for@$J1;
&$_($od)for@$J1;
&$_($sd)for@$J1;
&$_($wd)for@$J1;
&$_($Ad)for@$J1;
&$_($Ed)for@$J1;
&$_($Id)for@$J1;
&$_($Md)for@$J1;
&$_($Qd)for@$J1;
&$_($Ud)for@$J1;
&$_($Yd)for@$J1;
&$_($ee)for@$J1;
&$_($ie)for@$J1;
&$_($le)for@$me;
&$_($oe)for@$pe;
&$_($Ae)for@$J1;
&$_($Ee)for@$J1;
&$_($Ie)for@$J1;
&$_($Me)for@$J1;
&$_($Qe)for@$J1;
&$_($Te)for@$Ve;
&$_($nf)for@$J1;
&$_($rf)for@$J1;
&$_($vf)for@$J1;
&$_($zf)for@$J1;
&$_($Df)for@$J1;
&$_($Hf)for@$J1;
&$_($Lf)for@$J1;
&$_($Pf)for@$J1;
&$_($Tf)for@$J1;
&$_($Xf)for@$J1;
&$_($dg)for@$J1;
&$_($hg)for@$J1;
&$_($kg)for@$lg;
&$_($yg)for@$J1;
&$_($Dg)for@$J1;
&$_($Gg)for@$Hg;
&$_($Sg)for@$Tg;
&$_($Yg)for@$J1;
&$_($dh)for@$eh;
&$_($jh)for@$J1;
&$_($nh)for@$J1;
&$_($qh)for@$rh;
&$_($vh)for@$J1;
&$_($yh)for@$zh;
&$_($Ch)for@$Dh;
&$_($Lh)for@$Mh;
&$_($oi)for@$pi;
&$_($ri)for@$Mh;
&$_($yi)for@$zi;
&$_($Bi)for@$Ci;
&$_($Ji)for@$J1;
&$_($Mi)for@$Ni;
&$_($Si)for@$J1;
&$_($Vi)for@$Wi;
&$_($dj)for@$J1;
&$_($hj)for@$J1;
&$_($kj)for@$lj;
&$_($nj)for@$oj;
&$_($sj)for@$J1;
&$_($vj)for@$wj;
&$_($Bj)for@$J1;
&$_($Ej)for@$Fj;
&$_($Hj)for@$Ij;
&$_($Pj)for@$Qj;
&$_($Wj)for@$J1;
&$_($Zj)for@$ck;
&$_($gk)for@$J1;
&$_($jk)for@$kk;
&$_($pk)for@$J1;
&$_($sk)for@$tk;
&$_($zk)for@$J1;
&$_($Ck)for@$J1;
&$_($Fk)for@$Gk;
&$_($Ik)for@$Jk;
&$_($Ok)for@$J1;
&$_($Sk)for@$J1;
&$_($Vk)for@$Wk;
&$_($Yk)for@$Zk;
&$_($ll)for@$ml;
&$_($rl)for@$J1;
&$_($ul)for@$J1;
&$_($xl)for@$yl;
&$_($Cl)for@$J1;
&$_($Fl)for@$Gl;
&$_($Ll)for@$J1;
&$_($Pl)for@$J1;
&$_($Sl)for@$Tl;
&$_($Vl)for@$Wl;
&$_($gm)for@$hm;
&$_($mm)for@$J1;
&$_($pm)for@$qm;
&$_($um)for@$J1;
&$_($xm)for@$ym;
&$_($Cm)for@$J1;
&$_($Fm)for@$J1;
&$_($Im)for@$Jm;
&$_($Lm)for@$Mm;
&$_($cn)for@$dn;
&$_($jn)for@$J1;
&$_($nn)for@$J1;
&$_($rn)for@$J1;
&$_($vn)for@$J1;
&$_($yn)for@$zn;
&$_($Dn)for@$J1;
&$_($Gn)for@$Hn;
&$_($Ln)for@$Mn;
&$_($Qn)for@$J1;
&$_($Tn)for@$J1;
&$_($Wn)for@$Xn;
&$_($Zn)for@$co;
&$_($lo)for@$mo;
&$_($ro)for@$J1;
&$_($uo)for@$J1;
&$_($xo)for@$yo;
&$_($Co)for@$J1;
&$_($Fo)for@$Go;
&$_($Lo)for@$J1;
&$_($Oo)for@$Po;
&$_($To)for@$J1;
&$_($Wo)for@$J1;
&$_($Zo)for@$cp;
&$_($ep)for@$fp;
&$_($op)for@$pp;
&$_($up)for@$J1;
&$_($yp)for@$J1;
&$_($Cp)for@$J1;
&$_($Fp)for@$Gp;
&$_($Kp)for@$J1;
&$_($Np)for@$Op;
&$_($Sp)for@$J1;
&$_($Wp)for@$J1;
&$_($Zp)for@$J1;
&$_($eq)for@$fq;
&$_($hq)for@$iq;
&$_($rq)for@$J1;
&$_($vq)for@$J1;
&$_($zq)for@$J1;
&$_($Bq)for@$Cq;
ni->run(@ARGV);
__DATA__
