#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/lib/doc#;
$J=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$K=[$f,$J];
$L=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$M=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$N=[];
$O=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$P=bless({$o,$N,$q,$O,$s,$t},$u);
$Q=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$R=[];
$S=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$T=bless({$o,$R,$q,$S,$s,$t},$u);
$U=[$i,$L,$M,$n,$P,$Q,$n,$T];
$V=[$K,$U];
$W=q#/lib/doc#;
$X=bless({$e,$V,$D,$W},$F);
$Y=q#ni.doc:/unix/cat#;
$Z=q#
    my $combined = ni('ni:/unix/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  #;
$c1=[$f,$Z];
$d1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$e1=[$i,$d1];
$f1=[];
$g1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$h1=bless({$o,$f1,$q,$g1,$s,$t},$u);
$i1=[$n,$h1];
$j1=[$c1,$e1,$i1];
$k1=q#/unix/cat#;
$l1=bless({$e,$j1,$D,$k1},$F);
$m1=q#ni.doc:/unix/exec#;
$n1=q#
    my $pid = ni("ni:/unix/exec")->new("ls", "-l")
      ->fds(1 => ni"file:foo")
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$o1=[$f,$n1];
$p1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up FIFO connections to stdin/out if you use it
      this way.#;
$q1=[$i,$p1];
$r1=[];
$s1=q#my $e   = ni('ni:/unix/exec')->new('sh', '-c', 'echo hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$t1=bless({$o,$r1,$q,$s1,$s,$t},$u);
$u1=[$n,$t1];
$v1=[$o1,$q1,$u1];
$w1=q#/unix/exec#;
$x1=bless({$e,$v1,$D,$w1},$F);
$y1=q#ni.doc:/unix/pid#;
$z1=[];
$A1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$B1=bless({$o,$z1,$q,$A1,$s,$t},$u);
$C1=[$n,$B1];
$D1=[];
$E1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/unix/exec')->new('egrep', '[13579]$')
  ->fds(0 => $seq->stdout)
  ->fork;
now $grep->read_all == "1\\n3\\n5\\n7\\n9\\n";
now $seq->await == 0;
now $grep->await == 0;#;
$F1=bless({$o,$D1,$q,$E1,$s,$t},$u);
$G1=[$n,$F1];
$H1=[$C1,$G1];
$I1=q#/unix/pid#;
$J1=bless({$e,$H1,$D,$I1},$F);
$K1=q#ni:/class#;
$L1=q#applied_to#;
$M1=q#class#;
$N1=q#class.c#;
$O1=q#lib/behavior.c#;
$P1=q#lib/branch.c#;
$Q1=q#lib/dataslice.c#;
$R1=q#lib/doc.c#;
$S1=q#lib/fn.c#;
$T1=q#lib/image.c#;
$U1=q#lib/ni.c#;
$V1=q#lib/slice.c#;
$W1=q#lib/tag.c#;
$X1=q#lib/test_value.c#;
$Y1=q#metaclass.c#;
$Z1=q#module.c#;
$c2=q#object.c#;
$d2=q#unix/cat.c#;
$e2=q#unix/exec.c#;
$f2=q#unix/fd.c#;
$g2=q#unix/fifo.c#;
$h2=q#unix/file.c#;
$i2=q#unix/io.c#;
$j2=q#unix/pid.c#;
$k2=q#unix/pipeline.c#;
$l2=q#unix/str.c#;
$m2={$M1,1,$N1,1,$O1,1,$P1,1,$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1,$Z1,1,$c2,1,$d2,1,$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1};
$n2=q#slices#;
$o2=q#lib/test_value.c#;
$p2=q#metaclass#;
$q2=q#module#;
$r2={$M1,1,$N1,1,$O1,1,$P1,1,$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$o2,1,$p2,1,$Y1,1,$q2,1,$Z1,1,$c2,1,$d2,1,$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1};
$s2=q#/module#;
$t2=q#/lib/perlbranch.b#;
$u2={};
$v2=q#ctor#;
$w2=undef;
$x2=q#dtor#;
$y2=q#methods#;
$z2=q#add#;
$A2=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$B2=bless({$q,$A2,$s,$t},$u);
$C2=q#apply#;
$D2=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$E2=bless({$q,$D2,$s,$t},$u);
$F2={$z2,$B2,$C2,$E2};
$G2=q#/lib/branch.b#;
$H2=q#lib/slice#;
$I2=bless({$L1,$u2,$v2,$w2,$x2,$w2,$y2,$F2,$D,$G2},$H2);
$J2=q#lib/branch#;
$K2=q#lib/test_value.c#;
$L2=q#lib/slice::ctors#;
$M2={};
$N2=q#my $s = shift; ni->def($s->name, $s)#;
$O2=bless({$q,$N2,$s,$t},$u);
$P2=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$Q2=bless({$q,$P2,$s,$t},$u);
$R2={$D,$Q2};
$S2=q#/lib/named.b#;
$T2=bless({$L1,$M2,$v2,$O2,$x2,$w2,$y2,$R2,$D,$S2},$H2);
$U2=q#lib/tag#;
$V2=q#lib/test_value.c#;
$W2=q#lib/slice::ctors#;
$X2={};
$Y2=q#namespace#;
$Z2=q#'ni'#;
$c3=bless({$q,$Z2,$s,$t},$u);
$d3={$Y2,$c3};
$e3=q#/lib/named_in_ni.b#;
$f3=bless({$L1,$X2,$v2,$w2,$x2,$w2,$y2,$d3,$D,$e3},$H2);
$g3=q#lib/test_value.c#;
$h3=q#lib/slice::ctors#;
$i3={};
$j3=q#package#;
$k3=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$l3=bless({$q,$k3,$s,$t},$u);
$m3={$j3,$l3};
$n3=q#/lib/namespaced.b#;
$o3=bless({$L1,$i3,$v2,$w2,$x2,$w2,$y2,$m3,$D,$n3},$H2);
$p3=q#lib/test_value.c#;
$q3=q#lib/slice::ctors#;
$r3={};
$s3=q#resolve#;
$t3=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$u3=bless({$q,$t3,$s,$t},$u);
$v3={$s3,$u3};
$w3=q#/lib/resolver.b#;
$x3=bless({$L1,$r3,$v2,$w2,$x2,$w2,$y2,$v3,$D,$w3},$H2);
$y3=q#lib/test_value.c#;
$z3=q#lib/slice::ctors#;
$A3=[$I2,$T2,$f3,$o3,$x3];
$B3=bless({$D,$t2,$n2,$A3},$U2);
$C3=q#lib/tag::ctors#;
$D3={};
$E3=q#my $s = shift; $s->apply($s->package)#;
$F3=bless({$q,$E3,$s,$t},$u);
$G3=q#instantiate#;
$H3=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$I3=bless({$q,$H3,$s,$t},$u);
$J3={$G3,$I3};
$K3=q#/lib/class_init.b#;
$L3=bless({$L1,$D3,$v2,$F3,$x2,$w2,$y2,$J3,$D,$K3},$H2);
$M3=q#lib/test_value.c#;
$N3=q#lib/slice::ctors#;
$O3=q#lib/behavior#;
$P3=q#lib/dataslice#;
$Q3=q#lib/image#;
$R3=q#lib/ni#;
$S3=q#lib/test_value#;
$T3=q#lib/test_value.c#;
$U3=q#object#;
$V3=q#unix/cat#;
$W3=q#unix/exec#;
$X3=q#unix/fd#;
$Y3=q#unix/fifo#;
$Z3=q#unix/file#;
$c4=q#unix/io#;
$d4=q#unix/pid#;
$e4=q#unix/pipeline#;
$f4=q#unix/str#;
$g4={$M1,1,$N1,1,$O3,1,$O1,1,$J2,1,$P1,1,$P3,1,$Q1,1,$F,1,$R1,1,$u,1,$S1,1,$Q3,1,$T1,1,$R3,1,$U1,1,$H2,1,$V1,1,$U2,1,$W1,1,$S3,1,$T3,1,$p2,1,$Y1,1,$q2,1,$Z1,1,$U3,1,$c2,1,$V3,1,$d2,1,$W3,1,$e2,1,$X3,1,$f2,1,$Y3,1,$g2,1,$Z3,1,$h2,1,$c4,1,$i2,1,$d4,1,$j2,1,$e4,1,$k2,1,$f4,1,$l2,1};
$h4=q#/object#;
$i4={};
$j4=q#ni 'ni:/' . ref shift#;
$k4=bless({$q,$j4,$s,$t},$u);
$l4={$M1,$k4};
$m4=q#/lib/instance.b#;
$n4=bless({$L1,$i4,$v2,$w2,$x2,$w2,$y2,$l4,$D,$m4},$H2);
$o4=q#lib/test_value.c#;
$p4=q#lib/slice::ctors#;
$q4=[$n4];
$r4=bless({$L1,$g4,$D,$h4,$n2,$q4},$c2);
$s4=q#object.c::ctors#;
$t4=q#lib/test_value.c#;
$u4={$M1,1,$N1,1,$O3,1,$O1,1,$J2,1,$P1,1,$P3,1,$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$H2,1,$V1,1,$U2,1,$W1,1,$t4,1,$p2,1,$Y1,1,$q2,1,$Z1,1,$c2,1,$d2,1,$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1};
$v4=q#/lib/behavior#;
$w4={};
$x4=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$y4=bless({$q,$x4,$s,$t},$u);
$z4={$e,$y4};
$A4=q#/lib/documentable.b#;
$B4=bless({$L1,$w4,$v2,$w2,$x2,$w2,$y2,$z4,$D,$A4},$H2);
$C4=q#lib/test_value.c#;
$D4=q#lib/slice::ctors#;
$E4=[$r4,$B4];
$F4=bless({$L1,$u4,$D,$v4,$n2,$E4},$O1);
$G4=q#lib/behavior.c::ctors#;
$H4=q#lib/test_value.c#;
$I4={$M1,1,$N1,1,$O1,1,$J2,1,$P1,1,$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$H4,1,$p2,1,$Y1,1,$q2,1,$Z1,1,$c2,1,$d2,1,$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1};
$J4=q#/lib/definition.b#;
$K4={};
$L4=q#def#;
$M4=q#shift->add(ni('ni:/lib/slice')->new(@_))#;
$N4=bless({$q,$M4,$s,$t},$u);
$O4={$L4,$N4};
$P4=q#/lib/definition_def.b#;
$Q4=bless({$L1,$K4,$v2,$w2,$x2,$w2,$y2,$O4,$D,$P4},$H2);
$R4=q#lib/test_value.c#;
$S4=q#lib/slice::ctors#;
$T4={};
$U4=q#ro#;
$V4=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$W4=bless({$q,$V4,$s,$t},$u);
$X4=q#rw#;
$Y4=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$Z4=bless({$q,$Y4,$s,$t},$u);
$c5={$U4,$W4,$X4,$Z4};
$d5=q#/lib/accessor.b#;
$e5=bless({$L1,$T4,$v2,$w2,$x2,$w2,$y2,$c5,$D,$d5},$H2);
$f5=q#lib/test_value.c#;
$g5=q#lib/slice::ctors#;
$h5={};
$i5=q#(""#;
$j5=q#shift->name#;
$k5=bless({$q,$j5,$s,$t},$u);
$l5={$i5,$k5};
$m5=q#/lib/name_as_string.b#;
$n5=bless({$L1,$h5,$v2,$w2,$x2,$w2,$y2,$l5,$D,$m5},$H2);
$o5=q#lib/test_value.c#;
$p5=q#lib/slice::ctors#;
$q5={};
$r5=q#(eq#;
$s5=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$t5=bless({$q,$s5,$s,$t},$u);
$u5={$r5,$t5};
$v5=q#/lib/ref_eq.b#;
$w5=bless({$L1,$q5,$v2,$w2,$x2,$w2,$y2,$u5,$D,$v5},$H2);
$x5=q#lib/test_value.c#;
$y5=q#lib/slice::ctors#;
$z5={};
$A5=q#defdata#;
$B5=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$C5=bless({$q,$B5,$s,$t},$u);
$D5={$A5,$C5};
$E5=q#/lib/definition_defdata.b#;
$F5=bless({$L1,$z5,$v2,$w2,$x2,$w2,$y2,$D5,$D,$E5},$H2);
$G5=q#lib/test_value.c#;
$H5=q#lib/slice::ctors#;
$I5=[$Q4,$e5,$n5,$w5,$F5];
$J5=bless({$L1,$I4,$D,$J4,$n2,$I5},$J2);
$K5=q#lib/branch::ctors#;
$L5=[$B3,$L3,$r4,$F4,$J5];
$M5=bless({$L1,$r2,$D,$s2,$n2,$L5},$Z1);
$N5=q#module.c::ctors#;
$O5={};
$P5=q#DESTROY#;
$Q5=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$R5=bless({$q,$Q5,$s,$t},$u);
$S5=q#new#;
$T5=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$U5=bless({$q,$T5,$s,$t},$u);
$V5={$P5,$R5,$S5,$U5};
$W5=q#/lib/instantiable.b#;
$X5=bless({$L1,$O5,$y2,$V5,$D,$W5},$H2);
$Y5=q#lib/test_value.c#;
$Z5=q#lib/slice::ctors#;
$c6={};
$d6=q#child#;
$e6=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$f6=bless({$q,$e6,$s,$t},$u);
$g6={$d6,$f6};
$h6=q#/lib/subclass.b#;
$i6=bless({$L1,$c6,$v2,$w2,$x2,$w2,$y2,$g6,$D,$h6},$H2);
$j6=q#lib/test_value.c#;
$k6=q#lib/slice::ctors#;
$l6=[$M5,$X5,$L3,$M5,$i6];
$m6=bless({$L1,$m2,$D,$E,$n2,$l6},$N1);
$n6=q#class.c::ctors#;
$o6=q#ni:/class.c#;
$p6={$N1,1};
$q6=q#/class.c#;
$r6={$N1,1,$Z1,1};
$s6=q#/module.c#;
$t6=q#lib/test_value.c#;
$u6={$N1,1,$O1,1,$P1,1,$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$t6,1,$Z1,1,$c2,1,$d2,1,$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1};
$v6=q#/object.c#;
$w6=[$m6];
$x6=bless({$L1,$u6,$D,$v6,$n2,$w6},$p2);
$y6=q#metaclass::ctors#;
$z6={$N1,1,$O1,1,$P1,1,$Q1,1,$V1,1,$W1,1,$Z1,1};
$A6=q#/lib/behavior.c#;
$B6=[$x6];
$C6=bless({$L1,$z6,$D,$A6,$n2,$B6},$p2);
$D6=q#metaclass::ctors#;
$E6=[$x6,$X5,$C6];
$F6=bless({$L1,$r6,$D,$s6,$n2,$E6},$p2);
$G6=q#metaclass::ctors#;
$H6=[$F6];
$I6=bless({$L1,$p6,$D,$q6,$n2,$H6},$p2);
$J6=q#metaclass::ctors#;
$K6=q#ni:/lib/accessor.b#;
$L6=q#ni:/lib/behavior#;
$M6=q#ni:/lib/behavior.c#;
$N6=q#ni:/lib/branch#;
$O6={$J2,1};
$P6=q#/lib/branch#;
$Q6={};
$R6=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$S6=bless({$q,$R6,$s,$t},$u);
$T6={$G3,$S6};
$U6=q#/lib/branch_init.b#;
$V6=bless({$L1,$Q6,$v2,$w2,$x2,$w2,$y2,$T6,$D,$U6},$H2);
$W6=q#lib/slice::ctors#;
$X6=[$F4,$T2,$I2,$V6,$J5];
$Y6=bless({$L1,$O6,$D,$P6,$n2,$X6},$P1);
$Z6=q#lib/branch.c::ctors#;
$c7=q#ni:/lib/branch.b#;
$d7=q#ni:/lib/branch.c#;
$e7={$P1,1};
$f7=q#/lib/branch.c#;
$g7=[$C6];
$h7=bless({$L1,$e7,$D,$f7,$n2,$g7},$p2);
$i7=q#metaclass::ctors#;
$j7=q#ni:/lib/branch_init.b#;
$k7=q#ni:/lib/class_init.b#;
$l7=q#ni:/lib/dataslice#;
$m7={$P3,1};
$n7=q#/lib/dataslice#;
$o7={};
$p7=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$q7=bless({$q,$p7,$s,$t},$u);
$r7={$G3,$q7};
$s7=q#/lib/dataslice_init.b#;
$t7=bless({$L1,$o7,$v2,$w2,$x2,$w2,$y2,$r7,$D,$s7},$H2);
$u7=q#lib/slice::ctors#;
$v7={};
$w7=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$x7=bless({$q,$w7,$s,$t},$u);
$y7={$C2,$x7};
$z7=q#/lib/dataslice_apply.b#;
$A7=bless({$L1,$v7,$v2,$w2,$x2,$w2,$y2,$y7,$D,$z7},$H2);
$B7=q#lib/slice::ctors#;
$C7=[$F4,$t7,$A7];
$D7=bless({$L1,$m7,$D,$n7,$n2,$C7},$Q1);
$E7=q#lib/dataslice.c::ctors#;
$F7=q#ni:/lib/dataslice.c#;
$G7={$Q1,1};
$H7=q#/lib/dataslice.c#;
$I7=[$C6];
$J7=bless({$L1,$G7,$D,$H7,$n2,$I7},$p2);
$K7=q#metaclass::ctors#;
$L7=q#ni:/lib/dataslice_apply.b#;
$M7=q#ni:/lib/dataslice_init.b#;
$N7=q#ni:/lib/definition.b#;
$O7=q#ni:/lib/definition_def.b#;
$P7=q#ni:/lib/definition_defdata.b#;
$Q7=q#ni:/lib/doc#;
$R7={$F,1};
$S7={};
$T7=q#shift; +{name => shift, doc => []}#;
$U7=bless({$q,$T7,$s,$t},$u);
$V7={$G3,$U7};
$W7=q#/lib/doc_init.b#;
$X7=bless({$L1,$S7,$v2,$w2,$x2,$w2,$y2,$V7,$D,$W7},$H2);
$Y7=q#lib/slice::ctors#;
$Z7={};
$c8=q#'ni.doc'#;
$d8=bless({$q,$c8,$s,$t},$u);
$e8={$Y2,$d8};
$f8=q#/lib/doc_namespace.b#;
$g8=bless({$L1,$Z7,$v2,$w2,$x2,$w2,$y2,$e8,$D,$f8},$H2);
$h8=q#lib/slice::ctors#;
$i8={};
$j8=q#AUTOLOAD#;
$k8=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$l8=bless({$q,$k8,$s,$t},$u);
$m8={$j8,$l8};
$n8=q#/lib/doc_define.b#;
$o8=bless({$L1,$i8,$v2,$w2,$x2,$w2,$y2,$m8,$D,$n8},$H2);
$p8=q#lib/slice::ctors#;
$q8={};
$r8=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$s8=bless({$q,$r8,$s,$t},$u);
$t8=q#tests#;
$u8=q#my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$v8=bless({$q,$u8,$s,$t},$u);
$w8={$n,$s8,$t8,$v8};
$x8=q#/lib/doc_test.b#;
$y8=bless({$L1,$q8,$v2,$w2,$x2,$w2,$y2,$w8,$D,$x8},$H2);
$z8=q#lib/slice::ctors#;
$A8=[$r4,$T2,$X7,$g8,$o8,$y8];
$B8=bless({$L1,$R7,$D,$W,$n2,$A8},$R1);
$C8=q#lib/doc.c::ctors#;
$D8=q#ni:/lib/doc.c#;
$E8={$R1,1};
$F8=q#/lib/doc.c#;
$G8=[$x6];
$H8=bless({$L1,$E8,$D,$F8,$n2,$G8},$p2);
$I8=q#metaclass::ctors#;
$J8=q#ni:/lib/doc_define.b#;
$K8=q#ni:/lib/doc_init.b#;
$L8=q#ni:/lib/doc_namespace.b#;
$M8=q#ni:/lib/doc_test.b#;
$N8=q#ni:/lib/documentable.b#;
$O8=q#ni:/lib/fn#;
$P8={$u,1};
$Q8=q#/lib/fn#;
$R8={};
$S8=q#shift->compile#;
$T8=bless({$q,$S8,$s,$t},$u);
$U8=q#compile#;
$V8=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$W8=bless({$q,$V8,$s,$t},$u);
$X8=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$Y8=bless({$q,$X8,$s,$t},$u);
$Z8={$U8,$W8,$G3,$Y8};
$c9=q#/lib/fn_init.b#;
$d9=bless({$L1,$R8,$v2,$T8,$x2,$w2,$y2,$Z8,$D,$c9},$H2);
$e9=q#lib/slice::ctors#;
$f9={};
$g9=[];
$h9=q#shift->{'annotations'}#;
$i9=bless({$o,$g9,$q,$h9,$s,$t},$u);
$j9=[];
$k9=q#shift->{'code'}#;
$l9=bless({$o,$j9,$q,$k9,$s,$t},$u);
$m9=q#fn#;
$n9=[];
$o9=q#shift->{'fn'}#;
$p9=bless({$o,$n9,$q,$o9,$s,$t},$u);
$q9={$o,$i9,$q,$l9,$m9,$p9};
$r9=q#/lib/fn_ro.b#;
$s9=bless({$L1,$f9,$v2,$w2,$x2,$w2,$y2,$q9,$D,$r9},$H2);
$t9=q#lib/slice::ctors#;
$u9={};
$v9=[];
$w9=q#shift->{code}#;
$x9=bless({$o,$v9,$q,$w9,$s,$t},$u);
$y9=[];
$z9=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$A9=bless({$o,$y9,$q,$z9,$s,$t},$u);
$B9={$i5,$x9,$r5,$A9};
$C9=q#/lib/fn_ops.b#;
$D9=bless({$L1,$u9,$v2,$w2,$x2,$w2,$y2,$B9,$D,$C9},$H2);
$E9=q#lib/slice::ctors#;
$F9={};
$G9=q#serialize#;
$H9=[];
$I9=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$J9=bless({$o,$H9,$q,$I9,$s,$t},$u);
$K9={$G9,$J9};
$L9=q#/lib/fn_serialize.b#;
$M9=bless({$L1,$F9,$v2,$w2,$x2,$w2,$y2,$K9,$D,$L9},$H2);
$N9=q#lib/slice::ctors#;
$O9=[$r4,$X5,$d9,$s9,$D9,$M9];
$P9=bless({$L1,$P8,$D,$Q8,$n2,$O9},$S1);
$Q9=q#lib/fn.c::ctors#;
$R9=q#ni:/lib/fn.c#;
$S9={$S1,1};
$T9=q#/lib/fn.c#;
$U9=[$x6];
$V9=bless({$L1,$S9,$D,$T9,$n2,$U9},$p2);
$W9=q#metaclass::ctors#;
$X9=q#ni:/lib/fn_init.b#;
$Y9=q#ni:/lib/fn_ops.b#;
$Z9=q#ni:/lib/fn_ro.b#;
$ca=q#ni:/lib/fn_serialize.b#;
$da=q#ni:/lib/global_static_test.b#;
$ea={};
$fa=q#now#;
$ga=[];
$ha=q#ni('ni:/lib/test_value')->new(shift)#;
$ia=q#($)#;
$ja=bless({$o,$ga,$q,$ha,$s,$ia},$u);
$ka={$fa,$ja};
$la=q#/lib/global_static_test.b#;
$ma=bless({$L1,$ea,$v2,$w2,$x2,$w2,$y2,$ka,$D,$la},$H2);
$na=q#main#;
$oa=q#lib/slice::ctors#;
$pa=q#ni:/lib/image#;
$qa={$Q3,1};
$ra=q#/lib/image#;
$sa={};
$ta=[];
$ua=q#my $class = shift;
my %args  = (
  include_shebang => 1,
  include_license => 1,
  include_boot    => 1,
  include_classes => 1,
  include_run     => 1,
  local_vars      => 0,
  use_newlines    => 0,
  @_);

+{include_shebang => $args{include_shebang},
  include_license => $args{include_license},
  include_boot    => $args{include_boot},
  include_classes => $args{include_classes},
  include_run     => $args{include_run},
  local_vars      => $args{local_vars},
  use_newlines    => $args{use_newlines},

  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$va=bless({$o,$ta,$q,$ua,$s,$t},$u);
$wa={$G3,$va};
$xa=q#/lib/image_init.b#;
$ya=bless({$L1,$sa,$v2,$w2,$x2,$w2,$y2,$wa,$D,$xa},$H2);
$za=q#lib/slice::ctors#;
$Aa={};
$Ba=q#address#;
$Ca=[];
$Da=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 16;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$Ea=bless({$o,$Ca,$q,$Da,$s,$t},$u);
$Fa=q#allocate_gensym#;
$Ga=[];
$Ha=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$Ia=bless({$o,$Ga,$q,$Ha,$s,$t},$u);
$Ja=q#boot_side_effect#;
$Ka=[];
$La=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Ma=bless({$o,$Ka,$q,$La,$s,$t},$u);
$Na=q#circular_links#;
$Oa=[];
$Pa=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$Qa=bless({$o,$Oa,$q,$Pa,$s,$t},$u);
$Ra=q#finalizer#;
$Sa=[];
$Ta=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$Ua=bless({$o,$Sa,$q,$Ta,$s,$t},$u);
$Va=q#gensym#;
$Wa=[];
$Xa=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$Ya=bless({$o,$Wa,$q,$Xa,$s,$t},$u);
$Za=q#is_circular#;
$cb=[];
$db=q#my $self = shift;
ref $$self{visited}{$self->address($_[0])};#;
$eb=bless({$o,$cb,$q,$db,$s,$t},$u);
$fb=q#quote#;
$gb=[];
$hb=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? 'undef' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$ib=bless({$o,$gb,$q,$hb,$s,$t},$u);
$jb=q#quote_array#;
$kb=[];
$lb=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_])
  && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$mb=bless({$o,$kb,$q,$lb,$s,$t},$u);
$nb=q#quote_blessed#;
$ob=[];
$pb=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$qb=bless({$o,$ob,$q,$pb,$s,$t},$u);
$rb=q#quote_class#;
$sb=[];
$tb=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$ub=bless({$o,$sb,$q,$tb,$s,$t},$u);
$vb=q#quote_hash#;
$wb=[];
$xb=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  push @{$$self{circular}}, [$a, "{" . $self->quote($k) . "}",
                                 $self->address($$v{$k})]
  if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$yb=bless({$o,$wb,$q,$xb,$s,$t},$u);
$zb=q#quote_object#;
$Ab=[];
$Bb=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$Cb=bless({$o,$Ab,$q,$Bb,$s,$t},$u);
$Db=q#quote_scalar#;
$Eb=[];
$Fb=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$Gb=bless({$o,$Eb,$q,$Fb,$s,$t},$u);
$Hb=q#quote_value#;
$Ib=[];
$Jb=q#my $self = shift;
return $self->quote_scalar($_[0]) unless ref $_[0];
return $self->quote_array($_[0])  if 'ARRAY' eq ref $_[0];
return $self->quote_hash($_[0])   if 'HASH'  eq ref $_[0];
die "cannot serialize $_[0]"      if 'CODE'  eq ref $_[0];
$self->quote_object($_[0]);#;
$Kb=bless({$o,$Ib,$q,$Jb,$s,$t},$u);
$Lb=q#reconstruction#;
$Mb=[];
$Nb=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$Ob=bless({$o,$Mb,$q,$Nb,$s,$t},$u);
$Pb=q#side_effect#;
$Qb=[];
$Rb=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Sb=bless({$o,$Qb,$q,$Rb,$s,$t},$u);
$Tb=q#write#;
$Ub=[];
$Vb=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  ($$self{include_shebang} ? ("\#!/usr/bin/env perl\\n") : ()),
  ($$self{include_license} ? ("chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n") : ()),
  ($$self{include_boot}    ? ("BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n") : ()),
  ($$self{use_newlines}    ? map("$_\\n", $self->reconstruction) : $self->reconstruction),
  ($$self{include_run}     ? ("ni->run(\\@ARGV);", "\\n__DATA__\\n") : ());#;
$Wb=bless({$o,$Ub,$q,$Vb,$s,$t},$u);
$Xb={$Ba,$Ea,$Fa,$Ia,$Ja,$Ma,$Na,$Qa,$Ra,$Ua,$Va,$Ya,$Za,$eb,$fb,$ib,$jb,$mb,$nb,$qb,$rb,$ub,$vb,$yb,$zb,$Cb,$Db,$Gb,$Hb,$Kb,$Lb,$Ob,$Pb,$Sb,$Tb,$Wb};
$Yb=q#/lib/image_quoting.b#;
$Zb=bless({$L1,$Aa,$v2,$w2,$x2,$w2,$y2,$Xb,$D,$Yb},$H2);
$cc=q#lib/slice::ctors#;
$dc=[$r4,$ya,$Zb];
$ec=bless({$L1,$qa,$D,$ra,$n2,$dc},$T1);
$fc=q#lib/image.c::ctors#;
$gc=q#ni:/lib/image.c#;
$hc={$T1,1};
$ic=q#/lib/image.c#;
$jc=[$x6];
$kc=bless({$L1,$hc,$D,$ic,$n2,$jc},$p2);
$lc=q#metaclass::ctors#;
$mc=q#ni:/lib/image_init.b#;
$nc=q#ni:/lib/image_quoting.b#;
$oc=q#ni:/lib/instance.b#;
$pc=q#ni:/lib/instantiable.b#;
$qc=q#ni:/lib/json.b#;
$rc={};
$sc=q#json_decode#;
$tc=[];
$uc=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$vc=bless({$o,$tc,$q,$uc,$s,$ia},$u);
$wc=q#json_encode#;
$xc=[];
$yc=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$zc=bless({$o,$xc,$q,$yc,$s,$ia},$u);
$Ac=q#json_escape#;
$Bc=[];
$Cc=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$Dc=bless({$o,$Bc,$q,$Cc,$s,$ia},$u);
$Ec=q#json_unescape#;
$Fc=[];
$Gc=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$Hc=bless({$o,$Fc,$q,$Gc,$s,$ia},$u);
$Ic=q#json_unescape_one#;
$Jc=[];
$Kc=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$Lc=bless({$o,$Jc,$q,$Kc,$s,$ia},$u);
$Mc={$sc,$vc,$wc,$zc,$Ac,$Dc,$Ec,$Hc,$Ic,$Lc};
$Nc=q#/lib/json.b#;
$Oc=bless({$L1,$rc,$v2,$w2,$x2,$w2,$y2,$Mc,$D,$Nc},$H2);
$Pc=q#ni#;
$Qc=q#lib/slice::ctors#;
$Rc=q#ni:/lib/name_as_string.b#;
$Sc=q#ni:/lib/named.b#;
$Tc=q#ni:/lib/named_in_ni.b#;
$Uc=q#ni:/lib/namespaced.b#;
$Vc=q#ni:/lib/ni#;
$Wc={$R3,1};
$Xc=q#/lib/ni#;
$Yc={};
$Zc=q#is_mutable#;
$cd=[];
$dd=q#$0 ne "-" && -w $0#;
$ed=bless({$o,$cd,$q,$dd,$s,$t},$u);
$fd=q#modify#;
$gd=[];
$hd=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$id=bless({$o,$gd,$q,$hd,$s,$t},$u);
$jd={$Zc,$ed,$fd,$id};
$kd=q#/lib/ni_self.b#;
$ld=bless({$L1,$Yc,$v2,$w2,$x2,$w2,$y2,$jd,$D,$kd},$H2);
$md=q#lib/slice::ctors#;
$nd={};
$od=q#exists#;
$pd=[];
$qd=q#exists $_[0]->{named}{$_[1]}#;
$rd=bless({$o,$pd,$q,$qd,$s,$t},$u);
$sd=q#quoted#;
$td=[];
$ud=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$vd=bless({$o,$td,$q,$ud,$s,$t},$u);
$wd={$od,$rd,$sd,$vd};
$xd=q#/lib/ni_image.b#;
$yd=bless({$L1,$nd,$v2,$w2,$x2,$w2,$y2,$wd,$D,$xd},$H2);
$zd=q#lib/slice::ctors#;
$Ad={};
$Bd=q#--internal/+=#;
$Cd=[];
$Dd=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
  die "ni: failed to run $_: $!" unless $r;
}
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$Ed=bless({$o,$Cd,$q,$Dd,$s,$t},$u);
$Fd=q#--internal/eval#;
$Gd=[];
$Hd=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$Id=bless({$o,$Gd,$q,$Hd,$s,$t},$u);
$Jd=q#--internal/image#;
$Kd=[];
$Ld=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$Md=bless({$o,$Kd,$q,$Ld,$s,$t},$u);
$Nd=q#--internal/test#;
$Od=[];
$Pd=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
my $passed = @tests - $fails;
print "$passed test(s) passed\\n";
!!$fails;#;
$Qd=bless({$o,$Od,$q,$Pd,$s,$t},$u);
$Rd=q#run#;
$Sd=[];
$Td=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$Ud=bless({$o,$Sd,$q,$Td,$s,$t},$u);
$Vd={$Bd,$Ed,$Fd,$Id,$Jd,$Md,$Nd,$Qd,$Rd,$Ud};
$Wd=q#/lib/ni_main.b#;
$Xd=bless({$L1,$Ad,$v2,$w2,$x2,$w2,$y2,$Vd,$D,$Wd},$H2);
$Yd=q#lib/slice::ctors#;
$Zd={};
$ce=[];
$de=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$ee=bless({$o,$ce,$q,$de,$s,$t},$u);
$fe=q#resolver_for#;
$ge=[];
$he=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$ie=bless({$o,$ge,$q,$he,$s,$t},$u);
$je={$s3,$ee,$fe,$ie};
$ke=q#/lib/ni_resolver.b#;
$le=bless({$L1,$Zd,$v2,$w2,$x2,$w2,$y2,$je,$D,$ke},$H2);
$me=q#lib/slice::ctors#;
$ne=[$r4,$ld,$yd,$Xd,$le];
$oe=bless({$L1,$Wc,$D,$Xc,$n2,$ne},$U1);
$pe=q#lib/ni.c::ctors#;
$qe=q#ni:/lib/ni.c#;
$re={$U1,1};
$se=q#/lib/ni.c#;
$te=[$x6];
$ue=bless({$L1,$re,$D,$se,$n2,$te},$p2);
$ve=q#metaclass::ctors#;
$we=q#ni:/lib/ni_image.b#;
$xe=q#ni:/lib/ni_main.b#;
$ye=q#ni:/lib/ni_resolver.b#;
$ze=q#ni:/lib/ni_self.b#;
$Ae=q#ni:/lib/ni_static_util.b#;
$Be={};
$Ce=q#abbrev#;
$De=[];
$Ee=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$Fe=bless({$o,$De,$q,$Ee,$s,$t},$u);
$Ge=q#dor#;
$He=[];
$Ie=q#defined $_[0] ? $_[0] : $_[1]#;
$Je=bless({$o,$He,$q,$Ie,$s,$t},$u);
$Ke=q#indent#;
$Le=[];
$Me=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$Ne=bless({$o,$Le,$q,$Me,$s,$t},$u);
$Oe=q#max#;
$Pe=[];
$Qe=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$Re=bless({$o,$Pe,$q,$Qe,$s,$t},$u);
$Se=q#maxstr#;
$Te=[];
$Ue=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$Ve=bless({$o,$Te,$q,$Ue,$s,$t},$u);
$We=q#mean#;
$Xe=[];
$Ye=q#sum(@_) / (@_ || 1)#;
$Ze=bless({$o,$Xe,$q,$Ye,$s,$t},$u);
$cf=q#min#;
$df=[];
$ef=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$ff=bless({$o,$df,$q,$ef,$s,$t},$u);
$gf=q#minstr#;
$hf=[];
$if=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$jf=bless({$o,$hf,$q,$if,$s,$t},$u);
$kf=q#sgr#;
$lf=[];
$mf=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$nf=bless({$o,$lf,$q,$mf,$s,$t},$u);
$of=q#sr#;
$pf=[];
$qf=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$rf=bless({$o,$pf,$q,$qf,$s,$t},$u);
$sf=q#sum#;
$tf=[];
$uf=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$vf=bless({$o,$tf,$q,$uf,$s,$t},$u);
$wf=q#swap#;
$xf=[];
$yf=q#@_[0, 1] = @_[1, 0]#;
$zf=bless({$o,$xf,$q,$yf,$s,$t},$u);
$Af={$Ce,$Fe,$Ge,$Je,$Ke,$Ne,$Oe,$Re,$Se,$Ve,$We,$Ze,$cf,$ff,$gf,$jf,$kf,$nf,$of,$rf,$sf,$vf,$wf,$zf};
$Bf=q#/lib/ni_static_util.b#;
$Cf=bless({$L1,$Be,$v2,$w2,$x2,$w2,$y2,$Af,$D,$Bf},$H2);
$Df=q#lib/slice::ctors#;
$Ef=q#ni:/lib/perlbranch.b#;
$Ff=q#ni:/lib/ref_eq.b#;
$Gf=q#ni:/lib/resolver.b#;
$Hf=q#ni:/lib/slice#;
$If={$H2,1};
$Jf=q#/lib/slice#;
$Kf=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$Lf=bless({$q,$Kf,$s,$t},$u);
$Mf=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$Nf=bless({$q,$Mf,$s,$t},$u);
$Of=q#lib/slice::apply#;
$Pf=q#lib/slice::apply_unsafe#;
$Qf={};
$Rf=q#apply_unsafe#;
$Sf={$C2,$Lf,$Rf,$Nf};
$Tf=q#/lib/slice.b#;
$Uf=bless({$L1,$Qf,$y2,$Sf,$D,$Tf},$H2);
$Vf=q#lib/slice::ctors#;
$Wf={};
$Xf=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$Yf=bless({$q,$Xf,$s,$t},$u);
$Zf={$G3,$Yf};
$cg=q#/lib/slice_init.b#;
$dg=bless({$L1,$Wf,$y2,$Zf,$D,$cg},$H2);
$eg=q#lib/slice::ctors#;
$fg={};
$gg=[];
$hg=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$ig=bless({$o,$gg,$q,$hg,$s,$t},$u);
$jg={$G9,$ig};
$kg=q#/lib/slice_serialize.b#;
$lg=bless({$L1,$fg,$v2,$w2,$x2,$w2,$y2,$jg,$D,$kg},$H2);
$mg=q#lib/slice::ctors#;
$ng=[$F4,$T2,$Uf,$dg,$lg];
$og=bless({$L1,$If,$D,$Jf,$n2,$ng},$V1);
$pg=q#lib/slice.c::ctors#;
$qg=q#ni:/lib/slice.b#;
$rg=q#ni:/lib/slice.c#;
$sg={$V1,1};
$tg=q#/lib/slice.c#;
$ug=[$C6];
$vg=bless({$L1,$sg,$D,$tg,$n2,$ug},$p2);
$wg=q#metaclass::ctors#;
$xg=q#ni:/lib/slice_init.b#;
$yg=q#ni:/lib/slice_serialize.b#;
$zg=q#ni:/lib/static_fn.b#;
$Ag={};
$Bg=[];
$Cg=q#ni('ni:/lib/fn')->new(@_)#;
$Dg=bless({$o,$Bg,$q,$Cg,$s,$ia},$u);
$Eg=q#fp#;
$Fg=[];
$Gg=q#ni('ni:/lib/fn')->new(@_)#;
$Hg=q#($$)#;
$Ig=bless({$o,$Fg,$q,$Gg,$s,$Hg},$u);
$Jg={$m9,$Dg,$Eg,$Ig};
$Kg=q#/lib/static_fn.b#;
$Lg=bless({$L1,$Ag,$v2,$w2,$x2,$w2,$y2,$Jg,$D,$Kg},$H2);
$Mg=q#lib/slice::ctors#;
$Ng=q#ni:/lib/subclass.b#;
$Og=q#ni:/lib/tag#;
$Pg={$U2,1};
$Qg=q#/lib/tag#;
$Rg={};
$Sg=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$Tg=bless({$q,$Sg,$s,$t},$u);
$Ug={$C2,$Tg};
$Vg=q#/lib/tag.b#;
$Wg=bless({$L1,$Rg,$v2,$w2,$x2,$w2,$y2,$Ug,$D,$Vg},$H2);
$Xg=q#lib/slice::ctors#;
$Yg={};
$Zg=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$ch=bless({$q,$Zg,$s,$t},$u);
$dh={$G3,$ch};
$eh=q#/lib/tag_init.b#;
$fh=bless({$L1,$Yg,$v2,$w2,$x2,$w2,$y2,$dh,$D,$eh},$H2);
$gh=q#lib/slice::ctors#;
$hh=[$F4,$T2,$Wg,$fh];
$ih=bless({$L1,$Pg,$D,$Qg,$n2,$hh},$W1);
$jh=q#lib/tag.c::ctors#;
$kh=q#ni:/lib/tag.b#;
$lh=q#ni:/lib/tag.c#;
$mh={$W1,1};
$nh=q#/lib/tag.c#;
$oh=[$C6];
$ph=bless({$L1,$mh,$D,$nh,$n2,$oh},$p2);
$qh=q#metaclass::ctors#;
$rh=q#ni:/lib/tag_init.b#;
$sh=q#ni:/lib/test_value#;
$th={$S3,1};
$uh=q#/lib/test_value#;
$vh={};
$wh=[];
$xh=q#\\$_[1]#;
$yh=bless({$o,$wh,$q,$xh,$s,$t},$u);
$zh={$G3,$yh};
$Ah=q#/lib/test_value_init.b#;
$Bh=bless({$L1,$vh,$v2,$w2,$x2,$w2,$y2,$zh,$D,$Ah},$H2);
$Ch=q#lib/slice::ctors#;
$Dh={};
$Eh=q#(==#;
$Fh=[];
$Gh=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$Hh=bless({$o,$Fh,$q,$Gh,$s,$t},$u);
$Ih=q#diff#;
$Jh=[];
$Kh=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$Lh=bless({$o,$Jh,$q,$Kh,$s,$t},$u);
$Mh={$Eh,$Hh,$Ih,$Lh};
$Nh=q#/lib/test_value_eq.b#;
$Oh=bless({$L1,$Dh,$v2,$w2,$x2,$w2,$y2,$Mh,$D,$Nh},$H2);
$Ph=q#lib/slice::ctors#;
$Qh={};
$Rh=[];
$Sh=q#ni::json_encode ${$_[0]}#;
$Th=bless({$o,$Rh,$q,$Sh,$s,$t},$u);
$Uh={$i5,$Th};
$Vh=q#/lib/test_value_str.b#;
$Wh=bless({$L1,$Qh,$v2,$w2,$x2,$w2,$y2,$Uh,$D,$Vh},$H2);
$Xh=q#lib/slice::ctors#;
$Yh=[$r4,$Bh,$Oh,$Wh];
$Zh=q#lib/test_value.c#;
$ci=bless({$L1,$th,$D,$uh,$n2,$Yh},$Zh);
$di=q#lib/test_value.c::ctors#;
$ei=q#ni:/lib/test_value.c#;
$fi=q#lib/test_value.c#;
$gi={$fi,1};
$hi=q#/lib/test_value.c#;
$ii=[$x6];
$ji=bless({$L1,$gi,$D,$hi,$n2,$ii},$p2);
$ki=q#metaclass::ctors#;
$li=q#ni:/lib/test_value_eq.b#;
$mi=q#ni:/lib/test_value_init.b#;
$ni=q#ni:/lib/test_value_str.b#;
$oi=q#ni:/metaclass#;
$pi={$p2,1};
$qi=q#/metaclass#;
$ri=[$B3,$X5,$L3,$M5];
$si=bless({$L1,$pi,$D,$qi,$n2,$ri},$Y1);
$ti=q#metaclass.c::ctors#;
$ui=q#ni:/metaclass.c#;
$vi={$Y1,1};
$wi=q#/metaclass.c#;
$xi=[$m6];
$yi=bless({$L1,$vi,$D,$wi,$n2,$xi},$p2);
$zi=q#metaclass::ctors#;
$Ai=q#ni:/module#;
$Bi=q#ni:/module.c#;
$Ci=q#ni:/object#;
$Di=q#ni:/object.c#;
$Ei=q#ni:/unix/cat#;
$Fi={$V3,1};
$Gi={$V3,1,$X3,1,$Y3,1,$Z3,1,$c4,1,$d4,1,$e4,1,$f4,1};
$Hi=q#/unix/io#;
$Ii={};
$Ji=q#(bool#;
$Ki=[];
$Li=bless({$o,$Ki,$q,1,$s,$t},$u);
$Mi={$Ji,$Li};
$Ni=q#/unix/io_ops.b#;
$Oi=bless({$L1,$Ii,$v2,$w2,$x2,$w2,$y2,$Mi,$D,$Ni},$H2);
$Pi=q#lib/slice::ctors#;
$Qi={};
$Ri=q#into#;
$Si=[];
$Ti=q#local $_;
my ($self, $dest, $each) = @_;
my $block_size = $self->can('read_size') ? $self->read_size : 8192;
while ($self->read($_, $block_size)) {
  &$each($_) if defined $each;
  $dest->write($_);
}#;
$Ui=bless({$o,$Si,$q,$Ti,$s,$t},$u);
$Vi={$Ri,$Ui};
$Wi=q#/unix/io_stream.b#;
$Xi=bless({$L1,$Qi,$v2,$w2,$x2,$w2,$y2,$Vi,$D,$Wi},$H2);
$Yi=q#lib/slice::ctors#;
$Zi={};
$cj=q#(+#;
$dj=[];
$ej=q#ni('ni:/unix/cat')->new(@_[0, 1])#;
$fj=bless({$o,$dj,$q,$ej,$s,$t},$u);
$gj={$cj,$fj};
$hj=q#/unix/io_constructors.b#;
$ij=bless({$L1,$Zi,$v2,$w2,$x2,$w2,$y2,$gj,$D,$hj},$H2);
$jj=q#lib/slice::ctors#;
$kj={};
$lj=q#read_all#;
$mj=[];
$nj=q#shift->into(ni("ni:/unix/str")->new(my $data = ""));
$data;#;
$oj=bless({$o,$mj,$q,$nj,$s,$t},$u);
$pj={$lj,$oj};
$qj=q#/unix/io_memory.b#;
$rj=bless({$L1,$kj,$v2,$w2,$x2,$w2,$y2,$pj,$D,$qj},$H2);
$sj=q#lib/slice::ctors#;
$tj={};
$uj=q#(<>#;
$vj=[];
$wj=q#my $fh = shift->read_fh;
\# TODO: buffered line reading with a pushback queue#;
$xj=bless({$o,$vj,$q,$wj,$s,$t},$u);
$yj=q#(@{}#;
$zj=[];
$Aj=q#my $self = shift; [<$self>]#;
$Bj=bless({$o,$zj,$q,$Aj,$s,$t},$u);
$Cj={$uj,$xj,$yj,$Bj};
$Dj=q#/unix/io_readers.b#;
$Ej=bless({$L1,$tj,$v2,$w2,$x2,$w2,$y2,$Cj,$D,$Dj},$H2);
$Fj=q#lib/slice::ctors#;
$Gj=[$r4,$Oi,$Xi,$ij,$rj,$Ej];
$Hj=bless({$L1,$Gi,$D,$Hi,$n2,$Gj},$i2);
$Ij=q#unix/io.c::ctors#;
$Jj={};
$Kj=[];
$Lj=q#shift; +{fs => [@_]}#;
$Mj=bless({$o,$Kj,$q,$Lj,$s,$t},$u);
$Nj={$G3,$Mj};
$Oj=q#/unix/cat_init.b#;
$Pj=bless({$L1,$Jj,$v2,$w2,$x2,$w2,$y2,$Nj,$D,$Oj},$H2);
$Qj=q#lib/slice::ctors#;
$Rj={};
$Sj=q#read#;
$Tj=[];
$Uj=q#my $fs = shift->{fs};
my $n;
shift @$fs until !@$fs or $n = $$fs[0]->read(@_);
return $n;#;
$Vj=bless({$o,$Tj,$q,$Uj,$s,$t},$u);
$Wj={$Sj,$Vj};
$Xj=q#/unix/cat_read.b#;
$Yj=bless({$L1,$Rj,$v2,$w2,$x2,$w2,$y2,$Wj,$D,$Xj},$H2);
$Zj=q#lib/slice::ctors#;
$ck=[$Hj,$Pj,$Yj];
$dk=bless({$L1,$Fi,$D,$k1,$n2,$ck},$d2);
$ek=q#unix/cat.c::ctors#;
$fk=q#ni:/unix/cat.c#;
$gk={$d2,1};
$hk=q#/unix/cat.c#;
$ik={$d2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1};
$jk=q#/unix/io.c#;
$kk={};
$lk=q#has_fd#;
$mk=[];
$nk=q#shift->add('/unix/has_fd.b')#;
$ok=bless({$o,$mk,$q,$nk,$s,$t},$u);
$pk={$lk,$ok};
$qk=q#/unix/io.c_has_fd.b#;
$rk=bless({$L1,$kk,$v2,$w2,$x2,$w2,$y2,$pk,$D,$qk},$H2);
$sk=q#lib/slice::ctors#;
$tk=[$x6,$rk];
$uk=bless({$L1,$ik,$D,$jk,$n2,$tk},$p2);
$vk=q#metaclass::ctors#;
$wk=[$uk];
$xk=bless({$L1,$gk,$D,$hk,$n2,$wk},$p2);
$yk=q#metaclass::ctors#;
$zk=q#ni:/unix/cat_init.b#;
$Ak=q#ni:/unix/cat_read.b#;
$Bk=q#ni:/unix/exec#;
$Ck={$W3,1};
$Dk={};
$Ek=q#argv#;
$Fk=[];
$Gk=q#shift->{'argv'}#;
$Hk=bless({$o,$Fk,$q,$Gk,$s,$t},$u);
$Ik={$Ek,$Hk};
$Jk=q#/unix/exec_ro.b#;
$Kk=bless({$L1,$Dk,$v2,$w2,$x2,$w2,$y2,$Ik,$D,$Jk},$H2);
$Lk=q#lib/slice::ctors#;
$Mk={};
$Nk=[];
$Ok=q#my ($class, @argv) = @_;
+{argv  => \\@argv,
  env   => {%ENV},
  fds   => {},
  pipes => {}};#;
$Pk=bless({$o,$Nk,$q,$Ok,$s,$t},$u);
$Qk={$G3,$Pk};
$Rk=q#/unix/exec_init.b#;
$Sk=bless({$L1,$Mk,$v2,$w2,$x2,$w2,$y2,$Qk,$D,$Rk},$H2);
$Tk=q#lib/slice::ctors#;
$Uk={};
$Vk=q#fds#;
$Wk=[];
$Xk=q#my ($self, %fds) = @_;
return $$self{fds} unless keys %fds;
@{$$self{fds}}{keys %fds} = values %fds;
$self;#;
$Yk=bless({$o,$Wk,$q,$Xk,$s,$t},$u);
$Zk=q#pipes#;
$cl=[];
$dl=q#local $^F = 1024;
my ($self, @fds) = @_;
return $$self{pipes} unless @fds;
for (@fds) {
  die "ni:/unix/exec: must append 'r' or 'w' to extended fds"
    if $_ > 2 && !/^(\\d+)[rw]$/;
  $$self{pipes}{$_} ||= $$self{fds}{$_} = ni("ni:/unix/fifo")->new;
}
$self;#;
$el=bless({$o,$cl,$q,$dl,$s,$t},$u);
$fl=q#setup_stdio#;
$gl=[];
$hl=q#my $self = shift;
$self->pipes(grep !exists $$self{fds}{$_}, 0..2);
$self;#;
$il=bless({$o,$gl,$q,$hl,$s,$t},$u);
$jl={$Vk,$Yk,$Zk,$el,$fl,$il};
$kl=q#/unix/exec_io_setup.b#;
$ll=bless({$L1,$Uk,$v2,$w2,$x2,$w2,$y2,$jl,$D,$kl},$H2);
$ml=q#lib/slice::ctors#;
$nl={};
$ol=q#fd#;
$pl=[];
$ql=q#my ($self, $fd) = @_;
return $$self{pipes}{$fd} if exists $$self{pipes}{$fd};
$self->pipes($fd)->fd($fd);#;
$rl=bless({$o,$pl,$q,$ql,$s,$t},$u);
$sl=q#stderr#;
$tl=[];
$ul=q#shift->fd(2)#;
$vl=bless({$o,$tl,$q,$ul,$s,$t},$u);
$wl=q#stdin#;
$xl=[];
$yl=q#shift->fd(0)#;
$zl=bless({$o,$xl,$q,$yl,$s,$t},$u);
$Al=q#stdout#;
$Bl=[];
$Cl=q#shift->fd(1)#;
$Dl=bless({$o,$Bl,$q,$Cl,$s,$t},$u);
$El={$ol,$rl,$sl,$vl,$wl,$zl,$Al,$Dl};
$Fl=q#/unix/exec_io_accessors.b#;
$Gl=bless({$L1,$nl,$v2,$w2,$x2,$w2,$y2,$El,$D,$Fl},$H2);
$Hl=q#lib/slice::ctors#;
$Il={};
$Jl=q#env#;
$Kl=[];
$Ll=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$Ml=bless({$o,$Kl,$q,$Ll,$s,$t},$u);
$Nl={$Jl,$Ml};
$Ol=q#/unix/exec_env.b#;
$Pl=bless({$L1,$Il,$v2,$w2,$x2,$w2,$y2,$Nl,$D,$Ol},$H2);
$Ql=q#lib/slice::ctors#;
$Rl={};
$Sl=q#exec#;
$Tl=[];
$Ul=q#no warnings 'numeric';
my $self = shift->setup_stdio;
local %ENV = %{$$self{env}};
$self->move_fds;
for (keys %{$$self{pipes}}) {
  my $p = $$self{pipes}{$_};
  ($_ < 2 ? !$_ : /r$/) ? $p->r : $p->w;
}
my @argv = (@{$$self{argv}}, @_);
{ exec @argv };
print STDERR "ni:/unix/exec: exec @argv failed: $!";
exit 1;#;
$Vl=bless({$o,$Tl,$q,$Ul,$s,$t},$u);
$Wl=q#fork#;
$Xl=[];
$Yl=q#no warnings 'numeric';
my $self = shift->setup_stdio;
my $pid = fork;
die "ni:/unix/exec: fork failed: $!" unless defined $pid;
return $self->exec(@_) unless $pid;
for (keys %{$$self{pipes}}) {
  my $p = $$self{pipes}{$_};
  ($_ < 2 ? $_ : /r$/) ? $p->w : $p->r;
}
ni('ni:/unix/pid')->new($pid, %{$$self{pipes}});#;
$Zl=bless({$o,$Xl,$q,$Yl,$s,$t},$u);
$cm=q#move_fds#;
$dm=[];
$em=q#my $self = shift;
$$self{fds}{$_}->be($_) for keys %{$$self{fds}};
$self;#;
$fm=bless({$o,$dm,$q,$em,$s,$t},$u);
$gm={$Sl,$Vl,$Wl,$Zl,$cm,$fm};
$hm=q#/unix/exec_fork.b#;
$im=bless({$L1,$Rl,$v2,$w2,$x2,$w2,$y2,$gm,$D,$hm},$H2);
$jm=q#lib/slice::ctors#;
$km=[$r4,$Kk,$Sk,$ll,$Gl,$Pl,$im];
$lm=bless({$L1,$Ck,$D,$w1,$n2,$km},$e2);
$mm=q#unix/exec.c::ctors#;
$nm=q#ni:/unix/exec.c#;
$om={$e2,1};
$pm=q#/unix/exec.c#;
$qm=[$x6];
$rm=bless({$L1,$om,$D,$pm,$n2,$qm},$p2);
$sm=q#metaclass::ctors#;
$tm=q#ni:/unix/exec_env.b#;
$um=q#ni:/unix/exec_fork.b#;
$vm=q#ni:/unix/exec_init.b#;
$wm=q#ni:/unix/exec_io_accessors.b#;
$xm=q#ni:/unix/exec_io_setup.b#;
$ym=q#ni:/unix/exec_ro.b#;
$zm=q#ni:/unix/fd#;
$Am={$X3,1};
$Bm=q#/unix/fd#;
$Cm={};
$Dm=[];
$Em=q#shift->{'fd'}#;
$Fm=bless({$o,$Dm,$q,$Em,$s,$t},$u);
$Gm={$ol,$Fm};
$Hm=q#/unix/fd_readers.b#;
$Im=bless({$L1,$Cm,$v2,$w2,$x2,$w2,$y2,$Gm,$D,$Hm},$H2);
$Jm=q#lib/slice::ctors#;
$Km={};
$Lm=[];
$Mm=q#my ($class, $fd) = @_;
+{fd => ref $fd ? fileno $fd : $fd,
  fh => ref $fd ? $fd        : undef};#;
$Nm=bless({$o,$Lm,$q,$Mm,$s,$t},$u);
$Om={$G3,$Nm};
$Pm=q#/unix/fd_init.b#;
$Qm=bless({$L1,$Km,$v2,$w2,$x2,$w2,$y2,$Om,$D,$Pm},$H2);
$Rm=q#lib/slice::ctors#;
$Sm={};
$Tm=q#be#;
$Um=[];
$Vm=q#use POSIX qw/dup2/;
my ($self, $new) = @_;
return $self if $new == $$self{fd};
close $$self{fh} if Scalar::Util::openhandle $$self{fh};
dup2 $$self{fd}, $new or die "ni:/unix/fd: dup2($$self{fd}, $new): $!";
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$Wm=bless({$o,$Um,$q,$Vm,$s,$t},$u);
$Xm={$Tm,$Wm};
$Ym=q#/unix/fd_shell.b#;
$Zm=bless({$L1,$Sm,$v2,$w2,$x2,$w2,$y2,$Xm,$D,$Ym},$H2);
$cn=q#lib/slice::ctors#;
$dn={$X3,1,$Y3,1,$Z3,1,$d4,1,$e4,1};
$en=q#/unix/has_fd.b#;
$fn={};
$gn=q#read_fd#;
$hn=[];
$in=q#ni("ni:/unix/fd")->new(fileno shift->read_fh)#;
$jn=bless({$o,$hn,$q,$in,$s,$t},$u);
$kn=q#write_fd#;
$ln=[];
$mn=q#ni("ni:/unix/fd")->new(fileno shift->write_fh)#;
$nn=bless({$o,$ln,$q,$mn,$s,$t},$u);
$on={$gn,$jn,$kn,$nn};
$pn=q#/unix/fd_accessors.b#;
$qn=bless({$L1,$fn,$v2,$w2,$x2,$w2,$y2,$on,$D,$pn},$H2);
$rn=q#lib/slice::ctors#;
$sn={};
$tn=[];
$un=q#no warnings 'io';
use Errno qw/EINTR/;
my $fh = shift->read_fh;
my $n;
do {
  return $n if defined($n = read $fh, $_[0], $_[1], $_[2] || 0);
} while $!{EINTR};
return undef;#;
$vn=bless({$o,$tn,$q,$un,$s,$t},$u);
$wn=[];
$xn=q#my $fh = shift->write_fh;
my $n;
do {
  return $n if defined($n = syswrite $fh, $_[0]);
} while $!{EINTR};
return undef;#;
$yn=bless({$o,$wn,$q,$xn,$s,$t},$u);
$zn={$Sj,$vn,$Tb,$yn};
$An=q#/unix/fd_safeio.b#;
$Bn=bless({$L1,$sn,$v2,$w2,$x2,$w2,$y2,$zn,$D,$An},$H2);
$Cn=q#lib/slice::ctors#;
$Dn=[$qn,$Bn];
$En=bless({$L1,$dn,$D,$en,$n2,$Dn},$J2);
$Fn=q#lib/branch::ctors#;
$Gn={};
$Hn=q#read_fh#;
$In=[];
$Jn=q#my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, '<&=', $self->{fd}
  or die "ni:/unix/fd $self->{fd} failed to read: $!";
$self->{fh} = $fh;#;
$Kn=bless({$o,$In,$q,$Jn,$s,$t},$u);
$Ln=q#write_fh#;
$Mn=[];
$Nn=q#my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, '>&=', $self->{fd}
  or die "ni:/unix/file $self->{fd} failed to write: $!";
$self->{fh} = $fh;#;
$On=bless({$o,$Mn,$q,$Nn,$s,$t},$u);
$Pn={$Hn,$Kn,$Ln,$On};
$Qn=q#/unix/fd_io.b#;
$Rn=bless({$L1,$Gn,$v2,$w2,$x2,$w2,$y2,$Pn,$D,$Qn},$H2);
$Sn=q#lib/slice::ctors#;
$Tn=[$Hj,$Im,$Qm,$Zm,$En,$Rn];
$Un=bless({$L1,$Am,$D,$Bm,$n2,$Tn},$f2);
$Vn=q#unix/fd.c::ctors#;
$Wn=q#ni:/unix/fd.c#;
$Xn={$f2,1};
$Yn=q#/unix/fd.c#;
$Zn=[$uk];
$co=bless({$L1,$Xn,$D,$Yn,$n2,$Zn},$p2);
$do=q#metaclass::ctors#;
$eo=q#ni:/unix/fd_accessors.b#;
$fo=q#ni:/unix/fd_init.b#;
$go=q#ni:/unix/fd_io.b#;
$ho=q#ni:/unix/fd_readers.b#;
$io=q#ni:/unix/fd_safeio.b#;
$jo=q#ni:/unix/fd_shell.b#;
$ko=q#ni:/unix/fifo#;
$lo={$Y3,1};
$mo=q#/unix/fifo#;
$no={};
$oo=[];
$po=q#shift->{'read_fh'}#;
$qo=bless({$o,$oo,$q,$po,$s,$t},$u);
$ro=[];
$so=q#shift->{'write_fh'}#;
$to=bless({$o,$ro,$q,$so,$s,$t},$u);
$uo={$Hn,$qo,$Ln,$to};
$vo=q#/unix/fifo_io.b#;
$wo=bless({$L1,$no,$v2,$w2,$x2,$w2,$y2,$uo,$D,$vo},$H2);
$xo=q#lib/slice::ctors#;
$yo={};
$zo=[];
$Ao=q#my ($class) = @_;
pipe my ($r, $w) or die "ni:/unix/fifo failed: $!";
+{read_fh => $r, write_fh => $w};#;
$Bo=bless({$o,$zo,$q,$Ao,$s,$t},$u);
$Co={$G3,$Bo};
$Do=q#/unix/fifo_init.b#;
$Eo=bless({$L1,$yo,$v2,$w2,$x2,$w2,$y2,$Co,$D,$Do},$H2);
$Fo=q#lib/slice::ctors#;
$Go={};
$Ho=[];
$Io=q#my ($self, $fd) = @_;
(!$fd || $fd > 2 && $fd =~ s/[rw]$// && $1 eq 'r'
  ? $self->r
  : $self->w)->be($fd);
$self;#;
$Jo=bless({$o,$Ho,$q,$Io,$s,$t},$u);
$Ko={$Tm,$Jo};
$Lo=q#/unix/fifo_stdio.b#;
$Mo=bless({$L1,$Go,$v2,$w2,$x2,$w2,$y2,$Ko,$D,$Lo},$H2);
$No=q#lib/slice::ctors#;
$Oo={};
$Po=q#r#;
$Qo=[];
$Ro=q#my $self = shift;
close $$self{write_fh};
$self->read_fd;#;
$So=bless({$o,$Qo,$q,$Ro,$s,$t},$u);
$To=q#w#;
$Uo=[];
$Vo=q#my $self = shift;
close $$self{read_fh};
$self->write_fd;#;
$Wo=bless({$o,$Uo,$q,$Vo,$s,$t},$u);
$Xo={$Po,$So,$To,$Wo};
$Yo=q#/unix/fifo_direction.b#;
$Zo=bless({$L1,$Oo,$v2,$w2,$x2,$w2,$y2,$Xo,$D,$Yo},$H2);
$cp=q#lib/slice::ctors#;
$dp=[$Hj,$wo,$Eo,$Mo,$En,$Zo];
$ep=bless({$L1,$lo,$D,$mo,$n2,$dp},$g2);
$fp=q#unix/fifo.c::ctors#;
$gp=q#ni:/unix/fifo.c#;
$hp={$g2,1};
$ip=q#/unix/fifo.c#;
$jp=[$uk];
$kp=bless({$L1,$hp,$D,$ip,$n2,$jp},$p2);
$lp=q#metaclass::ctors#;
$mp=q#ni:/unix/fifo_direction.b#;
$np=q#ni:/unix/fifo_init.b#;
$op=q#ni:/unix/fifo_io.b#;
$pp=q#ni:/unix/fifo_stdio.b#;
$qp=q#ni:/unix/file#;
$rp={$Z3,1};
$sp=q#/unix/file#;
$tp={};
$up=[];
$vp=q#shift->{'name'}#;
$wp=bless({$o,$up,$q,$vp,$s,$t},$u);
$xp={$D,$wp};
$yp=q#/unix/file_readers.b#;
$zp=bless({$L1,$tp,$v2,$w2,$x2,$w2,$y2,$xp,$D,$yp},$H2);
$Ap=q#lib/slice::ctors#;
$Bp={};
$Cp=[];
$Dp=q#my ($class, $name) = @_;
+{name => $name, fh => undef};#;
$Ep=bless({$o,$Cp,$q,$Dp,$s,$t},$u);
$Fp={$G3,$Ep};
$Gp=q#/unix/file_init.b#;
$Hp=bless({$L1,$Bp,$v2,$w2,$x2,$w2,$y2,$Fp,$D,$Gp},$H2);
$Ip=q#lib/slice::ctors#;
$Jp={};
$Kp=[];
$Lp=q#my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, '<', $self->{name}
  or die "ni:/unix/file $self->{name} failed to read: $!";
$self->{fh} = $fh;#;
$Mp=bless({$o,$Kp,$q,$Lp,$s,$t},$u);
$Np=[];
$Op=q#my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, '>', $self->{name}
  or die "ni:/unix/file $self->{name} failed to write: $!";
$self->{fh} = $fh;#;
$Pp=bless({$o,$Np,$q,$Op,$s,$t},$u);
$Qp={$Hn,$Mp,$Ln,$Pp};
$Rp=q#/unix/file_io.b#;
$Sp=bless({$L1,$Jp,$v2,$w2,$x2,$w2,$y2,$Qp,$D,$Rp},$H2);
$Tp=q#lib/slice::ctors#;
$Up=[$Hj,$zp,$Hp,$En,$Sp];
$Vp=bless({$L1,$rp,$D,$sp,$n2,$Up},$h2);
$Wp=q#unix/file.c::ctors#;
$Xp=q#ni:/unix/file.c#;
$Yp={$h2,1};
$Zp=q#/unix/file.c#;
$cq=[$uk];
$dq=bless({$L1,$Yp,$D,$Zp,$n2,$cq},$p2);
$eq=q#metaclass::ctors#;
$fq=q#ni:/unix/file_init.b#;
$gq=q#ni:/unix/file_io.b#;
$hq=q#ni:/unix/file_readers.b#;
$iq=q#ni:/unix/has_fd.b#;
$jq=q#ni:/unix/io#;
$kq=q#ni:/unix/io.c#;
$lq=q#ni:/unix/io.c_has_fd.b#;
$mq=q#ni:/unix/io_constructors.b#;
$nq=q#ni:/unix/io_memory.b#;
$oq=q#ni:/unix/io_ops.b#;
$pq=q#ni:/unix/io_readers.b#;
$qq=q#ni:/unix/io_stream.b#;
$rq=q#ni:/unix/pid#;
$sq={$d4,1};
$tq={};
$uq=q#pid#;
$vq=[];
$wq=q#shift->{'pid'}#;
$xq=bless({$o,$vq,$q,$wq,$s,$t},$u);
$yq=q#status#;
$zq=[];
$Aq=q#shift->{'status'}#;
$Bq=bless({$o,$zq,$q,$Aq,$s,$t},$u);
$Cq={$uq,$xq,$yq,$Bq};
$Dq=q#/unix/pid_readers.b#;
$Eq=bless({$L1,$tq,$v2,$w2,$x2,$w2,$y2,$Cq,$D,$Dq},$H2);
$Fq=q#lib/slice::ctors#;
$Gq={};
$Hq=[];
$Iq=q#shift->await#;
$Jq=bless({$o,$Hq,$q,$Iq,$s,$t},$u);
$Kq=[];
$Lq=q#my ($class, $pid, %exposed_fds) = @_;
+{pid    => $pid,
  fds    => \\%exposed_fds,
  status => undef};#;
$Mq=bless({$o,$Kq,$q,$Lq,$s,$t},$u);
$Nq={$G3,$Mq};
$Oq=q#/unix/pid_init.b#;
$Pq=bless({$L1,$Gq,$v2,$w2,$x2,$Jq,$y2,$Nq,$D,$Oq},$H2);
$Qq=q#lib/slice::ctors#;
$Rq={};
$Sq=q#await#;
$Tq=[];
$Uq=q#my $self = shift;
return $$self{status} if defined $$self{status};
defined(waitpid $$self{pid}, 0)
  ? $$self{status} = $?
  : die "/unix/pid_wait.b: waitpid: $!";#;
$Vq=bless({$o,$Tq,$q,$Uq,$s,$t},$u);
$Wq=q#running#;
$Xq=[];
$Yq=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$Zq=bless({$o,$Xq,$q,$Yq,$s,$t},$u);
$cr={$Sq,$Vq,$Wq,$Zq};
$dr=q#/unix/pid_wait.b#;
$er=bless({$L1,$Rq,$v2,$w2,$x2,$w2,$y2,$cr,$D,$dr},$H2);
$fr=q#lib/slice::ctors#;
$gr={};
$hr=[];
$ir=q#shift->fd(1)->read_fh#;
$jr=bless({$o,$hr,$q,$ir,$s,$t},$u);
$kr=[];
$lr=q#shift->fd(0)->write_fh#;
$mr=bless({$o,$kr,$q,$lr,$s,$t},$u);
$nr={$Hn,$jr,$Ln,$mr};
$or=q#/unix/pid_io.b#;
$pr=bless({$L1,$gr,$v2,$w2,$x2,$w2,$y2,$nr,$D,$or},$H2);
$qr=q#lib/slice::ctors#;
$rr={};
$sr=[];
$tr=q#$_[0]->{fds}{$_[1]}#;
$ur=bless({$o,$sr,$q,$tr,$s,$t},$u);
$vr=[];
$wr=bless({$o,$vr,$q,$ul,$s,$t},$u);
$xr=[];
$yr=bless({$o,$xr,$q,$yl,$s,$t},$u);
$zr=[];
$Ar=bless({$o,$zr,$q,$Cl,$s,$t},$u);
$Br={$ol,$ur,$sl,$wr,$wl,$yr,$Al,$Ar};
$Cr=q#/unix/pid_accessors.b#;
$Dr=bless({$L1,$rr,$v2,$w2,$x2,$w2,$y2,$Br,$D,$Cr},$H2);
$Er=q#lib/slice::ctors#;
$Fr=[$Hj,$Eq,$Pq,$er,$En,$pr,$Dr];
$Gr=bless({$L1,$sq,$D,$I1,$n2,$Fr},$j2);
$Hr=q#unix/pid.c::ctors#;
$Ir=q#ni:/unix/pid.c#;
$Jr={$j2,1};
$Kr=q#/unix/pid.c#;
$Lr=[$uk];
$Mr=bless({$L1,$Jr,$D,$Kr,$n2,$Lr},$p2);
$Nr=q#metaclass::ctors#;
$Or=q#ni:/unix/pid_accessors.b#;
$Pr=q#ni:/unix/pid_init.b#;
$Qr=q#ni:/unix/pid_io.b#;
$Rr=q#ni:/unix/pid_readers.b#;
$Sr=q#ni:/unix/pid_wait.b#;
$Tr=q#ni:/unix/pipeline#;
$Ur={$e4,1};
$Vr=q#/unix/pipeline#;
$Wr={};
$Xr=[];
$Yr=q#shift->{'stdin'}#;
$Zr=bless({$o,$Xr,$q,$Yr,$s,$t},$u);
$cs=[];
$ds=q#shift->{'stdout'}#;
$es=bless({$o,$cs,$q,$ds,$s,$t},$u);
$fs={$wl,$Zr,$Al,$es};
$gs=q#/unix/pipeline_ro.b#;
$hs=bless({$L1,$Wr,$v2,$w2,$x2,$w2,$y2,$fs,$D,$gs},$H2);
$is=q#lib/slice::ctors#;
$js={};
$ks=[];
$ls=q#my $class  = shift;
my $stdin  = ni('ni:/unix/fifo')->new;
my $stdout = ni('ni:/unix/fifo')->new;
\# TODO: stderr and multiplexing, which probably happens here

my @rs = ($stdin, @_);
my @ws = (@_, $stdout);
my $rv; vec($rv, fileno $_->read_fh,  1) = 1 for @rs;
my $wv; vec($wv, fileno $_->write_fh, 1) = 1 for @ws;

+{ps     => [@_],
  stdin  => $stdin,
  stdout => $stdout,
  rs => \\@rs, rv => $rv,
  ws => \\@ws, wv => $wv};#;
$ms=bless({$o,$ks,$q,$ls,$s,$t},$u);
$ns={$G3,$ms};
$os=q#/unix/pipeline_init.b#;
$ps=bless({$L1,$js,$v2,$w2,$x2,$w2,$y2,$ns,$D,$os},$H2);
$qs=q#lib/slice::ctors#;
$rs={};
$ss=q#async_step#;
$ts=[];
$us=q#local $_;
my $self = shift;
my $rv = $$self{rv};
my $wv = $$self{wv};
my $ev = $$self{ev};
return $self unless select $rv, $wv, $ev, 0;
for my $i (0..$\#{$$self{rs}}) {
  my $rfh = $$self{rs}[$i]->read_fh;
  my $wfh = $$self{ws}[$i]->write_fh;
  next unless vec $rv, fileno $rfh, 1 and vec $wv, fileno $wfh, 1;
  $$self{rs}[$i]->read($_, 8192);
  $$self{ws}[$i]->write($_);
}
$self;#;
$vs=bless({$o,$ts,$q,$us,$s,$t},$u);
$ws={$ss,$vs};
$xs=q#/unix/pipeline_async.b#;
$ys=bless({$L1,$rs,$v2,$w2,$x2,$w2,$y2,$ws,$D,$xs},$H2);
$zs=q#lib/slice::ctors#;
$As={};
$Bs=[];
$Cs=q#shift->{stdout}->read_fh#;
$Ds=bless({$o,$Bs,$q,$Cs,$s,$t},$u);
$Es=[];
$Fs=q#shift->{stdin}->write_fh#;
$Gs=bless({$o,$Es,$q,$Fs,$s,$t},$u);
$Hs={$Hn,$Ds,$Ln,$Gs};
$Is=q#/unix/pipeline_io.b#;
$Js=bless({$L1,$As,$v2,$w2,$x2,$w2,$y2,$Hs,$D,$Is},$H2);
$Ks=q#lib/slice::ctors#;
$Ls=[$Hj,$hs,$ps,$ys,$En,$Js];
$Ms=bless({$L1,$Ur,$D,$Vr,$n2,$Ls},$k2);
$Ns=q#unix/pipeline.c::ctors#;
$Os=q#ni:/unix/pipeline.c#;
$Ps={$k2,1};
$Qs=q#/unix/pipeline.c#;
$Rs=[$uk];
$Ss=bless({$L1,$Ps,$D,$Qs,$n2,$Rs},$p2);
$Ts=q#metaclass::ctors#;
$Us=q#ni:/unix/pipeline_async.b#;
$Vs=q#ni:/unix/pipeline_init.b#;
$Ws=q#ni:/unix/pipeline_io.b#;
$Xs=q#ni:/unix/pipeline_ro.b#;
$Ys=q#ni:/unix/str#;
$Zs={$f4,1};
$ct=q#/unix/str#;
$dt={};
$et=q#data#;
$ft=[];
$gt=q#shift->{'data'}#;
$ht=bless({$o,$ft,$q,$gt,$s,$t},$u);
$it=q#end#;
$jt=[];
$kt=q#shift->{'end'}#;
$lt=bless({$o,$jt,$q,$kt,$s,$t},$u);
$mt=q#start#;
$nt=[];
$ot=q#shift->{'start'}#;
$pt=bless({$o,$nt,$q,$ot,$s,$t},$u);
$qt={$et,$ht,$it,$lt,$mt,$pt};
$rt=q#/unix/str_ro.b#;
$st=bless({$L1,$dt,$v2,$w2,$x2,$w2,$y2,$qt,$D,$rt},$H2);
$tt=q#lib/slice::ctors#;
$ut={};
$vt=[];
$wt=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$xt=bless({$o,$vt,$q,$wt,$s,$t},$u);
$yt={$G3,$xt};
$zt=q#/unix/str_init.b#;
$At=bless({$L1,$ut,$v2,$w2,$x2,$w2,$y2,$yt,$D,$zt},$H2);
$Bt=q#lib/slice::ctors#;
$Ct={};
$Dt=[];
$Et=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$Ft=bless({$o,$Dt,$q,$Et,$s,$t},$u);
$Gt=q#remaining#;
$Ht=[];
$It=q#my $self = shift; $$self{end} - $$self{start}#;
$Jt=bless({$o,$Ht,$q,$It,$s,$t},$u);
$Kt=[];
$Lt=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$Mt=bless({$o,$Kt,$q,$Lt,$s,$t},$u);
$Nt={$Sj,$Ft,$Gt,$Jt,$Tb,$Mt};
$Ot=q#/unix/str_io.b#;
$Pt=bless({$L1,$Ct,$v2,$w2,$x2,$w2,$y2,$Nt,$D,$Ot},$H2);
$Qt=q#lib/slice::ctors#;
$Rt=[$Hj,$st,$At,$Pt];
$St=bless({$L1,$Zs,$D,$ct,$n2,$Rt},$l2);
$Tt=q#unix/str.c::ctors#;
$Ut=q#ni:/unix/str.c#;
$Vt={$l2,1};
$Wt=q#/unix/str.c#;
$Xt=[$uk];
$Yt=bless({$L1,$Vt,$D,$Wt,$n2,$Xt},$p2);
$Zt=q#metaclass::ctors#;
$cu=q#ni:/unix/str_init.b#;
$du=q#ni:/unix/str_io.b#;
$eu=q#ni:/unix/str_ro.b#;
$fu=q#ni:main#;
$gu={$na,1};
$hu=[$Lg,$ma];
$iu=bless({$L1,$gu,$D,$na,$n2,$hu},$q2);
$ju=q#module::ctors#;
$ku=q#ni:ni#;
$lu={$Pc,1};
$mu={$Pc,1};
$nu=q#json_escapes#;
$ou=q##;
$pu=q#b#;
$qu=q#	#;
$ru=q#t#;
$su=q#
#;
$tu=q#n#;
$uu=q##;
$vu=q#"#;
$wu=q#/#;
$xu=q#\\#;
$yu={$ou,$pu,$qu,$ru,$su,$tu,$uu,$Po,$vu,$vu,$wu,$wu,$xu,$xu};
$zu=q#json_unescapes#;
$Au={$vu,$vu,$wu,$wu,$xu,$xu,$pu,$ou,$tu,$su,$Po,$uu,$ru,$qu};
$Bu={$nu,$yu,$zu,$Au};
$Cu=q#/lib/json_data.b#;
$Du=bless({$L1,$mu,$et,$Bu,$D,$Cu},$P3);
$Eu=q#lib/dataslice::ctors#;
$Fu=[$Du,$Oc,$Cf];
$Gu=bless({$L1,$lu,$D,$Pc,$n2,$Fu},$q2);
$Hu={$d,$G,$I,$X,$Y,$l1,$m1,$x1,$y1,$J1,$K1,$m6,$o6,$I6,$K6,$e5,$L6,$F4,$M6,$C6,$N6,$Y6,$c7,$I2,$d7,$h7,$j7,$V6,$k7,$L3,$l7,$D7,$F7,$J7,$L7,$A7,$M7,$t7,$N7,$J5,$O7,$Q4,$P7,$F5,$Q7,$B8,$D8,$H8,$J8,$o8,$K8,$X7,$L8,$g8,$M8,$y8,$N8,$B4,$O8,$P9,$R9,$V9,$X9,$d9,$Y9,$D9,$Z9,$s9,$ca,$M9,$da,$ma,$pa,$ec,$gc,$kc,$mc,$ya,$nc,$Zb,$oc,$n4,$pc,$X5,$qc,$Oc,$Rc,$n5,$Sc,$T2,$Tc,$f3,$Uc,$o3,$Vc,$oe,$qe,$ue,$we,$yd,$xe,$Xd,$ye,$le,$ze,$ld,$Ae,$Cf,$Ef,$B3,$Ff,$w5,$Gf,$x3,$Hf,$og,$qg,$Uf,$rg,$vg,$xg,$dg,$yg,$lg,$zg,$Lg,$Ng,$i6,$Og,$ih,$kh,$Wg,$lh,$ph,$rh,$fh,$sh,$ci,$ei,$ji,$li,$Oh,$mi,$Bh,$ni,$Wh,$oi,$si,$ui,$yi,$Ai,$M5,$Bi,$F6,$Ci,$r4,$Di,$x6,$Ei,$dk,$fk,$xk,$zk,$Pj,$Ak,$Yj,$Bk,$lm,$nm,$rm,$tm,$Pl,$um,$im,$vm,$Sk,$wm,$Gl,$xm,$ll,$ym,$Kk,$zm,$Un,$Wn,$co,$eo,$qn,$fo,$Qm,$go,$Rn,$ho,$Im,$io,$Bn,$jo,$Zm,$ko,$ep,$gp,$kp,$mp,$Zo,$np,$Eo,$op,$wo,$pp,$Mo,$qp,$Vp,$Xp,$dq,$fq,$Hp,$gq,$Sp,$hq,$zp,$iq,$En,$jq,$Hj,$kq,$uk,$lq,$rk,$mq,$ij,$nq,$rj,$oq,$Oi,$pq,$Ej,$qq,$Xi,$rq,$Gr,$Ir,$Mr,$Or,$Dr,$Pr,$Pq,$Qr,$pr,$Rr,$Eq,$Sr,$er,$Tr,$Ms,$Os,$Ss,$Us,$ys,$Vs,$ps,$Ws,$Js,$Xs,$hs,$Ys,$St,$Ut,$Yt,$cu,$At,$du,$Pt,$eu,$st,$fu,$iu,$ku,$Gu};
$Iu=q#resolvers#;
$Ju=[];
$Ku=q#my $f = shift;
$f =~ s/^fd:(?:\\/\\/)?//;
ni('ni:/unix/fd')->new($f);#;
$Lu=bless({$o,$Ju,$q,$Ku,$s,$t},$u);
$Mu=q#file#;
$Nu=[];
$Ou=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/unix/file')->new($f);#;
$Pu=bless({$o,$Nu,$q,$Ou,$s,$t},$u);
$Qu=q#sh#;
$Ru=[];
$Su=q#ni('ni:/unix/exec')->new('/bin/sh', '-c', substr shift, 3)->fork;#;
$Tu=bless({$o,$Ru,$q,$Su,$s,$t},$u);
$Uu=q#str#;
$Vu=[];
$Wu=q#my $s = shift;
ni('ni:/unix/str')->new(substr($s, 4) . "\\n");#;
$Xu=bless({$o,$Vu,$q,$Wu,$s,$t},$u);
$Yu={$ol,$Lu,$Mu,$Pu,$Qu,$Tu,$Uu,$Xu};
$Zu=bless({$c,$Hu,$Iu,$Yu},$R3);
$cv=q#lib/ni::ctors#;
*$Pf=\&$Nf;
*$Of=\&$Lf;
$I2->apply_unsafe($M1);
$I2->apply_unsafe($N1);
$I2->apply_unsafe($O1);
$I2->apply_unsafe($J2);
$I2->apply_unsafe($P1);
$I2->apply_unsafe($Q1);
$I2->apply_unsafe($R1);
$I2->apply_unsafe($S1);
$I2->apply_unsafe($T1);
$I2->apply_unsafe($U1);
$I2->apply_unsafe($V1);
$I2->apply_unsafe($W1);
$I2->apply_unsafe($K2);
$I2->apply_unsafe($p2);
$I2->apply_unsafe($Y1);
$I2->apply_unsafe($q2);
$I2->apply_unsafe($Z1);
$I2->apply_unsafe($c2);
$I2->apply_unsafe($d2);
$I2->apply_unsafe($e2);
$I2->apply_unsafe($f2);
$I2->apply_unsafe($g2);
$I2->apply_unsafe($h2);
$I2->apply_unsafe($i2);
$I2->apply_unsafe($j2);
$I2->apply_unsafe($k2);
$I2->apply_unsafe($l2);
$T2->apply_unsafe($M1);
$T2->apply_unsafe($N1);
$T2->apply_unsafe($O1);
$T2->apply_unsafe($J2);
$T2->apply_unsafe($P1);
$T2->apply_unsafe($Q1);
$T2->apply_unsafe($F);
$T2->apply_unsafe($R1);
$T2->apply_unsafe($S1);
$T2->apply_unsafe($T1);
$T2->apply_unsafe($U1);
$T2->apply_unsafe($H2);
$T2->apply_unsafe($V1);
$T2->apply_unsafe($U2);
$T2->apply_unsafe($W1);
$T2->apply_unsafe($V2);
$T2->apply_unsafe($p2);
$T2->apply_unsafe($Y1);
$T2->apply_unsafe($q2);
$T2->apply_unsafe($Z1);
$T2->apply_unsafe($c2);
$T2->apply_unsafe($d2);
$T2->apply_unsafe($e2);
$T2->apply_unsafe($f2);
$T2->apply_unsafe($g2);
$T2->apply_unsafe($h2);
$T2->apply_unsafe($i2);
$T2->apply_unsafe($j2);
$T2->apply_unsafe($k2);
$T2->apply_unsafe($l2);
$f3->apply_unsafe($M1);
$f3->apply_unsafe($N1);
$f3->apply_unsafe($O1);
$f3->apply_unsafe($J2);
$f3->apply_unsafe($P1);
$f3->apply_unsafe($Q1);
$f3->apply_unsafe($R1);
$f3->apply_unsafe($S1);
$f3->apply_unsafe($T1);
$f3->apply_unsafe($U1);
$f3->apply_unsafe($H2);
$f3->apply_unsafe($V1);
$f3->apply_unsafe($U2);
$f3->apply_unsafe($W1);
$f3->apply_unsafe($g3);
$f3->apply_unsafe($p2);
$f3->apply_unsafe($Y1);
$f3->apply_unsafe($q2);
$f3->apply_unsafe($Z1);
$f3->apply_unsafe($c2);
$f3->apply_unsafe($d2);
$f3->apply_unsafe($e2);
$f3->apply_unsafe($f2);
$f3->apply_unsafe($g2);
$f3->apply_unsafe($h2);
$f3->apply_unsafe($i2);
$f3->apply_unsafe($j2);
$f3->apply_unsafe($k2);
$f3->apply_unsafe($l2);
$o3->apply_unsafe($M1);
$o3->apply_unsafe($N1);
$o3->apply_unsafe($O1);
$o3->apply_unsafe($J2);
$o3->apply_unsafe($P1);
$o3->apply_unsafe($Q1);
$o3->apply_unsafe($R1);
$o3->apply_unsafe($S1);
$o3->apply_unsafe($T1);
$o3->apply_unsafe($U1);
$o3->apply_unsafe($H2);
$o3->apply_unsafe($V1);
$o3->apply_unsafe($U2);
$o3->apply_unsafe($W1);
$o3->apply_unsafe($p3);
$o3->apply_unsafe($p2);
$o3->apply_unsafe($Y1);
$o3->apply_unsafe($q2);
$o3->apply_unsafe($Z1);
$o3->apply_unsafe($c2);
$o3->apply_unsafe($d2);
$o3->apply_unsafe($e2);
$o3->apply_unsafe($f2);
$o3->apply_unsafe($g2);
$o3->apply_unsafe($h2);
$o3->apply_unsafe($i2);
$o3->apply_unsafe($j2);
$o3->apply_unsafe($k2);
$o3->apply_unsafe($l2);
$x3->apply_unsafe($M1);
$x3->apply_unsafe($N1);
$x3->apply_unsafe($O1);
$x3->apply_unsafe($J2);
$x3->apply_unsafe($P1);
$x3->apply_unsafe($Q1);
$x3->apply_unsafe($R1);
$x3->apply_unsafe($S1);
$x3->apply_unsafe($T1);
$x3->apply_unsafe($U1);
$x3->apply_unsafe($V1);
$x3->apply_unsafe($U2);
$x3->apply_unsafe($W1);
$x3->apply_unsafe($y3);
$x3->apply_unsafe($p2);
$x3->apply_unsafe($Y1);
$x3->apply_unsafe($q2);
$x3->apply_unsafe($Z1);
$x3->apply_unsafe($c2);
$x3->apply_unsafe($d2);
$x3->apply_unsafe($e2);
$x3->apply_unsafe($f2);
$x3->apply_unsafe($g2);
$x3->apply_unsafe($h2);
$x3->apply_unsafe($i2);
$x3->apply_unsafe($j2);
$x3->apply_unsafe($k2);
$x3->apply_unsafe($l2);
$L3->apply_unsafe($M1);
$L3->apply_unsafe($N1);
$L3->apply_unsafe($O1);
$L3->apply_unsafe($P1);
$L3->apply_unsafe($Q1);
$L3->apply_unsafe($R1);
$L3->apply_unsafe($S1);
$L3->apply_unsafe($T1);
$L3->apply_unsafe($U1);
$L3->apply_unsafe($V1);
$L3->apply_unsafe($W1);
$L3->apply_unsafe($M3);
$L3->apply_unsafe($p2);
$L3->apply_unsafe($Y1);
$L3->apply_unsafe($q2);
$L3->apply_unsafe($Z1);
$L3->apply_unsafe($c2);
$L3->apply_unsafe($d2);
$L3->apply_unsafe($e2);
$L3->apply_unsafe($f2);
$L3->apply_unsafe($g2);
$L3->apply_unsafe($h2);
$L3->apply_unsafe($i2);
$L3->apply_unsafe($j2);
$L3->apply_unsafe($k2);
$L3->apply_unsafe($l2);
$n4->apply_unsafe($M1);
$n4->apply_unsafe($N1);
$n4->apply_unsafe($O3);
$n4->apply_unsafe($O1);
$n4->apply_unsafe($J2);
$n4->apply_unsafe($P1);
$n4->apply_unsafe($P3);
$n4->apply_unsafe($Q1);
$n4->apply_unsafe($F);
$n4->apply_unsafe($R1);
$n4->apply_unsafe($u);
$n4->apply_unsafe($S1);
$n4->apply_unsafe($Q3);
$n4->apply_unsafe($T1);
$n4->apply_unsafe($R3);
$n4->apply_unsafe($U1);
$n4->apply_unsafe($H2);
$n4->apply_unsafe($V1);
$n4->apply_unsafe($U2);
$n4->apply_unsafe($W1);
$n4->apply_unsafe($S3);
$n4->apply_unsafe($o4);
$n4->apply_unsafe($p2);
$n4->apply_unsafe($Y1);
$n4->apply_unsafe($q2);
$n4->apply_unsafe($Z1);
$n4->apply_unsafe($U3);
$n4->apply_unsafe($c2);
$n4->apply_unsafe($V3);
$n4->apply_unsafe($d2);
$n4->apply_unsafe($W3);
$n4->apply_unsafe($e2);
$n4->apply_unsafe($X3);
$n4->apply_unsafe($f2);
$n4->apply_unsafe($Y3);
$n4->apply_unsafe($g2);
$n4->apply_unsafe($Z3);
$n4->apply_unsafe($h2);
$n4->apply_unsafe($c4);
$n4->apply_unsafe($i2);
$n4->apply_unsafe($d4);
$n4->apply_unsafe($j2);
$n4->apply_unsafe($e4);
$n4->apply_unsafe($k2);
$n4->apply_unsafe($f4);
$n4->apply_unsafe($l2);
$B4->apply_unsafe($M1);
$B4->apply_unsafe($N1);
$B4->apply_unsafe($O3);
$B4->apply_unsafe($O1);
$B4->apply_unsafe($J2);
$B4->apply_unsafe($P1);
$B4->apply_unsafe($P3);
$B4->apply_unsafe($Q1);
$B4->apply_unsafe($R1);
$B4->apply_unsafe($S1);
$B4->apply_unsafe($T1);
$B4->apply_unsafe($U1);
$B4->apply_unsafe($H2);
$B4->apply_unsafe($V1);
$B4->apply_unsafe($U2);
$B4->apply_unsafe($W1);
$B4->apply_unsafe($C4);
$B4->apply_unsafe($p2);
$B4->apply_unsafe($Y1);
$B4->apply_unsafe($q2);
$B4->apply_unsafe($Z1);
$B4->apply_unsafe($c2);
$B4->apply_unsafe($d2);
$B4->apply_unsafe($e2);
$B4->apply_unsafe($f2);
$B4->apply_unsafe($g2);
$B4->apply_unsafe($h2);
$B4->apply_unsafe($i2);
$B4->apply_unsafe($j2);
$B4->apply_unsafe($k2);
$B4->apply_unsafe($l2);
$Q4->apply_unsafe($M1);
$Q4->apply_unsafe($N1);
$Q4->apply_unsafe($O1);
$Q4->apply_unsafe($J2);
$Q4->apply_unsafe($P1);
$Q4->apply_unsafe($Q1);
$Q4->apply_unsafe($R1);
$Q4->apply_unsafe($S1);
$Q4->apply_unsafe($T1);
$Q4->apply_unsafe($U1);
$Q4->apply_unsafe($V1);
$Q4->apply_unsafe($W1);
$Q4->apply_unsafe($R4);
$Q4->apply_unsafe($p2);
$Q4->apply_unsafe($Y1);
$Q4->apply_unsafe($q2);
$Q4->apply_unsafe($Z1);
$Q4->apply_unsafe($c2);
$Q4->apply_unsafe($d2);
$Q4->apply_unsafe($e2);
$Q4->apply_unsafe($f2);
$Q4->apply_unsafe($g2);
$Q4->apply_unsafe($h2);
$Q4->apply_unsafe($i2);
$Q4->apply_unsafe($j2);
$Q4->apply_unsafe($k2);
$Q4->apply_unsafe($l2);
$e5->apply_unsafe($M1);
$e5->apply_unsafe($N1);
$e5->apply_unsafe($O1);
$e5->apply_unsafe($J2);
$e5->apply_unsafe($P1);
$e5->apply_unsafe($Q1);
$e5->apply_unsafe($R1);
$e5->apply_unsafe($S1);
$e5->apply_unsafe($T1);
$e5->apply_unsafe($U1);
$e5->apply_unsafe($V1);
$e5->apply_unsafe($W1);
$e5->apply_unsafe($f5);
$e5->apply_unsafe($p2);
$e5->apply_unsafe($Y1);
$e5->apply_unsafe($q2);
$e5->apply_unsafe($Z1);
$e5->apply_unsafe($c2);
$e5->apply_unsafe($d2);
$e5->apply_unsafe($e2);
$e5->apply_unsafe($f2);
$e5->apply_unsafe($g2);
$e5->apply_unsafe($h2);
$e5->apply_unsafe($i2);
$e5->apply_unsafe($j2);
$e5->apply_unsafe($k2);
$e5->apply_unsafe($l2);
$n5->apply_unsafe($M1);
$n5->apply_unsafe($N1);
$n5->apply_unsafe($O1);
$n5->apply_unsafe($J2);
$n5->apply_unsafe($P1);
$n5->apply_unsafe($Q1);
$n5->apply_unsafe($R1);
$n5->apply_unsafe($S1);
$n5->apply_unsafe($T1);
$n5->apply_unsafe($U1);
$n5->apply_unsafe($V1);
$n5->apply_unsafe($W1);
$n5->apply_unsafe($o5);
$n5->apply_unsafe($p2);
$n5->apply_unsafe($Y1);
$n5->apply_unsafe($q2);
$n5->apply_unsafe($Z1);
$n5->apply_unsafe($c2);
$n5->apply_unsafe($d2);
$n5->apply_unsafe($e2);
$n5->apply_unsafe($f2);
$n5->apply_unsafe($g2);
$n5->apply_unsafe($h2);
$n5->apply_unsafe($i2);
$n5->apply_unsafe($j2);
$n5->apply_unsafe($k2);
$n5->apply_unsafe($l2);
$w5->apply_unsafe($M1);
$w5->apply_unsafe($N1);
$w5->apply_unsafe($O1);
$w5->apply_unsafe($J2);
$w5->apply_unsafe($P1);
$w5->apply_unsafe($Q1);
$w5->apply_unsafe($R1);
$w5->apply_unsafe($S1);
$w5->apply_unsafe($T1);
$w5->apply_unsafe($U1);
$w5->apply_unsafe($V1);
$w5->apply_unsafe($W1);
$w5->apply_unsafe($x5);
$w5->apply_unsafe($p2);
$w5->apply_unsafe($Y1);
$w5->apply_unsafe($q2);
$w5->apply_unsafe($Z1);
$w5->apply_unsafe($c2);
$w5->apply_unsafe($d2);
$w5->apply_unsafe($e2);
$w5->apply_unsafe($f2);
$w5->apply_unsafe($g2);
$w5->apply_unsafe($h2);
$w5->apply_unsafe($i2);
$w5->apply_unsafe($j2);
$w5->apply_unsafe($k2);
$w5->apply_unsafe($l2);
$F5->apply_unsafe($M1);
$F5->apply_unsafe($N1);
$F5->apply_unsafe($O1);
$F5->apply_unsafe($J2);
$F5->apply_unsafe($P1);
$F5->apply_unsafe($Q1);
$F5->apply_unsafe($R1);
$F5->apply_unsafe($S1);
$F5->apply_unsafe($T1);
$F5->apply_unsafe($U1);
$F5->apply_unsafe($V1);
$F5->apply_unsafe($W1);
$F5->apply_unsafe($G5);
$F5->apply_unsafe($p2);
$F5->apply_unsafe($Y1);
$F5->apply_unsafe($q2);
$F5->apply_unsafe($Z1);
$F5->apply_unsafe($c2);
$F5->apply_unsafe($d2);
$F5->apply_unsafe($e2);
$F5->apply_unsafe($f2);
$F5->apply_unsafe($g2);
$F5->apply_unsafe($h2);
$F5->apply_unsafe($i2);
$F5->apply_unsafe($j2);
$F5->apply_unsafe($k2);
$F5->apply_unsafe($l2);
$X5->apply_unsafe($M1);
$X5->apply_unsafe($N1);
$X5->apply_unsafe($O1);
$X5->apply_unsafe($P1);
$X5->apply_unsafe($Q1);
$X5->apply_unsafe($R1);
$X5->apply_unsafe($u);
$X5->apply_unsafe($S1);
$X5->apply_unsafe($T1);
$X5->apply_unsafe($U1);
$X5->apply_unsafe($H2);
$X5->apply_unsafe($V1);
$X5->apply_unsafe($U2);
$X5->apply_unsafe($W1);
$X5->apply_unsafe($Y5);
$X5->apply_unsafe($p2);
$X5->apply_unsafe($Y1);
$X5->apply_unsafe($Z1);
$X5->apply_unsafe($c2);
$X5->apply_unsafe($d2);
$X5->apply_unsafe($e2);
$X5->apply_unsafe($f2);
$X5->apply_unsafe($g2);
$X5->apply_unsafe($h2);
$X5->apply_unsafe($i2);
$X5->apply_unsafe($j2);
$X5->apply_unsafe($k2);
$X5->apply_unsafe($l2);
$i6->apply_unsafe($M1);
$i6->apply_unsafe($N1);
$i6->apply_unsafe($O1);
$i6->apply_unsafe($P1);
$i6->apply_unsafe($Q1);
$i6->apply_unsafe($R1);
$i6->apply_unsafe($S1);
$i6->apply_unsafe($T1);
$i6->apply_unsafe($U1);
$i6->apply_unsafe($V1);
$i6->apply_unsafe($W1);
$i6->apply_unsafe($j6);
$i6->apply_unsafe($Y1);
$i6->apply_unsafe($Z1);
$i6->apply_unsafe($c2);
$i6->apply_unsafe($d2);
$i6->apply_unsafe($e2);
$i6->apply_unsafe($f2);
$i6->apply_unsafe($g2);
$i6->apply_unsafe($h2);
$i6->apply_unsafe($i2);
$i6->apply_unsafe($j2);
$i6->apply_unsafe($k2);
$i6->apply_unsafe($l2);
$V6->apply_unsafe($J2);
$t7->apply_unsafe($P3);
$A7->apply_unsafe($P3);
$X7->apply_unsafe($F);
$g8->apply_unsafe($F);
$o8->apply_unsafe($F);
$y8->apply_unsafe($F);
$d9->apply_unsafe($u);
$s9->apply_unsafe($u);
$D9->apply_unsafe($u);
$M9->apply_unsafe($u);
$ma->apply_unsafe($na);
$ya->apply_unsafe($Q3);
$Zb->apply_unsafe($Q3);
$Oc->apply_unsafe($Pc);
$ld->apply_unsafe($R3);
$yd->apply_unsafe($R3);
$Xd->apply_unsafe($R3);
$le->apply_unsafe($R3);
$Cf->apply_unsafe($Pc);
$Uf->apply_unsafe($H2);
$dg->apply_unsafe($H2);
$lg->apply_unsafe($H2);
$Lg->apply_unsafe($na);
$Wg->apply_unsafe($U2);
$fh->apply_unsafe($U2);
$Bh->apply_unsafe($S3);
$Oh->apply_unsafe($S3);
$Wh->apply_unsafe($S3);
$Oi->apply_unsafe($V3);
$Oi->apply_unsafe($X3);
$Oi->apply_unsafe($Y3);
$Oi->apply_unsafe($Z3);
$Oi->apply_unsafe($c4);
$Oi->apply_unsafe($d4);
$Oi->apply_unsafe($e4);
$Oi->apply_unsafe($f4);
$Xi->apply_unsafe($V3);
$Xi->apply_unsafe($X3);
$Xi->apply_unsafe($Y3);
$Xi->apply_unsafe($Z3);
$Xi->apply_unsafe($c4);
$Xi->apply_unsafe($d4);
$Xi->apply_unsafe($e4);
$Xi->apply_unsafe($f4);
$ij->apply_unsafe($V3);
$ij->apply_unsafe($X3);
$ij->apply_unsafe($Y3);
$ij->apply_unsafe($Z3);
$ij->apply_unsafe($c4);
$ij->apply_unsafe($d4);
$ij->apply_unsafe($e4);
$ij->apply_unsafe($f4);
$rj->apply_unsafe($V3);
$rj->apply_unsafe($X3);
$rj->apply_unsafe($Y3);
$rj->apply_unsafe($Z3);
$rj->apply_unsafe($c4);
$rj->apply_unsafe($d4);
$rj->apply_unsafe($e4);
$rj->apply_unsafe($f4);
$Ej->apply_unsafe($V3);
$Ej->apply_unsafe($X3);
$Ej->apply_unsafe($Y3);
$Ej->apply_unsafe($Z3);
$Ej->apply_unsafe($c4);
$Ej->apply_unsafe($d4);
$Ej->apply_unsafe($e4);
$Ej->apply_unsafe($f4);
$Pj->apply_unsafe($V3);
$Yj->apply_unsafe($V3);
$rk->apply_unsafe($d2);
$rk->apply_unsafe($f2);
$rk->apply_unsafe($g2);
$rk->apply_unsafe($h2);
$rk->apply_unsafe($i2);
$rk->apply_unsafe($j2);
$rk->apply_unsafe($k2);
$rk->apply_unsafe($l2);
$Kk->apply_unsafe($W3);
$Sk->apply_unsafe($W3);
$ll->apply_unsafe($W3);
$Gl->apply_unsafe($W3);
$Pl->apply_unsafe($W3);
$im->apply_unsafe($W3);
$Im->apply_unsafe($X3);
$Qm->apply_unsafe($X3);
$Zm->apply_unsafe($X3);
$qn->apply_unsafe($X3);
$qn->apply_unsafe($Y3);
$qn->apply_unsafe($Z3);
$qn->apply_unsafe($d4);
$qn->apply_unsafe($e4);
$Bn->apply_unsafe($X3);
$Bn->apply_unsafe($Y3);
$Bn->apply_unsafe($Z3);
$Bn->apply_unsafe($d4);
$Bn->apply_unsafe($e4);
$Rn->apply_unsafe($X3);
$wo->apply_unsafe($Y3);
$Eo->apply_unsafe($Y3);
$Mo->apply_unsafe($Y3);
$Zo->apply_unsafe($Y3);
$zp->apply_unsafe($Z3);
$Hp->apply_unsafe($Z3);
$Sp->apply_unsafe($Z3);
$Eq->apply_unsafe($d4);
$Pq->apply_unsafe($d4);
$er->apply_unsafe($d4);
$pr->apply_unsafe($d4);
$Dr->apply_unsafe($d4);
$hs->apply_unsafe($e4);
$ps->apply_unsafe($e4);
$ys->apply_unsafe($e4);
$Js->apply_unsafe($e4);
$st->apply_unsafe($f4);
$At->apply_unsafe($f4);
$Pt->apply_unsafe($f4);
$ni::self=$Zu;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($P)for@$w;
&$_($T)for@$w;
&$_($X)for@$H;
&$_($h1)for@$w;
&$_($l1)for@$H;
&$_($t1)for@$w;
&$_($x1)for@$H;
&$_($B1)for@$w;
&$_($F1)for@$w;
&$_($J1)for@$H;
&$_($B2)for@$w;
&$_($E2)for@$w;
&$_($I2)for@$L2;
&$_($O2)for@$w;
&$_($Q2)for@$w;
&$_($T2)for@$W2;
&$_($c3)for@$w;
&$_($f3)for@$h3;
&$_($l3)for@$w;
&$_($o3)for@$q3;
&$_($u3)for@$w;
&$_($x3)for@$z3;
&$_($B3)for@$C3;
&$_($F3)for@$w;
&$_($I3)for@$w;
&$_($L3)for@$N3;
&$_($k4)for@$w;
&$_($n4)for@$p4;
&$_($r4)for@$s4;
&$_($y4)for@$w;
&$_($B4)for@$D4;
&$_($F4)for@$G4;
&$_($N4)for@$w;
&$_($Q4)for@$S4;
&$_($W4)for@$w;
&$_($Z4)for@$w;
&$_($e5)for@$g5;
&$_($k5)for@$w;
&$_($n5)for@$p5;
&$_($t5)for@$w;
&$_($w5)for@$y5;
&$_($C5)for@$w;
&$_($F5)for@$H5;
&$_($J5)for@$K5;
&$_($M5)for@$N5;
&$_($R5)for@$w;
&$_($U5)for@$w;
&$_($X5)for@$Z5;
&$_($f6)for@$w;
&$_($i6)for@$k6;
&$_($m6)for@$n6;
&$_($x6)for@$y6;
&$_($C6)for@$D6;
&$_($F6)for@$G6;
&$_($I6)for@$J6;
&$_($S6)for@$w;
&$_($V6)for@$W6;
&$_($Y6)for@$Z6;
&$_($h7)for@$i7;
&$_($q7)for@$w;
&$_($t7)for@$u7;
&$_($x7)for@$w;
&$_($A7)for@$B7;
&$_($D7)for@$E7;
&$_($J7)for@$K7;
&$_($U7)for@$w;
&$_($X7)for@$Y7;
&$_($d8)for@$w;
&$_($g8)for@$h8;
&$_($l8)for@$w;
&$_($o8)for@$p8;
&$_($s8)for@$w;
&$_($v8)for@$w;
&$_($y8)for@$z8;
&$_($B8)for@$C8;
&$_($H8)for@$I8;
&$_($T8)for@$w;
&$_($W8)for@$w;
&$_($Y8)for@$w;
&$_($d9)for@$e9;
&$_($i9)for@$w;
&$_($l9)for@$w;
&$_($p9)for@$w;
&$_($s9)for@$t9;
&$_($x9)for@$w;
&$_($A9)for@$w;
&$_($D9)for@$E9;
&$_($J9)for@$w;
&$_($M9)for@$N9;
&$_($P9)for@$Q9;
&$_($V9)for@$W9;
&$_($ja)for@$w;
&$_($ma)for@$oa;
&$_($va)for@$w;
&$_($ya)for@$za;
&$_($Ea)for@$w;
&$_($Ia)for@$w;
&$_($Ma)for@$w;
&$_($Qa)for@$w;
&$_($Ua)for@$w;
&$_($Ya)for@$w;
&$_($eb)for@$w;
&$_($ib)for@$w;
&$_($mb)for@$w;
&$_($qb)for@$w;
&$_($ub)for@$w;
&$_($yb)for@$w;
&$_($Cb)for@$w;
&$_($Gb)for@$w;
&$_($Kb)for@$w;
&$_($Ob)for@$w;
&$_($Sb)for@$w;
&$_($Wb)for@$w;
&$_($Zb)for@$cc;
&$_($ec)for@$fc;
&$_($kc)for@$lc;
&$_($vc)for@$w;
&$_($zc)for@$w;
&$_($Dc)for@$w;
&$_($Hc)for@$w;
&$_($Lc)for@$w;
&$_($Oc)for@$Qc;
&$_($ed)for@$w;
&$_($id)for@$w;
&$_($ld)for@$md;
&$_($rd)for@$w;
&$_($vd)for@$w;
&$_($yd)for@$zd;
&$_($Ed)for@$w;
&$_($Id)for@$w;
&$_($Md)for@$w;
&$_($Qd)for@$w;
&$_($Ud)for@$w;
&$_($Xd)for@$Yd;
&$_($ee)for@$w;
&$_($ie)for@$w;
&$_($le)for@$me;
&$_($oe)for@$pe;
&$_($ue)for@$ve;
&$_($Fe)for@$w;
&$_($Je)for@$w;
&$_($Ne)for@$w;
&$_($Re)for@$w;
&$_($Ve)for@$w;
&$_($Ze)for@$w;
&$_($ff)for@$w;
&$_($jf)for@$w;
&$_($nf)for@$w;
&$_($rf)for@$w;
&$_($vf)for@$w;
&$_($zf)for@$w;
&$_($Cf)for@$Df;
&$_($Lf)for@$w;
&$_($Nf)for@$w;
&$_($Uf)for@$Vf;
&$_($Yf)for@$w;
&$_($dg)for@$eg;
&$_($ig)for@$w;
&$_($lg)for@$mg;
&$_($og)for@$pg;
&$_($vg)for@$wg;
&$_($Dg)for@$w;
&$_($Ig)for@$w;
&$_($Lg)for@$Mg;
&$_($Tg)for@$w;
&$_($Wg)for@$Xg;
&$_($ch)for@$w;
&$_($fh)for@$gh;
&$_($ih)for@$jh;
&$_($ph)for@$qh;
&$_($yh)for@$w;
&$_($Bh)for@$Ch;
&$_($Hh)for@$w;
&$_($Lh)for@$w;
&$_($Oh)for@$Ph;
&$_($Th)for@$w;
&$_($Wh)for@$Xh;
&$_($ci)for@$di;
&$_($ji)for@$ki;
&$_($si)for@$ti;
&$_($yi)for@$zi;
&$_($Li)for@$w;
&$_($Oi)for@$Pi;
&$_($Ui)for@$w;
&$_($Xi)for@$Yi;
&$_($fj)for@$w;
&$_($ij)for@$jj;
&$_($oj)for@$w;
&$_($rj)for@$sj;
&$_($xj)for@$w;
&$_($Bj)for@$w;
&$_($Ej)for@$Fj;
&$_($Hj)for@$Ij;
&$_($Mj)for@$w;
&$_($Pj)for@$Qj;
&$_($Vj)for@$w;
&$_($Yj)for@$Zj;
&$_($dk)for@$ek;
&$_($ok)for@$w;
&$_($rk)for@$sk;
&$_($uk)for@$vk;
&$_($xk)for@$yk;
&$_($Hk)for@$w;
&$_($Kk)for@$Lk;
&$_($Pk)for@$w;
&$_($Sk)for@$Tk;
&$_($Yk)for@$w;
&$_($el)for@$w;
&$_($il)for@$w;
&$_($ll)for@$ml;
&$_($rl)for@$w;
&$_($vl)for@$w;
&$_($zl)for@$w;
&$_($Dl)for@$w;
&$_($Gl)for@$Hl;
&$_($Ml)for@$w;
&$_($Pl)for@$Ql;
&$_($Vl)for@$w;
&$_($Zl)for@$w;
&$_($fm)for@$w;
&$_($im)for@$jm;
&$_($lm)for@$mm;
&$_($rm)for@$sm;
&$_($Fm)for@$w;
&$_($Im)for@$Jm;
&$_($Nm)for@$w;
&$_($Qm)for@$Rm;
&$_($Wm)for@$w;
&$_($Zm)for@$cn;
&$_($jn)for@$w;
&$_($nn)for@$w;
&$_($qn)for@$rn;
&$_($vn)for@$w;
&$_($yn)for@$w;
&$_($Bn)for@$Cn;
&$_($En)for@$Fn;
&$_($Kn)for@$w;
&$_($On)for@$w;
&$_($Rn)for@$Sn;
&$_($Un)for@$Vn;
&$_($co)for@$do;
&$_($qo)for@$w;
&$_($to)for@$w;
&$_($wo)for@$xo;
&$_($Bo)for@$w;
&$_($Eo)for@$Fo;
&$_($Jo)for@$w;
&$_($Mo)for@$No;
&$_($So)for@$w;
&$_($Wo)for@$w;
&$_($Zo)for@$cp;
&$_($ep)for@$fp;
&$_($kp)for@$lp;
&$_($wp)for@$w;
&$_($zp)for@$Ap;
&$_($Ep)for@$w;
&$_($Hp)for@$Ip;
&$_($Mp)for@$w;
&$_($Pp)for@$w;
&$_($Sp)for@$Tp;
&$_($Vp)for@$Wp;
&$_($dq)for@$eq;
&$_($xq)for@$w;
&$_($Bq)for@$w;
&$_($Eq)for@$Fq;
&$_($Jq)for@$w;
&$_($Mq)for@$w;
&$_($Pq)for@$Qq;
&$_($Vq)for@$w;
&$_($Zq)for@$w;
&$_($er)for@$fr;
&$_($jr)for@$w;
&$_($mr)for@$w;
&$_($pr)for@$qr;
&$_($ur)for@$w;
&$_($wr)for@$w;
&$_($yr)for@$w;
&$_($Ar)for@$w;
&$_($Dr)for@$Er;
&$_($Gr)for@$Hr;
&$_($Mr)for@$Nr;
&$_($Zr)for@$w;
&$_($es)for@$w;
&$_($hs)for@$is;
&$_($ms)for@$w;
&$_($ps)for@$qs;
&$_($vs)for@$w;
&$_($ys)for@$zs;
&$_($Ds)for@$w;
&$_($Gs)for@$w;
&$_($Js)for@$Ks;
&$_($Ms)for@$Ns;
&$_($Ss)for@$Ts;
&$_($ht)for@$w;
&$_($lt)for@$w;
&$_($pt)for@$w;
&$_($st)for@$tt;
&$_($xt)for@$w;
&$_($At)for@$Bt;
&$_($Ft)for@$w;
&$_($Jt)for@$w;
&$_($Mt)for@$w;
&$_($Pt)for@$Qt;
&$_($St)for@$Tt;
&$_($Yt)for@$Zt;
&$_($iu)for@$ju;
&$_($Du)for@$Eu;
&$_($Gu)for@$ju;
&$_($Lu)for@$w;
&$_($Pu)for@$w;
&$_($Tu)for@$w;
&$_($Xu)for@$w;
&$_($Zu)for@$cv;
ni->run(@ARGV);
__DATA__
