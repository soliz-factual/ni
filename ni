#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use POSIX;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/lib/doc#;
$J=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$K=[$f,$J];
$L=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$M=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$N=[];
$O=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$P=bless({$o,$N,$q,$O,$s,$t},$u);
$Q=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$R=[];
$S=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$T=bless({$o,$R,$q,$S,$s,$t},$u);
$U=[$i,$L,$M,$n,$P,$Q,$n,$T];
$V=[$K,$U];
$W=q#/lib/doc#;
$X=bless({$e,$V,$D,$W},$F);
$Y=q#ni.doc:/unix#;
$Z=q#Abstractions around UNIX stuff like file descriptors and child processes.
      We bypass as much Perl machinery as possible to keep things simple,
      particularly in terms of IO: FDs are just numbers so we don't have to
      contend with Perl close-on-deallocation issues or buffering.#;
$c1=[$i,$Z];
$d1=[$c1];
$e1=q#/unix#;
$f1=bless({$e,$d1,$D,$e1},$F);
$g1=q#ni.doc:/unix/cat#;
$h1=q#
    my $combined = ni('ni:/unix/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  #;
$i1=[$f,$h1];
$j1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$k1=[$i,$j1];
$l1=[];
$m1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$n1=bless({$o,$l1,$q,$m1,$s,$t},$u);
$o1=[$n,$n1];
$p1=[$i1,$k1,$o1];
$q1=q#/unix/cat#;
$r1=bless({$e,$p1,$D,$q1},$F);
$s1=q#ni.doc:/unix/exec#;
$t1=q#
    my $pid = ni("ni:/unix/exec")->new("ls", "-l")
      ->fds(1 => ni"file:foo")
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$u1=[$f,$t1];
$v1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up FIFO connections to stdin/out if you use it
      this way.#;
$w1=[$i,$v1];
$x1=[];
$y1=q#my $e   = ni('ni:/unix/exec')->new('sh', '-c', 'echo hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$z1=bless({$o,$x1,$q,$y1,$s,$t},$u);
$A1=[$n,$z1];
$B1=[$u1,$w1,$A1];
$C1=q#/unix/exec#;
$D1=bless({$e,$B1,$D,$C1},$F);
$E1=q#ni.doc:/unix/pid#;
$F1=[];
$G1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$H1=bless({$o,$F1,$q,$G1,$s,$t},$u);
$I1=[$n,$H1];
$J1=[];
$K1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$L1=bless({$o,$J1,$q,$K1,$s,$t},$u);
$M1=[$n,$L1];
$N1=[];
$O1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/unix/exec')->new('egrep', '[13579]$')
  ->fds(0 => $seq->stdout)
  ->fork;
now $grep->read_all == "1\\n3\\n5\\n7\\n9\\n";
now $seq->await == 0;
now $grep->await == 0;#;
$P1=bless({$o,$N1,$q,$O1,$s,$t},$u);
$Q1=[$n,$P1];
$R1=[$I1,$M1,$Q1];
$S1=q#/unix/pid#;
$T1=bless({$e,$R1,$D,$S1},$F);
$U1=q#ni:/class#;
$V1=q#applied_to#;
$W1=q#class#;
$X1=q#class.c#;
$Y1=q#lib/behavior.c#;
$Z1=q#lib/branch.c#;
$c2=q#lib/dataslice.c#;
$d2=q#lib/doc.c#;
$e2=q#lib/fn.c#;
$f2=q#lib/image.c#;
$g2=q#lib/ni.c#;
$h2=q#lib/slice.c#;
$i2=q#lib/tag.c#;
$j2=q#lib/test_value.c#;
$k2=q#metaclass.c#;
$l2=q#module.c#;
$m2=q#object.c#;
$n2=q#unix/cat.c#;
$o2=q#unix/exec.c#;
$p2=q#unix/fd.c#;
$q2=q#unix/fifo.c#;
$r2=q#unix/file.c#;
$s2=q#unix/io.c#;
$t2=q#unix/pid.c#;
$u2=q#unix/pipeline.c#;
$v2=q#unix/str.c#;
$w2={$W1,1,$X1,1,$Y1,1,$Z1,1,$c2,1,$d2,1,$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1};
$x2=q#slices#;
$y2=q#lib/test_value.c#;
$z2=q#metaclass#;
$A2=q#module#;
$B2={$W1,1,$X1,1,$Y1,1,$Z1,1,$c2,1,$d2,1,$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$y2,1,$z2,1,$k2,1,$A2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1};
$C2=q#/module#;
$D2=q#/lib/perlbranch.b#;
$E2={};
$F2=q#ctor#;
$G2=undef;
$H2=q#dtor#;
$I2=q#methods#;
$J2=q#add#;
$K2=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$L2=bless({$q,$K2,$s,$t},$u);
$M2=q#apply#;
$N2=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$O2=bless({$q,$N2,$s,$t},$u);
$P2={$J2,$L2,$M2,$O2};
$Q2=q#/lib/branch.b#;
$R2=q#lib/slice#;
$S2=bless({$V1,$E2,$F2,$G2,$H2,$G2,$I2,$P2,$D,$Q2},$R2);
$T2=q#lib/branch#;
$U2=q#lib/test_value.c#;
$V2=q#lib/slice::ctors#;
$W2={};
$X2=q#my $s = shift; ni->def($s->name, $s)#;
$Y2=bless({$q,$X2,$s,$t},$u);
$Z2=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$c3=bless({$q,$Z2,$s,$t},$u);
$d3={$D,$c3};
$e3=q#/lib/named.b#;
$f3=bless({$V1,$W2,$F2,$Y2,$H2,$G2,$I2,$d3,$D,$e3},$R2);
$g3=q#lib/tag#;
$h3=q#lib/test_value.c#;
$i3=q#lib/slice::ctors#;
$j3={};
$k3=q#namespace#;
$l3=q#'ni'#;
$m3=bless({$q,$l3,$s,$t},$u);
$n3={$k3,$m3};
$o3=q#/lib/named_in_ni.b#;
$p3=bless({$V1,$j3,$F2,$G2,$H2,$G2,$I2,$n3,$D,$o3},$R2);
$q3=q#lib/test_value.c#;
$r3=q#lib/slice::ctors#;
$s3={};
$t3=q#package#;
$u3=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$v3=bless({$q,$u3,$s,$t},$u);
$w3={$t3,$v3};
$x3=q#/lib/namespaced.b#;
$y3=bless({$V1,$s3,$F2,$G2,$H2,$G2,$I2,$w3,$D,$x3},$R2);
$z3=q#lib/test_value.c#;
$A3=q#lib/slice::ctors#;
$B3={};
$C3=q#resolve#;
$D3=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$E3=bless({$q,$D3,$s,$t},$u);
$F3={$C3,$E3};
$G3=q#/lib/resolver.b#;
$H3=bless({$V1,$B3,$F2,$G2,$H2,$G2,$I2,$F3,$D,$G3},$R2);
$I3=q#lib/test_value.c#;
$J3=q#lib/slice::ctors#;
$K3=[$S2,$f3,$p3,$y3,$H3];
$L3=bless({$D,$D2,$x2,$K3},$g3);
$M3=q#lib/tag::ctors#;
$N3={};
$O3=q#my $s = shift; $s->apply($s->package)#;
$P3=bless({$q,$O3,$s,$t},$u);
$Q3=q#instantiate#;
$R3=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$S3=bless({$q,$R3,$s,$t},$u);
$T3={$Q3,$S3};
$U3=q#/lib/class_init.b#;
$V3=bless({$V1,$N3,$F2,$P3,$H2,$G2,$I2,$T3,$D,$U3},$R2);
$W3=q#lib/test_value.c#;
$X3=q#lib/slice::ctors#;
$Y3=q#lib/behavior#;
$Z3=q#lib/dataslice#;
$c4=q#lib/image#;
$d4=q#lib/ni#;
$e4=q#lib/test_value#;
$f4=q#lib/test_value.c#;
$g4=q#object#;
$h4=q#unix/cat#;
$i4=q#unix/exec#;
$j4=q#unix/fd#;
$k4=q#unix/fifo#;
$l4=q#unix/file#;
$m4=q#unix/io#;
$n4=q#unix/pid#;
$o4=q#unix/pipeline#;
$p4=q#unix/str#;
$q4={$W1,1,$X1,1,$Y3,1,$Y1,1,$T2,1,$Z1,1,$Z3,1,$c2,1,$F,1,$d2,1,$u,1,$e2,1,$c4,1,$f2,1,$d4,1,$g2,1,$R2,1,$h2,1,$g3,1,$i2,1,$e4,1,$f4,1,$z2,1,$k2,1,$A2,1,$l2,1,$g4,1,$m2,1,$h4,1,$n2,1,$i4,1,$o2,1,$j4,1,$p2,1,$k4,1,$q2,1,$l4,1,$r2,1,$m4,1,$s2,1,$n4,1,$t2,1,$o4,1,$u2,1,$p4,1,$v2,1};
$r4=q#/object#;
$s4={};
$t4=q#ni 'ni:/' . ref shift#;
$u4=bless({$q,$t4,$s,$t},$u);
$v4={$W1,$u4};
$w4=q#/lib/instance.b#;
$x4=bless({$V1,$s4,$F2,$G2,$H2,$G2,$I2,$v4,$D,$w4},$R2);
$y4=q#lib/test_value.c#;
$z4=q#lib/slice::ctors#;
$A4=[$x4];
$B4=bless({$V1,$q4,$D,$r4,$x2,$A4},$m2);
$C4=q#object.c::ctors#;
$D4=q#lib/test_value.c#;
$E4={$W1,1,$X1,1,$Y3,1,$Y1,1,$T2,1,$Z1,1,$Z3,1,$c2,1,$d2,1,$e2,1,$f2,1,$g2,1,$R2,1,$h2,1,$g3,1,$i2,1,$D4,1,$z2,1,$k2,1,$A2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1};
$F4=q#/lib/behavior#;
$G4={};
$H4=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$I4=bless({$q,$H4,$s,$t},$u);
$J4={$e,$I4};
$K4=q#/lib/documentable.b#;
$L4=bless({$V1,$G4,$F2,$G2,$H2,$G2,$I2,$J4,$D,$K4},$R2);
$M4=q#lib/test_value.c#;
$N4=q#lib/slice::ctors#;
$O4=[$B4,$L4];
$P4=bless({$V1,$E4,$D,$F4,$x2,$O4},$Y1);
$Q4=q#lib/behavior.c::ctors#;
$R4=q#lib/test_value.c#;
$S4={$W1,1,$X1,1,$Y1,1,$T2,1,$Z1,1,$c2,1,$d2,1,$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$R4,1,$z2,1,$k2,1,$A2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1};
$T4=q#/lib/definition.b#;
$U4={};
$V4=q#def#;
$W4=q#shift->add(ni('ni:/lib/slice')->new(@_))#;
$X4=bless({$q,$W4,$s,$t},$u);
$Y4={$V4,$X4};
$Z4=q#/lib/definition_def.b#;
$c5=bless({$V1,$U4,$F2,$G2,$H2,$G2,$I2,$Y4,$D,$Z4},$R2);
$d5=q#lib/test_value.c#;
$e5=q#lib/slice::ctors#;
$f5={};
$g5=q#ro#;
$h5=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$i5=bless({$q,$h5,$s,$t},$u);
$j5=q#rw#;
$k5=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$l5=bless({$q,$k5,$s,$t},$u);
$m5={$g5,$i5,$j5,$l5};
$n5=q#/lib/accessor.b#;
$o5=bless({$V1,$f5,$F2,$G2,$H2,$G2,$I2,$m5,$D,$n5},$R2);
$p5=q#lib/test_value.c#;
$q5=q#lib/slice::ctors#;
$r5={};
$s5=q#(""#;
$t5=q#shift->name#;
$u5=bless({$q,$t5,$s,$t},$u);
$v5={$s5,$u5};
$w5=q#/lib/name_as_string.b#;
$x5=bless({$V1,$r5,$F2,$G2,$H2,$G2,$I2,$v5,$D,$w5},$R2);
$y5=q#lib/test_value.c#;
$z5=q#lib/slice::ctors#;
$A5={};
$B5=q#(eq#;
$C5=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$D5=bless({$q,$C5,$s,$t},$u);
$E5={$B5,$D5};
$F5=q#/lib/ref_eq.b#;
$G5=bless({$V1,$A5,$F2,$G2,$H2,$G2,$I2,$E5,$D,$F5},$R2);
$H5=q#lib/test_value.c#;
$I5=q#lib/slice::ctors#;
$J5={};
$K5=q#defdata#;
$L5=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$M5=bless({$q,$L5,$s,$t},$u);
$N5={$K5,$M5};
$O5=q#/lib/definition_defdata.b#;
$P5=bless({$V1,$J5,$F2,$G2,$H2,$G2,$I2,$N5,$D,$O5},$R2);
$Q5=q#lib/test_value.c#;
$R5=q#lib/slice::ctors#;
$S5=[$c5,$o5,$x5,$G5,$P5];
$T5=bless({$V1,$S4,$D,$T4,$x2,$S5},$T2);
$U5=q#lib/branch::ctors#;
$V5=[$L3,$V3,$B4,$P4,$T5];
$W5=bless({$V1,$B2,$D,$C2,$x2,$V5},$l2);
$X5=q#module.c::ctors#;
$Y5={};
$Z5=q#DESTROY#;
$c6=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$d6=bless({$q,$c6,$s,$t},$u);
$e6=q#new#;
$f6=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$g6=bless({$q,$f6,$s,$t},$u);
$h6={$Z5,$d6,$e6,$g6};
$i6=q#/lib/instantiable.b#;
$j6=bless({$V1,$Y5,$I2,$h6,$D,$i6},$R2);
$k6=q#lib/test_value.c#;
$l6=q#lib/slice::ctors#;
$m6={};
$n6=q#child#;
$o6=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$p6=bless({$q,$o6,$s,$t},$u);
$q6={$n6,$p6};
$r6=q#/lib/subclass.b#;
$s6=bless({$V1,$m6,$F2,$G2,$H2,$G2,$I2,$q6,$D,$r6},$R2);
$t6=q#lib/test_value.c#;
$u6=q#lib/slice::ctors#;
$v6=[$W5,$j6,$V3,$W5,$s6];
$w6=bless({$V1,$w2,$D,$E,$x2,$v6},$X1);
$x6=q#class.c::ctors#;
$y6=q#ni:/class.c#;
$z6={$X1,1};
$A6=q#/class.c#;
$B6={$X1,1,$l2,1};
$C6=q#/module.c#;
$D6=q#lib/test_value.c#;
$E6={$X1,1,$Y1,1,$Z1,1,$c2,1,$d2,1,$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$D6,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1};
$F6=q#/object.c#;
$G6=[$w6];
$H6=bless({$V1,$E6,$D,$F6,$x2,$G6},$z2);
$I6=q#metaclass::ctors#;
$J6={$X1,1,$Y1,1,$Z1,1,$c2,1,$h2,1,$i2,1,$l2,1};
$K6=q#/lib/behavior.c#;
$L6=[$H6];
$M6=bless({$V1,$J6,$D,$K6,$x2,$L6},$z2);
$N6=q#metaclass::ctors#;
$O6=[$H6,$j6,$M6];
$P6=bless({$V1,$B6,$D,$C6,$x2,$O6},$z2);
$Q6=q#metaclass::ctors#;
$R6=[$P6];
$S6=bless({$V1,$z6,$D,$A6,$x2,$R6},$z2);
$T6=q#metaclass::ctors#;
$U6=q#ni:/lib/accessor.b#;
$V6=q#ni:/lib/behavior#;
$W6=q#ni:/lib/behavior.c#;
$X6=q#ni:/lib/branch#;
$Y6={$T2,1};
$Z6=q#/lib/branch#;
$c7={};
$d7=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$e7=bless({$q,$d7,$s,$t},$u);
$f7={$Q3,$e7};
$g7=q#/lib/branch_init.b#;
$h7=bless({$V1,$c7,$F2,$G2,$H2,$G2,$I2,$f7,$D,$g7},$R2);
$i7=q#lib/slice::ctors#;
$j7=[$P4,$f3,$S2,$h7,$T5];
$k7=bless({$V1,$Y6,$D,$Z6,$x2,$j7},$Z1);
$l7=q#lib/branch.c::ctors#;
$m7=q#ni:/lib/branch.b#;
$n7=q#ni:/lib/branch.c#;
$o7={$Z1,1};
$p7=q#/lib/branch.c#;
$q7=[$M6];
$r7=bless({$V1,$o7,$D,$p7,$x2,$q7},$z2);
$s7=q#metaclass::ctors#;
$t7=q#ni:/lib/branch_init.b#;
$u7=q#ni:/lib/class_init.b#;
$v7=q#ni:/lib/dataslice#;
$w7={$Z3,1};
$x7=q#/lib/dataslice#;
$y7={};
$z7=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$A7=bless({$q,$z7,$s,$t},$u);
$B7={$Q3,$A7};
$C7=q#/lib/dataslice_init.b#;
$D7=bless({$V1,$y7,$F2,$G2,$H2,$G2,$I2,$B7,$D,$C7},$R2);
$E7=q#lib/slice::ctors#;
$F7={};
$G7=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$H7=bless({$q,$G7,$s,$t},$u);
$I7={$M2,$H7};
$J7=q#/lib/dataslice_apply.b#;
$K7=bless({$V1,$F7,$F2,$G2,$H2,$G2,$I2,$I7,$D,$J7},$R2);
$L7=q#lib/slice::ctors#;
$M7=[$P4,$D7,$K7];
$N7=bless({$V1,$w7,$D,$x7,$x2,$M7},$c2);
$O7=q#lib/dataslice.c::ctors#;
$P7=q#ni:/lib/dataslice.c#;
$Q7={$c2,1};
$R7=q#/lib/dataslice.c#;
$S7=[$M6];
$T7=bless({$V1,$Q7,$D,$R7,$x2,$S7},$z2);
$U7=q#metaclass::ctors#;
$V7=q#ni:/lib/dataslice_apply.b#;
$W7=q#ni:/lib/dataslice_init.b#;
$X7=q#ni:/lib/definition.b#;
$Y7=q#ni:/lib/definition_def.b#;
$Z7=q#ni:/lib/definition_defdata.b#;
$c8=q#ni:/lib/doc#;
$d8={$F,1};
$e8={};
$f8=q#shift; +{name => shift, doc => []}#;
$g8=bless({$q,$f8,$s,$t},$u);
$h8={$Q3,$g8};
$i8=q#/lib/doc_init.b#;
$j8=bless({$V1,$e8,$F2,$G2,$H2,$G2,$I2,$h8,$D,$i8},$R2);
$k8=q#lib/slice::ctors#;
$l8={};
$m8=q#'ni.doc'#;
$n8=bless({$q,$m8,$s,$t},$u);
$o8={$k3,$n8};
$p8=q#/lib/doc_namespace.b#;
$q8=bless({$V1,$l8,$F2,$G2,$H2,$G2,$I2,$o8,$D,$p8},$R2);
$r8=q#lib/slice::ctors#;
$s8={};
$t8=q#AUTOLOAD#;
$u8=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$v8=bless({$q,$u8,$s,$t},$u);
$w8={$t8,$v8};
$x8=q#/lib/doc_define.b#;
$y8=bless({$V1,$s8,$F2,$G2,$H2,$G2,$I2,$w8,$D,$x8},$R2);
$z8=q#lib/slice::ctors#;
$A8={};
$B8=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$C8=bless({$q,$B8,$s,$t},$u);
$D8=q#tests#;
$E8=q#my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$F8=bless({$q,$E8,$s,$t},$u);
$G8={$n,$C8,$D8,$F8};
$H8=q#/lib/doc_test.b#;
$I8=bless({$V1,$A8,$F2,$G2,$H2,$G2,$I2,$G8,$D,$H8},$R2);
$J8=q#lib/slice::ctors#;
$K8=[$B4,$f3,$j8,$q8,$y8,$I8];
$L8=bless({$V1,$d8,$D,$W,$x2,$K8},$d2);
$M8=q#lib/doc.c::ctors#;
$N8=q#ni:/lib/doc.c#;
$O8={$d2,1};
$P8=q#/lib/doc.c#;
$Q8=[$H6];
$R8=bless({$V1,$O8,$D,$P8,$x2,$Q8},$z2);
$S8=q#metaclass::ctors#;
$T8=q#ni:/lib/doc_define.b#;
$U8=q#ni:/lib/doc_init.b#;
$V8=q#ni:/lib/doc_namespace.b#;
$W8=q#ni:/lib/doc_test.b#;
$X8=q#ni:/lib/documentable.b#;
$Y8=q#ni:/lib/fn#;
$Z8={$u,1};
$c9=q#/lib/fn#;
$d9={};
$e9=q#shift->compile#;
$f9=bless({$q,$e9,$s,$t},$u);
$g9=q#compile#;
$h9=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$i9=bless({$q,$h9,$s,$t},$u);
$j9=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$k9=bless({$q,$j9,$s,$t},$u);
$l9={$g9,$i9,$Q3,$k9};
$m9=q#/lib/fn_init.b#;
$n9=bless({$V1,$d9,$F2,$f9,$H2,$G2,$I2,$l9,$D,$m9},$R2);
$o9=q#lib/slice::ctors#;
$p9={};
$q9=[];
$r9=q#shift->{'annotations'}#;
$s9=bless({$o,$q9,$q,$r9,$s,$t},$u);
$t9=[];
$u9=q#shift->{'code'}#;
$v9=bless({$o,$t9,$q,$u9,$s,$t},$u);
$w9=q#fn#;
$x9=[];
$y9=q#shift->{'fn'}#;
$z9=bless({$o,$x9,$q,$y9,$s,$t},$u);
$A9={$o,$s9,$q,$v9,$w9,$z9};
$B9=q#/lib/fn_ro.b#;
$C9=bless({$V1,$p9,$F2,$G2,$H2,$G2,$I2,$A9,$D,$B9},$R2);
$D9=q#lib/slice::ctors#;
$E9={};
$F9=[];
$G9=q#shift->{code}#;
$H9=bless({$o,$F9,$q,$G9,$s,$t},$u);
$I9=[];
$J9=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$K9=bless({$o,$I9,$q,$J9,$s,$t},$u);
$L9={$s5,$H9,$B5,$K9};
$M9=q#/lib/fn_ops.b#;
$N9=bless({$V1,$E9,$F2,$G2,$H2,$G2,$I2,$L9,$D,$M9},$R2);
$O9=q#lib/slice::ctors#;
$P9={};
$Q9=q#serialize#;
$R9=[];
$S9=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$T9=bless({$o,$R9,$q,$S9,$s,$t},$u);
$U9={$Q9,$T9};
$V9=q#/lib/fn_serialize.b#;
$W9=bless({$V1,$P9,$F2,$G2,$H2,$G2,$I2,$U9,$D,$V9},$R2);
$X9=q#lib/slice::ctors#;
$Y9=[$B4,$j6,$n9,$C9,$N9,$W9];
$Z9=bless({$V1,$Z8,$D,$c9,$x2,$Y9},$e2);
$ca=q#lib/fn.c::ctors#;
$da=q#ni:/lib/fn.c#;
$ea={$e2,1};
$fa=q#/lib/fn.c#;
$ga=[$H6];
$ha=bless({$V1,$ea,$D,$fa,$x2,$ga},$z2);
$ia=q#metaclass::ctors#;
$ja=q#ni:/lib/fn_init.b#;
$ka=q#ni:/lib/fn_ops.b#;
$la=q#ni:/lib/fn_ro.b#;
$ma=q#ni:/lib/fn_serialize.b#;
$na=q#ni:/lib/global_static_test.b#;
$oa={};
$pa=q#now#;
$qa=[];
$ra=q#ni('ni:/lib/test_value')->new(shift)#;
$sa=q#($)#;
$ta=bless({$o,$qa,$q,$ra,$s,$sa},$u);
$ua={$pa,$ta};
$va=q#/lib/global_static_test.b#;
$wa=bless({$V1,$oa,$F2,$G2,$H2,$G2,$I2,$ua,$D,$va},$R2);
$xa=q#main#;
$ya=q#lib/slice::ctors#;
$za=q#ni:/lib/image#;
$Aa={$c4,1};
$Ba=q#/lib/image#;
$Ca={};
$Da=[];
$Ea=q#my $class = shift;
my %args  = (
  include_shebang => 1,
  include_license => 1,
  include_boot    => 1,
  include_classes => 1,
  include_run     => 1,
  local_vars      => 0,
  use_newlines    => 0,
  @_);

+{include_shebang => $args{include_shebang},
  include_license => $args{include_license},
  include_boot    => $args{include_boot},
  include_classes => $args{include_classes},
  include_run     => $args{include_run},
  local_vars      => $args{local_vars},
  use_newlines    => $args{use_newlines},

  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$Fa=bless({$o,$Da,$q,$Ea,$s,$t},$u);
$Ga={$Q3,$Fa};
$Ha=q#/lib/image_init.b#;
$Ia=bless({$V1,$Ca,$F2,$G2,$H2,$G2,$I2,$Ga,$D,$Ha},$R2);
$Ja=q#lib/slice::ctors#;
$Ka={};
$La=q#address#;
$Ma=[];
$Na=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 16;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$Oa=bless({$o,$Ma,$q,$Na,$s,$t},$u);
$Pa=q#allocate_gensym#;
$Qa=[];
$Ra=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$Sa=bless({$o,$Qa,$q,$Ra,$s,$t},$u);
$Ta=q#boot_side_effect#;
$Ua=[];
$Va=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Wa=bless({$o,$Ua,$q,$Va,$s,$t},$u);
$Xa=q#circular_links#;
$Ya=[];
$Za=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$cb=bless({$o,$Ya,$q,$Za,$s,$t},$u);
$db=q#finalizer#;
$eb=[];
$fb=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$gb=bless({$o,$eb,$q,$fb,$s,$t},$u);
$hb=q#gensym#;
$ib=[];
$jb=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$kb=bless({$o,$ib,$q,$jb,$s,$t},$u);
$lb=q#is_circular#;
$mb=[];
$nb=q#my $self = shift;
ref $$self{visited}{$self->address($_[0])};#;
$ob=bless({$o,$mb,$q,$nb,$s,$t},$u);
$pb=q#quote#;
$qb=[];
$rb=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? 'undef' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$sb=bless({$o,$qb,$q,$rb,$s,$t},$u);
$tb=q#quote_array#;
$ub=[];
$vb=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_])
  && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$wb=bless({$o,$ub,$q,$vb,$s,$t},$u);
$xb=q#quote_blessed#;
$yb=[];
$zb=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$Ab=bless({$o,$yb,$q,$zb,$s,$t},$u);
$Bb=q#quote_class#;
$Cb=[];
$Db=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$Eb=bless({$o,$Cb,$q,$Db,$s,$t},$u);
$Fb=q#quote_hash#;
$Gb=[];
$Hb=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  push @{$$self{circular}}, [$a, "{" . $self->quote($k) . "}",
                                 $self->address($$v{$k})]
  if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$Ib=bless({$o,$Gb,$q,$Hb,$s,$t},$u);
$Jb=q#quote_object#;
$Kb=[];
$Lb=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$Mb=bless({$o,$Kb,$q,$Lb,$s,$t},$u);
$Nb=q#quote_scalar#;
$Ob=[];
$Pb=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$Qb=bless({$o,$Ob,$q,$Pb,$s,$t},$u);
$Rb=q#quote_value#;
$Sb=[];
$Tb=q#my $self = shift;
return $self->quote_scalar($_[0]) unless ref $_[0];
return $self->quote_array($_[0])  if 'ARRAY' eq ref $_[0];
return $self->quote_hash($_[0])   if 'HASH'  eq ref $_[0];
die "cannot serialize $_[0]"      if 'CODE'  eq ref $_[0];
$self->quote_object($_[0]);#;
$Ub=bless({$o,$Sb,$q,$Tb,$s,$t},$u);
$Vb=q#reconstruction#;
$Wb=[];
$Xb=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$Yb=bless({$o,$Wb,$q,$Xb,$s,$t},$u);
$Zb=q#side_effect#;
$cc=[];
$dc=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$ec=bless({$o,$cc,$q,$dc,$s,$t},$u);
$fc=q#write#;
$gc=[];
$hc=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  ($$self{include_shebang} ? ("\#!/usr/bin/env perl\\n") : ()),
  ($$self{include_license} ? ("chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n") : ()),
  ($$self{include_boot}    ? ("BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n") : ()),
  ($$self{use_newlines}    ? map("$_\\n", $self->reconstruction) : $self->reconstruction),
  ($$self{include_run}     ? ("ni->run(\\@ARGV);", "\\n__DATA__\\n") : ());#;
$ic=bless({$o,$gc,$q,$hc,$s,$t},$u);
$jc={$La,$Oa,$Pa,$Sa,$Ta,$Wa,$Xa,$cb,$db,$gb,$hb,$kb,$lb,$ob,$pb,$sb,$tb,$wb,$xb,$Ab,$Bb,$Eb,$Fb,$Ib,$Jb,$Mb,$Nb,$Qb,$Rb,$Ub,$Vb,$Yb,$Zb,$ec,$fc,$ic};
$kc=q#/lib/image_quoting.b#;
$lc=bless({$V1,$Ka,$F2,$G2,$H2,$G2,$I2,$jc,$D,$kc},$R2);
$mc=q#lib/slice::ctors#;
$nc=[$B4,$Ia,$lc];
$oc=bless({$V1,$Aa,$D,$Ba,$x2,$nc},$f2);
$pc=q#lib/image.c::ctors#;
$qc=q#ni:/lib/image.c#;
$rc={$f2,1};
$sc=q#/lib/image.c#;
$tc=[$H6];
$uc=bless({$V1,$rc,$D,$sc,$x2,$tc},$z2);
$vc=q#metaclass::ctors#;
$wc=q#ni:/lib/image_init.b#;
$xc=q#ni:/lib/image_quoting.b#;
$yc=q#ni:/lib/instance.b#;
$zc=q#ni:/lib/instantiable.b#;
$Ac=q#ni:/lib/json.b#;
$Bc={};
$Cc=q#json_decode#;
$Dc=[];
$Ec=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$Fc=bless({$o,$Dc,$q,$Ec,$s,$sa},$u);
$Gc=q#json_encode#;
$Hc=[];
$Ic=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$Jc=bless({$o,$Hc,$q,$Ic,$s,$sa},$u);
$Kc=q#json_escape#;
$Lc=[];
$Mc=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$Nc=bless({$o,$Lc,$q,$Mc,$s,$sa},$u);
$Oc=q#json_unescape#;
$Pc=[];
$Qc=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$Rc=bless({$o,$Pc,$q,$Qc,$s,$sa},$u);
$Sc=q#json_unescape_one#;
$Tc=[];
$Uc=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$Vc=bless({$o,$Tc,$q,$Uc,$s,$sa},$u);
$Wc={$Cc,$Fc,$Gc,$Jc,$Kc,$Nc,$Oc,$Rc,$Sc,$Vc};
$Xc=q#/lib/json.b#;
$Yc=bless({$V1,$Bc,$F2,$G2,$H2,$G2,$I2,$Wc,$D,$Xc},$R2);
$Zc=q#ni#;
$cd=q#lib/slice::ctors#;
$dd=q#ni:/lib/name_as_string.b#;
$ed=q#ni:/lib/named.b#;
$fd=q#ni:/lib/named_in_ni.b#;
$gd=q#ni:/lib/namespaced.b#;
$hd=q#ni:/lib/ni#;
$id={$d4,1};
$jd=q#/lib/ni#;
$kd={};
$ld=q#extend#;
$md=[];
$nd=q#my ($self, $f) = @_;
my $r = do $f;
die "ni: failed to parse $f: $@" if $@;
die "ni: failed to execute $f: $!" unless defined $r;
die "ni: failed to run $f: $!" unless $r;
$self;#;
$od=bless({$o,$md,$q,$nd,$s,$t},$u);
$pd=q#is_mutable#;
$qd=[];
$rd=q#$0 ne "-" && -w $0#;
$sd=bless({$o,$qd,$q,$rd,$s,$t},$u);
$td=q#modify#;
$ud=[];
$vd=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$wd=bless({$o,$ud,$q,$vd,$s,$t},$u);
$xd={$ld,$od,$pd,$sd,$td,$wd};
$yd=q#/lib/ni_self.b#;
$zd=bless({$V1,$kd,$F2,$G2,$H2,$G2,$I2,$xd,$D,$yd},$R2);
$Ad=q#lib/slice::ctors#;
$Bd={};
$Cd=q#exists#;
$Dd=[];
$Ed=q#exists $_[0]->{named}{$_[1]}#;
$Fd=bless({$o,$Dd,$q,$Ed,$s,$t},$u);
$Gd=q#quoted#;
$Hd=[];
$Id=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$Jd=bless({$o,$Hd,$q,$Id,$s,$t},$u);
$Kd={$Cd,$Fd,$Gd,$Jd};
$Ld=q#/lib/ni_image.b#;
$Md=bless({$V1,$Bd,$F2,$G2,$H2,$G2,$I2,$Kd,$D,$Ld},$R2);
$Nd=q#lib/slice::ctors#;
$Od={};
$Pd=q#--internal/+=#;
$Qd=[];
$Rd=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$Sd=bless({$o,$Qd,$q,$Rd,$s,$t},$u);
$Td=q#--internal/eval#;
$Ud=[];
$Vd=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$Wd=bless({$o,$Ud,$q,$Vd,$s,$t},$u);
$Xd=q#--internal/image#;
$Yd=[];
$Zd=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$ce=bless({$o,$Yd,$q,$Zd,$s,$t},$u);
$de=q#--internal/test#;
$ee=[];
$fe=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$ge=bless({$o,$ee,$q,$fe,$s,$t},$u);
$he=q#run#;
$ie=[];
$je=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$ke=bless({$o,$ie,$q,$je,$s,$t},$u);
$le={$Pd,$Sd,$Td,$Wd,$Xd,$ce,$de,$ge,$he,$ke};
$me=q#/lib/ni_main.b#;
$ne=bless({$V1,$Od,$F2,$G2,$H2,$G2,$I2,$le,$D,$me},$R2);
$oe=q#lib/slice::ctors#;
$pe={};
$qe=[];
$re=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$se=bless({$o,$qe,$q,$re,$s,$t},$u);
$te=q#resolver_for#;
$ue=[];
$ve=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$we=bless({$o,$ue,$q,$ve,$s,$t},$u);
$xe={$C3,$se,$te,$we};
$ye=q#/lib/ni_resolver.b#;
$ze=bless({$V1,$pe,$F2,$G2,$H2,$G2,$I2,$xe,$D,$ye},$R2);
$Ae=q#lib/slice::ctors#;
$Be=[$B4,$zd,$Md,$ne,$ze];
$Ce=bless({$V1,$id,$D,$jd,$x2,$Be},$g2);
$De=q#lib/ni.c::ctors#;
$Ee=q#ni:/lib/ni.c#;
$Fe={$g2,1};
$Ge=q#/lib/ni.c#;
$He=[$H6];
$Ie=bless({$V1,$Fe,$D,$Ge,$x2,$He},$z2);
$Je=q#metaclass::ctors#;
$Ke=q#ni:/lib/ni_image.b#;
$Le=q#ni:/lib/ni_main.b#;
$Me=q#ni:/lib/ni_resolver.b#;
$Ne=q#ni:/lib/ni_self.b#;
$Oe=q#ni:/lib/ni_static_util.b#;
$Pe={};
$Qe=q#abbrev#;
$Re=[];
$Se=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$Te=bless({$o,$Re,$q,$Se,$s,$t},$u);
$Ue=q#dor#;
$Ve=[];
$We=q#defined $_[0] ? $_[0] : $_[1]#;
$Xe=bless({$o,$Ve,$q,$We,$s,$t},$u);
$Ye=q#indent#;
$Ze=[];
$cf=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$df=bless({$o,$Ze,$q,$cf,$s,$t},$u);
$ef=q#max#;
$ff=[];
$gf=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$hf=bless({$o,$ff,$q,$gf,$s,$t},$u);
$if=q#maxstr#;
$jf=[];
$kf=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$lf=bless({$o,$jf,$q,$kf,$s,$t},$u);
$mf=q#mean#;
$nf=[];
$of=q#sum(@_) / (@_ || 1)#;
$pf=bless({$o,$nf,$q,$of,$s,$t},$u);
$qf=q#min#;
$rf=[];
$sf=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$tf=bless({$o,$rf,$q,$sf,$s,$t},$u);
$uf=q#minstr#;
$vf=[];
$wf=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$xf=bless({$o,$vf,$q,$wf,$s,$t},$u);
$yf=q#sgr#;
$zf=[];
$Af=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$Bf=bless({$o,$zf,$q,$Af,$s,$t},$u);
$Cf=q#sr#;
$Df=[];
$Ef=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$Ff=bless({$o,$Df,$q,$Ef,$s,$t},$u);
$Gf=q#sum#;
$Hf=[];
$If=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$Jf=bless({$o,$Hf,$q,$If,$s,$t},$u);
$Kf=q#swap#;
$Lf=[];
$Mf=q#@_[0, 1] = @_[1, 0]#;
$Nf=bless({$o,$Lf,$q,$Mf,$s,$t},$u);
$Of={$Qe,$Te,$Ue,$Xe,$Ye,$df,$ef,$hf,$if,$lf,$mf,$pf,$qf,$tf,$uf,$xf,$yf,$Bf,$Cf,$Ff,$Gf,$Jf,$Kf,$Nf};
$Pf=q#/lib/ni_static_util.b#;
$Qf=bless({$V1,$Pe,$F2,$G2,$H2,$G2,$I2,$Of,$D,$Pf},$R2);
$Rf=q#lib/slice::ctors#;
$Sf=q#ni:/lib/perlbranch.b#;
$Tf=q#ni:/lib/ref_eq.b#;
$Uf=q#ni:/lib/resolver.b#;
$Vf=q#ni:/lib/slice#;
$Wf={$R2,1};
$Xf=q#/lib/slice#;
$Yf=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$Zf=bless({$q,$Yf,$s,$t},$u);
$cg=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$dg=bless({$q,$cg,$s,$t},$u);
$eg=q#lib/slice::apply#;
$fg=q#lib/slice::apply_unsafe#;
$gg={};
$hg=q#apply_unsafe#;
$ig={$M2,$Zf,$hg,$dg};
$jg=q#/lib/slice.b#;
$kg=bless({$V1,$gg,$I2,$ig,$D,$jg},$R2);
$lg=q#lib/slice::ctors#;
$mg={};
$ng=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$og=bless({$q,$ng,$s,$t},$u);
$pg={$Q3,$og};
$qg=q#/lib/slice_init.b#;
$rg=bless({$V1,$mg,$I2,$pg,$D,$qg},$R2);
$sg=q#lib/slice::ctors#;
$tg={};
$ug=[];
$vg=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$wg=bless({$o,$ug,$q,$vg,$s,$t},$u);
$xg={$Q9,$wg};
$yg=q#/lib/slice_serialize.b#;
$zg=bless({$V1,$tg,$F2,$G2,$H2,$G2,$I2,$xg,$D,$yg},$R2);
$Ag=q#lib/slice::ctors#;
$Bg=[$P4,$f3,$kg,$rg,$zg];
$Cg=bless({$V1,$Wf,$D,$Xf,$x2,$Bg},$h2);
$Dg=q#lib/slice.c::ctors#;
$Eg=q#ni:/lib/slice.b#;
$Fg=q#ni:/lib/slice.c#;
$Gg={$h2,1};
$Hg=q#/lib/slice.c#;
$Ig=[$M6];
$Jg=bless({$V1,$Gg,$D,$Hg,$x2,$Ig},$z2);
$Kg=q#metaclass::ctors#;
$Lg=q#ni:/lib/slice_init.b#;
$Mg=q#ni:/lib/slice_serialize.b#;
$Ng=q#ni:/lib/static_fn.b#;
$Og={};
$Pg=[];
$Qg=q#ni('ni:/lib/fn')->new(@_)#;
$Rg=bless({$o,$Pg,$q,$Qg,$s,$sa},$u);
$Sg=q#fp#;
$Tg=[];
$Ug=q#ni('ni:/lib/fn')->new(@_)#;
$Vg=q#($$)#;
$Wg=bless({$o,$Tg,$q,$Ug,$s,$Vg},$u);
$Xg={$w9,$Rg,$Sg,$Wg};
$Yg=q#/lib/static_fn.b#;
$Zg=bless({$V1,$Og,$F2,$G2,$H2,$G2,$I2,$Xg,$D,$Yg},$R2);
$ch=q#lib/slice::ctors#;
$dh=q#ni:/lib/subclass.b#;
$eh=q#ni:/lib/tag#;
$fh={$g3,1};
$gh=q#/lib/tag#;
$hh={};
$ih=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$jh=bless({$q,$ih,$s,$t},$u);
$kh={$M2,$jh};
$lh=q#/lib/tag.b#;
$mh=bless({$V1,$hh,$F2,$G2,$H2,$G2,$I2,$kh,$D,$lh},$R2);
$nh=q#lib/slice::ctors#;
$oh={};
$ph=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$qh=bless({$q,$ph,$s,$t},$u);
$rh={$Q3,$qh};
$sh=q#/lib/tag_init.b#;
$th=bless({$V1,$oh,$F2,$G2,$H2,$G2,$I2,$rh,$D,$sh},$R2);
$uh=q#lib/slice::ctors#;
$vh=[$P4,$f3,$mh,$th];
$wh=bless({$V1,$fh,$D,$gh,$x2,$vh},$i2);
$xh=q#lib/tag.c::ctors#;
$yh=q#ni:/lib/tag.b#;
$zh=q#ni:/lib/tag.c#;
$Ah={$i2,1};
$Bh=q#/lib/tag.c#;
$Ch=[$M6];
$Dh=bless({$V1,$Ah,$D,$Bh,$x2,$Ch},$z2);
$Eh=q#metaclass::ctors#;
$Fh=q#ni:/lib/tag_init.b#;
$Gh=q#ni:/lib/test_value#;
$Hh={$e4,1};
$Ih=q#/lib/test_value#;
$Jh={};
$Kh=[];
$Lh=q#\\$_[1]#;
$Mh=bless({$o,$Kh,$q,$Lh,$s,$t},$u);
$Nh={$Q3,$Mh};
$Oh=q#/lib/test_value_init.b#;
$Ph=bless({$V1,$Jh,$F2,$G2,$H2,$G2,$I2,$Nh,$D,$Oh},$R2);
$Qh=q#lib/slice::ctors#;
$Rh={};
$Sh=q#(==#;
$Th=[];
$Uh=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$Vh=bless({$o,$Th,$q,$Uh,$s,$t},$u);
$Wh=q#diff#;
$Xh=[];
$Yh=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$Zh=bless({$o,$Xh,$q,$Yh,$s,$t},$u);
$ci={$Sh,$Vh,$Wh,$Zh};
$di=q#/lib/test_value_eq.b#;
$ei=bless({$V1,$Rh,$F2,$G2,$H2,$G2,$I2,$ci,$D,$di},$R2);
$fi=q#lib/slice::ctors#;
$gi={};
$hi=[];
$ii=q#ni::json_encode ${$_[0]}#;
$ji=bless({$o,$hi,$q,$ii,$s,$t},$u);
$ki={$s5,$ji};
$li=q#/lib/test_value_str.b#;
$mi=bless({$V1,$gi,$F2,$G2,$H2,$G2,$I2,$ki,$D,$li},$R2);
$ni=q#lib/slice::ctors#;
$oi=[$B4,$Ph,$ei,$mi];
$pi=q#lib/test_value.c#;
$qi=bless({$V1,$Hh,$D,$Ih,$x2,$oi},$pi);
$ri=q#lib/test_value.c::ctors#;
$si=q#ni:/lib/test_value.c#;
$ti=q#lib/test_value.c#;
$ui={$ti,1};
$vi=q#/lib/test_value.c#;
$wi=[$H6];
$xi=bless({$V1,$ui,$D,$vi,$x2,$wi},$z2);
$yi=q#metaclass::ctors#;
$zi=q#ni:/lib/test_value_eq.b#;
$Ai=q#ni:/lib/test_value_init.b#;
$Bi=q#ni:/lib/test_value_str.b#;
$Ci=q#ni:/metaclass#;
$Di={$z2,1};
$Ei=q#/metaclass#;
$Fi=[$L3,$j6,$V3,$W5];
$Gi=bless({$V1,$Di,$D,$Ei,$x2,$Fi},$k2);
$Hi=q#metaclass.c::ctors#;
$Ii=q#ni:/metaclass.c#;
$Ji={$k2,1};
$Ki=q#/metaclass.c#;
$Li=[$w6];
$Mi=bless({$V1,$Ji,$D,$Ki,$x2,$Li},$z2);
$Ni=q#metaclass::ctors#;
$Oi=q#ni:/module#;
$Pi=q#ni:/module.c#;
$Qi=q#ni:/object#;
$Ri=q#ni:/object.c#;
$Si=q#ni:/unix/cat#;
$Ti={$h4,1};
$Ui={$h4,1,$j4,1,$k4,1,$l4,1,$m4,1,$n4,1,$o4,1,$p4,1};
$Vi=q#/unix/io#;
$Wi={};
$Xi=q#(bool#;
$Yi=[];
$Zi=bless({$o,$Yi,$q,1,$s,$t},$u);
$cj={$Xi,$Zi};
$dj=q#/unix/io_ops.b#;
$ej=bless({$V1,$Wi,$F2,$G2,$H2,$G2,$I2,$cj,$D,$dj},$R2);
$fj=q#lib/slice::ctors#;
$gj={};
$hj=q#into#;
$ij=[];
$jj=q#local $_;
my ($self, $dest, $each) = @_;
my $block_size = $self->can('read_size') ? $self->read_size : 8192;
while ($self->read($_, $block_size)) {
  $dest->write($_);
  &$each($_) && return if defined $each;
}#;
$kj=bless({$o,$ij,$q,$jj,$s,$t},$u);
$lj={$hj,$kj};
$mj=q#/unix/io_stream.b#;
$nj=bless({$V1,$gj,$F2,$G2,$H2,$G2,$I2,$lj,$D,$mj},$R2);
$oj=q#lib/slice::ctors#;
$pj={};
$qj=q#(+#;
$rj=[];
$sj=q#ni('ni:/unix/cat')->new(@_[0, 1])#;
$tj=bless({$o,$rj,$q,$sj,$s,$t},$u);
$uj={$qj,$tj};
$vj=q#/unix/io_constructors.b#;
$wj=bless({$V1,$pj,$F2,$G2,$H2,$G2,$I2,$uj,$D,$vj},$R2);
$xj=q#lib/slice::ctors#;
$yj={};
$zj=q#read_all#;
$Aj=[];
$Bj=q#shift->into(ni('ni:/unix/str')->new(my $data = ''));
$data;#;
$Cj=bless({$o,$Aj,$q,$Bj,$s,$t},$u);
$Dj={$zj,$Cj};
$Ej=q#/unix/io_memory.b#;
$Fj=bless({$V1,$yj,$F2,$G2,$H2,$G2,$I2,$Dj,$D,$Ej},$R2);
$Gj=q#lib/slice::ctors#;
$Hj=[$B4,$ej,$nj,$wj,$Fj];
$Ij=bless({$V1,$Ui,$D,$Vi,$x2,$Hj},$s2);
$Jj=q#unix/io.c::ctors#;
$Kj={};
$Lj=[];
$Mj=q#shift; +{fs => [@_]}#;
$Nj=bless({$o,$Lj,$q,$Mj,$s,$t},$u);
$Oj={$Q3,$Nj};
$Pj=q#/unix/cat_init.b#;
$Qj=bless({$V1,$Kj,$F2,$G2,$H2,$G2,$I2,$Oj,$D,$Pj},$R2);
$Rj=q#lib/slice::ctors#;
$Sj={};
$Tj=q#read#;
$Uj=[];
$Vj=q#my $fs = shift->{fs};
my $n;
shift @$fs until !@$fs or $n = $$fs[0]->read(@_);
return $n;#;
$Wj=bless({$o,$Uj,$q,$Vj,$s,$t},$u);
$Xj={$Tj,$Wj};
$Yj=q#/unix/cat_read.b#;
$Zj=bless({$V1,$Sj,$F2,$G2,$H2,$G2,$I2,$Xj,$D,$Yj},$R2);
$ck=q#lib/slice::ctors#;
$dk=[$Ij,$Qj,$Zj];
$ek=bless({$V1,$Ti,$D,$q1,$x2,$dk},$n2);
$fk=q#unix/cat.c::ctors#;
$gk=q#ni:/unix/cat.c#;
$hk={$n2,1};
$ik=q#/unix/cat.c#;
$jk={$n2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1};
$kk=q#/unix/io.c#;
$lk={};
$mk=q#has_fd#;
$nk=[];
$ok=q#shift->add('/unix/has_fd.b')#;
$pk=bless({$o,$nk,$q,$ok,$s,$t},$u);
$qk={$mk,$pk};
$rk=q#/unix/io.c_has_fd.b#;
$sk=bless({$V1,$lk,$F2,$G2,$H2,$G2,$I2,$qk,$D,$rk},$R2);
$tk=q#lib/slice::ctors#;
$uk=[$H6,$sk];
$vk=bless({$V1,$jk,$D,$kk,$x2,$uk},$z2);
$wk=q#metaclass::ctors#;
$xk=[$vk];
$yk=bless({$V1,$hk,$D,$ik,$x2,$xk},$z2);
$zk=q#metaclass::ctors#;
$Ak=q#ni:/unix/cat_init.b#;
$Bk=q#ni:/unix/cat_read.b#;
$Ck=q#ni:/unix/exec#;
$Dk={$i4,1};
$Ek={};
$Fk=q#argv#;
$Gk=[];
$Hk=q#shift->{'argv'}#;
$Ik=bless({$o,$Gk,$q,$Hk,$s,$t},$u);
$Jk={$Fk,$Ik};
$Kk=q#/unix/exec_ro.b#;
$Lk=bless({$V1,$Ek,$F2,$G2,$H2,$G2,$I2,$Jk,$D,$Kk},$R2);
$Mk=q#lib/slice::ctors#;
$Nk={};
$Ok=[];
$Pk=q#my ($class, @argv) = @_;
+{argv  => \\@argv,
  env   => {%ENV},
  fds   => {},
  pipes => {}};#;
$Qk=bless({$o,$Ok,$q,$Pk,$s,$t},$u);
$Rk={$Q3,$Qk};
$Sk=q#/unix/exec_init.b#;
$Tk=bless({$V1,$Nk,$F2,$G2,$H2,$G2,$I2,$Rk,$D,$Sk},$R2);
$Uk=q#lib/slice::ctors#;
$Vk={};
$Wk=q#fds#;
$Xk=[];
$Yk=q#my ($self, %fds) = @_;
return $$self{fds} unless keys %fds;
@{$$self{fds}}{keys %fds} = values %fds;
$self;#;
$Zk=bless({$o,$Xk,$q,$Yk,$s,$t},$u);
$cl=q#pipes#;
$dl=[];
$el=q#local $^F = 1024;
my ($self, @fds) = @_;
return $$self{pipes} unless @fds;
for (@fds) {
  die "ni:/unix/exec: must append 'r' or 'w' to extended fds"
    if $_ > 2 && !/^(\\d+)[rw]$/;
  $$self{pipes}{$_} ||= $$self{fds}{$_} = ni("ni:/unix/fifo")->new;
}
$self;#;
$fl=bless({$o,$dl,$q,$el,$s,$t},$u);
$gl=q#setup_stdio#;
$hl=[];
$il=q#my $self = shift;
$self->pipes(grep !exists $$self{fds}{$_}, 0..2);
$self;#;
$jl=bless({$o,$hl,$q,$il,$s,$t},$u);
$kl={$Wk,$Zk,$cl,$fl,$gl,$jl};
$ll=q#/unix/exec_io_setup.b#;
$ml=bless({$V1,$Vk,$F2,$G2,$H2,$G2,$I2,$kl,$D,$ll},$R2);
$nl=q#lib/slice::ctors#;
$ol={};
$pl=q#fd#;
$ql=[];
$rl=q#my ($self, $fd) = @_;
return $$self{pipes}{$fd} if exists $$self{pipes}{$fd};
$self->pipes($fd)->fd($fd);#;
$sl=bless({$o,$ql,$q,$rl,$s,$t},$u);
$tl=q#stderr#;
$ul=[];
$vl=q#shift->fd(2)#;
$wl=bless({$o,$ul,$q,$vl,$s,$t},$u);
$xl=q#stdin#;
$yl=[];
$zl=q#shift->fd(0)#;
$Al=bless({$o,$yl,$q,$zl,$s,$t},$u);
$Bl=q#stdout#;
$Cl=[];
$Dl=q#shift->fd(1)#;
$El=bless({$o,$Cl,$q,$Dl,$s,$t},$u);
$Fl={$pl,$sl,$tl,$wl,$xl,$Al,$Bl,$El};
$Gl=q#/unix/exec_io_accessors.b#;
$Hl=bless({$V1,$ol,$F2,$G2,$H2,$G2,$I2,$Fl,$D,$Gl},$R2);
$Il=q#lib/slice::ctors#;
$Jl={};
$Kl=q#env#;
$Ll=[];
$Ml=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$Nl=bless({$o,$Ll,$q,$Ml,$s,$t},$u);
$Ol={$Kl,$Nl};
$Pl=q#/unix/exec_env.b#;
$Ql=bless({$V1,$Jl,$F2,$G2,$H2,$G2,$I2,$Ol,$D,$Pl},$R2);
$Rl=q#lib/slice::ctors#;
$Sl={};
$Tl=q#exec#;
$Ul=[];
$Vl=q#no warnings 'numeric';
my $self = shift->setup_stdio;
local %ENV = %{$$self{env}};
$self->move_fds;
for (keys %{$$self{pipes}}) {
  my $p = $$self{pipes}{$_};
  ($_ < 2 ? !$_ : /r$/) ? $p->r : $p->w;
}
my @argv = (@{$$self{argv}}, @_);
{ exec @argv };
print STDERR "ni:/unix/exec: exec @argv failed: $!";
exit 1;#;
$Wl=bless({$o,$Ul,$q,$Vl,$s,$t},$u);
$Xl=q#fork#;
$Yl=[];
$Zl=q#no warnings 'numeric';
my $self = shift->setup_stdio;
my $pid = fork;
die "ni:/unix/exec: fork failed: $!" unless defined $pid;
return $self->exec(@_) unless $pid;
for (keys %{$$self{pipes}}) {
  my $p = $$self{pipes}{$_};
  ($_ < 2 ? $_ : /r$/) ? $p->w : $p->r;
}
ni('ni:/unix/pid')->new($pid, %{$$self{pipes}});#;
$cm=bless({$o,$Yl,$q,$Zl,$s,$t},$u);
$dm=q#move_fds#;
$em=[];
$fm=q#my $self = shift;
$$self{fds}{$_}->be($_) for keys %{$$self{fds}};
$self;#;
$gm=bless({$o,$em,$q,$fm,$s,$t},$u);
$hm={$Tl,$Wl,$Xl,$cm,$dm,$gm};
$im=q#/unix/exec_fork.b#;
$jm=bless({$V1,$Sl,$F2,$G2,$H2,$G2,$I2,$hm,$D,$im},$R2);
$km=q#lib/slice::ctors#;
$lm=[$B4,$Lk,$Tk,$ml,$Hl,$Ql,$jm];
$mm=bless({$V1,$Dk,$D,$C1,$x2,$lm},$o2);
$nm=q#unix/exec.c::ctors#;
$om=q#ni:/unix/exec.c#;
$pm={$o2,1};
$qm=q#/unix/exec.c#;
$rm=[$H6];
$sm=bless({$V1,$pm,$D,$qm,$x2,$rm},$z2);
$tm=q#metaclass::ctors#;
$um=q#ni:/unix/exec_env.b#;
$vm=q#ni:/unix/exec_fork.b#;
$wm=q#ni:/unix/exec_init.b#;
$xm=q#ni:/unix/exec_io_accessors.b#;
$ym=q#ni:/unix/exec_io_setup.b#;
$zm=q#ni:/unix/exec_ro.b#;
$Am=q#ni:/unix/fd#;
$Bm={$j4,1};
$Cm=q#/unix/fd#;
$Dm={};
$Em=[];
$Fm=q#shift->{'fd'}#;
$Gm=bless({$o,$Em,$q,$Fm,$s,$t},$u);
$Hm={$pl,$Gm};
$Im=q#/unix/fd_readers.b#;
$Jm=bless({$V1,$Dm,$F2,$G2,$H2,$G2,$I2,$Hm,$D,$Im},$R2);
$Km=q#lib/slice::ctors#;
$Lm={};
$Mm=[];
$Nm=q#my ($class, $fd) = @_;
+{fd => ref $fd ? fileno $fd : $fd,
  fh => ref $fd ? $fd        : undef};#;
$Om=bless({$o,$Mm,$q,$Nm,$s,$t},$u);
$Pm={$Q3,$Om};
$Qm=q#/unix/fd_init.b#;
$Rm=bless({$V1,$Lm,$F2,$G2,$H2,$G2,$I2,$Pm,$D,$Qm},$R2);
$Sm=q#lib/slice::ctors#;
$Tm={};
$Um=q#be#;
$Vm=[];
$Wm=q#use POSIX qw/dup2/;
my ($self, $new) = @_;
return $self if $new == $$self{fd};
close $$self{fh} if Scalar::Util::openhandle $$self{fh};
dup2 $$self{fd}, $new or die "ni:/unix/fd: dup2($$self{fd}, $new): $!";
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$Xm=bless({$o,$Vm,$q,$Wm,$s,$t},$u);
$Ym={$Um,$Xm};
$Zm=q#/unix/fd_shell.b#;
$cn=bless({$V1,$Tm,$F2,$G2,$H2,$G2,$I2,$Ym,$D,$Zm},$R2);
$dn=q#lib/slice::ctors#;
$en={$j4,1,$k4,1,$l4,1,$n4,1,$o4,1};
$fn=q#/unix/has_fd.b#;
$gn={};
$hn=q#read_fd#;
$in=[];
$jn=q#ni("ni:/unix/fd")->new(fileno shift->read_fh)#;
$kn=bless({$o,$in,$q,$jn,$s,$t},$u);
$ln=q#write_fd#;
$mn=[];
$nn=q#ni("ni:/unix/fd")->new(fileno shift->write_fh)#;
$on=bless({$o,$mn,$q,$nn,$s,$t},$u);
$pn={$hn,$kn,$ln,$on};
$qn=q#/unix/fd_accessors.b#;
$rn=bless({$V1,$gn,$F2,$G2,$H2,$G2,$I2,$pn,$D,$qn},$R2);
$sn=q#lib/slice::ctors#;
$tn={};
$un=[];
$vn=q#no warnings 'io';
use Errno qw/EINTR/;
my $fh = shift->read_fh;
my $n;
do {
  return $n if defined($n = read $fh, $_[0], $_[1], $_[2] || 0);
} while $!{EINTR};
return undef;#;
$wn=bless({$o,$un,$q,$vn,$s,$t},$u);
$xn=[];
$yn=q#my $fh = shift->write_fh;
my $n;
do {
  return $n if defined($n = syswrite $fh, $_[0]);
} while $!{EINTR};
return undef;#;
$zn=bless({$o,$xn,$q,$yn,$s,$t},$u);
$An={$Tj,$wn,$fc,$zn};
$Bn=q#/unix/fd_safeio.b#;
$Cn=bless({$V1,$tn,$F2,$G2,$H2,$G2,$I2,$An,$D,$Bn},$R2);
$Dn=q#lib/slice::ctors#;
$En=[$rn,$Cn];
$Fn=bless({$V1,$en,$D,$fn,$x2,$En},$T2);
$Gn=q#lib/branch::ctors#;
$Hn={};
$In=q#read_fh#;
$Jn=[];
$Kn=q#my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, '<&=', $$self{fd}
  or die "ni:/unix/fd $$self{fd} failed to read: $!";
$self->{fh} = $fh;#;
$Ln=bless({$o,$Jn,$q,$Kn,$s,$t},$u);
$Mn=q#write_fh#;
$Nn=[];
$On=q#my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, '>&=', $$self{fd}
  or die "ni:/unix/file $$self{fd} failed to write: $!";
$self->{fh} = $fh;#;
$Pn=bless({$o,$Nn,$q,$On,$s,$t},$u);
$Qn={$In,$Ln,$Mn,$Pn};
$Rn=q#/unix/fd_io.b#;
$Sn=bless({$V1,$Hn,$F2,$G2,$H2,$G2,$I2,$Qn,$D,$Rn},$R2);
$Tn=q#lib/slice::ctors#;
$Un=[$Ij,$Jm,$Rm,$cn,$Fn,$Sn];
$Vn=bless({$V1,$Bm,$D,$Cm,$x2,$Un},$p2);
$Wn=q#unix/fd.c::ctors#;
$Xn=q#ni:/unix/fd.c#;
$Yn={$p2,1};
$Zn=q#/unix/fd.c#;
$co=[$vk];
$do=bless({$V1,$Yn,$D,$Zn,$x2,$co},$z2);
$eo=q#metaclass::ctors#;
$fo=q#ni:/unix/fd_accessors.b#;
$go=q#ni:/unix/fd_init.b#;
$ho=q#ni:/unix/fd_io.b#;
$io=q#ni:/unix/fd_readers.b#;
$jo=q#ni:/unix/fd_safeio.b#;
$ko=q#ni:/unix/fd_shell.b#;
$lo=q#ni:/unix/fifo#;
$mo={$k4,1};
$no=q#/unix/fifo#;
$oo={};
$po=[];
$qo=q#shift->{'read_fh'}#;
$ro=bless({$o,$po,$q,$qo,$s,$t},$u);
$so=[];
$to=q#shift->{'write_fh'}#;
$uo=bless({$o,$so,$q,$to,$s,$t},$u);
$vo={$In,$ro,$Mn,$uo};
$wo=q#/unix/fifo_io.b#;
$xo=bless({$V1,$oo,$F2,$G2,$H2,$G2,$I2,$vo,$D,$wo},$R2);
$yo=q#lib/slice::ctors#;
$zo={};
$Ao=[];
$Bo=q#my ($class) = @_;
pipe my ($r, $w) or die "ni:/unix/fifo failed: $!";
+{read_fh => $r, write_fh => $w};#;
$Co=bless({$o,$Ao,$q,$Bo,$s,$t},$u);
$Do={$Q3,$Co};
$Eo=q#/unix/fifo_init.b#;
$Fo=bless({$V1,$zo,$F2,$G2,$H2,$G2,$I2,$Do,$D,$Eo},$R2);
$Go=q#lib/slice::ctors#;
$Ho={};
$Io=[];
$Jo=q#my ($self, $fd) = @_;
(!$fd || $fd > 2 && $fd =~ s/[rw]$// && $1 eq 'r'
  ? $self->r
  : $self->w)->be($fd);
$self;#;
$Ko=bless({$o,$Io,$q,$Jo,$s,$t},$u);
$Lo={$Um,$Ko};
$Mo=q#/unix/fifo_stdio.b#;
$No=bless({$V1,$Ho,$F2,$G2,$H2,$G2,$I2,$Lo,$D,$Mo},$R2);
$Oo=q#lib/slice::ctors#;
$Po={};
$Qo=q#r#;
$Ro=[];
$So=q#my $self = shift;
close $$self{write_fh};
$self->read_fd;#;
$To=bless({$o,$Ro,$q,$So,$s,$t},$u);
$Uo=q#w#;
$Vo=[];
$Wo=q#my $self = shift;
close $$self{read_fh};
$self->write_fd;#;
$Xo=bless({$o,$Vo,$q,$Wo,$s,$t},$u);
$Yo={$Qo,$To,$Uo,$Xo};
$Zo=q#/unix/fifo_direction.b#;
$cp=bless({$V1,$Po,$F2,$G2,$H2,$G2,$I2,$Yo,$D,$Zo},$R2);
$dp=q#lib/slice::ctors#;
$ep=[$Ij,$xo,$Fo,$No,$Fn,$cp];
$fp=bless({$V1,$mo,$D,$no,$x2,$ep},$q2);
$gp=q#unix/fifo.c::ctors#;
$hp=q#ni:/unix/fifo.c#;
$ip={$q2,1};
$jp=q#/unix/fifo.c#;
$kp=[$vk];
$lp=bless({$V1,$ip,$D,$jp,$x2,$kp},$z2);
$mp=q#metaclass::ctors#;
$np=q#ni:/unix/fifo_direction.b#;
$op=q#ni:/unix/fifo_init.b#;
$pp=q#ni:/unix/fifo_io.b#;
$qp=q#ni:/unix/fifo_stdio.b#;
$rp=q#ni:/unix/file#;
$sp={$l4,1};
$tp=q#/unix/file#;
$up={};
$vp=[];
$wp=q#shift->{'name'}#;
$xp=bless({$o,$vp,$q,$wp,$s,$t},$u);
$yp={$D,$xp};
$zp=q#/unix/file_readers.b#;
$Ap=bless({$V1,$up,$F2,$G2,$H2,$G2,$I2,$yp,$D,$zp},$R2);
$Bp=q#lib/slice::ctors#;
$Cp={};
$Dp=[];
$Ep=q#my ($class, $name) = @_;
+{name => $name, fh => undef};#;
$Fp=bless({$o,$Dp,$q,$Ep,$s,$t},$u);
$Gp={$Q3,$Fp};
$Hp=q#/unix/file_init.b#;
$Ip=bless({$V1,$Cp,$F2,$G2,$H2,$G2,$I2,$Gp,$D,$Hp},$R2);
$Jp=q#lib/slice::ctors#;
$Kp={};
$Lp=[];
$Mp=q#my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, '<', $self->{name}
  or die "ni:/unix/file $self->{name} failed to read: $!";
$self->{fh} = $fh;#;
$Np=bless({$o,$Lp,$q,$Mp,$s,$t},$u);
$Op=[];
$Pp=q#my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, '>', $self->{name}
  or die "ni:/unix/file $self->{name} failed to write: $!";
$self->{fh} = $fh;#;
$Qp=bless({$o,$Op,$q,$Pp,$s,$t},$u);
$Rp={$In,$Np,$Mn,$Qp};
$Sp=q#/unix/file_io.b#;
$Tp=bless({$V1,$Kp,$F2,$G2,$H2,$G2,$I2,$Rp,$D,$Sp},$R2);
$Up=q#lib/slice::ctors#;
$Vp=[$Ij,$Ap,$Ip,$Fn,$Tp];
$Wp=bless({$V1,$sp,$D,$tp,$x2,$Vp},$r2);
$Xp=q#unix/file.c::ctors#;
$Yp=q#ni:/unix/file.c#;
$Zp={$r2,1};
$cq=q#/unix/file.c#;
$dq=[$vk];
$eq=bless({$V1,$Zp,$D,$cq,$x2,$dq},$z2);
$fq=q#metaclass::ctors#;
$gq=q#ni:/unix/file_init.b#;
$hq=q#ni:/unix/file_io.b#;
$iq=q#ni:/unix/file_readers.b#;
$jq=q#ni:/unix/has_fd.b#;
$kq=q#ni:/unix/io#;
$lq=q#ni:/unix/io.c#;
$mq=q#ni:/unix/io.c_has_fd.b#;
$nq=q#ni:/unix/io_constructors.b#;
$oq=q#ni:/unix/io_memory.b#;
$pq=q#ni:/unix/io_ops.b#;
$qq=q#ni:/unix/io_stream.b#;
$rq=q#ni:/unix/pid#;
$sq={$n4,1};
$tq={};
$uq=q#pid#;
$vq=[];
$wq=q#shift->{'pid'}#;
$xq=bless({$o,$vq,$q,$wq,$s,$t},$u);
$yq=q#status#;
$zq=[];
$Aq=q#shift->{'status'}#;
$Bq=bless({$o,$zq,$q,$Aq,$s,$t},$u);
$Cq={$uq,$xq,$yq,$Bq};
$Dq=q#/unix/pid_readers.b#;
$Eq=bless({$V1,$tq,$F2,$G2,$H2,$G2,$I2,$Cq,$D,$Dq},$R2);
$Fq=q#lib/slice::ctors#;
$Gq={};
$Hq=[];
$Iq=q#shift->await#;
$Jq=bless({$o,$Hq,$q,$Iq,$s,$t},$u);
$Kq=[];
$Lq=q#my ($class, $pid, %exposed_fds) = @_;
+{pid    => $pid,
  fds    => \\%exposed_fds,
  status => undef};#;
$Mq=bless({$o,$Kq,$q,$Lq,$s,$t},$u);
$Nq={$Q3,$Mq};
$Oq=q#/unix/pid_init.b#;
$Pq=bless({$V1,$Gq,$F2,$G2,$H2,$Jq,$I2,$Nq,$D,$Oq},$R2);
$Qq=q#lib/slice::ctors#;
$Rq={};
$Sq=q#await#;
$Tq=[];
$Uq=q#my $self = shift;
return $$self{status} if defined $$self{status};
defined(waitpid $$self{pid}, 0)
  ? $$self{status} = $?
  : die "/unix/pid_wait.b: waitpid: $!";#;
$Vq=bless({$o,$Tq,$q,$Uq,$s,$t},$u);
$Wq=q#running#;
$Xq=[];
$Yq=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$Zq=bless({$o,$Xq,$q,$Yq,$s,$t},$u);
$cr={$Sq,$Vq,$Wq,$Zq};
$dr=q#/unix/pid_wait.b#;
$er=bless({$V1,$Rq,$F2,$G2,$H2,$G2,$I2,$cr,$D,$dr},$R2);
$fr=q#lib/slice::ctors#;
$gr={};
$hr=[];
$ir=q#shift->fd(1)->read_fh#;
$jr=bless({$o,$hr,$q,$ir,$s,$t},$u);
$kr=[];
$lr=q#shift->fd(0)->write_fh#;
$mr=bless({$o,$kr,$q,$lr,$s,$t},$u);
$nr={$In,$jr,$Mn,$mr};
$or=q#/unix/pid_io.b#;
$pr=bless({$V1,$gr,$F2,$G2,$H2,$G2,$I2,$nr,$D,$or},$R2);
$qr=q#lib/slice::ctors#;
$rr={};
$sr=[];
$tr=q#$_[0]->{fds}{$_[1]}#;
$ur=bless({$o,$sr,$q,$tr,$s,$t},$u);
$vr=[];
$wr=bless({$o,$vr,$q,$vl,$s,$t},$u);
$xr=[];
$yr=bless({$o,$xr,$q,$zl,$s,$t},$u);
$zr=[];
$Ar=bless({$o,$zr,$q,$Dl,$s,$t},$u);
$Br={$pl,$ur,$tl,$wr,$xl,$yr,$Bl,$Ar};
$Cr=q#/unix/pid_accessors.b#;
$Dr=bless({$V1,$rr,$F2,$G2,$H2,$G2,$I2,$Br,$D,$Cr},$R2);
$Er=q#lib/slice::ctors#;
$Fr=[$Ij,$Eq,$Pq,$er,$Fn,$pr,$Dr];
$Gr=bless({$V1,$sq,$D,$S1,$x2,$Fr},$t2);
$Hr=q#unix/pid.c::ctors#;
$Ir=q#ni:/unix/pid.c#;
$Jr={$t2,1};
$Kr=q#/unix/pid.c#;
$Lr=[$vk];
$Mr=bless({$V1,$Jr,$D,$Kr,$x2,$Lr},$z2);
$Nr=q#metaclass::ctors#;
$Or=q#ni:/unix/pid_accessors.b#;
$Pr=q#ni:/unix/pid_init.b#;
$Qr=q#ni:/unix/pid_io.b#;
$Rr=q#ni:/unix/pid_readers.b#;
$Sr=q#ni:/unix/pid_wait.b#;
$Tr=q#ni:/unix/pipeline#;
$Ur={$o4,1};
$Vr=q#/unix/pipeline#;
$Wr={};
$Xr=[];
$Yr=q#shift->{'stdin'}#;
$Zr=bless({$o,$Xr,$q,$Yr,$s,$t},$u);
$cs=[];
$ds=q#shift->{'stdout'}#;
$es=bless({$o,$cs,$q,$ds,$s,$t},$u);
$fs={$xl,$Zr,$Bl,$es};
$gs=q#/unix/pipeline_ro.b#;
$hs=bless({$V1,$Wr,$F2,$G2,$H2,$G2,$I2,$fs,$D,$gs},$R2);
$is=q#lib/slice::ctors#;
$js={};
$ks=[];
$ls=q#my $class  = shift;
my $stdin  = ni('ni:/unix/fifo')->new;
my $stdout = ni('ni:/unix/fifo')->new;
\# TODO: stderr and multiplexing, which probably happens here

my @rs = ($stdin, @_);
my @ws = (@_, $stdout);
my $rv; vec($rv, fileno $_->read_fh,  1) = 1 for @rs;
my $wv; vec($wv, fileno $_->write_fh, 1) = 1 for @ws;

+{ps     => [@_],
  stdin  => $stdin,
  stdout => $stdout,
  rs => \\@rs, rv => $rv,
  ws => \\@ws, wv => $wv};#;
$ms=bless({$o,$ks,$q,$ls,$s,$t},$u);
$ns={$Q3,$ms};
$os=q#/unix/pipeline_init.b#;
$ps=bless({$V1,$js,$F2,$G2,$H2,$G2,$I2,$ns,$D,$os},$R2);
$qs=q#lib/slice::ctors#;
$rs={};
$ss=q#async_step#;
$ts=[];
$us=q#local $_;
my $self = shift;
my $rv = $$self{rv};
my $wv = $$self{wv};
my $ev = $$self{ev};
return $self unless select $rv, $wv, $ev, 0;
for my $i (0..$\#{$$self{rs}}) {
  my $rfh = $$self{rs}[$i]->read_fh;
  my $wfh = $$self{ws}[$i]->write_fh;
  next unless vec $rv, fileno $rfh, 1 and vec $wv, fileno $wfh, 1;
  $$self{rs}[$i]->read($_, 8192);
  $$self{ws}[$i]->write($_);
}
$self;#;
$vs=bless({$o,$ts,$q,$us,$s,$t},$u);
$ws={$ss,$vs};
$xs=q#/unix/pipeline_async.b#;
$ys=bless({$V1,$rs,$F2,$G2,$H2,$G2,$I2,$ws,$D,$xs},$R2);
$zs=q#lib/slice::ctors#;
$As={};
$Bs=[];
$Cs=q#shift->{stdout}->read_fh#;
$Ds=bless({$o,$Bs,$q,$Cs,$s,$t},$u);
$Es=[];
$Fs=q#shift->{stdin}->write_fh#;
$Gs=bless({$o,$Es,$q,$Fs,$s,$t},$u);
$Hs={$In,$Ds,$Mn,$Gs};
$Is=q#/unix/pipeline_io.b#;
$Js=bless({$V1,$As,$F2,$G2,$H2,$G2,$I2,$Hs,$D,$Is},$R2);
$Ks=q#lib/slice::ctors#;
$Ls=[$Ij,$hs,$ps,$ys,$Fn,$Js];
$Ms=bless({$V1,$Ur,$D,$Vr,$x2,$Ls},$u2);
$Ns=q#unix/pipeline.c::ctors#;
$Os=q#ni:/unix/pipeline.c#;
$Ps={$u2,1};
$Qs=q#/unix/pipeline.c#;
$Rs=[$vk];
$Ss=bless({$V1,$Ps,$D,$Qs,$x2,$Rs},$z2);
$Ts=q#metaclass::ctors#;
$Us=q#ni:/unix/pipeline_async.b#;
$Vs=q#ni:/unix/pipeline_init.b#;
$Ws=q#ni:/unix/pipeline_io.b#;
$Xs=q#ni:/unix/pipeline_ro.b#;
$Ys=q#ni:/unix/str#;
$Zs={$p4,1};
$ct=q#/unix/str#;
$dt={};
$et=q#data#;
$ft=[];
$gt=q#shift->{'data'}#;
$ht=bless({$o,$ft,$q,$gt,$s,$t},$u);
$it=q#end#;
$jt=[];
$kt=q#shift->{'end'}#;
$lt=bless({$o,$jt,$q,$kt,$s,$t},$u);
$mt=q#start#;
$nt=[];
$ot=q#shift->{'start'}#;
$pt=bless({$o,$nt,$q,$ot,$s,$t},$u);
$qt={$et,$ht,$it,$lt,$mt,$pt};
$rt=q#/unix/str_ro.b#;
$st=bless({$V1,$dt,$F2,$G2,$H2,$G2,$I2,$qt,$D,$rt},$R2);
$tt=q#lib/slice::ctors#;
$ut={};
$vt=[];
$wt=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$xt=bless({$o,$vt,$q,$wt,$s,$t},$u);
$yt={$Q3,$xt};
$zt=q#/unix/str_init.b#;
$At=bless({$V1,$ut,$F2,$G2,$H2,$G2,$I2,$yt,$D,$zt},$R2);
$Bt=q#lib/slice::ctors#;
$Ct={};
$Dt=[];
$Et=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$Ft=bless({$o,$Dt,$q,$Et,$s,$t},$u);
$Gt=q#remaining#;
$Ht=[];
$It=q#my $self = shift; $$self{end} - $$self{start}#;
$Jt=bless({$o,$Ht,$q,$It,$s,$t},$u);
$Kt=[];
$Lt=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$Mt=bless({$o,$Kt,$q,$Lt,$s,$t},$u);
$Nt={$Tj,$Ft,$Gt,$Jt,$fc,$Mt};
$Ot=q#/unix/str_io.b#;
$Pt=bless({$V1,$Ct,$F2,$G2,$H2,$G2,$I2,$Nt,$D,$Ot},$R2);
$Qt=q#lib/slice::ctors#;
$Rt=[$Ij,$st,$At,$Pt];
$St=bless({$V1,$Zs,$D,$ct,$x2,$Rt},$v2);
$Tt=q#unix/str.c::ctors#;
$Ut=q#ni:/unix/str.c#;
$Vt={$v2,1};
$Wt=q#/unix/str.c#;
$Xt=[$vk];
$Yt=bless({$V1,$Vt,$D,$Wt,$x2,$Xt},$z2);
$Zt=q#metaclass::ctors#;
$cu=q#ni:/unix/str_init.b#;
$du=q#ni:/unix/str_io.b#;
$eu=q#ni:/unix/str_ro.b#;
$fu=q#ni:main#;
$gu={$xa,1};
$hu=[$Zg,$wa];
$iu=bless({$V1,$gu,$D,$xa,$x2,$hu},$A2);
$ju=q#module::ctors#;
$ku=q#ni:ni#;
$lu={$Zc,1};
$mu={$Zc,1};
$nu=q#json_escapes#;
$ou=q##;
$pu=q#b#;
$qu=q#	#;
$ru=q#t#;
$su=q#
#;
$tu=q#n#;
$uu=q##;
$vu=q#"#;
$wu=q#/#;
$xu=q#\\#;
$yu={$ou,$pu,$qu,$ru,$su,$tu,$uu,$Qo,$vu,$vu,$wu,$wu,$xu,$xu};
$zu=q#json_unescapes#;
$Au={$vu,$vu,$wu,$wu,$xu,$xu,$pu,$ou,$tu,$su,$Qo,$uu,$ru,$qu};
$Bu={$nu,$yu,$zu,$Au};
$Cu=q#/lib/json_data.b#;
$Du=bless({$V1,$mu,$et,$Bu,$D,$Cu},$Z3);
$Eu=q#lib/dataslice::ctors#;
$Fu=[$Du,$Yc,$Qf];
$Gu=bless({$V1,$lu,$D,$Zc,$x2,$Fu},$A2);
$Hu={$d,$G,$I,$X,$Y,$f1,$g1,$r1,$s1,$D1,$E1,$T1,$U1,$w6,$y6,$S6,$U6,$o5,$V6,$P4,$W6,$M6,$X6,$k7,$m7,$S2,$n7,$r7,$t7,$h7,$u7,$V3,$v7,$N7,$P7,$T7,$V7,$K7,$W7,$D7,$X7,$T5,$Y7,$c5,$Z7,$P5,$c8,$L8,$N8,$R8,$T8,$y8,$U8,$j8,$V8,$q8,$W8,$I8,$X8,$L4,$Y8,$Z9,$da,$ha,$ja,$n9,$ka,$N9,$la,$C9,$ma,$W9,$na,$wa,$za,$oc,$qc,$uc,$wc,$Ia,$xc,$lc,$yc,$x4,$zc,$j6,$Ac,$Yc,$dd,$x5,$ed,$f3,$fd,$p3,$gd,$y3,$hd,$Ce,$Ee,$Ie,$Ke,$Md,$Le,$ne,$Me,$ze,$Ne,$zd,$Oe,$Qf,$Sf,$L3,$Tf,$G5,$Uf,$H3,$Vf,$Cg,$Eg,$kg,$Fg,$Jg,$Lg,$rg,$Mg,$zg,$Ng,$Zg,$dh,$s6,$eh,$wh,$yh,$mh,$zh,$Dh,$Fh,$th,$Gh,$qi,$si,$xi,$zi,$ei,$Ai,$Ph,$Bi,$mi,$Ci,$Gi,$Ii,$Mi,$Oi,$W5,$Pi,$P6,$Qi,$B4,$Ri,$H6,$Si,$ek,$gk,$yk,$Ak,$Qj,$Bk,$Zj,$Ck,$mm,$om,$sm,$um,$Ql,$vm,$jm,$wm,$Tk,$xm,$Hl,$ym,$ml,$zm,$Lk,$Am,$Vn,$Xn,$do,$fo,$rn,$go,$Rm,$ho,$Sn,$io,$Jm,$jo,$Cn,$ko,$cn,$lo,$fp,$hp,$lp,$np,$cp,$op,$Fo,$pp,$xo,$qp,$No,$rp,$Wp,$Yp,$eq,$gq,$Ip,$hq,$Tp,$iq,$Ap,$jq,$Fn,$kq,$Ij,$lq,$vk,$mq,$sk,$nq,$wj,$oq,$Fj,$pq,$ej,$qq,$nj,$rq,$Gr,$Ir,$Mr,$Or,$Dr,$Pr,$Pq,$Qr,$pr,$Rr,$Eq,$Sr,$er,$Tr,$Ms,$Os,$Ss,$Us,$ys,$Vs,$ps,$Ws,$Js,$Xs,$hs,$Ys,$St,$Ut,$Yt,$cu,$At,$du,$Pt,$eu,$st,$fu,$iu,$ku,$Gu};
$Iu=q#resolvers#;
$Ju=[];
$Ku=q#ni('ni:/unix/fd')->new(0 + substr shift, 3)#;
$Lu=bless({$o,$Ju,$q,$Ku,$s,$t},$u);
$Mu=q#file#;
$Nu=[];
$Ou=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/unix/file')->new($f);#;
$Pu=bless({$o,$Nu,$q,$Ou,$s,$t},$u);
$Qu=q#sh#;
$Ru=[];
$Su=q#ni('ni:/unix/exec')->new('/bin/sh', '-c', substr shift, 3)->fork;#;
$Tu=bless({$o,$Ru,$q,$Su,$s,$t},$u);
$Uu=q#str#;
$Vu=[];
$Wu=q#my $s = shift;
ni('ni:/unix/str')->new(substr($s, 4) . "\\n");#;
$Xu=bless({$o,$Vu,$q,$Wu,$s,$t},$u);
$Yu={$pl,$Lu,$Mu,$Pu,$Qu,$Tu,$Uu,$Xu};
$Zu=bless({$c,$Hu,$Iu,$Yu},$d4);
$cv=q#lib/ni::ctors#;
*$fg=\&$dg;
*$eg=\&$Zf;
$S2->apply_unsafe($W1);
$S2->apply_unsafe($X1);
$S2->apply_unsafe($Y1);
$S2->apply_unsafe($T2);
$S2->apply_unsafe($Z1);
$S2->apply_unsafe($c2);
$S2->apply_unsafe($d2);
$S2->apply_unsafe($e2);
$S2->apply_unsafe($f2);
$S2->apply_unsafe($g2);
$S2->apply_unsafe($h2);
$S2->apply_unsafe($i2);
$S2->apply_unsafe($U2);
$S2->apply_unsafe($z2);
$S2->apply_unsafe($k2);
$S2->apply_unsafe($A2);
$S2->apply_unsafe($l2);
$S2->apply_unsafe($m2);
$S2->apply_unsafe($n2);
$S2->apply_unsafe($o2);
$S2->apply_unsafe($p2);
$S2->apply_unsafe($q2);
$S2->apply_unsafe($r2);
$S2->apply_unsafe($s2);
$S2->apply_unsafe($t2);
$S2->apply_unsafe($u2);
$S2->apply_unsafe($v2);
$f3->apply_unsafe($W1);
$f3->apply_unsafe($X1);
$f3->apply_unsafe($Y1);
$f3->apply_unsafe($T2);
$f3->apply_unsafe($Z1);
$f3->apply_unsafe($c2);
$f3->apply_unsafe($F);
$f3->apply_unsafe($d2);
$f3->apply_unsafe($e2);
$f3->apply_unsafe($f2);
$f3->apply_unsafe($g2);
$f3->apply_unsafe($R2);
$f3->apply_unsafe($h2);
$f3->apply_unsafe($g3);
$f3->apply_unsafe($i2);
$f3->apply_unsafe($h3);
$f3->apply_unsafe($z2);
$f3->apply_unsafe($k2);
$f3->apply_unsafe($A2);
$f3->apply_unsafe($l2);
$f3->apply_unsafe($m2);
$f3->apply_unsafe($n2);
$f3->apply_unsafe($o2);
$f3->apply_unsafe($p2);
$f3->apply_unsafe($q2);
$f3->apply_unsafe($r2);
$f3->apply_unsafe($s2);
$f3->apply_unsafe($t2);
$f3->apply_unsafe($u2);
$f3->apply_unsafe($v2);
$p3->apply_unsafe($W1);
$p3->apply_unsafe($X1);
$p3->apply_unsafe($Y1);
$p3->apply_unsafe($T2);
$p3->apply_unsafe($Z1);
$p3->apply_unsafe($c2);
$p3->apply_unsafe($d2);
$p3->apply_unsafe($e2);
$p3->apply_unsafe($f2);
$p3->apply_unsafe($g2);
$p3->apply_unsafe($R2);
$p3->apply_unsafe($h2);
$p3->apply_unsafe($g3);
$p3->apply_unsafe($i2);
$p3->apply_unsafe($q3);
$p3->apply_unsafe($z2);
$p3->apply_unsafe($k2);
$p3->apply_unsafe($A2);
$p3->apply_unsafe($l2);
$p3->apply_unsafe($m2);
$p3->apply_unsafe($n2);
$p3->apply_unsafe($o2);
$p3->apply_unsafe($p2);
$p3->apply_unsafe($q2);
$p3->apply_unsafe($r2);
$p3->apply_unsafe($s2);
$p3->apply_unsafe($t2);
$p3->apply_unsafe($u2);
$p3->apply_unsafe($v2);
$y3->apply_unsafe($W1);
$y3->apply_unsafe($X1);
$y3->apply_unsafe($Y1);
$y3->apply_unsafe($T2);
$y3->apply_unsafe($Z1);
$y3->apply_unsafe($c2);
$y3->apply_unsafe($d2);
$y3->apply_unsafe($e2);
$y3->apply_unsafe($f2);
$y3->apply_unsafe($g2);
$y3->apply_unsafe($R2);
$y3->apply_unsafe($h2);
$y3->apply_unsafe($g3);
$y3->apply_unsafe($i2);
$y3->apply_unsafe($z3);
$y3->apply_unsafe($z2);
$y3->apply_unsafe($k2);
$y3->apply_unsafe($A2);
$y3->apply_unsafe($l2);
$y3->apply_unsafe($m2);
$y3->apply_unsafe($n2);
$y3->apply_unsafe($o2);
$y3->apply_unsafe($p2);
$y3->apply_unsafe($q2);
$y3->apply_unsafe($r2);
$y3->apply_unsafe($s2);
$y3->apply_unsafe($t2);
$y3->apply_unsafe($u2);
$y3->apply_unsafe($v2);
$H3->apply_unsafe($W1);
$H3->apply_unsafe($X1);
$H3->apply_unsafe($Y1);
$H3->apply_unsafe($T2);
$H3->apply_unsafe($Z1);
$H3->apply_unsafe($c2);
$H3->apply_unsafe($d2);
$H3->apply_unsafe($e2);
$H3->apply_unsafe($f2);
$H3->apply_unsafe($g2);
$H3->apply_unsafe($h2);
$H3->apply_unsafe($g3);
$H3->apply_unsafe($i2);
$H3->apply_unsafe($I3);
$H3->apply_unsafe($z2);
$H3->apply_unsafe($k2);
$H3->apply_unsafe($A2);
$H3->apply_unsafe($l2);
$H3->apply_unsafe($m2);
$H3->apply_unsafe($n2);
$H3->apply_unsafe($o2);
$H3->apply_unsafe($p2);
$H3->apply_unsafe($q2);
$H3->apply_unsafe($r2);
$H3->apply_unsafe($s2);
$H3->apply_unsafe($t2);
$H3->apply_unsafe($u2);
$H3->apply_unsafe($v2);
$V3->apply_unsafe($W1);
$V3->apply_unsafe($X1);
$V3->apply_unsafe($Y1);
$V3->apply_unsafe($Z1);
$V3->apply_unsafe($c2);
$V3->apply_unsafe($d2);
$V3->apply_unsafe($e2);
$V3->apply_unsafe($f2);
$V3->apply_unsafe($g2);
$V3->apply_unsafe($h2);
$V3->apply_unsafe($i2);
$V3->apply_unsafe($W3);
$V3->apply_unsafe($z2);
$V3->apply_unsafe($k2);
$V3->apply_unsafe($A2);
$V3->apply_unsafe($l2);
$V3->apply_unsafe($m2);
$V3->apply_unsafe($n2);
$V3->apply_unsafe($o2);
$V3->apply_unsafe($p2);
$V3->apply_unsafe($q2);
$V3->apply_unsafe($r2);
$V3->apply_unsafe($s2);
$V3->apply_unsafe($t2);
$V3->apply_unsafe($u2);
$V3->apply_unsafe($v2);
$x4->apply_unsafe($W1);
$x4->apply_unsafe($X1);
$x4->apply_unsafe($Y3);
$x4->apply_unsafe($Y1);
$x4->apply_unsafe($T2);
$x4->apply_unsafe($Z1);
$x4->apply_unsafe($Z3);
$x4->apply_unsafe($c2);
$x4->apply_unsafe($F);
$x4->apply_unsafe($d2);
$x4->apply_unsafe($u);
$x4->apply_unsafe($e2);
$x4->apply_unsafe($c4);
$x4->apply_unsafe($f2);
$x4->apply_unsafe($d4);
$x4->apply_unsafe($g2);
$x4->apply_unsafe($R2);
$x4->apply_unsafe($h2);
$x4->apply_unsafe($g3);
$x4->apply_unsafe($i2);
$x4->apply_unsafe($e4);
$x4->apply_unsafe($y4);
$x4->apply_unsafe($z2);
$x4->apply_unsafe($k2);
$x4->apply_unsafe($A2);
$x4->apply_unsafe($l2);
$x4->apply_unsafe($g4);
$x4->apply_unsafe($m2);
$x4->apply_unsafe($h4);
$x4->apply_unsafe($n2);
$x4->apply_unsafe($i4);
$x4->apply_unsafe($o2);
$x4->apply_unsafe($j4);
$x4->apply_unsafe($p2);
$x4->apply_unsafe($k4);
$x4->apply_unsafe($q2);
$x4->apply_unsafe($l4);
$x4->apply_unsafe($r2);
$x4->apply_unsafe($m4);
$x4->apply_unsafe($s2);
$x4->apply_unsafe($n4);
$x4->apply_unsafe($t2);
$x4->apply_unsafe($o4);
$x4->apply_unsafe($u2);
$x4->apply_unsafe($p4);
$x4->apply_unsafe($v2);
$L4->apply_unsafe($W1);
$L4->apply_unsafe($X1);
$L4->apply_unsafe($Y3);
$L4->apply_unsafe($Y1);
$L4->apply_unsafe($T2);
$L4->apply_unsafe($Z1);
$L4->apply_unsafe($Z3);
$L4->apply_unsafe($c2);
$L4->apply_unsafe($d2);
$L4->apply_unsafe($e2);
$L4->apply_unsafe($f2);
$L4->apply_unsafe($g2);
$L4->apply_unsafe($R2);
$L4->apply_unsafe($h2);
$L4->apply_unsafe($g3);
$L4->apply_unsafe($i2);
$L4->apply_unsafe($M4);
$L4->apply_unsafe($z2);
$L4->apply_unsafe($k2);
$L4->apply_unsafe($A2);
$L4->apply_unsafe($l2);
$L4->apply_unsafe($m2);
$L4->apply_unsafe($n2);
$L4->apply_unsafe($o2);
$L4->apply_unsafe($p2);
$L4->apply_unsafe($q2);
$L4->apply_unsafe($r2);
$L4->apply_unsafe($s2);
$L4->apply_unsafe($t2);
$L4->apply_unsafe($u2);
$L4->apply_unsafe($v2);
$c5->apply_unsafe($W1);
$c5->apply_unsafe($X1);
$c5->apply_unsafe($Y1);
$c5->apply_unsafe($T2);
$c5->apply_unsafe($Z1);
$c5->apply_unsafe($c2);
$c5->apply_unsafe($d2);
$c5->apply_unsafe($e2);
$c5->apply_unsafe($f2);
$c5->apply_unsafe($g2);
$c5->apply_unsafe($h2);
$c5->apply_unsafe($i2);
$c5->apply_unsafe($d5);
$c5->apply_unsafe($z2);
$c5->apply_unsafe($k2);
$c5->apply_unsafe($A2);
$c5->apply_unsafe($l2);
$c5->apply_unsafe($m2);
$c5->apply_unsafe($n2);
$c5->apply_unsafe($o2);
$c5->apply_unsafe($p2);
$c5->apply_unsafe($q2);
$c5->apply_unsafe($r2);
$c5->apply_unsafe($s2);
$c5->apply_unsafe($t2);
$c5->apply_unsafe($u2);
$c5->apply_unsafe($v2);
$o5->apply_unsafe($W1);
$o5->apply_unsafe($X1);
$o5->apply_unsafe($Y1);
$o5->apply_unsafe($T2);
$o5->apply_unsafe($Z1);
$o5->apply_unsafe($c2);
$o5->apply_unsafe($d2);
$o5->apply_unsafe($e2);
$o5->apply_unsafe($f2);
$o5->apply_unsafe($g2);
$o5->apply_unsafe($h2);
$o5->apply_unsafe($i2);
$o5->apply_unsafe($p5);
$o5->apply_unsafe($z2);
$o5->apply_unsafe($k2);
$o5->apply_unsafe($A2);
$o5->apply_unsafe($l2);
$o5->apply_unsafe($m2);
$o5->apply_unsafe($n2);
$o5->apply_unsafe($o2);
$o5->apply_unsafe($p2);
$o5->apply_unsafe($q2);
$o5->apply_unsafe($r2);
$o5->apply_unsafe($s2);
$o5->apply_unsafe($t2);
$o5->apply_unsafe($u2);
$o5->apply_unsafe($v2);
$x5->apply_unsafe($W1);
$x5->apply_unsafe($X1);
$x5->apply_unsafe($Y1);
$x5->apply_unsafe($T2);
$x5->apply_unsafe($Z1);
$x5->apply_unsafe($c2);
$x5->apply_unsafe($d2);
$x5->apply_unsafe($e2);
$x5->apply_unsafe($f2);
$x5->apply_unsafe($g2);
$x5->apply_unsafe($h2);
$x5->apply_unsafe($i2);
$x5->apply_unsafe($y5);
$x5->apply_unsafe($z2);
$x5->apply_unsafe($k2);
$x5->apply_unsafe($A2);
$x5->apply_unsafe($l2);
$x5->apply_unsafe($m2);
$x5->apply_unsafe($n2);
$x5->apply_unsafe($o2);
$x5->apply_unsafe($p2);
$x5->apply_unsafe($q2);
$x5->apply_unsafe($r2);
$x5->apply_unsafe($s2);
$x5->apply_unsafe($t2);
$x5->apply_unsafe($u2);
$x5->apply_unsafe($v2);
$G5->apply_unsafe($W1);
$G5->apply_unsafe($X1);
$G5->apply_unsafe($Y1);
$G5->apply_unsafe($T2);
$G5->apply_unsafe($Z1);
$G5->apply_unsafe($c2);
$G5->apply_unsafe($d2);
$G5->apply_unsafe($e2);
$G5->apply_unsafe($f2);
$G5->apply_unsafe($g2);
$G5->apply_unsafe($h2);
$G5->apply_unsafe($i2);
$G5->apply_unsafe($H5);
$G5->apply_unsafe($z2);
$G5->apply_unsafe($k2);
$G5->apply_unsafe($A2);
$G5->apply_unsafe($l2);
$G5->apply_unsafe($m2);
$G5->apply_unsafe($n2);
$G5->apply_unsafe($o2);
$G5->apply_unsafe($p2);
$G5->apply_unsafe($q2);
$G5->apply_unsafe($r2);
$G5->apply_unsafe($s2);
$G5->apply_unsafe($t2);
$G5->apply_unsafe($u2);
$G5->apply_unsafe($v2);
$P5->apply_unsafe($W1);
$P5->apply_unsafe($X1);
$P5->apply_unsafe($Y1);
$P5->apply_unsafe($T2);
$P5->apply_unsafe($Z1);
$P5->apply_unsafe($c2);
$P5->apply_unsafe($d2);
$P5->apply_unsafe($e2);
$P5->apply_unsafe($f2);
$P5->apply_unsafe($g2);
$P5->apply_unsafe($h2);
$P5->apply_unsafe($i2);
$P5->apply_unsafe($Q5);
$P5->apply_unsafe($z2);
$P5->apply_unsafe($k2);
$P5->apply_unsafe($A2);
$P5->apply_unsafe($l2);
$P5->apply_unsafe($m2);
$P5->apply_unsafe($n2);
$P5->apply_unsafe($o2);
$P5->apply_unsafe($p2);
$P5->apply_unsafe($q2);
$P5->apply_unsafe($r2);
$P5->apply_unsafe($s2);
$P5->apply_unsafe($t2);
$P5->apply_unsafe($u2);
$P5->apply_unsafe($v2);
$j6->apply_unsafe($W1);
$j6->apply_unsafe($X1);
$j6->apply_unsafe($Y1);
$j6->apply_unsafe($Z1);
$j6->apply_unsafe($c2);
$j6->apply_unsafe($d2);
$j6->apply_unsafe($u);
$j6->apply_unsafe($e2);
$j6->apply_unsafe($f2);
$j6->apply_unsafe($g2);
$j6->apply_unsafe($R2);
$j6->apply_unsafe($h2);
$j6->apply_unsafe($g3);
$j6->apply_unsafe($i2);
$j6->apply_unsafe($k6);
$j6->apply_unsafe($z2);
$j6->apply_unsafe($k2);
$j6->apply_unsafe($l2);
$j6->apply_unsafe($m2);
$j6->apply_unsafe($n2);
$j6->apply_unsafe($o2);
$j6->apply_unsafe($p2);
$j6->apply_unsafe($q2);
$j6->apply_unsafe($r2);
$j6->apply_unsafe($s2);
$j6->apply_unsafe($t2);
$j6->apply_unsafe($u2);
$j6->apply_unsafe($v2);
$s6->apply_unsafe($W1);
$s6->apply_unsafe($X1);
$s6->apply_unsafe($Y1);
$s6->apply_unsafe($Z1);
$s6->apply_unsafe($c2);
$s6->apply_unsafe($d2);
$s6->apply_unsafe($e2);
$s6->apply_unsafe($f2);
$s6->apply_unsafe($g2);
$s6->apply_unsafe($h2);
$s6->apply_unsafe($i2);
$s6->apply_unsafe($t6);
$s6->apply_unsafe($k2);
$s6->apply_unsafe($l2);
$s6->apply_unsafe($m2);
$s6->apply_unsafe($n2);
$s6->apply_unsafe($o2);
$s6->apply_unsafe($p2);
$s6->apply_unsafe($q2);
$s6->apply_unsafe($r2);
$s6->apply_unsafe($s2);
$s6->apply_unsafe($t2);
$s6->apply_unsafe($u2);
$s6->apply_unsafe($v2);
$h7->apply_unsafe($T2);
$D7->apply_unsafe($Z3);
$K7->apply_unsafe($Z3);
$j8->apply_unsafe($F);
$q8->apply_unsafe($F);
$y8->apply_unsafe($F);
$I8->apply_unsafe($F);
$n9->apply_unsafe($u);
$C9->apply_unsafe($u);
$N9->apply_unsafe($u);
$W9->apply_unsafe($u);
$wa->apply_unsafe($xa);
$Ia->apply_unsafe($c4);
$lc->apply_unsafe($c4);
$Yc->apply_unsafe($Zc);
$zd->apply_unsafe($d4);
$Md->apply_unsafe($d4);
$ne->apply_unsafe($d4);
$ze->apply_unsafe($d4);
$Qf->apply_unsafe($Zc);
$kg->apply_unsafe($R2);
$rg->apply_unsafe($R2);
$zg->apply_unsafe($R2);
$Zg->apply_unsafe($xa);
$mh->apply_unsafe($g3);
$th->apply_unsafe($g3);
$Ph->apply_unsafe($e4);
$ei->apply_unsafe($e4);
$mi->apply_unsafe($e4);
$ej->apply_unsafe($h4);
$ej->apply_unsafe($j4);
$ej->apply_unsafe($k4);
$ej->apply_unsafe($l4);
$ej->apply_unsafe($m4);
$ej->apply_unsafe($n4);
$ej->apply_unsafe($o4);
$ej->apply_unsafe($p4);
$nj->apply_unsafe($h4);
$nj->apply_unsafe($j4);
$nj->apply_unsafe($k4);
$nj->apply_unsafe($l4);
$nj->apply_unsafe($m4);
$nj->apply_unsafe($n4);
$nj->apply_unsafe($o4);
$nj->apply_unsafe($p4);
$wj->apply_unsafe($h4);
$wj->apply_unsafe($j4);
$wj->apply_unsafe($k4);
$wj->apply_unsafe($l4);
$wj->apply_unsafe($m4);
$wj->apply_unsafe($n4);
$wj->apply_unsafe($o4);
$wj->apply_unsafe($p4);
$Fj->apply_unsafe($h4);
$Fj->apply_unsafe($j4);
$Fj->apply_unsafe($k4);
$Fj->apply_unsafe($l4);
$Fj->apply_unsafe($m4);
$Fj->apply_unsafe($n4);
$Fj->apply_unsafe($o4);
$Fj->apply_unsafe($p4);
$Qj->apply_unsafe($h4);
$Zj->apply_unsafe($h4);
$sk->apply_unsafe($n2);
$sk->apply_unsafe($p2);
$sk->apply_unsafe($q2);
$sk->apply_unsafe($r2);
$sk->apply_unsafe($s2);
$sk->apply_unsafe($t2);
$sk->apply_unsafe($u2);
$sk->apply_unsafe($v2);
$Lk->apply_unsafe($i4);
$Tk->apply_unsafe($i4);
$ml->apply_unsafe($i4);
$Hl->apply_unsafe($i4);
$Ql->apply_unsafe($i4);
$jm->apply_unsafe($i4);
$Jm->apply_unsafe($j4);
$Rm->apply_unsafe($j4);
$cn->apply_unsafe($j4);
$rn->apply_unsafe($j4);
$rn->apply_unsafe($k4);
$rn->apply_unsafe($l4);
$rn->apply_unsafe($n4);
$rn->apply_unsafe($o4);
$Cn->apply_unsafe($j4);
$Cn->apply_unsafe($k4);
$Cn->apply_unsafe($l4);
$Cn->apply_unsafe($n4);
$Cn->apply_unsafe($o4);
$Sn->apply_unsafe($j4);
$xo->apply_unsafe($k4);
$Fo->apply_unsafe($k4);
$No->apply_unsafe($k4);
$cp->apply_unsafe($k4);
$Ap->apply_unsafe($l4);
$Ip->apply_unsafe($l4);
$Tp->apply_unsafe($l4);
$Eq->apply_unsafe($n4);
$Pq->apply_unsafe($n4);
$er->apply_unsafe($n4);
$pr->apply_unsafe($n4);
$Dr->apply_unsafe($n4);
$hs->apply_unsafe($o4);
$ps->apply_unsafe($o4);
$ys->apply_unsafe($o4);
$Js->apply_unsafe($o4);
$st->apply_unsafe($p4);
$At->apply_unsafe($p4);
$Pt->apply_unsafe($p4);
$ni::self=$Zu;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($P)for@$w;
&$_($T)for@$w;
&$_($X)for@$H;
&$_($f1)for@$H;
&$_($n1)for@$w;
&$_($r1)for@$H;
&$_($z1)for@$w;
&$_($D1)for@$H;
&$_($H1)for@$w;
&$_($L1)for@$w;
&$_($P1)for@$w;
&$_($T1)for@$H;
&$_($L2)for@$w;
&$_($O2)for@$w;
&$_($S2)for@$V2;
&$_($Y2)for@$w;
&$_($c3)for@$w;
&$_($f3)for@$i3;
&$_($m3)for@$w;
&$_($p3)for@$r3;
&$_($v3)for@$w;
&$_($y3)for@$A3;
&$_($E3)for@$w;
&$_($H3)for@$J3;
&$_($L3)for@$M3;
&$_($P3)for@$w;
&$_($S3)for@$w;
&$_($V3)for@$X3;
&$_($u4)for@$w;
&$_($x4)for@$z4;
&$_($B4)for@$C4;
&$_($I4)for@$w;
&$_($L4)for@$N4;
&$_($P4)for@$Q4;
&$_($X4)for@$w;
&$_($c5)for@$e5;
&$_($i5)for@$w;
&$_($l5)for@$w;
&$_($o5)for@$q5;
&$_($u5)for@$w;
&$_($x5)for@$z5;
&$_($D5)for@$w;
&$_($G5)for@$I5;
&$_($M5)for@$w;
&$_($P5)for@$R5;
&$_($T5)for@$U5;
&$_($W5)for@$X5;
&$_($d6)for@$w;
&$_($g6)for@$w;
&$_($j6)for@$l6;
&$_($p6)for@$w;
&$_($s6)for@$u6;
&$_($w6)for@$x6;
&$_($H6)for@$I6;
&$_($M6)for@$N6;
&$_($P6)for@$Q6;
&$_($S6)for@$T6;
&$_($e7)for@$w;
&$_($h7)for@$i7;
&$_($k7)for@$l7;
&$_($r7)for@$s7;
&$_($A7)for@$w;
&$_($D7)for@$E7;
&$_($H7)for@$w;
&$_($K7)for@$L7;
&$_($N7)for@$O7;
&$_($T7)for@$U7;
&$_($g8)for@$w;
&$_($j8)for@$k8;
&$_($n8)for@$w;
&$_($q8)for@$r8;
&$_($v8)for@$w;
&$_($y8)for@$z8;
&$_($C8)for@$w;
&$_($F8)for@$w;
&$_($I8)for@$J8;
&$_($L8)for@$M8;
&$_($R8)for@$S8;
&$_($f9)for@$w;
&$_($i9)for@$w;
&$_($k9)for@$w;
&$_($n9)for@$o9;
&$_($s9)for@$w;
&$_($v9)for@$w;
&$_($z9)for@$w;
&$_($C9)for@$D9;
&$_($H9)for@$w;
&$_($K9)for@$w;
&$_($N9)for@$O9;
&$_($T9)for@$w;
&$_($W9)for@$X9;
&$_($Z9)for@$ca;
&$_($ha)for@$ia;
&$_($ta)for@$w;
&$_($wa)for@$ya;
&$_($Fa)for@$w;
&$_($Ia)for@$Ja;
&$_($Oa)for@$w;
&$_($Sa)for@$w;
&$_($Wa)for@$w;
&$_($cb)for@$w;
&$_($gb)for@$w;
&$_($kb)for@$w;
&$_($ob)for@$w;
&$_($sb)for@$w;
&$_($wb)for@$w;
&$_($Ab)for@$w;
&$_($Eb)for@$w;
&$_($Ib)for@$w;
&$_($Mb)for@$w;
&$_($Qb)for@$w;
&$_($Ub)for@$w;
&$_($Yb)for@$w;
&$_($ec)for@$w;
&$_($ic)for@$w;
&$_($lc)for@$mc;
&$_($oc)for@$pc;
&$_($uc)for@$vc;
&$_($Fc)for@$w;
&$_($Jc)for@$w;
&$_($Nc)for@$w;
&$_($Rc)for@$w;
&$_($Vc)for@$w;
&$_($Yc)for@$cd;
&$_($od)for@$w;
&$_($sd)for@$w;
&$_($wd)for@$w;
&$_($zd)for@$Ad;
&$_($Fd)for@$w;
&$_($Jd)for@$w;
&$_($Md)for@$Nd;
&$_($Sd)for@$w;
&$_($Wd)for@$w;
&$_($ce)for@$w;
&$_($ge)for@$w;
&$_($ke)for@$w;
&$_($ne)for@$oe;
&$_($se)for@$w;
&$_($we)for@$w;
&$_($ze)for@$Ae;
&$_($Ce)for@$De;
&$_($Ie)for@$Je;
&$_($Te)for@$w;
&$_($Xe)for@$w;
&$_($df)for@$w;
&$_($hf)for@$w;
&$_($lf)for@$w;
&$_($pf)for@$w;
&$_($tf)for@$w;
&$_($xf)for@$w;
&$_($Bf)for@$w;
&$_($Ff)for@$w;
&$_($Jf)for@$w;
&$_($Nf)for@$w;
&$_($Qf)for@$Rf;
&$_($Zf)for@$w;
&$_($dg)for@$w;
&$_($kg)for@$lg;
&$_($og)for@$w;
&$_($rg)for@$sg;
&$_($wg)for@$w;
&$_($zg)for@$Ag;
&$_($Cg)for@$Dg;
&$_($Jg)for@$Kg;
&$_($Rg)for@$w;
&$_($Wg)for@$w;
&$_($Zg)for@$ch;
&$_($jh)for@$w;
&$_($mh)for@$nh;
&$_($qh)for@$w;
&$_($th)for@$uh;
&$_($wh)for@$xh;
&$_($Dh)for@$Eh;
&$_($Mh)for@$w;
&$_($Ph)for@$Qh;
&$_($Vh)for@$w;
&$_($Zh)for@$w;
&$_($ei)for@$fi;
&$_($ji)for@$w;
&$_($mi)for@$ni;
&$_($qi)for@$ri;
&$_($xi)for@$yi;
&$_($Gi)for@$Hi;
&$_($Mi)for@$Ni;
&$_($Zi)for@$w;
&$_($ej)for@$fj;
&$_($kj)for@$w;
&$_($nj)for@$oj;
&$_($tj)for@$w;
&$_($wj)for@$xj;
&$_($Cj)for@$w;
&$_($Fj)for@$Gj;
&$_($Ij)for@$Jj;
&$_($Nj)for@$w;
&$_($Qj)for@$Rj;
&$_($Wj)for@$w;
&$_($Zj)for@$ck;
&$_($ek)for@$fk;
&$_($pk)for@$w;
&$_($sk)for@$tk;
&$_($vk)for@$wk;
&$_($yk)for@$zk;
&$_($Ik)for@$w;
&$_($Lk)for@$Mk;
&$_($Qk)for@$w;
&$_($Tk)for@$Uk;
&$_($Zk)for@$w;
&$_($fl)for@$w;
&$_($jl)for@$w;
&$_($ml)for@$nl;
&$_($sl)for@$w;
&$_($wl)for@$w;
&$_($Al)for@$w;
&$_($El)for@$w;
&$_($Hl)for@$Il;
&$_($Nl)for@$w;
&$_($Ql)for@$Rl;
&$_($Wl)for@$w;
&$_($cm)for@$w;
&$_($gm)for@$w;
&$_($jm)for@$km;
&$_($mm)for@$nm;
&$_($sm)for@$tm;
&$_($Gm)for@$w;
&$_($Jm)for@$Km;
&$_($Om)for@$w;
&$_($Rm)for@$Sm;
&$_($Xm)for@$w;
&$_($cn)for@$dn;
&$_($kn)for@$w;
&$_($on)for@$w;
&$_($rn)for@$sn;
&$_($wn)for@$w;
&$_($zn)for@$w;
&$_($Cn)for@$Dn;
&$_($Fn)for@$Gn;
&$_($Ln)for@$w;
&$_($Pn)for@$w;
&$_($Sn)for@$Tn;
&$_($Vn)for@$Wn;
&$_($do)for@$eo;
&$_($ro)for@$w;
&$_($uo)for@$w;
&$_($xo)for@$yo;
&$_($Co)for@$w;
&$_($Fo)for@$Go;
&$_($Ko)for@$w;
&$_($No)for@$Oo;
&$_($To)for@$w;
&$_($Xo)for@$w;
&$_($cp)for@$dp;
&$_($fp)for@$gp;
&$_($lp)for@$mp;
&$_($xp)for@$w;
&$_($Ap)for@$Bp;
&$_($Fp)for@$w;
&$_($Ip)for@$Jp;
&$_($Np)for@$w;
&$_($Qp)for@$w;
&$_($Tp)for@$Up;
&$_($Wp)for@$Xp;
&$_($eq)for@$fq;
&$_($xq)for@$w;
&$_($Bq)for@$w;
&$_($Eq)for@$Fq;
&$_($Jq)for@$w;
&$_($Mq)for@$w;
&$_($Pq)for@$Qq;
&$_($Vq)for@$w;
&$_($Zq)for@$w;
&$_($er)for@$fr;
&$_($jr)for@$w;
&$_($mr)for@$w;
&$_($pr)for@$qr;
&$_($ur)for@$w;
&$_($wr)for@$w;
&$_($yr)for@$w;
&$_($Ar)for@$w;
&$_($Dr)for@$Er;
&$_($Gr)for@$Hr;
&$_($Mr)for@$Nr;
&$_($Zr)for@$w;
&$_($es)for@$w;
&$_($hs)for@$is;
&$_($ms)for@$w;
&$_($ps)for@$qs;
&$_($vs)for@$w;
&$_($ys)for@$zs;
&$_($Ds)for@$w;
&$_($Gs)for@$w;
&$_($Js)for@$Ks;
&$_($Ms)for@$Ns;
&$_($Ss)for@$Ts;
&$_($ht)for@$w;
&$_($lt)for@$w;
&$_($pt)for@$w;
&$_($st)for@$tt;
&$_($xt)for@$w;
&$_($At)for@$Bt;
&$_($Ft)for@$w;
&$_($Jt)for@$w;
&$_($Mt)for@$w;
&$_($Pt)for@$Qt;
&$_($St)for@$Tt;
&$_($Yt)for@$Zt;
&$_($iu)for@$ju;
&$_($Du)for@$Eu;
&$_($Gu)for@$ju;
&$_($Lu)for@$w;
&$_($Pu)for@$w;
&$_($Tu)for@$w;
&$_($Xu)for@$w;
&$_($Zu)for@$cv;
ni->run(@ARGV);
__DATA__
