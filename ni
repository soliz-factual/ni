#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q'named';
$d=q'ni.doc:/class';
$e=q'doc';
$f=q'synopsis';
$g=q'
    ni(\'ni:/object\')->child(\'/message\')
      ->add(\'/behaviorname.b\')          # add existing behavior
      ->def(\'/message_init.b\',          # define new slice behavior
        instantiate => fn q{            # called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       # return object to be blessed
        })
      ->def(\'/behaviorname.b\',          # define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! \'" . $$self{message} . "\'\\n";
        });
    ni(\'ni:/child\')->new(\'hello world!\')->method1;
  ';
$h=[$f,$g];
$i=q'description';
$j=q'ni:class is at the core of ni\'s object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you\'d expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.';
$k=[$i,$j];
$l=q'behaviors';
$m=q'ni\'s objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.';
$n=q'eg';
$o=q'annotations';
$p=[];
$q=q'code';
$r=q'my $fn = fn q{"hi"};
my $slice = ni(\'ni:/lib/slice\')->new(\'myslice\', f => $fn);
$slice->apply(\'foo\');
now foo->f == \'hi\';';
$s=q'proto';
$t=q'';
$u=q'lib/fn';
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q'lib/fn::ctors';
$x=q'TODO...';
$y=[$l,$m,$n,$v,$x];
$z=q'classes';
$A=q'ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni\'s classes are slice unions and as such don\'t
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn\'t in the picture,
      which makes multiple inheritance straightforward to implement.';
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q'name';
$E=q'/class';
$F=q'lib/doc';
$G=bless({$e,$C,$D,$E},$F);
$H=q'lib/doc::ctors';
$I=q'ni.doc:/lib/doc';
$J=q'
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...';
$K=[$f,$J];
$L=q'Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class\'s code without bringing along all of
      its documentation and unit tests.';
$M=q'Documentation objects are internally represented as arrays of quoted
      method calls:';
$N=[];
$O=q'my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];';
$P=bless({$o,$N,$q,$O,$s,$t},$u);
$Q=q'This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":';
$R=[];
$S=q'my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];';
$T=bless({$o,$R,$q,$S,$s,$t},$u);
$U=[$i,$L,$M,$n,$P,$Q,$n,$T];
$V=[$K,$U];
$W=q'/lib/doc';
$X=bless({$e,$V,$D,$W},$F);
$Y=q'ni.doc:/unix/cat';
$Z=q'
    my $combined = ni(\'ni:/unix/cat\')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  ';
$c1=[$f,$Z];
$d1=q'Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.';
$e1=[$i,$d1];
$f1=[];
$g1=q'my $cat = ni("str:foo") + ni("str:bar");
now $cat->read_all == "foo\\nbar\\n";';
$h1=bless({$o,$f1,$q,$g1,$s,$t},$u);
$i1=[$n,$h1];
$j1=[$c1,$e1,$i1];
$k1=q'/unix/cat';
$l1=bless({$e,$j1,$D,$k1},$F);
$m1=q'ni.doc:/unix/pid';
$n1=q'
    my $pid = ni::fork {something};
    my $pid = ni::fork_with(stdin => $mypipe, ..., sub {something});
    my $pid = ni::fork_exec("ls", "-l")';
$o1=[$f,$n1];
$p1=[];
$q1=q'my $pid = ni("sh:seq 4");
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];';
$r1=bless({$o,$p1,$q,$q1,$s,$t},$u);
$s1=[$n,$r1];
$t1=[];
$u1=q'my $pid = ni("sh:seq 10");
my $filter = ni::fork_with stdin => $pid->stdout, sub {exec \'egrep\', \'[13579]$\'};
my $data = $filter->read_all;
now [$pid->await, $filter->await, $data] == [0, 0, "1\\n3\\n5\\n7\\n9\\n"];';
$v1=bless({$o,$t1,$q,$u1,$s,$t},$u);
$w1=[$n,$v1];
$x1=[$o1,$s1,$w1];
$y1=q'/unix/pid';
$z1=bless({$e,$x1,$D,$y1},$F);
$A1=q'ni:/class';
$B1=q'applied_to';
$C1=q'class';
$D1=q'class.c';
$E1=q'lib/behavior.c';
$F1=q'lib/branch.c';
$G1=q'lib/dataslice.c';
$H1=q'lib/doc.c';
$I1=q'lib/fn.c';
$J1=q'lib/image.c';
$K1=q'lib/ni.c';
$L1=q'lib/slice.c';
$M1=q'lib/tag.c';
$N1=q'lib/test_value.c';
$O1=q'metaclass.c';
$P1=q'module.c';
$Q1=q'object.c';
$R1=q'unix/cat.c';
$S1=q'unix/fd.c';
$T1=q'unix/fifo.c';
$U1=q'unix/file.c';
$V1=q'unix/io.c';
$W1=q'unix/pid.c';
$X1=q'unix/pipeline.c';
$Y1=q'unix/str.c';
$Z1={$C1,1,$D1,1,$E1,1,$F1,1,$G1,1,$H1,1,$I1,1,$J1,1,$K1,1,$L1,1,$M1,1,$N1,1,$O1,1,$P1,1,$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1};
$c2=q'slices';
$d2=q'lib/test_value.c';
$e2=q'metaclass';
$f2=q'module';
$g2={$C1,1,$D1,1,$E1,1,$F1,1,$G1,1,$H1,1,$I1,1,$J1,1,$K1,1,$L1,1,$M1,1,$d2,1,$e2,1,$O1,1,$f2,1,$P1,1,$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1};
$h2=q'/module';
$i2=q'/lib/perlbranch.b';
$j2={};
$k2=q'ctor';
$l2=undef;
$m2=q'dtor';
$n2=q'methods';
$o2=q'add';
$p2=q'local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;';
$q2=bless({$q,$p2,$s,$t},$u);
$r2=q'apply';
$s2=q'local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;';
$t2=bless({$q,$s2,$s,$t},$u);
$u2={$o2,$q2,$r2,$t2};
$v2=q'/lib/branch.b';
$w2=q'lib/slice';
$x2=bless({$B1,$j2,$k2,$l2,$m2,$l2,$n2,$u2,$D,$v2},$w2);
$y2=q'lib/branch';
$z2=q'lib/test_value.c';
$A2=q'lib/slice::ctors';
$B2={};
$C2=q'my $s = shift; ni->def($s->name, $s)';
$D2=bless({$q,$C2,$s,$t},$u);
$E2=q'$_[0]->namespace . ":" . $_[0]->{name}';
$F2=bless({$q,$E2,$s,$t},$u);
$G2={$D,$F2};
$H2=q'/lib/named.b';
$I2=bless({$B1,$B2,$k2,$D2,$m2,$l2,$n2,$G2,$D,$H2},$w2);
$J2=q'lib/tag';
$K2=q'lib/test_value.c';
$L2=q'lib/slice::ctors';
$M2={};
$N2=q'namespace';
$O2=q'\'ni\'';
$P2=bless({$q,$O2,$s,$t},$u);
$Q2={$N2,$P2};
$R2=q'/lib/named_in_ni.b';
$S2=bless({$B1,$M2,$k2,$l2,$m2,$l2,$n2,$Q2,$D,$R2},$w2);
$T2=q'lib/test_value.c';
$U2=q'lib/slice::ctors';
$V2={};
$W2=q'package';
$X2=q'(my $name = shift->{name}) =~ s/^\\///; $name';
$Y2=bless({$q,$X2,$s,$t},$u);
$Z2={$W2,$Y2};
$c3=q'/lib/namespaced.b';
$d3=bless({$B1,$V2,$k2,$l2,$m2,$l2,$n2,$Z2,$D,$c3},$w2);
$e3=q'lib/test_value.c';
$f3=q'lib/slice::ctors';
$g3={};
$h3=q'resolve';
$i3=q'ref $_[1] ? $_[1] : ni"ni:$_[1]"';
$j3=bless({$q,$i3,$s,$t},$u);
$k3={$h3,$j3};
$l3=q'/lib/resolver.b';
$m3=bless({$B1,$g3,$k2,$l2,$m2,$l2,$n2,$k3,$D,$l3},$w2);
$n3=q'lib/test_value.c';
$o3=q'lib/slice::ctors';
$p3=[$x2,$I2,$S2,$d3,$m3];
$q3=bless({$D,$i2,$c2,$p3},$J2);
$r3=q'lib/tag::ctors';
$s3={};
$t3=q'my $s = shift; $s->apply($s->package)';
$u3=bless({$q,$t3,$s,$t},$u);
$v3=q'instantiate';
$w3=q'local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};';
$x3=bless({$q,$w3,$s,$t},$u);
$y3={$v3,$x3};
$z3=q'/lib/class_init.b';
$A3=bless({$B1,$s3,$k2,$u3,$m2,$l2,$n2,$y3,$D,$z3},$w2);
$B3=q'lib/test_value.c';
$C3=q'lib/slice::ctors';
$D3=q'lib/behavior';
$E3=q'lib/dataslice';
$F3=q'lib/image';
$G3=q'lib/ni';
$H3=q'lib/test_value';
$I3=q'lib/test_value.c';
$J3=q'object';
$K3=q'unix/cat';
$L3=q'unix/fd';
$M3=q'unix/fifo';
$N3=q'unix/file';
$O3=q'unix/io';
$P3=q'unix/pid';
$Q3=q'unix/pipeline';
$R3=q'unix/str';
$S3={$C1,1,$D1,1,$D3,1,$E1,1,$y2,1,$F1,1,$E3,1,$G1,1,$F,1,$H1,1,$u,1,$I1,1,$F3,1,$J1,1,$G3,1,$K1,1,$w2,1,$L1,1,$J2,1,$M1,1,$H3,1,$I3,1,$e2,1,$O1,1,$f2,1,$P1,1,$J3,1,$Q1,1,$K3,1,$R1,1,$L3,1,$S1,1,$M3,1,$T1,1,$N3,1,$U1,1,$O3,1,$V1,1,$P3,1,$W1,1,$Q3,1,$X1,1,$R3,1,$Y1,1};
$T3=q'/object';
$U3={};
$V3=q'ni \'ni:/\' . ref shift';
$W3=bless({$q,$V3,$s,$t},$u);
$X3={$C1,$W3};
$Y3=q'/lib/instance.b';
$Z3=bless({$B1,$U3,$k2,$l2,$m2,$l2,$n2,$X3,$D,$Y3},$w2);
$c4=q'lib/test_value.c';
$d4=q'lib/slice::ctors';
$e4=[$Z3];
$f4=bless({$B1,$S3,$D,$T3,$c2,$e4},$Q1);
$g4=q'object.c::ctors';
$h4=q'lib/test_value.c';
$i4={$C1,1,$D1,1,$D3,1,$E1,1,$y2,1,$F1,1,$E3,1,$G1,1,$H1,1,$I1,1,$J1,1,$K1,1,$w2,1,$L1,1,$J2,1,$M1,1,$h4,1,$e2,1,$O1,1,$f2,1,$P1,1,$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1};
$j4=q'/lib/behavior';
$k4={};
$l4=q'my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can(\'exists\') && ni->exists("ni.doc:$name");
ni(\'ni:/lib/doc\')->new($name);';
$m4=bless({$q,$l4,$s,$t},$u);
$n4={$e,$m4};
$o4=q'/lib/documentable.b';
$p4=bless({$B1,$k4,$k2,$l2,$m2,$l2,$n2,$n4,$D,$o4},$w2);
$q4=q'lib/test_value.c';
$r4=q'lib/slice::ctors';
$s4=[$f4,$p4];
$t4=bless({$B1,$i4,$D,$j4,$c2,$s4},$E1);
$u4=q'lib/behavior.c::ctors';
$v4=q'lib/test_value.c';
$w4={$C1,1,$D1,1,$E1,1,$y2,1,$F1,1,$G1,1,$H1,1,$I1,1,$J1,1,$K1,1,$L1,1,$M1,1,$v4,1,$e2,1,$O1,1,$f2,1,$P1,1,$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1};
$x4=q'/lib/definition.b';
$y4={};
$z4=q'def';
$A4=q'shift->add(ni(\'ni:/lib/slice\')->new(@_))';
$B4=bless({$q,$A4,$s,$t},$u);
$C4={$z4,$B4};
$D4=q'/lib/definition_def.b';
$E4=bless({$B1,$y4,$k2,$l2,$m2,$l2,$n2,$C4,$D,$D4},$w2);
$F4=q'lib/test_value.c';
$G4=q'lib/slice::ctors';
$H4={};
$I4=q'ro';
$J4=q'my ($self, $slice, @rs) = @_;
$self->add(ni(\'ni:/lib/slice\')->new(
  $slice,
  map +($_ => fn qq{shift->{\'$_\'}}), @rs));';
$K4=bless({$q,$J4,$s,$t},$u);
$L4=q'rw';
$M4=q'my ($self, $slice, @as) = @_;
$self->add(ni(\'ni:/lib/slice\')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{\'$_\'} = \\$_[1] : shift->{\'$_\'}}), @as));';
$N4=bless({$q,$M4,$s,$t},$u);
$O4={$I4,$K4,$L4,$N4};
$P4=q'/lib/accessor.b';
$Q4=bless({$B1,$H4,$k2,$l2,$m2,$l2,$n2,$O4,$D,$P4},$w2);
$R4=q'lib/test_value.c';
$S4=q'lib/slice::ctors';
$T4={};
$U4=q'(""';
$V4=q'shift->name';
$W4=bless({$q,$V4,$s,$t},$u);
$X4={$U4,$W4};
$Y4=q'/lib/name_as_string.b';
$Z4=bless({$B1,$T4,$k2,$l2,$m2,$l2,$n2,$X4,$D,$Y4},$w2);
$c5=q'lib/test_value.c';
$d5=q'lib/slice::ctors';
$e5={};
$f5=q'(eq';
$g5=q'ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);';
$h5=bless({$q,$g5,$s,$t},$u);
$i5={$f5,$h5};
$j5=q'/lib/ref_eq.b';
$k5=bless({$B1,$e5,$k2,$l2,$m2,$l2,$n2,$i5,$D,$j5},$w2);
$l5=q'lib/test_value.c';
$m5=q'lib/slice::ctors';
$n5={};
$o5=q'defdata';
$p5=q'shift->add(ni(\'ni:/lib/dataslice\')->new(@_))';
$q5=bless({$q,$p5,$s,$t},$u);
$r5={$o5,$q5};
$s5=q'/lib/definition_defdata.b';
$t5=bless({$B1,$n5,$k2,$l2,$m2,$l2,$n2,$r5,$D,$s5},$w2);
$u5=q'lib/test_value.c';
$v5=q'lib/slice::ctors';
$w5=[$E4,$Q4,$Z4,$k5,$t5];
$x5=bless({$B1,$w4,$D,$x4,$c2,$w5},$y2);
$y5=q'lib/branch::ctors';
$z5=[$q3,$A3,$f4,$t4,$x5];
$A5=bless({$B1,$g2,$D,$h2,$c2,$z5},$P1);
$B5=q'module.c::ctors';
$C5={};
$D5=q'DESTROY';
$E5=q'local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};';
$F5=bless({$q,$E5,$s,$t},$u);
$G5=q'new';
$H5=q'local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;';
$I5=bless({$q,$H5,$s,$t},$u);
$J5={$D5,$F5,$G5,$I5};
$K5=q'/lib/instantiable.b';
$L5=bless({$B1,$C5,$n2,$J5,$D,$K5},$w2);
$M5=q'lib/test_value.c';
$N5=q'lib/slice::ctors';
$O5={};
$P5=q'child';
$Q5=q'my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);';
$R5=bless({$q,$Q5,$s,$t},$u);
$S5={$P5,$R5};
$T5=q'/lib/subclass.b';
$U5=bless({$B1,$O5,$k2,$l2,$m2,$l2,$n2,$S5,$D,$T5},$w2);
$V5=q'lib/test_value.c';
$W5=q'lib/slice::ctors';
$X5=[$A5,$L5,$A3,$A5,$U5];
$Y5=bless({$B1,$Z1,$D,$E,$c2,$X5},$D1);
$Z5=q'class.c::ctors';
$c6=q'ni:/class.c';
$d6={$D1,1};
$e6=q'/class.c';
$f6={$D1,1,$P1,1};
$g6=q'/module.c';
$h6=q'lib/test_value.c';
$i6={$D1,1,$E1,1,$F1,1,$G1,1,$H1,1,$I1,1,$J1,1,$K1,1,$L1,1,$M1,1,$h6,1,$P1,1,$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1};
$j6=q'/object.c';
$k6=[$Y5];
$l6=bless({$B1,$i6,$D,$j6,$c2,$k6},$e2);
$m6=q'metaclass::ctors';
$n6={$D1,1,$E1,1,$F1,1,$G1,1,$L1,1,$M1,1,$P1,1};
$o6=q'/lib/behavior.c';
$p6=[$l6];
$q6=bless({$B1,$n6,$D,$o6,$c2,$p6},$e2);
$r6=q'metaclass::ctors';
$s6=[$l6,$L5,$q6];
$t6=bless({$B1,$f6,$D,$g6,$c2,$s6},$e2);
$u6=q'metaclass::ctors';
$v6=[$t6];
$w6=bless({$B1,$d6,$D,$e6,$c2,$v6},$e2);
$x6=q'metaclass::ctors';
$y6=q'ni:/lib/accessor.b';
$z6=q'ni:/lib/behavior';
$A6=q'ni:/lib/behavior.c';
$B6=q'ni:/lib/branch';
$C6={$y2,1};
$D6=q'/lib/branch';
$E6={};
$F6=q'local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};';
$G6=bless({$q,$F6,$s,$t},$u);
$H6={$v3,$G6};
$I6=q'/lib/branch_init.b';
$J6=bless({$B1,$E6,$k2,$l2,$m2,$l2,$n2,$H6,$D,$I6},$w2);
$K6=q'lib/slice::ctors';
$L6=[$t4,$I2,$x2,$J6,$x5];
$M6=bless({$B1,$C6,$D,$D6,$c2,$L6},$F1);
$N6=q'lib/branch.c::ctors';
$O6=q'ni:/lib/branch.b';
$P6=q'ni:/lib/branch.c';
$Q6={$F1,1};
$R6=q'/lib/branch.c';
$S6=[$q6];
$T6=bless({$B1,$Q6,$D,$R6,$c2,$S6},$e2);
$U6=q'metaclass::ctors';
$V6=q'ni:/lib/branch_init.b';
$W6=q'ni:/lib/class_init.b';
$X6=q'ni:/lib/dataslice';
$Y6={$E3,1};
$Z6=q'/lib/dataslice';
$c7={};
$d7=q'my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};';
$e7=bless({$q,$d7,$s,$t},$u);
$f7={$v3,$e7};
$g7=q'/lib/dataslice_init.b';
$h7=bless({$B1,$c7,$k2,$l2,$m2,$l2,$n2,$f7,$D,$g7},$w2);
$i7=q'lib/slice::ctors';
$j7={};
$k7=q'local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;';
$l7=bless({$q,$k7,$s,$t},$u);
$m7={$r2,$l7};
$n7=q'/lib/dataslice_apply.b';
$o7=bless({$B1,$j7,$k2,$l2,$m2,$l2,$n2,$m7,$D,$n7},$w2);
$p7=q'lib/slice::ctors';
$q7=[$t4,$h7,$o7];
$r7=bless({$B1,$Y6,$D,$Z6,$c2,$q7},$G1);
$s7=q'lib/dataslice.c::ctors';
$t7=q'ni:/lib/dataslice.c';
$u7={$G1,1};
$v7=q'/lib/dataslice.c';
$w7=[$q6];
$x7=bless({$B1,$u7,$D,$v7,$c2,$w7},$e2);
$y7=q'metaclass::ctors';
$z7=q'ni:/lib/dataslice_apply.b';
$A7=q'ni:/lib/dataslice_init.b';
$B7=q'ni:/lib/definition.b';
$C7=q'ni:/lib/definition_def.b';
$D7=q'ni:/lib/definition_defdata.b';
$E7=q'ni:/lib/doc';
$F7={$F,1};
$G7={};
$H7=q'shift; +{name => shift, doc => []}';
$I7=bless({$q,$H7,$s,$t},$u);
$J7={$v3,$I7};
$K7=q'/lib/doc_init.b';
$L7=bless({$B1,$G7,$k2,$l2,$m2,$l2,$n2,$J7,$D,$K7},$w2);
$M7=q'lib/slice::ctors';
$N7={};
$O7=q'\'ni.doc\'';
$P7=bless({$q,$O7,$s,$t},$u);
$Q7={$N2,$P7};
$R7=q'/lib/doc_namespace.b';
$S7=bless({$B1,$N7,$k2,$l2,$m2,$l2,$n2,$Q7,$D,$R7},$w2);
$T7=q'lib/slice::ctors';
$U7={};
$V7=q'AUTOLOAD';
$W7=q'my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;';
$X7=bless({$q,$W7,$s,$t},$u);
$Y7={$V7,$X7};
$Z7=q'/lib/doc_define.b';
$c8=bless({$B1,$U7,$k2,$l2,$m2,$l2,$n2,$Y7,$D,$Z7},$w2);
$d8=q'lib/slice::ctors';
$e8={};
$f8=q'my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;';
$g8=bless({$q,$f8,$s,$t},$u);
$h8=q'tests';
$i8=q'my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq \'eg\';
}
@tests;';
$j8=bless({$q,$i8,$s,$t},$u);
$k8={$n,$g8,$h8,$j8};
$l8=q'/lib/doc_test.b';
$m8=bless({$B1,$e8,$k2,$l2,$m2,$l2,$n2,$k8,$D,$l8},$w2);
$n8=q'lib/slice::ctors';
$o8=[$f4,$I2,$L7,$S7,$c8,$m8];
$p8=bless({$B1,$F7,$D,$W,$c2,$o8},$H1);
$q8=q'lib/doc.c::ctors';
$r8=q'ni:/lib/doc.c';
$s8={$H1,1};
$t8=q'/lib/doc.c';
$u8=[$l6];
$v8=bless({$B1,$s8,$D,$t8,$c2,$u8},$e2);
$w8=q'metaclass::ctors';
$x8=q'ni:/lib/doc_define.b';
$y8=q'ni:/lib/doc_init.b';
$z8=q'ni:/lib/doc_namespace.b';
$A8=q'ni:/lib/doc_test.b';
$B8=q'ni:/lib/documentable.b';
$C8=q'ni:/lib/fn';
$D8={$u,1};
$E8=q'/lib/fn';
$F8={};
$G8=q'shift->compile';
$H8=bless({$q,$G8,$s,$t},$u);
$I8=q'compile';
$J8=q'local $@;
my $self = shift;
$$self{proto} ||= \'\';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};';
$K8=bless({$q,$J8,$s,$t},$u);
$L8=q'my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : \'\';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};';
$M8=bless({$q,$L8,$s,$t},$u);
$N8={$I8,$K8,$v3,$M8};
$O8=q'/lib/fn_init.b';
$P8=bless({$B1,$F8,$k2,$H8,$m2,$l2,$n2,$N8,$D,$O8},$w2);
$Q8=q'lib/slice::ctors';
$R8={};
$S8=[];
$T8=q'shift->{\'annotations\'}';
$U8=bless({$o,$S8,$q,$T8,$s,$t},$u);
$V8=[];
$W8=q'shift->{\'code\'}';
$X8=bless({$o,$V8,$q,$W8,$s,$t},$u);
$Y8=q'fn';
$Z8=[];
$c9=q'shift->{\'fn\'}';
$d9=bless({$o,$Z8,$q,$c9,$s,$t},$u);
$e9={$o,$U8,$q,$X8,$Y8,$d9};
$f9=q'/lib/fn_ro.b';
$g9=bless({$B1,$R8,$k2,$l2,$m2,$l2,$n2,$e9,$D,$f9},$w2);
$h9=q'lib/slice::ctors';
$i9={};
$j9=[];
$k9=q'shift->{code}';
$l9=bless({$o,$j9,$q,$k9,$s,$t},$u);
$m9=[];
$n9=q'ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])';
$o9=bless({$o,$m9,$q,$n9,$s,$t},$u);
$p9={$U4,$l9,$f5,$o9};
$q9=q'/lib/fn_ops.b';
$r9=bless({$B1,$i9,$k2,$l2,$m2,$l2,$n2,$p9,$D,$q9},$w2);
$s9=q'lib/slice::ctors';
$t9={};
$u9=q'serialize';
$v9=[];
$w9=q'local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = \' \' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);';
$x9=bless({$o,$v9,$q,$w9,$s,$t},$u);
$y9={$u9,$x9};
$z9=q'/lib/fn_serialize.b';
$A9=bless({$B1,$t9,$k2,$l2,$m2,$l2,$n2,$y9,$D,$z9},$w2);
$B9=q'lib/slice::ctors';
$C9=[$f4,$L5,$P8,$g9,$r9,$A9];
$D9=bless({$B1,$D8,$D,$E8,$c2,$C9},$I1);
$E9=q'lib/fn.c::ctors';
$F9=q'ni:/lib/fn.c';
$G9={$I1,1};
$H9=q'/lib/fn.c';
$I9=[$l6];
$J9=bless({$B1,$G9,$D,$H9,$c2,$I9},$e2);
$K9=q'metaclass::ctors';
$L9=q'ni:/lib/fn_init.b';
$M9=q'ni:/lib/fn_ops.b';
$N9=q'ni:/lib/fn_ro.b';
$O9=q'ni:/lib/fn_serialize.b';
$P9=q'ni:/lib/global_static_test.b';
$Q9={};
$R9=q'now';
$S9=[];
$T9=q'ni(\'ni:/lib/test_value\')->new(shift)';
$U9=q'($)';
$V9=bless({$o,$S9,$q,$T9,$s,$U9},$u);
$W9={$R9,$V9};
$X9=q'/lib/global_static_test.b';
$Y9=bless({$B1,$Q9,$k2,$l2,$m2,$l2,$n2,$W9,$D,$X9},$w2);
$Z9=q'main';
$ca=q'lib/slice::ctors';
$da=q'ni:/lib/image';
$ea={$F3,1};
$fa=q'/lib/image';
$ga={};
$ha=[];
$ia=q'my $class = shift;
my %args  = (
  include_shebang => 1,
  include_license => 1,
  include_boot    => 1,
  include_classes => 1,
  include_run     => 1,
  local_vars      => 0,
  use_newlines    => 0,
  @_);

+{include_shebang => $args{include_shebang},
  include_license => $args{include_license},
  include_boot    => $args{include_boot},
  include_classes => $args{include_classes},
  include_run     => $args{include_run},
  local_vars      => $args{local_vars},
  use_newlines    => $args{use_newlines},

  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};';
$ja=bless({$o,$ha,$q,$ia,$s,$t},$u);
$ka={$v3,$ja};
$la=q'/lib/image_init.b';
$ma=bless({$B1,$ga,$k2,$l2,$m2,$l2,$n2,$ka,$D,$la},$w2);
$na=q'lib/slice::ctors';
$oa={};
$pa=q'address';
$qa=[];
$ra=q'return \'undef\' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 16;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);';
$sa=bless({$o,$qa,$q,$ra,$s,$t},$u);
$ta=q'allocate_gensym';
$ua=[];
$va=q'my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;';
$wa=bless({$o,$ua,$q,$va,$s,$t},$u);
$xa=q'boot_side_effect';
$ya=[];
$za=q'unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]';
$Aa=bless({$o,$ya,$q,$za,$s,$t},$u);
$Ba=q'circular_links';
$Ca=[];
$Da=q'local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};';
$Ea=bless({$o,$Ca,$q,$Da,$s,$t},$u);
$Fa=q'finalizer';
$Ga=[];
$Ha=q'push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]';
$Ia=bless({$o,$Ga,$q,$Ha,$s,$t},$u);
$Ja=q'gensym';
$Ka=[];
$La=q'my $n = shift->{gensym_n}++;
my $s = \'$\' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;';
$Ma=bless({$o,$Ka,$q,$La,$s,$t},$u);
$Na=q'is_circular';
$Oa=[];
$Pa=q'my $self = shift;
ref $$self{visited}{$self->address($_[0])};';
$Qa=bless({$o,$Oa,$q,$Pa,$s,$t},$u);
$Ra=q'quote';
$Sa=[];
$Ta=q'my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? \'undef\' : $v if defined $v;
$$self{visited}{$a} = \\\'undef\';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));';
$Ua=bless({$o,$Sa,$q,$Ta,$s,$t},$u);
$Va=q'quote_array';
$Wa=[];
$Xa=q'local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_])
  && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
for 0..$#{$v};
\'[\' . join(\',\', map $self->quote($_), @$v) . \']\';';
$Ya=bless({$o,$Wa,$q,$Xa,$s,$t},$u);
$Za=q'quote_blessed';
$cb=[];
$db=q'my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq \'HASH\' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";';
$eb=bless({$o,$cb,$q,$db,$s,$t},$u);
$fb=q'quote_class';
$gb=[];
$hb=q'my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");';
$ib=bless({$o,$gb,$q,$hb,$s,$t},$u);
$jb=q'quote_hash';
$kb=[];
$lb=q'local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  push @{$$self{circular}}, [$a, "{" . $self->quote($k) . "}",
                                 $self->address($$v{$k})]
  if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
\'{\' . join(",", @qs) . \'}\';';
$mb=bless({$o,$kb,$q,$lb,$s,$t},$u);
$nb=q'quote_object';
$ob=[];
$pb=q'my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can(\'serialize\') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;';
$qb=bless({$o,$ob,$q,$pb,$s,$t},$u);
$rb=q'quote_scalar';
$sb=[];
$tb=q'my $v = $_[1];
return \'undef\' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\'])/\\\\$1/g;
"q\'$v\'";';
$ub=bless({$o,$sb,$q,$tb,$s,$t},$u);
$vb=q'quote_value';
$wb=[];
$xb=q'my $self = shift;
return $self->quote_scalar($_[0]) unless ref $_[0];
return $self->quote_array($_[0])  if \'ARRAY\' eq ref $_[0];
return $self->quote_hash($_[0])   if \'HASH\'  eq ref $_[0];
die "cannot serialize $_[0]"      if \'CODE\'  eq ref $_[0];
$self->quote_object($_[0]);';
$yb=bless({$o,$wb,$q,$xb,$s,$t},$u);
$zb=q'reconstruction';
$Ab=[];
$Bb=q'my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});';
$Cb=bless({$o,$Ab,$q,$Bb,$s,$t},$u);
$Db=q'side_effect';
$Eb=[];
$Fb=q'push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]';
$Gb=bless({$o,$Eb,$q,$Fb,$s,$t},$u);
$Hb=q'write';
$Ib=[];
$Jb=q'local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  ($$self{include_shebang} ? ("#!/usr/bin/env perl\\n") : ()),
  ($$self{include_license} ? ("chomp(\\$ni::license=<<\'_\');\\n", $ni::license, "\\n_\\n") : ()),
  ($$self{include_boot}    ? ("BEGIN{eval(\\$ni::boot=<<\'_\')}\\n", $ni::boot, "\\n_\\n") : ()),
  ($$self{use_newlines}    ? map("$_\\n", $self->reconstruction) : $self->reconstruction),
  ($$self{include_run}     ? ("ni->run(\\@ARGV);", "\\n__DATA__\\n") : ());';
$Kb=bless({$o,$Ib,$q,$Jb,$s,$t},$u);
$Lb={$pa,$sa,$ta,$wa,$xa,$Aa,$Ba,$Ea,$Fa,$Ia,$Ja,$Ma,$Na,$Qa,$Ra,$Ua,$Va,$Ya,$Za,$eb,$fb,$ib,$jb,$mb,$nb,$qb,$rb,$ub,$vb,$yb,$zb,$Cb,$Db,$Gb,$Hb,$Kb};
$Mb=q'/lib/image_quoting.b';
$Nb=bless({$B1,$oa,$k2,$l2,$m2,$l2,$n2,$Lb,$D,$Mb},$w2);
$Ob=q'lib/slice::ctors';
$Pb=[$f4,$ma,$Nb];
$Qb=bless({$B1,$ea,$D,$fa,$c2,$Pb},$J1);
$Rb=q'lib/image.c::ctors';
$Sb=q'ni:/lib/image.c';
$Tb={$J1,1};
$Ub=q'/lib/image.c';
$Vb=[$l6];
$Wb=bless({$B1,$Tb,$D,$Ub,$c2,$Vb},$e2);
$Xb=q'metaclass::ctors';
$Yb=q'ni:/lib/image_init.b';
$Zb=q'ni:/lib/image_quoting.b';
$cc=q'ni:/lib/instance.b';
$dc=q'ni:/lib/instantiable.b';
$ec=q'ni:/lib/json.b';
$fc={};
$gc=q'json_decode';
$hc=[];
$ic=q'local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];';
$jc=bless({$o,$hc,$q,$ic,$s,$U9},$u);
$kc=q'json_encode';
$lc=[];
$mc=q'local $_;
my ($v) = @_;
return "[" . join(\',\', map ni::json_encode($_), @$v) . "]" if \'ARRAY\' eq ref $v;
return "{" . join(\',\', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if \'HASH\' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : \'null\';';
$nc=bless({$o,$lc,$q,$mc,$s,$U9},$u);
$oc=q'json_escape';
$pc=[];
$qc=q'(my $x = $_[0]) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . $ni::json_escapes{$1}/eg;
"\\"$x\\"";';
$rc=bless({$o,$pc,$q,$qc,$s,$U9},$u);
$sc=q'json_unescape';
$tc=[];
$uc=q'my $x = substr $_[0], 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;';
$vc=bless({$o,$tc,$q,$uc,$s,$U9},$u);
$wc=q'json_unescape_one';
$xc=[];
$yc=q'$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1';
$zc=bless({$o,$xc,$q,$yc,$s,$U9},$u);
$Ac={$gc,$jc,$kc,$nc,$oc,$rc,$sc,$vc,$wc,$zc};
$Bc=q'/lib/json.b';
$Cc=bless({$B1,$fc,$k2,$l2,$m2,$l2,$n2,$Ac,$D,$Bc},$w2);
$Dc=q'ni';
$Ec=q'lib/slice::ctors';
$Fc=q'ni:/lib/name_as_string.b';
$Gc=q'ni:/lib/named.b';
$Hc=q'ni:/lib/named_in_ni.b';
$Ic=q'ni:/lib/namespaced.b';
$Jc=q'ni:/lib/ni';
$Kc={$G3,1};
$Lc=q'/lib/ni';
$Mc={};
$Nc=q'is_mutable';
$Oc=[];
$Pc=q'$0 ne "-" && -w $0';
$Qc=bless({$o,$Oc,$q,$Pc,$s,$t},$u);
$Rc=q'modify';
$Sc=[];
$Tc=q'my ($self, $fn) = @_;
# TODO: replace all of this with a generalized "atomic-update" function
# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join \'/\', @r;
open my $w, \'>\', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";';
$Uc=bless({$o,$Sc,$q,$Tc,$s,$t},$u);
$Vc={$Nc,$Qc,$Rc,$Uc};
$Wc=q'/lib/ni_self.b';
$Xc=bless({$B1,$Mc,$k2,$l2,$m2,$l2,$n2,$Vc,$D,$Wc},$w2);
$Yc=q'lib/slice::ctors';
$Zc={};
$cd=q'exists';
$dd=[];
$ed=q'exists $_[0]->{named}{$_[1]}';
$fd=bless({$o,$dd,$q,$ed,$s,$t},$u);
$gd=q'quoted';
$hd=[];
$id=q'my $self = shift;
my $q = ni(\'ni:/lib/image\')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;';
$jd=bless({$o,$hd,$q,$id,$s,$t},$u);
$kd={$cd,$fd,$gd,$jd};
$ld=q'/lib/ni_image.b';
$md=bless({$B1,$Zc,$k2,$l2,$m2,$l2,$n2,$kd,$D,$ld},$w2);
$nd=q'lib/slice::ctors';
$od={};
$pd=q'--internal/+=';
$qd=[];
$rd=q'my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
  die "ni: failed to run $_: $!" unless $r;
}
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;';
$sd=bless({$o,$qd,$q,$rd,$s,$t},$u);
$td=q'--internal/eval';
$ud=[];
$vd=q'my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;';
$wd=bless({$o,$ud,$q,$vd,$s,$t},$u);
$xd=q'--internal/image';
$yd=[];
$zd=q'shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;';
$Ad=bless({$o,$yd,$q,$zd,$s,$t},$u);
$Bd=q'--internal/test';
$Cd=[];
$Dd=q'my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL: $@ in $t\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL: $r\\n";
  }
}
my $passed = @tests - $fails;
print "$passed test(s) passed\\n";
!!$fails;';
$Ed=bless({$o,$Cd,$q,$Dd,$s,$t},$u);
$Fd=q'run';
$Gd=[];
$Hd=q'my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);';
$Id=bless({$o,$Gd,$q,$Hd,$s,$t},$u);
$Jd={$pd,$sd,$td,$wd,$xd,$Ad,$Bd,$Ed,$Fd,$Id};
$Kd=q'/lib/ni_main.b';
$Ld=bless({$B1,$od,$k2,$l2,$m2,$l2,$n2,$Jd,$D,$Kd},$w2);
$Md=q'lib/slice::ctors';
$Nd={};
$Od=[];
$Pd=q'my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";';
$Qd=bless({$o,$Od,$q,$Pd,$s,$t},$u);
$Rd=q'resolver_for';
$Sd=[];
$Td=q'my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;';
$Ud=bless({$o,$Sd,$q,$Td,$s,$t},$u);
$Vd={$h3,$Qd,$Rd,$Ud};
$Wd=q'/lib/ni_resolver.b';
$Xd=bless({$B1,$Nd,$k2,$l2,$m2,$l2,$n2,$Vd,$D,$Wd},$w2);
$Yd=q'lib/slice::ctors';
$Zd=[$f4,$Xc,$md,$Ld,$Xd];
$ce=bless({$B1,$Kc,$D,$Lc,$c2,$Zd},$K1);
$de=q'lib/ni.c::ctors';
$ee=q'ni:/lib/ni.c';
$fe={$K1,1};
$ge=q'/lib/ni.c';
$he=[$l6];
$ie=bless({$B1,$fe,$D,$ge,$c2,$he},$e2);
$je=q'metaclass::ctors';
$ke=q'ni:/lib/ni_fork.b';
$le={};
$me=q'fork';
$ne=[];
$oe=q'ni::fork_with(shift)';
$pe=q'(&)';
$qe=bless({$o,$ne,$q,$oe,$s,$pe},$u);
$re=q'fork_with';
$se=[];
$te=q'my $fn     = pop;
my %pipes  = @_;
my $stdin  = $pipes{stdin}  || ni(\'ni:/unix/fifo\')->new;
my $stdout = $pipes{stdout} || ni(\'ni:/unix/fifo\')->new;
my $stderr = $pipes{stderr} || ni(\'ni:/unix/fifo\')->new;
my $pid    = fork;
die "/lib/ni_fork.b: failed to fork: $!" unless defined $pid;

return ni(\'ni:/unix/pid\')->new($pid,
  exists $pipes{stdin}  ? undef : $stdin->w,
  exists $pipes{stdout} ? undef : $stdout->r,
  exists $pipes{stderr} ? undef : $stderr->r) if $pid;

exists $pipes{stdin}  ? $stdin->be_stdin   : $stdin->r->be_stdin;
exists $pipes{stdout} ? $stdout->be_stdout : $stdout->w->be_stdout;
exists $pipes{stderr} ? $stderr->be_stderr : $stderr->w->be_stderr;
exit &$fn($stdin, $stdout, $stderr);';
$ue=bless({$o,$se,$q,$te,$s,$t},$u);
$ve={$me,$qe,$re,$ue};
$we=q'/lib/ni_fork.b';
$xe=bless({$B1,$le,$k2,$l2,$m2,$l2,$n2,$ve,$D,$we},$w2);
$ye=q'lib/slice::ctors';
$ze=q'ni:/lib/ni_fork_exec.b';
$Ae={};
$Be=q'fork_exec';
$Ce=[];
$De=q'my @argv = @_;
ni::fork {exec @argv or die "ni:/unix/pid.c: failed to exec @argv: $!"};';
$Ee=bless({$o,$Ce,$q,$De,$s,$t},$u);
$Fe={$Be,$Ee};
$Ge=q'/lib/ni_fork_exec.b';
$He=bless({$B1,$Ae,$k2,$l2,$m2,$l2,$n2,$Fe,$D,$Ge},$w2);
$Ie=q'lib/slice::ctors';
$Je=q'ni:/lib/ni_image.b';
$Ke=q'ni:/lib/ni_main.b';
$Le=q'ni:/lib/ni_resolver.b';
$Me=q'ni:/lib/ni_self.b';
$Ne=q'ni:/lib/ni_static_util.b';
$Oe={};
$Pe=q'abbrev';
$Qe=[];
$Re=q'length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . \'...\'';
$Se=bless({$o,$Qe,$q,$Re,$s,$t},$u);
$Te=q'dor';
$Ue=[];
$Ve=q'defined $_[0] ? $_[0] : $_[1]';
$We=bless({$o,$Ue,$q,$Ve,$s,$t},$u);
$Xe=q'indent';
$Ye=[];
$Ze=q'my ($s, $indent) = (@_, 2);
join "\\n", map \' \' x $indent . $_, split /\\n/, $s;';
$cf=bless({$o,$Ye,$q,$Ze,$s,$t},$u);
$df=q'max';
$ef=[];
$ff=q'local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m';
$gf=bless({$o,$ef,$q,$ff,$s,$t},$u);
$hf=q'maxstr';
$if=[];
$jf=q'local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m';
$kf=bless({$o,$if,$q,$jf,$s,$t},$u);
$lf=q'mean';
$mf=[];
$nf=q'sum(@_) / (@_ || 1)';
$of=bless({$o,$mf,$q,$nf,$s,$t},$u);
$pf=q'min';
$qf=[];
$rf=q'local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m';
$sf=bless({$o,$qf,$q,$rf,$s,$t},$u);
$tf=q'minstr';
$uf=[];
$vf=q'local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m';
$wf=bless({$o,$uf,$q,$vf,$s,$t},$u);
$xf=q'sgr';
$yf=[];
$zf=q'(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x';
$Af=bless({$o,$yf,$q,$zf,$s,$t},$u);
$Bf=q'sr';
$Cf=[];
$Df=q'(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x';
$Ef=bless({$o,$Cf,$q,$Df,$s,$t},$u);
$Ff=q'sum';
$Gf=[];
$Hf=q'local $_; my $x = 0; $x += $_ for @_; $x';
$If=bless({$o,$Gf,$q,$Hf,$s,$t},$u);
$Jf=q'swap';
$Kf=[];
$Lf=q'@_[0, 1] = @_[1, 0]';
$Mf=bless({$o,$Kf,$q,$Lf,$s,$t},$u);
$Nf={$Pe,$Se,$Te,$We,$Xe,$cf,$df,$gf,$hf,$kf,$lf,$of,$pf,$sf,$tf,$wf,$xf,$Af,$Bf,$Ef,$Ff,$If,$Jf,$Mf};
$Of=q'/lib/ni_static_util.b';
$Pf=bless({$B1,$Oe,$k2,$l2,$m2,$l2,$n2,$Nf,$D,$Of},$w2);
$Qf=q'lib/slice::ctors';
$Rf=q'ni:/lib/perlbranch.b';
$Sf=q'ni:/lib/ref_eq.b';
$Tf=q'ni:/lib/resolver.b';
$Uf=q'ni:/lib/slice';
$Vf={$w2,1};
$Wf=q'/lib/slice';
$Xf=q'local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply(\'$p\'): perl packages don\'t start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);';
$Yf=bless({$q,$Xf,$s,$t},$u);
$Zf=q'local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;';
$cg=bless({$q,$Zf,$s,$t},$u);
$dg=q'lib/slice::apply';
$eg=q'lib/slice::apply_unsafe';
$fg={};
$gg=q'apply_unsafe';
$hg={$r2,$Yf,$gg,$cg};
$ig=q'/lib/slice.b';
$jg=bless({$B1,$fg,$n2,$hg,$D,$ig},$w2);
$kg=q'lib/slice::ctors';
$lg={};
$mg=q'my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};';
$ng=bless({$q,$mg,$s,$t},$u);
$og={$v3,$ng};
$pg=q'/lib/slice_init.b';
$qg=bless({$B1,$lg,$n2,$og,$D,$pg},$w2);
$rg=q'lib/slice::ctors';
$sg={};
$tg=[];
$ug=q'local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq \'ni:/lib/slice.b\') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      \'*\' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;';
$vg=bless({$o,$tg,$q,$ug,$s,$t},$u);
$wg={$u9,$vg};
$xg=q'/lib/slice_serialize.b';
$yg=bless({$B1,$sg,$k2,$l2,$m2,$l2,$n2,$wg,$D,$xg},$w2);
$zg=q'lib/slice::ctors';
$Ag=[$t4,$I2,$jg,$qg,$yg];
$Bg=bless({$B1,$Vf,$D,$Wf,$c2,$Ag},$L1);
$Cg=q'lib/slice.c::ctors';
$Dg=q'ni:/lib/slice.b';
$Eg=q'ni:/lib/slice.c';
$Fg={$L1,1};
$Gg=q'/lib/slice.c';
$Hg=[$q6];
$Ig=bless({$B1,$Fg,$D,$Gg,$c2,$Hg},$e2);
$Jg=q'metaclass::ctors';
$Kg=q'ni:/lib/slice_init.b';
$Lg=q'ni:/lib/slice_serialize.b';
$Mg=q'ni:/lib/static_fn.b';
$Ng={};
$Og=[];
$Pg=q'ni(\'ni:/lib/fn\')->new(@_)';
$Qg=bless({$o,$Og,$q,$Pg,$s,$U9},$u);
$Rg=q'fp';
$Sg=[];
$Tg=q'ni(\'ni:/lib/fn\')->new(@_)';
$Ug=q'($$)';
$Vg=bless({$o,$Sg,$q,$Tg,$s,$Ug},$u);
$Wg={$Y8,$Qg,$Rg,$Vg};
$Xg=q'/lib/static_fn.b';
$Yg=bless({$B1,$Ng,$k2,$l2,$m2,$l2,$n2,$Wg,$D,$Xg},$w2);
$Zg=q'lib/slice::ctors';
$ch=q'ni:/lib/subclass.b';
$dh=q'ni:/lib/tag';
$eh={$J2,1};
$fh=q'/lib/tag';
$gh={};
$hh=q'local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;';
$ih=bless({$q,$hh,$s,$t},$u);
$jh={$r2,$ih};
$kh=q'/lib/tag.b';
$lh=bless({$B1,$gh,$k2,$l2,$m2,$l2,$n2,$jh,$D,$kh},$w2);
$mh=q'lib/slice::ctors';
$nh={};
$oh=q'local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};';
$ph=bless({$q,$oh,$s,$t},$u);
$qh={$v3,$ph};
$rh=q'/lib/tag_init.b';
$sh=bless({$B1,$nh,$k2,$l2,$m2,$l2,$n2,$qh,$D,$rh},$w2);
$th=q'lib/slice::ctors';
$uh=[$t4,$I2,$lh,$sh];
$vh=bless({$B1,$eh,$D,$fh,$c2,$uh},$M1);
$wh=q'lib/tag.c::ctors';
$xh=q'ni:/lib/tag.b';
$yh=q'ni:/lib/tag.c';
$zh={$M1,1};
$Ah=q'/lib/tag.c';
$Bh=[$q6];
$Ch=bless({$B1,$zh,$D,$Ah,$c2,$Bh},$e2);
$Dh=q'metaclass::ctors';
$Eh=q'ni:/lib/tag_init.b';
$Fh=q'ni:/lib/test_value';
$Gh={$H3,1};
$Hh=q'/lib/test_value';
$Ih={};
$Jh=[];
$Kh=q'\\$_[1]';
$Lh=bless({$o,$Jh,$q,$Kh,$s,$t},$u);
$Mh={$v3,$Lh};
$Nh=q'/lib/test_value_init.b';
$Oh=bless({$B1,$Ih,$k2,$l2,$m2,$l2,$n2,$Mh,$D,$Nh},$w2);
$Ph=q'lib/slice::ctors';
$Qh={};
$Rh=q'(==';
$Sh=[];
$Th=q'my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;';
$Uh=bless({$o,$Sh,$q,$Th,$s,$t},$u);
$Vh=q'diff';
$Wh=[];
$Xh=q'my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq \'HASH\') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq \'ARRAY\') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq \'SCALAR\') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;';
$Yh=bless({$o,$Wh,$q,$Xh,$s,$t},$u);
$Zh={$Rh,$Uh,$Vh,$Yh};
$ci=q'/lib/test_value_eq.b';
$di=bless({$B1,$Qh,$k2,$l2,$m2,$l2,$n2,$Zh,$D,$ci},$w2);
$ei=q'lib/slice::ctors';
$fi={};
$gi=[];
$hi=q'ni::json_encode ${$_[0]}';
$ii=bless({$o,$gi,$q,$hi,$s,$t},$u);
$ji={$U4,$ii};
$ki=q'/lib/test_value_str.b';
$li=bless({$B1,$fi,$k2,$l2,$m2,$l2,$n2,$ji,$D,$ki},$w2);
$mi=q'lib/slice::ctors';
$ni=[$f4,$Oh,$di,$li];
$oi=q'lib/test_value.c';
$pi=bless({$B1,$Gh,$D,$Hh,$c2,$ni},$oi);
$qi=q'lib/test_value.c::ctors';
$ri=q'ni:/lib/test_value.c';
$si=q'lib/test_value.c';
$ti={$si,1};
$ui=q'/lib/test_value.c';
$vi=[$l6];
$wi=bless({$B1,$ti,$D,$ui,$c2,$vi},$e2);
$xi=q'metaclass::ctors';
$yi=q'ni:/lib/test_value_eq.b';
$zi=q'ni:/lib/test_value_init.b';
$Ai=q'ni:/lib/test_value_str.b';
$Bi=q'ni:/metaclass';
$Ci={$e2,1};
$Di=q'/metaclass';
$Ei=[$q3,$L5,$A3,$A5];
$Fi=bless({$B1,$Ci,$D,$Di,$c2,$Ei},$O1);
$Gi=q'metaclass.c::ctors';
$Hi=q'ni:/metaclass.c';
$Ii={$O1,1};
$Ji=q'/metaclass.c';
$Ki=[$Y5];
$Li=bless({$B1,$Ii,$D,$Ji,$c2,$Ki},$e2);
$Mi=q'metaclass::ctors';
$Ni=q'ni:/module';
$Oi=q'ni:/module.c';
$Pi=q'ni:/object';
$Qi=q'ni:/object.c';
$Ri=q'ni:/unix/cat';
$Si={$K3,1};
$Ti={$K3,1,$L3,1,$M3,1,$N3,1,$O3,1,$P3,1,$Q3,1,$R3,1};
$Ui=q'/unix/io';
$Vi={};
$Wi=q'(bool';
$Xi=[];
$Yi=bless({$o,$Xi,$q,1,$s,$t},$u);
$Zi={$Wi,$Yi};
$cj=q'/unix/io_ops.b';
$dj=bless({$B1,$Vi,$k2,$l2,$m2,$l2,$n2,$Zi,$D,$cj},$w2);
$ej=q'lib/slice::ctors';
$fj={};
$gj=q'into';
$hj=[];
$ij=q'local $_;
my ($self, $dest, $each) = @_;
my $block_size = $self->can(\'read_size\') ? $self->read_size : 8192;
while ($self->read($_, $block_size)) {
  &$each($_) if defined $each;
  $dest->write($_);
}';
$jj=bless({$o,$hj,$q,$ij,$s,$t},$u);
$kj={$gj,$jj};
$lj=q'/unix/io_stream.b';
$mj=bless({$B1,$fj,$k2,$l2,$m2,$l2,$n2,$kj,$D,$lj},$w2);
$nj=q'lib/slice::ctors';
$oj={};
$pj=q'(+';
$qj=[];
$rj=q'ni(\'ni:/unix/cat\')->new(@_[0, 1])';
$sj=bless({$o,$qj,$q,$rj,$s,$t},$u);
$tj={$pj,$sj};
$uj=q'/unix/io_constructors.b';
$vj=bless({$B1,$oj,$k2,$l2,$m2,$l2,$n2,$tj,$D,$uj},$w2);
$wj=q'lib/slice::ctors';
$xj={};
$yj=q'read_all';
$zj=[];
$Aj=q'shift->into(ni("ni:/unix/str")->new(my $data = ""));
$data;';
$Bj=bless({$o,$zj,$q,$Aj,$s,$t},$u);
$Cj={$yj,$Bj};
$Dj=q'/unix/io_memory.b';
$Ej=bless({$B1,$xj,$k2,$l2,$m2,$l2,$n2,$Cj,$D,$Dj},$w2);
$Fj=q'lib/slice::ctors';
$Gj={};
$Hj=q'(<>';
$Ij=[];
$Jj=q'my $fh = shift->read_fh;
# TODO: buffered line reading with a pushback queue';
$Kj=bless({$o,$Ij,$q,$Jj,$s,$t},$u);
$Lj=q'(@{}';
$Mj=[];
$Nj=q'my $self = shift; [<$self>]';
$Oj=bless({$o,$Mj,$q,$Nj,$s,$t},$u);
$Pj={$Hj,$Kj,$Lj,$Oj};
$Qj=q'/unix/io_readers.b';
$Rj=bless({$B1,$Gj,$k2,$l2,$m2,$l2,$n2,$Pj,$D,$Qj},$w2);
$Sj=q'lib/slice::ctors';
$Tj=[$f4,$dj,$mj,$vj,$Ej,$Rj];
$Uj=bless({$B1,$Ti,$D,$Ui,$c2,$Tj},$V1);
$Vj=q'unix/io.c::ctors';
$Wj={};
$Xj=[];
$Yj=q'shift; +{fs => [@_]}';
$Zj=bless({$o,$Xj,$q,$Yj,$s,$t},$u);
$ck={$v3,$Zj};
$dk=q'/unix/cat_init.b';
$ek=bless({$B1,$Wj,$k2,$l2,$m2,$l2,$n2,$ck,$D,$dk},$w2);
$fk=q'lib/slice::ctors';
$gk={};
$hk=q'read';
$ik=[];
$jk=q'my $fs = shift->{fs};
my $n;
shift @$fs until !@$fs or $n = $$fs[0]->read(@_);
return $n;';
$kk=bless({$o,$ik,$q,$jk,$s,$t},$u);
$lk={$hk,$kk};
$mk=q'/unix/cat_read.b';
$nk=bless({$B1,$gk,$k2,$l2,$m2,$l2,$n2,$lk,$D,$mk},$w2);
$ok=q'lib/slice::ctors';
$pk=[$Uj,$ek,$nk];
$qk=bless({$B1,$Si,$D,$k1,$c2,$pk},$R1);
$rk=q'unix/cat.c::ctors';
$sk=q'ni:/unix/cat.c';
$tk={$R1,1};
$uk=q'/unix/cat.c';
$vk={$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1};
$wk=q'/unix/io.c';
$xk=[$l6];
$yk=bless({$B1,$vk,$D,$wk,$c2,$xk},$e2);
$zk=q'metaclass::ctors';
$Ak=[$yk];
$Bk=bless({$B1,$tk,$D,$uk,$c2,$Ak},$e2);
$Ck=q'metaclass::ctors';
$Dk=q'ni:/unix/cat_init.b';
$Ek=q'ni:/unix/cat_read.b';
$Fk=q'ni:/unix/fd';
$Gk={$L3,1};
$Hk=q'/unix/fd';
$Ik={};
$Jk=q'fd';
$Kk=[];
$Lk=q'shift->{\'fd\'}';
$Mk=bless({$o,$Kk,$q,$Lk,$s,$t},$u);
$Nk={$Jk,$Mk};
$Ok=q'/unix/fd_readers.b';
$Pk=bless({$B1,$Ik,$k2,$l2,$m2,$l2,$n2,$Nk,$D,$Ok},$w2);
$Qk=q'lib/slice::ctors';
$Rk={};
$Sk=[];
$Tk=q'my ($class, $fd) = @_;
+{fd => ref $fd ? fileno $fd : $fd,
  fh => ref $fd ? $fd        : undef};';
$Uk=bless({$o,$Sk,$q,$Tk,$s,$t},$u);
$Vk={$v3,$Uk};
$Wk=q'/unix/fd_init.b';
$Xk=bless({$B1,$Rk,$k2,$l2,$m2,$l2,$n2,$Vk,$D,$Wk},$w2);
$Yk=q'lib/slice::ctors';
$Zk={};
$cl=q'be';
$dl=[];
$el=q'use POSIX qw/dup2/;
my ($self, $new) = @_;
return $self if $new == $$self{fd};
close $$self{fh} if Scalar::Util::openhandle $$self{fh};
dup2 $$self{fd}, $new or die "ni:/unix/fd: dup2($$self{fd}, $new): $!";
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;';
$fl=bless({$o,$dl,$q,$el,$s,$t},$u);
$gl={$cl,$fl};
$hl=q'/unix/fd_shell.b';
$il=bless({$B1,$Zk,$k2,$l2,$m2,$l2,$n2,$gl,$D,$hl},$w2);
$jl=q'lib/slice::ctors';
$kl={$L3,1,$M3,1,$N3,1,$P3,1,$Q3,1};
$ll=q'/unix/has_fd.b';
$ml={};
$nl=q'be_stderr';
$ol=[];
$pl=q'ni("ni:/unix/fd")->new(fileno shift->write_fh)->be(2)';
$ql=bless({$o,$ol,$q,$pl,$s,$t},$u);
$rl=q'be_stdin';
$sl=[];
$tl=q'ni("ni:/unix/fd")->new(fileno shift->read_fh)->be(0)';
$ul=bless({$o,$sl,$q,$tl,$s,$t},$u);
$vl=q'be_stdout';
$wl=[];
$xl=q'ni("ni:/unix/fd")->new(fileno shift->write_fh)->be(1)';
$yl=bless({$o,$wl,$q,$xl,$s,$t},$u);
$zl={$nl,$ql,$rl,$ul,$vl,$yl};
$Al=q'/unix/fd_stdio.b';
$Bl=bless({$B1,$ml,$k2,$l2,$m2,$l2,$n2,$zl,$D,$Al},$w2);
$Cl=q'lib/slice::ctors';
$Dl={};
$El=[];
$Fl=q'no warnings \'io\';
use Errno qw/EINTR/;
my $fh = shift->read_fh;
my $n;
do {
  return $n if defined($n = read $fh, $_[0], $_[1], $_[2] || 0);
} while $!{EINTR};
return undef;';
$Gl=bless({$o,$El,$q,$Fl,$s,$t},$u);
$Hl=[];
$Il=q'my $fh = shift->write_fh;
my $n;
do {
  return $n if defined($n = syswrite $fh, $_[0]);
} while $!{EINTR};
return undef;';
$Jl=bless({$o,$Hl,$q,$Il,$s,$t},$u);
$Kl={$hk,$Gl,$Hb,$Jl};
$Ll=q'/unix/fd_safeio.b';
$Ml=bless({$B1,$Dl,$k2,$l2,$m2,$l2,$n2,$Kl,$D,$Ll},$w2);
$Nl=q'lib/slice::ctors';
$Ol=[$Bl,$Ml];
$Pl=bless({$B1,$kl,$D,$ll,$c2,$Ol},$y2);
$Ql=q'lib/branch::ctors';
$Rl={};
$Sl=q'read_fh';
$Tl=[];
$Ul=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'<&=\', $self->{fd}
  or die "ni:/unix/fd $self->{fd} failed to read: $!";
$self->{fh} = $fh;';
$Vl=bless({$o,$Tl,$q,$Ul,$s,$t},$u);
$Wl=q'write_fh';
$Xl=[];
$Yl=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'>&=\', $self->{fd}
  or die "ni:/unix/file $self->{fd} failed to write: $!";
$self->{fh} = $fh;';
$Zl=bless({$o,$Xl,$q,$Yl,$s,$t},$u);
$cm={$Sl,$Vl,$Wl,$Zl};
$dm=q'/unix/fd_io.b';
$em=bless({$B1,$Rl,$k2,$l2,$m2,$l2,$n2,$cm,$D,$dm},$w2);
$fm=q'lib/slice::ctors';
$gm=[$Uj,$Pk,$Xk,$il,$Pl,$em];
$hm=bless({$B1,$Gk,$D,$Hk,$c2,$gm},$S1);
$im=q'unix/fd.c::ctors';
$jm=q'ni:/unix/fd.c';
$km={$S1,1};
$lm=q'/unix/fd.c';
$mm=[$yk];
$nm=bless({$B1,$km,$D,$lm,$c2,$mm},$e2);
$om=q'metaclass::ctors';
$pm=q'ni:/unix/fd_init.b';
$qm=q'ni:/unix/fd_io.b';
$rm=q'ni:/unix/fd_readers.b';
$sm=q'ni:/unix/fd_safeio.b';
$tm=q'ni:/unix/fd_shell.b';
$um=q'ni:/unix/fd_stdio.b';
$vm=q'ni:/unix/fifo';
$wm={$M3,1};
$xm=q'/unix/fifo';
$ym={};
$zm=[];
$Am=q'shift->{\'read_fh\'}';
$Bm=bless({$o,$zm,$q,$Am,$s,$t},$u);
$Cm=[];
$Dm=q'shift->{\'write_fh\'}';
$Em=bless({$o,$Cm,$q,$Dm,$s,$t},$u);
$Fm={$Sl,$Bm,$Wl,$Em};
$Gm=q'/unix/fifo_io.b';
$Hm=bless({$B1,$ym,$k2,$l2,$m2,$l2,$n2,$Fm,$D,$Gm},$w2);
$Im=q'lib/slice::ctors';
$Jm={};
$Km=[];
$Lm=q'my ($class) = @_;
pipe my ($r, $w) or die "ni:/unix/fifo failed: $!";
+{read_fh => $r, write_fh => $w};';
$Mm=bless({$o,$Km,$q,$Lm,$s,$t},$u);
$Nm={$v3,$Mm};
$Om=q'/unix/fifo_init.b';
$Pm=bless({$B1,$Jm,$k2,$l2,$m2,$l2,$n2,$Nm,$D,$Om},$w2);
$Qm=q'lib/slice::ctors';
$Rm={};
$Sm=q'r';
$Tm=[];
$Um=q'my $self = shift;
close $$self{write_fh};
ni("ni:/unix/fd")->new(fileno $$self{read_fh});';
$Vm=bless({$o,$Tm,$q,$Um,$s,$t},$u);
$Wm=q'w';
$Xm=[];
$Ym=q'my $self = shift;
close $$self{read_fh};
ni("ni:/unix/fd")->new(fileno $$self{write_fh});';
$Zm=bless({$o,$Xm,$q,$Ym,$s,$t},$u);
$cn={$Sm,$Vm,$Wm,$Zm};
$dn=q'/unix/fifo_direction.b';
$en=bless({$B1,$Rm,$k2,$l2,$m2,$l2,$n2,$cn,$D,$dn},$w2);
$fn=q'lib/slice::ctors';
$gn=[$Uj,$Hm,$Pm,$Pl,$en];
$hn=bless({$B1,$wm,$D,$xm,$c2,$gn},$T1);
$in=q'unix/fifo.c::ctors';
$jn=q'ni:/unix/fifo.c';
$kn={$T1,1};
$ln=q'/unix/fifo.c';
$mn=[$yk];
$nn=bless({$B1,$kn,$D,$ln,$c2,$mn},$e2);
$on=q'metaclass::ctors';
$pn=q'ni:/unix/fifo_direction.b';
$qn=q'ni:/unix/fifo_init.b';
$rn=q'ni:/unix/fifo_io.b';
$sn=q'ni:/unix/file';
$tn={$N3,1};
$un=q'/unix/file';
$vn={};
$wn=[];
$xn=q'shift->{\'name\'}';
$yn=bless({$o,$wn,$q,$xn,$s,$t},$u);
$zn={$D,$yn};
$An=q'/unix/file_readers.b';
$Bn=bless({$B1,$vn,$k2,$l2,$m2,$l2,$n2,$zn,$D,$An},$w2);
$Cn=q'lib/slice::ctors';
$Dn={};
$En=[];
$Fn=q'my ($class, $name) = @_;
+{name => $name, fh => undef};';
$Gn=bless({$o,$En,$q,$Fn,$s,$t},$u);
$Hn={$v3,$Gn};
$In=q'/unix/file_init.b';
$Jn=bless({$B1,$Dn,$k2,$l2,$m2,$l2,$n2,$Hn,$D,$In},$w2);
$Kn=q'lib/slice::ctors';
$Ln={};
$Mn=[];
$Nn=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'<\', $self->{name}
  or die "ni:/unix/file $self->{name} failed to read: $!";
$self->{fh} = $fh;';
$On=bless({$o,$Mn,$q,$Nn,$s,$t},$u);
$Pn=[];
$Qn=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'>\', $self->{name}
  or die "ni:/unix/file $self->{name} failed to write: $!";
$self->{fh} = $fh;';
$Rn=bless({$o,$Pn,$q,$Qn,$s,$t},$u);
$Sn={$Sl,$On,$Wl,$Rn};
$Tn=q'/unix/file_io.b';
$Un=bless({$B1,$Ln,$k2,$l2,$m2,$l2,$n2,$Sn,$D,$Tn},$w2);
$Vn=q'lib/slice::ctors';
$Wn=[$Uj,$Bn,$Jn,$Pl,$Un];
$Xn=bless({$B1,$tn,$D,$un,$c2,$Wn},$U1);
$Yn=q'unix/file.c::ctors';
$Zn=q'ni:/unix/file.c';
$co={$U1,1};
$do=q'/unix/file.c';
$eo=[$yk];
$fo=bless({$B1,$co,$D,$do,$c2,$eo},$e2);
$go=q'metaclass::ctors';
$ho=q'ni:/unix/file_init.b';
$io=q'ni:/unix/file_io.b';
$jo=q'ni:/unix/file_readers.b';
$ko=q'ni:/unix/has_fd.b';
$lo=q'ni:/unix/io';
$mo=q'ni:/unix/io.c';
$no=q'ni:/unix/io_constructors.b';
$oo=q'ni:/unix/io_memory.b';
$po=q'ni:/unix/io_ops.b';
$qo=q'ni:/unix/io_readers.b';
$ro=q'ni:/unix/io_stream.b';
$so=q'ni:/unix/pid';
$to={$P3,1};
$uo={};
$vo=q'pid';
$wo=[];
$xo=q'shift->{\'pid\'}';
$yo=bless({$o,$wo,$q,$xo,$s,$t},$u);
$zo=q'status';
$Ao=[];
$Bo=q'shift->{\'status\'}';
$Co=bless({$o,$Ao,$q,$Bo,$s,$t},$u);
$Do=q'stderr';
$Eo=[];
$Fo=q'shift->{\'stderr\'}';
$Go=bless({$o,$Eo,$q,$Fo,$s,$t},$u);
$Ho=q'stdin';
$Io=[];
$Jo=q'shift->{\'stdin\'}';
$Ko=bless({$o,$Io,$q,$Jo,$s,$t},$u);
$Lo=q'stdout';
$Mo=[];
$No=q'shift->{\'stdout\'}';
$Oo=bless({$o,$Mo,$q,$No,$s,$t},$u);
$Po={$vo,$yo,$zo,$Co,$Do,$Go,$Ho,$Ko,$Lo,$Oo};
$Qo=q'/unix/pid_readers.b';
$Ro=bless({$B1,$uo,$k2,$l2,$m2,$l2,$n2,$Po,$D,$Qo},$w2);
$So=q'lib/slice::ctors';
$To={};
$Uo=[];
$Vo=q'shift->await';
$Wo=bless({$o,$Uo,$q,$Vo,$s,$t},$u);
$Xo=[];
$Yo=q'my ($class, $pid, $i, $o, $e) = @_;
+{pid    => $pid,
  stdin  => $i,
  stdout => $o,
  stderr => $e,
  status => undef};';
$Zo=bless({$o,$Xo,$q,$Yo,$s,$t},$u);
$cp={$v3,$Zo};
$dp=q'/unix/pid_init.b';
$ep=bless({$B1,$To,$k2,$l2,$m2,$Wo,$n2,$cp,$D,$dp},$w2);
$fp=q'lib/slice::ctors';
$gp={};
$hp=q'await';
$ip=[];
$jp=q'my $self = shift;
return $$self{status} if defined $$self{status};
defined(waitpid $$self{pid}, 0)
  ? $$self{status} = $?
  : die "/unix/pid_wait.b: waitpid: $!";';
$kp=bless({$o,$ip,$q,$jp,$s,$t},$u);
$lp=q'running';
$mp=[];
$np=q'not defined $_[0]->{status} and kill 0, $_[0]->{pid}';
$op=bless({$o,$mp,$q,$np,$s,$t},$u);
$pp={$hp,$kp,$lp,$op};
$qp=q'/unix/pid_wait.b';
$rp=bless({$B1,$gp,$k2,$l2,$m2,$l2,$n2,$pp,$D,$qp},$w2);
$sp=q'lib/slice::ctors';
$tp={};
$up=[];
$vp=q'shift->{stdout}->read_fh';
$wp=bless({$o,$up,$q,$vp,$s,$t},$u);
$xp=[];
$yp=q'shift->{stdin}->write_fh';
$zp=bless({$o,$xp,$q,$yp,$s,$t},$u);
$Ap={$Sl,$wp,$Wl,$zp};
$Bp=q'/unix/pid_io.b';
$Cp=bless({$B1,$tp,$k2,$l2,$m2,$l2,$n2,$Ap,$D,$Bp},$w2);
$Dp=q'lib/slice::ctors';
$Ep=[$Uj,$Ro,$ep,$rp,$Pl,$Cp];
$Fp=bless({$B1,$to,$D,$y1,$c2,$Ep},$W1);
$Gp=q'unix/pid.c::ctors';
$Hp=q'ni:/unix/pid.c';
$Ip={$W1,1};
$Jp=q'/unix/pid.c';
$Kp=[$yk];
$Lp=bless({$B1,$Ip,$D,$Jp,$c2,$Kp},$e2);
$Mp=q'metaclass::ctors';
$Np=q'ni:/unix/pid_init.b';
$Op=q'ni:/unix/pid_io.b';
$Pp=q'ni:/unix/pid_readers.b';
$Qp=q'ni:/unix/pid_wait.b';
$Rp=q'ni:/unix/pipeline';
$Sp={$Q3,1};
$Tp=q'/unix/pipeline';
$Up={};
$Vp=[];
$Wp=q'shift->{\'stdin\'}';
$Xp=bless({$o,$Vp,$q,$Wp,$s,$t},$u);
$Yp=[];
$Zp=q'shift->{\'stdout\'}';
$cq=bless({$o,$Yp,$q,$Zp,$s,$t},$u);
$dq={$Ho,$Xp,$Lo,$cq};
$eq=q'/unix/pipeline_ro.b';
$fq=bless({$B1,$Up,$k2,$l2,$m2,$l2,$n2,$dq,$D,$eq},$w2);
$gq=q'lib/slice::ctors';
$hq={};
$iq=[];
$jq=q'my $class  = shift;
my $stdin  = ni(\'ni:/unix/fifo\')->new;
my $stdout = ni(\'ni:/unix/fifo\')->new;
# TODO: stderr and multiplexing, which probably happens here

my @rs = ($stdin, @_);
my @ws = (@_, $stdout);
my $rv; vec($rv, fileno $_->read_fh,  1) = 1 for @rs;
my $wv; vec($wv, fileno $_->write_fh, 1) = 1 for @ws;

+{ps     => [@_],
  stdin  => $stdin,
  stdout => $stdout,
  rs => \\@rs, rv => $rv,
  ws => \\@ws, wv => $wv};';
$kq=bless({$o,$iq,$q,$jq,$s,$t},$u);
$lq={$v3,$kq};
$mq=q'/unix/pipeline_init.b';
$nq=bless({$B1,$hq,$k2,$l2,$m2,$l2,$n2,$lq,$D,$mq},$w2);
$oq=q'lib/slice::ctors';
$pq={};
$qq=q'async_step';
$rq=[];
$sq=q'local $_;
my $self = shift;
my $rv = $$self{rv};
my $wv = $$self{wv};
my $ev = $$self{ev};
return $self unless select $rv, $wv, $ev, 0;
for my $i (0..$#{$$self{rs}}) {
  my $rfh = $$self{rs}[$i]->read_fh;
  my $wfh = $$self{ws}[$i]->write_fh;
  next unless vec $rv, fileno $rfh, 1 and vec $wv, fileno $wfh, 1;
  $$self{rs}[$i]->read($_, 8192);
  $$self{ws}[$i]->write($_);
}
$self;';
$tq=bless({$o,$rq,$q,$sq,$s,$t},$u);
$uq={$qq,$tq};
$vq=q'/unix/pipeline_async.b';
$wq=bless({$B1,$pq,$k2,$l2,$m2,$l2,$n2,$uq,$D,$vq},$w2);
$xq=q'lib/slice::ctors';
$yq={};
$zq=[];
$Aq=q'shift->{stdout}->read_fh';
$Bq=bless({$o,$zq,$q,$Aq,$s,$t},$u);
$Cq=[];
$Dq=q'shift->{stdin}->write_fh';
$Eq=bless({$o,$Cq,$q,$Dq,$s,$t},$u);
$Fq={$Sl,$Bq,$Wl,$Eq};
$Gq=q'/unix/pipeline_io.b';
$Hq=bless({$B1,$yq,$k2,$l2,$m2,$l2,$n2,$Fq,$D,$Gq},$w2);
$Iq=q'lib/slice::ctors';
$Jq=[$Uj,$fq,$nq,$wq,$Pl,$Hq];
$Kq=bless({$B1,$Sp,$D,$Tp,$c2,$Jq},$X1);
$Lq=q'unix/pipeline.c::ctors';
$Mq=q'ni:/unix/pipeline.c';
$Nq={$X1,1};
$Oq=q'/unix/pipeline.c';
$Pq=[$yk];
$Qq=bless({$B1,$Nq,$D,$Oq,$c2,$Pq},$e2);
$Rq=q'metaclass::ctors';
$Sq=q'ni:/unix/pipeline_async.b';
$Tq=q'ni:/unix/pipeline_init.b';
$Uq=q'ni:/unix/pipeline_io.b';
$Vq=q'ni:/unix/pipeline_ro.b';
$Wq=q'ni:/unix/str';
$Xq={$R3,1};
$Yq=q'/unix/str';
$Zq={};
$cr=q'data';
$dr=[];
$er=q'shift->{\'data\'}';
$fr=bless({$o,$dr,$q,$er,$s,$t},$u);
$gr=q'end';
$hr=[];
$ir=q'shift->{\'end\'}';
$jr=bless({$o,$hr,$q,$ir,$s,$t},$u);
$kr=q'start';
$lr=[];
$mr=q'shift->{\'start\'}';
$nr=bless({$o,$lr,$q,$mr,$s,$t},$u);
$or={$cr,$fr,$gr,$jr,$kr,$nr};
$pr=q'/unix/str_ro.b';
$qr=bless({$B1,$Zq,$k2,$l2,$m2,$l2,$n2,$or,$D,$pr},$w2);
$rr=q'lib/slice::ctors';
$sr={};
$tr=[];
$ur=q'my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};';
$vr=bless({$o,$tr,$q,$ur,$s,$t},$u);
$wr={$v3,$vr};
$xr=q'/unix/str_init.b';
$yr=bless({$B1,$sr,$k2,$l2,$m2,$l2,$n2,$wr,$D,$xr},$w2);
$zr=q'lib/slice::ctors';
$Ar={};
$Br=[];
$Cr=q'my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;';
$Dr=bless({$o,$Br,$q,$Cr,$s,$t},$u);
$Er=q'remaining';
$Fr=[];
$Gr=q'my $self = shift; $$self{end} - $$self{start}';
$Hr=bless({$o,$Fr,$q,$Gr,$s,$t},$u);
$Ir=[];
$Jr=q'my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];';
$Kr=bless({$o,$Ir,$q,$Jr,$s,$t},$u);
$Lr={$hk,$Dr,$Er,$Hr,$Hb,$Kr};
$Mr=q'/unix/str_io.b';
$Nr=bless({$B1,$Ar,$k2,$l2,$m2,$l2,$n2,$Lr,$D,$Mr},$w2);
$Or=q'lib/slice::ctors';
$Pr=[$Uj,$qr,$yr,$Nr];
$Qr=bless({$B1,$Xq,$D,$Yq,$c2,$Pr},$Y1);
$Rr=q'unix/str.c::ctors';
$Sr=q'ni:/unix/str.c';
$Tr={$Y1,1};
$Ur=q'/unix/str.c';
$Vr=[$yk];
$Wr=bless({$B1,$Tr,$D,$Ur,$c2,$Vr},$e2);
$Xr=q'metaclass::ctors';
$Yr=q'ni:/unix/str_init.b';
$Zr=q'ni:/unix/str_io.b';
$cs=q'ni:/unix/str_ro.b';
$ds=q'ni:main';
$es={$Z9,1};
$fs=[$Yg,$Y9];
$gs=bless({$B1,$es,$D,$Z9,$c2,$fs},$f2);
$hs=q'module::ctors';
$is=q'ni:ni';
$js={$Dc,1};
$ks={$Dc,1};
$ls=q'json_escapes';
$ms=q'';
$ns=q'b';
$os=q'	';
$ps=q't';
$qs=q'
';
$rs=q'n';
$ss=q'';
$ts=q'"';
$us=q'/';
$vs=q'\\';
$ws={$ms,$ns,$os,$ps,$qs,$rs,$ss,$Sm,$ts,$ts,$us,$us,$vs,$vs};
$xs=q'json_unescapes';
$ys={$ts,$ts,$us,$us,$vs,$vs,$ns,$ms,$rs,$qs,$Sm,$ss,$ps,$os};
$zs={$ls,$ws,$xs,$ys};
$As=q'/lib/json_data.b';
$Bs=bless({$B1,$ks,$cr,$zs,$D,$As},$E3);
$Cs=q'lib/dataslice::ctors';
$Ds=[$Bs,$Cc,$Pf,$xe,$He];
$Es=bless({$B1,$js,$D,$Dc,$c2,$Ds},$f2);
$Fs={$d,$G,$I,$X,$Y,$l1,$m1,$z1,$A1,$Y5,$c6,$w6,$y6,$Q4,$z6,$t4,$A6,$q6,$B6,$M6,$O6,$x2,$P6,$T6,$V6,$J6,$W6,$A3,$X6,$r7,$t7,$x7,$z7,$o7,$A7,$h7,$B7,$x5,$C7,$E4,$D7,$t5,$E7,$p8,$r8,$v8,$x8,$c8,$y8,$L7,$z8,$S7,$A8,$m8,$B8,$p4,$C8,$D9,$F9,$J9,$L9,$P8,$M9,$r9,$N9,$g9,$O9,$A9,$P9,$Y9,$da,$Qb,$Sb,$Wb,$Yb,$ma,$Zb,$Nb,$cc,$Z3,$dc,$L5,$ec,$Cc,$Fc,$Z4,$Gc,$I2,$Hc,$S2,$Ic,$d3,$Jc,$ce,$ee,$ie,$ke,$xe,$ze,$He,$Je,$md,$Ke,$Ld,$Le,$Xd,$Me,$Xc,$Ne,$Pf,$Rf,$q3,$Sf,$k5,$Tf,$m3,$Uf,$Bg,$Dg,$jg,$Eg,$Ig,$Kg,$qg,$Lg,$yg,$Mg,$Yg,$ch,$U5,$dh,$vh,$xh,$lh,$yh,$Ch,$Eh,$sh,$Fh,$pi,$ri,$wi,$yi,$di,$zi,$Oh,$Ai,$li,$Bi,$Fi,$Hi,$Li,$Ni,$A5,$Oi,$t6,$Pi,$f4,$Qi,$l6,$Ri,$qk,$sk,$Bk,$Dk,$ek,$Ek,$nk,$Fk,$hm,$jm,$nm,$pm,$Xk,$qm,$em,$rm,$Pk,$sm,$Ml,$tm,$il,$um,$Bl,$vm,$hn,$jn,$nn,$pn,$en,$qn,$Pm,$rn,$Hm,$sn,$Xn,$Zn,$fo,$ho,$Jn,$io,$Un,$jo,$Bn,$ko,$Pl,$lo,$Uj,$mo,$yk,$no,$vj,$oo,$Ej,$po,$dj,$qo,$Rj,$ro,$mj,$so,$Fp,$Hp,$Lp,$Np,$ep,$Op,$Cp,$Pp,$Ro,$Qp,$rp,$Rp,$Kq,$Mq,$Qq,$Sq,$wq,$Tq,$nq,$Uq,$Hq,$Vq,$fq,$Wq,$Qr,$Sr,$Wr,$Yr,$yr,$Zr,$Nr,$cs,$qr,$ds,$gs,$is,$Es};
$Gs=q'resolvers';
$Hs=[];
$Is=q'my $f = shift;
$f =~ s/^fd:(?:\\/\\/)?//;
ni(\'ni:/unix/fd\')->new($f);';
$Js=bless({$o,$Hs,$q,$Is,$s,$t},$u);
$Ks=q'file';
$Ls=[];
$Ms=q'my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni(\'ni:/unix/file\')->new($f);';
$Ns=bless({$o,$Ls,$q,$Ms,$s,$t},$u);
$Os=q'sh';
$Ps=[];
$Qs=q'ni::fork_exec \'/bin/sh\', \'-c\', substr shift, 3';
$Rs=bless({$o,$Ps,$q,$Qs,$s,$t},$u);
$Ss=q'str';
$Ts=[];
$Us=q'my $s = shift;
ni(\'ni:/unix/str\')->new(substr($s, 4) . "\\n");';
$Vs=bless({$o,$Ts,$q,$Us,$s,$t},$u);
$Ws={$Jk,$Js,$Ks,$Ns,$Os,$Rs,$Ss,$Vs};
$Xs=bless({$c,$Fs,$Gs,$Ws},$G3);
$Ys=q'lib/ni::ctors';
*$eg=\&$cg;
*$dg=\&$Yf;
$x2->apply_unsafe($C1);
$x2->apply_unsafe($D1);
$x2->apply_unsafe($E1);
$x2->apply_unsafe($y2);
$x2->apply_unsafe($F1);
$x2->apply_unsafe($G1);
$x2->apply_unsafe($H1);
$x2->apply_unsafe($I1);
$x2->apply_unsafe($J1);
$x2->apply_unsafe($K1);
$x2->apply_unsafe($L1);
$x2->apply_unsafe($M1);
$x2->apply_unsafe($z2);
$x2->apply_unsafe($e2);
$x2->apply_unsafe($O1);
$x2->apply_unsafe($f2);
$x2->apply_unsafe($P1);
$x2->apply_unsafe($Q1);
$x2->apply_unsafe($R1);
$x2->apply_unsafe($S1);
$x2->apply_unsafe($T1);
$x2->apply_unsafe($U1);
$x2->apply_unsafe($V1);
$x2->apply_unsafe($W1);
$x2->apply_unsafe($X1);
$x2->apply_unsafe($Y1);
$I2->apply_unsafe($C1);
$I2->apply_unsafe($D1);
$I2->apply_unsafe($E1);
$I2->apply_unsafe($y2);
$I2->apply_unsafe($F1);
$I2->apply_unsafe($G1);
$I2->apply_unsafe($F);
$I2->apply_unsafe($H1);
$I2->apply_unsafe($I1);
$I2->apply_unsafe($J1);
$I2->apply_unsafe($K1);
$I2->apply_unsafe($w2);
$I2->apply_unsafe($L1);
$I2->apply_unsafe($J2);
$I2->apply_unsafe($M1);
$I2->apply_unsafe($K2);
$I2->apply_unsafe($e2);
$I2->apply_unsafe($O1);
$I2->apply_unsafe($f2);
$I2->apply_unsafe($P1);
$I2->apply_unsafe($Q1);
$I2->apply_unsafe($R1);
$I2->apply_unsafe($S1);
$I2->apply_unsafe($T1);
$I2->apply_unsafe($U1);
$I2->apply_unsafe($V1);
$I2->apply_unsafe($W1);
$I2->apply_unsafe($X1);
$I2->apply_unsafe($Y1);
$S2->apply_unsafe($C1);
$S2->apply_unsafe($D1);
$S2->apply_unsafe($E1);
$S2->apply_unsafe($y2);
$S2->apply_unsafe($F1);
$S2->apply_unsafe($G1);
$S2->apply_unsafe($H1);
$S2->apply_unsafe($I1);
$S2->apply_unsafe($J1);
$S2->apply_unsafe($K1);
$S2->apply_unsafe($w2);
$S2->apply_unsafe($L1);
$S2->apply_unsafe($J2);
$S2->apply_unsafe($M1);
$S2->apply_unsafe($T2);
$S2->apply_unsafe($e2);
$S2->apply_unsafe($O1);
$S2->apply_unsafe($f2);
$S2->apply_unsafe($P1);
$S2->apply_unsafe($Q1);
$S2->apply_unsafe($R1);
$S2->apply_unsafe($S1);
$S2->apply_unsafe($T1);
$S2->apply_unsafe($U1);
$S2->apply_unsafe($V1);
$S2->apply_unsafe($W1);
$S2->apply_unsafe($X1);
$S2->apply_unsafe($Y1);
$d3->apply_unsafe($C1);
$d3->apply_unsafe($D1);
$d3->apply_unsafe($E1);
$d3->apply_unsafe($y2);
$d3->apply_unsafe($F1);
$d3->apply_unsafe($G1);
$d3->apply_unsafe($H1);
$d3->apply_unsafe($I1);
$d3->apply_unsafe($J1);
$d3->apply_unsafe($K1);
$d3->apply_unsafe($w2);
$d3->apply_unsafe($L1);
$d3->apply_unsafe($J2);
$d3->apply_unsafe($M1);
$d3->apply_unsafe($e3);
$d3->apply_unsafe($e2);
$d3->apply_unsafe($O1);
$d3->apply_unsafe($f2);
$d3->apply_unsafe($P1);
$d3->apply_unsafe($Q1);
$d3->apply_unsafe($R1);
$d3->apply_unsafe($S1);
$d3->apply_unsafe($T1);
$d3->apply_unsafe($U1);
$d3->apply_unsafe($V1);
$d3->apply_unsafe($W1);
$d3->apply_unsafe($X1);
$d3->apply_unsafe($Y1);
$m3->apply_unsafe($C1);
$m3->apply_unsafe($D1);
$m3->apply_unsafe($E1);
$m3->apply_unsafe($y2);
$m3->apply_unsafe($F1);
$m3->apply_unsafe($G1);
$m3->apply_unsafe($H1);
$m3->apply_unsafe($I1);
$m3->apply_unsafe($J1);
$m3->apply_unsafe($K1);
$m3->apply_unsafe($L1);
$m3->apply_unsafe($J2);
$m3->apply_unsafe($M1);
$m3->apply_unsafe($n3);
$m3->apply_unsafe($e2);
$m3->apply_unsafe($O1);
$m3->apply_unsafe($f2);
$m3->apply_unsafe($P1);
$m3->apply_unsafe($Q1);
$m3->apply_unsafe($R1);
$m3->apply_unsafe($S1);
$m3->apply_unsafe($T1);
$m3->apply_unsafe($U1);
$m3->apply_unsafe($V1);
$m3->apply_unsafe($W1);
$m3->apply_unsafe($X1);
$m3->apply_unsafe($Y1);
$A3->apply_unsafe($C1);
$A3->apply_unsafe($D1);
$A3->apply_unsafe($E1);
$A3->apply_unsafe($F1);
$A3->apply_unsafe($G1);
$A3->apply_unsafe($H1);
$A3->apply_unsafe($I1);
$A3->apply_unsafe($J1);
$A3->apply_unsafe($K1);
$A3->apply_unsafe($L1);
$A3->apply_unsafe($M1);
$A3->apply_unsafe($B3);
$A3->apply_unsafe($e2);
$A3->apply_unsafe($O1);
$A3->apply_unsafe($f2);
$A3->apply_unsafe($P1);
$A3->apply_unsafe($Q1);
$A3->apply_unsafe($R1);
$A3->apply_unsafe($S1);
$A3->apply_unsafe($T1);
$A3->apply_unsafe($U1);
$A3->apply_unsafe($V1);
$A3->apply_unsafe($W1);
$A3->apply_unsafe($X1);
$A3->apply_unsafe($Y1);
$Z3->apply_unsafe($C1);
$Z3->apply_unsafe($D1);
$Z3->apply_unsafe($D3);
$Z3->apply_unsafe($E1);
$Z3->apply_unsafe($y2);
$Z3->apply_unsafe($F1);
$Z3->apply_unsafe($E3);
$Z3->apply_unsafe($G1);
$Z3->apply_unsafe($F);
$Z3->apply_unsafe($H1);
$Z3->apply_unsafe($u);
$Z3->apply_unsafe($I1);
$Z3->apply_unsafe($F3);
$Z3->apply_unsafe($J1);
$Z3->apply_unsafe($G3);
$Z3->apply_unsafe($K1);
$Z3->apply_unsafe($w2);
$Z3->apply_unsafe($L1);
$Z3->apply_unsafe($J2);
$Z3->apply_unsafe($M1);
$Z3->apply_unsafe($H3);
$Z3->apply_unsafe($c4);
$Z3->apply_unsafe($e2);
$Z3->apply_unsafe($O1);
$Z3->apply_unsafe($f2);
$Z3->apply_unsafe($P1);
$Z3->apply_unsafe($J3);
$Z3->apply_unsafe($Q1);
$Z3->apply_unsafe($K3);
$Z3->apply_unsafe($R1);
$Z3->apply_unsafe($L3);
$Z3->apply_unsafe($S1);
$Z3->apply_unsafe($M3);
$Z3->apply_unsafe($T1);
$Z3->apply_unsafe($N3);
$Z3->apply_unsafe($U1);
$Z3->apply_unsafe($O3);
$Z3->apply_unsafe($V1);
$Z3->apply_unsafe($P3);
$Z3->apply_unsafe($W1);
$Z3->apply_unsafe($Q3);
$Z3->apply_unsafe($X1);
$Z3->apply_unsafe($R3);
$Z3->apply_unsafe($Y1);
$p4->apply_unsafe($C1);
$p4->apply_unsafe($D1);
$p4->apply_unsafe($D3);
$p4->apply_unsafe($E1);
$p4->apply_unsafe($y2);
$p4->apply_unsafe($F1);
$p4->apply_unsafe($E3);
$p4->apply_unsafe($G1);
$p4->apply_unsafe($H1);
$p4->apply_unsafe($I1);
$p4->apply_unsafe($J1);
$p4->apply_unsafe($K1);
$p4->apply_unsafe($w2);
$p4->apply_unsafe($L1);
$p4->apply_unsafe($J2);
$p4->apply_unsafe($M1);
$p4->apply_unsafe($q4);
$p4->apply_unsafe($e2);
$p4->apply_unsafe($O1);
$p4->apply_unsafe($f2);
$p4->apply_unsafe($P1);
$p4->apply_unsafe($Q1);
$p4->apply_unsafe($R1);
$p4->apply_unsafe($S1);
$p4->apply_unsafe($T1);
$p4->apply_unsafe($U1);
$p4->apply_unsafe($V1);
$p4->apply_unsafe($W1);
$p4->apply_unsafe($X1);
$p4->apply_unsafe($Y1);
$E4->apply_unsafe($C1);
$E4->apply_unsafe($D1);
$E4->apply_unsafe($E1);
$E4->apply_unsafe($y2);
$E4->apply_unsafe($F1);
$E4->apply_unsafe($G1);
$E4->apply_unsafe($H1);
$E4->apply_unsafe($I1);
$E4->apply_unsafe($J1);
$E4->apply_unsafe($K1);
$E4->apply_unsafe($L1);
$E4->apply_unsafe($M1);
$E4->apply_unsafe($F4);
$E4->apply_unsafe($e2);
$E4->apply_unsafe($O1);
$E4->apply_unsafe($f2);
$E4->apply_unsafe($P1);
$E4->apply_unsafe($Q1);
$E4->apply_unsafe($R1);
$E4->apply_unsafe($S1);
$E4->apply_unsafe($T1);
$E4->apply_unsafe($U1);
$E4->apply_unsafe($V1);
$E4->apply_unsafe($W1);
$E4->apply_unsafe($X1);
$E4->apply_unsafe($Y1);
$Q4->apply_unsafe($C1);
$Q4->apply_unsafe($D1);
$Q4->apply_unsafe($E1);
$Q4->apply_unsafe($y2);
$Q4->apply_unsafe($F1);
$Q4->apply_unsafe($G1);
$Q4->apply_unsafe($H1);
$Q4->apply_unsafe($I1);
$Q4->apply_unsafe($J1);
$Q4->apply_unsafe($K1);
$Q4->apply_unsafe($L1);
$Q4->apply_unsafe($M1);
$Q4->apply_unsafe($R4);
$Q4->apply_unsafe($e2);
$Q4->apply_unsafe($O1);
$Q4->apply_unsafe($f2);
$Q4->apply_unsafe($P1);
$Q4->apply_unsafe($Q1);
$Q4->apply_unsafe($R1);
$Q4->apply_unsafe($S1);
$Q4->apply_unsafe($T1);
$Q4->apply_unsafe($U1);
$Q4->apply_unsafe($V1);
$Q4->apply_unsafe($W1);
$Q4->apply_unsafe($X1);
$Q4->apply_unsafe($Y1);
$Z4->apply_unsafe($C1);
$Z4->apply_unsafe($D1);
$Z4->apply_unsafe($E1);
$Z4->apply_unsafe($y2);
$Z4->apply_unsafe($F1);
$Z4->apply_unsafe($G1);
$Z4->apply_unsafe($H1);
$Z4->apply_unsafe($I1);
$Z4->apply_unsafe($J1);
$Z4->apply_unsafe($K1);
$Z4->apply_unsafe($L1);
$Z4->apply_unsafe($M1);
$Z4->apply_unsafe($c5);
$Z4->apply_unsafe($e2);
$Z4->apply_unsafe($O1);
$Z4->apply_unsafe($f2);
$Z4->apply_unsafe($P1);
$Z4->apply_unsafe($Q1);
$Z4->apply_unsafe($R1);
$Z4->apply_unsafe($S1);
$Z4->apply_unsafe($T1);
$Z4->apply_unsafe($U1);
$Z4->apply_unsafe($V1);
$Z4->apply_unsafe($W1);
$Z4->apply_unsafe($X1);
$Z4->apply_unsafe($Y1);
$k5->apply_unsafe($C1);
$k5->apply_unsafe($D1);
$k5->apply_unsafe($E1);
$k5->apply_unsafe($y2);
$k5->apply_unsafe($F1);
$k5->apply_unsafe($G1);
$k5->apply_unsafe($H1);
$k5->apply_unsafe($I1);
$k5->apply_unsafe($J1);
$k5->apply_unsafe($K1);
$k5->apply_unsafe($L1);
$k5->apply_unsafe($M1);
$k5->apply_unsafe($l5);
$k5->apply_unsafe($e2);
$k5->apply_unsafe($O1);
$k5->apply_unsafe($f2);
$k5->apply_unsafe($P1);
$k5->apply_unsafe($Q1);
$k5->apply_unsafe($R1);
$k5->apply_unsafe($S1);
$k5->apply_unsafe($T1);
$k5->apply_unsafe($U1);
$k5->apply_unsafe($V1);
$k5->apply_unsafe($W1);
$k5->apply_unsafe($X1);
$k5->apply_unsafe($Y1);
$t5->apply_unsafe($C1);
$t5->apply_unsafe($D1);
$t5->apply_unsafe($E1);
$t5->apply_unsafe($y2);
$t5->apply_unsafe($F1);
$t5->apply_unsafe($G1);
$t5->apply_unsafe($H1);
$t5->apply_unsafe($I1);
$t5->apply_unsafe($J1);
$t5->apply_unsafe($K1);
$t5->apply_unsafe($L1);
$t5->apply_unsafe($M1);
$t5->apply_unsafe($u5);
$t5->apply_unsafe($e2);
$t5->apply_unsafe($O1);
$t5->apply_unsafe($f2);
$t5->apply_unsafe($P1);
$t5->apply_unsafe($Q1);
$t5->apply_unsafe($R1);
$t5->apply_unsafe($S1);
$t5->apply_unsafe($T1);
$t5->apply_unsafe($U1);
$t5->apply_unsafe($V1);
$t5->apply_unsafe($W1);
$t5->apply_unsafe($X1);
$t5->apply_unsafe($Y1);
$L5->apply_unsafe($C1);
$L5->apply_unsafe($D1);
$L5->apply_unsafe($E1);
$L5->apply_unsafe($F1);
$L5->apply_unsafe($G1);
$L5->apply_unsafe($H1);
$L5->apply_unsafe($u);
$L5->apply_unsafe($I1);
$L5->apply_unsafe($J1);
$L5->apply_unsafe($K1);
$L5->apply_unsafe($w2);
$L5->apply_unsafe($L1);
$L5->apply_unsafe($J2);
$L5->apply_unsafe($M1);
$L5->apply_unsafe($M5);
$L5->apply_unsafe($e2);
$L5->apply_unsafe($O1);
$L5->apply_unsafe($P1);
$L5->apply_unsafe($Q1);
$L5->apply_unsafe($R1);
$L5->apply_unsafe($S1);
$L5->apply_unsafe($T1);
$L5->apply_unsafe($U1);
$L5->apply_unsafe($V1);
$L5->apply_unsafe($W1);
$L5->apply_unsafe($X1);
$L5->apply_unsafe($Y1);
$U5->apply_unsafe($C1);
$U5->apply_unsafe($D1);
$U5->apply_unsafe($E1);
$U5->apply_unsafe($F1);
$U5->apply_unsafe($G1);
$U5->apply_unsafe($H1);
$U5->apply_unsafe($I1);
$U5->apply_unsafe($J1);
$U5->apply_unsafe($K1);
$U5->apply_unsafe($L1);
$U5->apply_unsafe($M1);
$U5->apply_unsafe($V5);
$U5->apply_unsafe($O1);
$U5->apply_unsafe($P1);
$U5->apply_unsafe($Q1);
$U5->apply_unsafe($R1);
$U5->apply_unsafe($S1);
$U5->apply_unsafe($T1);
$U5->apply_unsafe($U1);
$U5->apply_unsafe($V1);
$U5->apply_unsafe($W1);
$U5->apply_unsafe($X1);
$U5->apply_unsafe($Y1);
$J6->apply_unsafe($y2);
$h7->apply_unsafe($E3);
$o7->apply_unsafe($E3);
$L7->apply_unsafe($F);
$S7->apply_unsafe($F);
$c8->apply_unsafe($F);
$m8->apply_unsafe($F);
$P8->apply_unsafe($u);
$g9->apply_unsafe($u);
$r9->apply_unsafe($u);
$A9->apply_unsafe($u);
$Y9->apply_unsafe($Z9);
$ma->apply_unsafe($F3);
$Nb->apply_unsafe($F3);
$Cc->apply_unsafe($Dc);
$Xc->apply_unsafe($G3);
$md->apply_unsafe($G3);
$Ld->apply_unsafe($G3);
$Xd->apply_unsafe($G3);
$xe->apply_unsafe($Dc);
$He->apply_unsafe($Dc);
$Pf->apply_unsafe($Dc);
$jg->apply_unsafe($w2);
$qg->apply_unsafe($w2);
$yg->apply_unsafe($w2);
$Yg->apply_unsafe($Z9);
$lh->apply_unsafe($J2);
$sh->apply_unsafe($J2);
$Oh->apply_unsafe($H3);
$di->apply_unsafe($H3);
$li->apply_unsafe($H3);
$dj->apply_unsafe($K3);
$dj->apply_unsafe($L3);
$dj->apply_unsafe($M3);
$dj->apply_unsafe($N3);
$dj->apply_unsafe($O3);
$dj->apply_unsafe($P3);
$dj->apply_unsafe($Q3);
$dj->apply_unsafe($R3);
$mj->apply_unsafe($K3);
$mj->apply_unsafe($L3);
$mj->apply_unsafe($M3);
$mj->apply_unsafe($N3);
$mj->apply_unsafe($O3);
$mj->apply_unsafe($P3);
$mj->apply_unsafe($Q3);
$mj->apply_unsafe($R3);
$vj->apply_unsafe($K3);
$vj->apply_unsafe($L3);
$vj->apply_unsafe($M3);
$vj->apply_unsafe($N3);
$vj->apply_unsafe($O3);
$vj->apply_unsafe($P3);
$vj->apply_unsafe($Q3);
$vj->apply_unsafe($R3);
$Ej->apply_unsafe($K3);
$Ej->apply_unsafe($L3);
$Ej->apply_unsafe($M3);
$Ej->apply_unsafe($N3);
$Ej->apply_unsafe($O3);
$Ej->apply_unsafe($P3);
$Ej->apply_unsafe($Q3);
$Ej->apply_unsafe($R3);
$Rj->apply_unsafe($K3);
$Rj->apply_unsafe($L3);
$Rj->apply_unsafe($M3);
$Rj->apply_unsafe($N3);
$Rj->apply_unsafe($O3);
$Rj->apply_unsafe($P3);
$Rj->apply_unsafe($Q3);
$Rj->apply_unsafe($R3);
$ek->apply_unsafe($K3);
$nk->apply_unsafe($K3);
$Pk->apply_unsafe($L3);
$Xk->apply_unsafe($L3);
$il->apply_unsafe($L3);
$Bl->apply_unsafe($L3);
$Bl->apply_unsafe($M3);
$Bl->apply_unsafe($N3);
$Bl->apply_unsafe($P3);
$Bl->apply_unsafe($Q3);
$Ml->apply_unsafe($L3);
$Ml->apply_unsafe($M3);
$Ml->apply_unsafe($N3);
$Ml->apply_unsafe($P3);
$Ml->apply_unsafe($Q3);
$em->apply_unsafe($L3);
$Hm->apply_unsafe($M3);
$Pm->apply_unsafe($M3);
$en->apply_unsafe($M3);
$Bn->apply_unsafe($N3);
$Jn->apply_unsafe($N3);
$Un->apply_unsafe($N3);
$Ro->apply_unsafe($P3);
$ep->apply_unsafe($P3);
$rp->apply_unsafe($P3);
$Cp->apply_unsafe($P3);
$fq->apply_unsafe($Q3);
$nq->apply_unsafe($Q3);
$wq->apply_unsafe($Q3);
$Hq->apply_unsafe($Q3);
$qr->apply_unsafe($R3);
$yr->apply_unsafe($R3);
$Nr->apply_unsafe($R3);
$ni::self=$Xs;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($P)for@$w;
&$_($T)for@$w;
&$_($X)for@$H;
&$_($h1)for@$w;
&$_($l1)for@$H;
&$_($r1)for@$w;
&$_($v1)for@$w;
&$_($z1)for@$H;
&$_($q2)for@$w;
&$_($t2)for@$w;
&$_($x2)for@$A2;
&$_($D2)for@$w;
&$_($F2)for@$w;
&$_($I2)for@$L2;
&$_($P2)for@$w;
&$_($S2)for@$U2;
&$_($Y2)for@$w;
&$_($d3)for@$f3;
&$_($j3)for@$w;
&$_($m3)for@$o3;
&$_($q3)for@$r3;
&$_($u3)for@$w;
&$_($x3)for@$w;
&$_($A3)for@$C3;
&$_($W3)for@$w;
&$_($Z3)for@$d4;
&$_($f4)for@$g4;
&$_($m4)for@$w;
&$_($p4)for@$r4;
&$_($t4)for@$u4;
&$_($B4)for@$w;
&$_($E4)for@$G4;
&$_($K4)for@$w;
&$_($N4)for@$w;
&$_($Q4)for@$S4;
&$_($W4)for@$w;
&$_($Z4)for@$d5;
&$_($h5)for@$w;
&$_($k5)for@$m5;
&$_($q5)for@$w;
&$_($t5)for@$v5;
&$_($x5)for@$y5;
&$_($A5)for@$B5;
&$_($F5)for@$w;
&$_($I5)for@$w;
&$_($L5)for@$N5;
&$_($R5)for@$w;
&$_($U5)for@$W5;
&$_($Y5)for@$Z5;
&$_($l6)for@$m6;
&$_($q6)for@$r6;
&$_($t6)for@$u6;
&$_($w6)for@$x6;
&$_($G6)for@$w;
&$_($J6)for@$K6;
&$_($M6)for@$N6;
&$_($T6)for@$U6;
&$_($e7)for@$w;
&$_($h7)for@$i7;
&$_($l7)for@$w;
&$_($o7)for@$p7;
&$_($r7)for@$s7;
&$_($x7)for@$y7;
&$_($I7)for@$w;
&$_($L7)for@$M7;
&$_($P7)for@$w;
&$_($S7)for@$T7;
&$_($X7)for@$w;
&$_($c8)for@$d8;
&$_($g8)for@$w;
&$_($j8)for@$w;
&$_($m8)for@$n8;
&$_($p8)for@$q8;
&$_($v8)for@$w8;
&$_($H8)for@$w;
&$_($K8)for@$w;
&$_($M8)for@$w;
&$_($P8)for@$Q8;
&$_($U8)for@$w;
&$_($X8)for@$w;
&$_($d9)for@$w;
&$_($g9)for@$h9;
&$_($l9)for@$w;
&$_($o9)for@$w;
&$_($r9)for@$s9;
&$_($x9)for@$w;
&$_($A9)for@$B9;
&$_($D9)for@$E9;
&$_($J9)for@$K9;
&$_($V9)for@$w;
&$_($Y9)for@$ca;
&$_($ja)for@$w;
&$_($ma)for@$na;
&$_($sa)for@$w;
&$_($wa)for@$w;
&$_($Aa)for@$w;
&$_($Ea)for@$w;
&$_($Ia)for@$w;
&$_($Ma)for@$w;
&$_($Qa)for@$w;
&$_($Ua)for@$w;
&$_($Ya)for@$w;
&$_($eb)for@$w;
&$_($ib)for@$w;
&$_($mb)for@$w;
&$_($qb)for@$w;
&$_($ub)for@$w;
&$_($yb)for@$w;
&$_($Cb)for@$w;
&$_($Gb)for@$w;
&$_($Kb)for@$w;
&$_($Nb)for@$Ob;
&$_($Qb)for@$Rb;
&$_($Wb)for@$Xb;
&$_($jc)for@$w;
&$_($nc)for@$w;
&$_($rc)for@$w;
&$_($vc)for@$w;
&$_($zc)for@$w;
&$_($Cc)for@$Ec;
&$_($Qc)for@$w;
&$_($Uc)for@$w;
&$_($Xc)for@$Yc;
&$_($fd)for@$w;
&$_($jd)for@$w;
&$_($md)for@$nd;
&$_($sd)for@$w;
&$_($wd)for@$w;
&$_($Ad)for@$w;
&$_($Ed)for@$w;
&$_($Id)for@$w;
&$_($Ld)for@$Md;
&$_($Qd)for@$w;
&$_($Ud)for@$w;
&$_($Xd)for@$Yd;
&$_($ce)for@$de;
&$_($ie)for@$je;
&$_($qe)for@$w;
&$_($ue)for@$w;
&$_($xe)for@$ye;
&$_($Ee)for@$w;
&$_($He)for@$Ie;
&$_($Se)for@$w;
&$_($We)for@$w;
&$_($cf)for@$w;
&$_($gf)for@$w;
&$_($kf)for@$w;
&$_($of)for@$w;
&$_($sf)for@$w;
&$_($wf)for@$w;
&$_($Af)for@$w;
&$_($Ef)for@$w;
&$_($If)for@$w;
&$_($Mf)for@$w;
&$_($Pf)for@$Qf;
&$_($Yf)for@$w;
&$_($cg)for@$w;
&$_($jg)for@$kg;
&$_($ng)for@$w;
&$_($qg)for@$rg;
&$_($vg)for@$w;
&$_($yg)for@$zg;
&$_($Bg)for@$Cg;
&$_($Ig)for@$Jg;
&$_($Qg)for@$w;
&$_($Vg)for@$w;
&$_($Yg)for@$Zg;
&$_($ih)for@$w;
&$_($lh)for@$mh;
&$_($ph)for@$w;
&$_($sh)for@$th;
&$_($vh)for@$wh;
&$_($Ch)for@$Dh;
&$_($Lh)for@$w;
&$_($Oh)for@$Ph;
&$_($Uh)for@$w;
&$_($Yh)for@$w;
&$_($di)for@$ei;
&$_($ii)for@$w;
&$_($li)for@$mi;
&$_($pi)for@$qi;
&$_($wi)for@$xi;
&$_($Fi)for@$Gi;
&$_($Li)for@$Mi;
&$_($Yi)for@$w;
&$_($dj)for@$ej;
&$_($jj)for@$w;
&$_($mj)for@$nj;
&$_($sj)for@$w;
&$_($vj)for@$wj;
&$_($Bj)for@$w;
&$_($Ej)for@$Fj;
&$_($Kj)for@$w;
&$_($Oj)for@$w;
&$_($Rj)for@$Sj;
&$_($Uj)for@$Vj;
&$_($Zj)for@$w;
&$_($ek)for@$fk;
&$_($kk)for@$w;
&$_($nk)for@$ok;
&$_($qk)for@$rk;
&$_($yk)for@$zk;
&$_($Bk)for@$Ck;
&$_($Mk)for@$w;
&$_($Pk)for@$Qk;
&$_($Uk)for@$w;
&$_($Xk)for@$Yk;
&$_($fl)for@$w;
&$_($il)for@$jl;
&$_($ql)for@$w;
&$_($ul)for@$w;
&$_($yl)for@$w;
&$_($Bl)for@$Cl;
&$_($Gl)for@$w;
&$_($Jl)for@$w;
&$_($Ml)for@$Nl;
&$_($Pl)for@$Ql;
&$_($Vl)for@$w;
&$_($Zl)for@$w;
&$_($em)for@$fm;
&$_($hm)for@$im;
&$_($nm)for@$om;
&$_($Bm)for@$w;
&$_($Em)for@$w;
&$_($Hm)for@$Im;
&$_($Mm)for@$w;
&$_($Pm)for@$Qm;
&$_($Vm)for@$w;
&$_($Zm)for@$w;
&$_($en)for@$fn;
&$_($hn)for@$in;
&$_($nn)for@$on;
&$_($yn)for@$w;
&$_($Bn)for@$Cn;
&$_($Gn)for@$w;
&$_($Jn)for@$Kn;
&$_($On)for@$w;
&$_($Rn)for@$w;
&$_($Un)for@$Vn;
&$_($Xn)for@$Yn;
&$_($fo)for@$go;
&$_($yo)for@$w;
&$_($Co)for@$w;
&$_($Go)for@$w;
&$_($Ko)for@$w;
&$_($Oo)for@$w;
&$_($Ro)for@$So;
&$_($Wo)for@$w;
&$_($Zo)for@$w;
&$_($ep)for@$fp;
&$_($kp)for@$w;
&$_($op)for@$w;
&$_($rp)for@$sp;
&$_($wp)for@$w;
&$_($zp)for@$w;
&$_($Cp)for@$Dp;
&$_($Fp)for@$Gp;
&$_($Lp)for@$Mp;
&$_($Xp)for@$w;
&$_($cq)for@$w;
&$_($fq)for@$gq;
&$_($kq)for@$w;
&$_($nq)for@$oq;
&$_($tq)for@$w;
&$_($wq)for@$xq;
&$_($Bq)for@$w;
&$_($Eq)for@$w;
&$_($Hq)for@$Iq;
&$_($Kq)for@$Lq;
&$_($Qq)for@$Rq;
&$_($fr)for@$w;
&$_($jr)for@$w;
&$_($nr)for@$w;
&$_($qr)for@$rr;
&$_($vr)for@$w;
&$_($yr)for@$zr;
&$_($Dr)for@$w;
&$_($Hr)for@$w;
&$_($Kr)for@$w;
&$_($Nr)for@$Or;
&$_($Qr)for@$Rr;
&$_($Wr)for@$Xr;
&$_($gs)for@$hs;
&$_($Bs)for@$Cs;
&$_($Es)for@$hs;
&$_($Js)for@$w;
&$_($Ns)for@$w;
&$_($Rs)for@$w;
&$_($Vs)for@$w;
&$_($Xs)for@$Ys;
ni->run(@ARGV);
__DATA__
