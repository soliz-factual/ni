#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/lib/doc#;
$J=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$K=[$f,$J];
$L=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$M=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$N=[];
$O=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$P=bless({$o,$N,$q,$O,$s,$t},$u);
$Q=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$R=[];
$S=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$T=bless({$o,$R,$q,$S,$s,$t},$u);
$U=[$i,$L,$M,$n,$P,$Q,$n,$T];
$V=[$K,$U];
$W=q#/lib/doc#;
$X=bless({$e,$V,$D,$W},$F);
$Y=q#ni.doc:/unix/cat#;
$Z=q#
    my $combined = ni('ni:/unix/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  #;
$c1=[$f,$Z];
$d1=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$e1=[$i,$d1];
$f1=[];
$g1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$h1=bless({$o,$f1,$q,$g1,$s,$t},$u);
$i1=[$n,$h1];
$j1=[$c1,$e1,$i1];
$k1=q#/unix/cat#;
$l1=bless({$e,$j1,$D,$k1},$F);
$m1=q#ni.doc:/unix/exec#;
$n1=q#
    my $pid = ni("ni:/unix/exec")->new("ls", "-l")
      ->fds(1 => ni"file:foo")
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$o1=[$f,$n1];
$p1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up FIFO connections to stdin/out if you use it
      this way.#;
$q1=[$i,$p1];
$r1=[];
$s1=q#my $e   = ni('ni:/unix/exec')->new('sh', '-c', 'echo hi');
my $out = $e->stdout;
my $pid = $e->fork;
now $out->read_all == "hi\\n";
now $pid->await == 0;#;
$t1=bless({$o,$r1,$q,$s1,$s,$t},$u);
$u1=[$n,$t1];
$v1=[$o1,$q1,$u1];
$w1=q#/unix/exec#;
$x1=bless({$e,$v1,$D,$w1},$F);
$y1=q#ni.doc:/unix/pid#;
$z1=[];
$A1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$B1=bless({$o,$z1,$q,$A1,$s,$t},$u);
$C1=[$n,$B1];
$D1=[];
$E1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$F1=bless({$o,$D1,$q,$E1,$s,$t},$u);
$G1=[$n,$F1];
$H1=[];
$I1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/unix/exec')->new('egrep', '[13579]$')
  ->fds(0 => $seq->stdout)
  ->fork;
now $grep->read_all == "1\\n3\\n5\\n7\\n9\\n";
now $seq->await == 0;
now $grep->await == 0;#;
$J1=bless({$o,$H1,$q,$I1,$s,$t},$u);
$K1=[$n,$J1];
$L1=[$C1,$G1,$K1];
$M1=q#/unix/pid#;
$N1=bless({$e,$L1,$D,$M1},$F);
$O1=q#ni:/class#;
$P1=q#applied_to#;
$Q1=q#class#;
$R1=q#class.c#;
$S1=q#lib/behavior.c#;
$T1=q#lib/branch.c#;
$U1=q#lib/dataslice.c#;
$V1=q#lib/doc.c#;
$W1=q#lib/fn.c#;
$X1=q#lib/image.c#;
$Y1=q#lib/ni.c#;
$Z1=q#lib/slice.c#;
$c2=q#lib/tag.c#;
$d2=q#lib/test_value.c#;
$e2=q#metaclass.c#;
$f2=q#module.c#;
$g2=q#object.c#;
$h2=q#unix/cat.c#;
$i2=q#unix/exec.c#;
$j2=q#unix/fd.c#;
$k2=q#unix/fifo.c#;
$l2=q#unix/file.c#;
$m2=q#unix/io.c#;
$n2=q#unix/pid.c#;
$o2=q#unix/pipeline.c#;
$p2=q#unix/str.c#;
$q2={$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1,$Z1,1,$c2,1,$d2,1,$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1};
$r2=q#slices#;
$s2=q#lib/test_value.c#;
$t2=q#metaclass#;
$u2=q#module#;
$v2={$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1,$Z1,1,$c2,1,$s2,1,$t2,1,$e2,1,$u2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1};
$w2=q#/module#;
$x2=q#/lib/perlbranch.b#;
$y2={};
$z2=q#ctor#;
$A2=undef;
$B2=q#dtor#;
$C2=q#methods#;
$D2=q#add#;
$E2=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$F2=bless({$q,$E2,$s,$t},$u);
$G2=q#apply#;
$H2=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$I2=bless({$q,$H2,$s,$t},$u);
$J2={$D2,$F2,$G2,$I2};
$K2=q#/lib/branch.b#;
$L2=q#lib/slice#;
$M2=bless({$P1,$y2,$z2,$A2,$B2,$A2,$C2,$J2,$D,$K2},$L2);
$N2=q#lib/branch#;
$O2=q#lib/test_value.c#;
$P2=q#lib/slice::ctors#;
$Q2={};
$R2=q#my $s = shift; ni->def($s->name, $s)#;
$S2=bless({$q,$R2,$s,$t},$u);
$T2=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$U2=bless({$q,$T2,$s,$t},$u);
$V2={$D,$U2};
$W2=q#/lib/named.b#;
$X2=bless({$P1,$Q2,$z2,$S2,$B2,$A2,$C2,$V2,$D,$W2},$L2);
$Y2=q#lib/tag#;
$Z2=q#lib/test_value.c#;
$c3=q#lib/slice::ctors#;
$d3={};
$e3=q#namespace#;
$f3=q#'ni'#;
$g3=bless({$q,$f3,$s,$t},$u);
$h3={$e3,$g3};
$i3=q#/lib/named_in_ni.b#;
$j3=bless({$P1,$d3,$z2,$A2,$B2,$A2,$C2,$h3,$D,$i3},$L2);
$k3=q#lib/test_value.c#;
$l3=q#lib/slice::ctors#;
$m3={};
$n3=q#package#;
$o3=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$p3=bless({$q,$o3,$s,$t},$u);
$q3={$n3,$p3};
$r3=q#/lib/namespaced.b#;
$s3=bless({$P1,$m3,$z2,$A2,$B2,$A2,$C2,$q3,$D,$r3},$L2);
$t3=q#lib/test_value.c#;
$u3=q#lib/slice::ctors#;
$v3={};
$w3=q#resolve#;
$x3=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$y3=bless({$q,$x3,$s,$t},$u);
$z3={$w3,$y3};
$A3=q#/lib/resolver.b#;
$B3=bless({$P1,$v3,$z2,$A2,$B2,$A2,$C2,$z3,$D,$A3},$L2);
$C3=q#lib/test_value.c#;
$D3=q#lib/slice::ctors#;
$E3=[$M2,$X2,$j3,$s3,$B3];
$F3=bless({$D,$x2,$r2,$E3},$Y2);
$G3=q#lib/tag::ctors#;
$H3={};
$I3=q#my $s = shift; $s->apply($s->package)#;
$J3=bless({$q,$I3,$s,$t},$u);
$K3=q#instantiate#;
$L3=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$M3=bless({$q,$L3,$s,$t},$u);
$N3={$K3,$M3};
$O3=q#/lib/class_init.b#;
$P3=bless({$P1,$H3,$z2,$J3,$B2,$A2,$C2,$N3,$D,$O3},$L2);
$Q3=q#lib/test_value.c#;
$R3=q#lib/slice::ctors#;
$S3=q#lib/behavior#;
$T3=q#lib/dataslice#;
$U3=q#lib/image#;
$V3=q#lib/ni#;
$W3=q#lib/test_value#;
$X3=q#lib/test_value.c#;
$Y3=q#object#;
$Z3=q#unix/cat#;
$c4=q#unix/exec#;
$d4=q#unix/fd#;
$e4=q#unix/fifo#;
$f4=q#unix/file#;
$g4=q#unix/io#;
$h4=q#unix/pid#;
$i4=q#unix/pipeline#;
$j4=q#unix/str#;
$k4={$Q1,1,$R1,1,$S3,1,$S1,1,$N2,1,$T1,1,$T3,1,$U1,1,$F,1,$V1,1,$u,1,$W1,1,$U3,1,$X1,1,$V3,1,$Y1,1,$L2,1,$Z1,1,$Y2,1,$c2,1,$W3,1,$X3,1,$t2,1,$e2,1,$u2,1,$f2,1,$Y3,1,$g2,1,$Z3,1,$h2,1,$c4,1,$i2,1,$d4,1,$j2,1,$e4,1,$k2,1,$f4,1,$l2,1,$g4,1,$m2,1,$h4,1,$n2,1,$i4,1,$o2,1,$j4,1,$p2,1};
$l4=q#/object#;
$m4={};
$n4=q#ni 'ni:/' . ref shift#;
$o4=bless({$q,$n4,$s,$t},$u);
$p4={$Q1,$o4};
$q4=q#/lib/instance.b#;
$r4=bless({$P1,$m4,$z2,$A2,$B2,$A2,$C2,$p4,$D,$q4},$L2);
$s4=q#lib/test_value.c#;
$t4=q#lib/slice::ctors#;
$u4=[$r4];
$v4=bless({$P1,$k4,$D,$l4,$r2,$u4},$g2);
$w4=q#object.c::ctors#;
$x4=q#lib/test_value.c#;
$y4={$Q1,1,$R1,1,$S3,1,$S1,1,$N2,1,$T1,1,$T3,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1,$L2,1,$Z1,1,$Y2,1,$c2,1,$x4,1,$t2,1,$e2,1,$u2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1};
$z4=q#/lib/behavior#;
$A4={};
$B4=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$C4=bless({$q,$B4,$s,$t},$u);
$D4={$e,$C4};
$E4=q#/lib/documentable.b#;
$F4=bless({$P1,$A4,$z2,$A2,$B2,$A2,$C2,$D4,$D,$E4},$L2);
$G4=q#lib/test_value.c#;
$H4=q#lib/slice::ctors#;
$I4=[$v4,$F4];
$J4=bless({$P1,$y4,$D,$z4,$r2,$I4},$S1);
$K4=q#lib/behavior.c::ctors#;
$L4=q#lib/test_value.c#;
$M4={$Q1,1,$R1,1,$S1,1,$N2,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1,$Z1,1,$c2,1,$L4,1,$t2,1,$e2,1,$u2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1};
$N4=q#/lib/definition.b#;
$O4={};
$P4=q#def#;
$Q4=q#shift->add(ni('ni:/lib/slice')->new(@_))#;
$R4=bless({$q,$Q4,$s,$t},$u);
$S4={$P4,$R4};
$T4=q#/lib/definition_def.b#;
$U4=bless({$P1,$O4,$z2,$A2,$B2,$A2,$C2,$S4,$D,$T4},$L2);
$V4=q#lib/test_value.c#;
$W4=q#lib/slice::ctors#;
$X4={};
$Y4=q#ro#;
$Z4=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$c5=bless({$q,$Z4,$s,$t},$u);
$d5=q#rw#;
$e5=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$f5=bless({$q,$e5,$s,$t},$u);
$g5={$Y4,$c5,$d5,$f5};
$h5=q#/lib/accessor.b#;
$i5=bless({$P1,$X4,$z2,$A2,$B2,$A2,$C2,$g5,$D,$h5},$L2);
$j5=q#lib/test_value.c#;
$k5=q#lib/slice::ctors#;
$l5={};
$m5=q#(""#;
$n5=q#shift->name#;
$o5=bless({$q,$n5,$s,$t},$u);
$p5={$m5,$o5};
$q5=q#/lib/name_as_string.b#;
$r5=bless({$P1,$l5,$z2,$A2,$B2,$A2,$C2,$p5,$D,$q5},$L2);
$s5=q#lib/test_value.c#;
$t5=q#lib/slice::ctors#;
$u5={};
$v5=q#(eq#;
$w5=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$x5=bless({$q,$w5,$s,$t},$u);
$y5={$v5,$x5};
$z5=q#/lib/ref_eq.b#;
$A5=bless({$P1,$u5,$z2,$A2,$B2,$A2,$C2,$y5,$D,$z5},$L2);
$B5=q#lib/test_value.c#;
$C5=q#lib/slice::ctors#;
$D5={};
$E5=q#defdata#;
$F5=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$G5=bless({$q,$F5,$s,$t},$u);
$H5={$E5,$G5};
$I5=q#/lib/definition_defdata.b#;
$J5=bless({$P1,$D5,$z2,$A2,$B2,$A2,$C2,$H5,$D,$I5},$L2);
$K5=q#lib/test_value.c#;
$L5=q#lib/slice::ctors#;
$M5=[$U4,$i5,$r5,$A5,$J5];
$N5=bless({$P1,$M4,$D,$N4,$r2,$M5},$N2);
$O5=q#lib/branch::ctors#;
$P5=[$F3,$P3,$v4,$J4,$N5];
$Q5=bless({$P1,$v2,$D,$w2,$r2,$P5},$f2);
$R5=q#module.c::ctors#;
$S5={};
$T5=q#DESTROY#;
$U5=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$V5=bless({$q,$U5,$s,$t},$u);
$W5=q#new#;
$X5=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$Y5=bless({$q,$X5,$s,$t},$u);
$Z5={$T5,$V5,$W5,$Y5};
$c6=q#/lib/instantiable.b#;
$d6=bless({$P1,$S5,$C2,$Z5,$D,$c6},$L2);
$e6=q#lib/test_value.c#;
$f6=q#lib/slice::ctors#;
$g6={};
$h6=q#child#;
$i6=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$j6=bless({$q,$i6,$s,$t},$u);
$k6={$h6,$j6};
$l6=q#/lib/subclass.b#;
$m6=bless({$P1,$g6,$z2,$A2,$B2,$A2,$C2,$k6,$D,$l6},$L2);
$n6=q#lib/test_value.c#;
$o6=q#lib/slice::ctors#;
$p6=[$Q5,$d6,$P3,$Q5,$m6];
$q6=bless({$P1,$q2,$D,$E,$r2,$p6},$R1);
$r6=q#class.c::ctors#;
$s6=q#ni:/class.c#;
$t6={$R1,1};
$u6=q#/class.c#;
$v6={$R1,1,$f2,1};
$w6=q#/module.c#;
$x6=q#lib/test_value.c#;
$y6={$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1,$Z1,1,$c2,1,$x6,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1};
$z6=q#/object.c#;
$A6=[$q6];
$B6=bless({$P1,$y6,$D,$z6,$r2,$A6},$t2);
$C6=q#metaclass::ctors#;
$D6={$R1,1,$S1,1,$T1,1,$U1,1,$Z1,1,$c2,1,$f2,1};
$E6=q#/lib/behavior.c#;
$F6=[$B6];
$G6=bless({$P1,$D6,$D,$E6,$r2,$F6},$t2);
$H6=q#metaclass::ctors#;
$I6=[$B6,$d6,$G6];
$J6=bless({$P1,$v6,$D,$w6,$r2,$I6},$t2);
$K6=q#metaclass::ctors#;
$L6=[$J6];
$M6=bless({$P1,$t6,$D,$u6,$r2,$L6},$t2);
$N6=q#metaclass::ctors#;
$O6=q#ni:/lib/accessor.b#;
$P6=q#ni:/lib/behavior#;
$Q6=q#ni:/lib/behavior.c#;
$R6=q#ni:/lib/branch#;
$S6={$N2,1};
$T6=q#/lib/branch#;
$U6={};
$V6=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$W6=bless({$q,$V6,$s,$t},$u);
$X6={$K3,$W6};
$Y6=q#/lib/branch_init.b#;
$Z6=bless({$P1,$U6,$z2,$A2,$B2,$A2,$C2,$X6,$D,$Y6},$L2);
$c7=q#lib/slice::ctors#;
$d7=[$J4,$X2,$M2,$Z6,$N5];
$e7=bless({$P1,$S6,$D,$T6,$r2,$d7},$T1);
$f7=q#lib/branch.c::ctors#;
$g7=q#ni:/lib/branch.b#;
$h7=q#ni:/lib/branch.c#;
$i7={$T1,1};
$j7=q#/lib/branch.c#;
$k7=[$G6];
$l7=bless({$P1,$i7,$D,$j7,$r2,$k7},$t2);
$m7=q#metaclass::ctors#;
$n7=q#ni:/lib/branch_init.b#;
$o7=q#ni:/lib/class_init.b#;
$p7=q#ni:/lib/dataslice#;
$q7={$T3,1};
$r7=q#/lib/dataslice#;
$s7={};
$t7=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$u7=bless({$q,$t7,$s,$t},$u);
$v7={$K3,$u7};
$w7=q#/lib/dataslice_init.b#;
$x7=bless({$P1,$s7,$z2,$A2,$B2,$A2,$C2,$v7,$D,$w7},$L2);
$y7=q#lib/slice::ctors#;
$z7={};
$A7=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$B7=bless({$q,$A7,$s,$t},$u);
$C7={$G2,$B7};
$D7=q#/lib/dataslice_apply.b#;
$E7=bless({$P1,$z7,$z2,$A2,$B2,$A2,$C2,$C7,$D,$D7},$L2);
$F7=q#lib/slice::ctors#;
$G7=[$J4,$x7,$E7];
$H7=bless({$P1,$q7,$D,$r7,$r2,$G7},$U1);
$I7=q#lib/dataslice.c::ctors#;
$J7=q#ni:/lib/dataslice.c#;
$K7={$U1,1};
$L7=q#/lib/dataslice.c#;
$M7=[$G6];
$N7=bless({$P1,$K7,$D,$L7,$r2,$M7},$t2);
$O7=q#metaclass::ctors#;
$P7=q#ni:/lib/dataslice_apply.b#;
$Q7=q#ni:/lib/dataslice_init.b#;
$R7=q#ni:/lib/definition.b#;
$S7=q#ni:/lib/definition_def.b#;
$T7=q#ni:/lib/definition_defdata.b#;
$U7=q#ni:/lib/doc#;
$V7={$F,1};
$W7={};
$X7=q#shift; +{name => shift, doc => []}#;
$Y7=bless({$q,$X7,$s,$t},$u);
$Z7={$K3,$Y7};
$c8=q#/lib/doc_init.b#;
$d8=bless({$P1,$W7,$z2,$A2,$B2,$A2,$C2,$Z7,$D,$c8},$L2);
$e8=q#lib/slice::ctors#;
$f8={};
$g8=q#'ni.doc'#;
$h8=bless({$q,$g8,$s,$t},$u);
$i8={$e3,$h8};
$j8=q#/lib/doc_namespace.b#;
$k8=bless({$P1,$f8,$z2,$A2,$B2,$A2,$C2,$i8,$D,$j8},$L2);
$l8=q#lib/slice::ctors#;
$m8={};
$n8=q#AUTOLOAD#;
$o8=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$p8=bless({$q,$o8,$s,$t},$u);
$q8={$n8,$p8};
$r8=q#/lib/doc_define.b#;
$s8=bless({$P1,$m8,$z2,$A2,$B2,$A2,$C2,$q8,$D,$r8},$L2);
$t8=q#lib/slice::ctors#;
$u8={};
$v8=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$w8=bless({$q,$v8,$s,$t},$u);
$x8=q#tests#;
$y8=q#my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$z8=bless({$q,$y8,$s,$t},$u);
$A8={$n,$w8,$x8,$z8};
$B8=q#/lib/doc_test.b#;
$C8=bless({$P1,$u8,$z2,$A2,$B2,$A2,$C2,$A8,$D,$B8},$L2);
$D8=q#lib/slice::ctors#;
$E8=[$v4,$X2,$d8,$k8,$s8,$C8];
$F8=bless({$P1,$V7,$D,$W,$r2,$E8},$V1);
$G8=q#lib/doc.c::ctors#;
$H8=q#ni:/lib/doc.c#;
$I8={$V1,1};
$J8=q#/lib/doc.c#;
$K8=[$B6];
$L8=bless({$P1,$I8,$D,$J8,$r2,$K8},$t2);
$M8=q#metaclass::ctors#;
$N8=q#ni:/lib/doc_define.b#;
$O8=q#ni:/lib/doc_init.b#;
$P8=q#ni:/lib/doc_namespace.b#;
$Q8=q#ni:/lib/doc_test.b#;
$R8=q#ni:/lib/documentable.b#;
$S8=q#ni:/lib/fn#;
$T8={$u,1};
$U8=q#/lib/fn#;
$V8={};
$W8=q#shift->compile#;
$X8=bless({$q,$W8,$s,$t},$u);
$Y8=q#compile#;
$Z8=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$c9=bless({$q,$Z8,$s,$t},$u);
$d9=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$e9=bless({$q,$d9,$s,$t},$u);
$f9={$Y8,$c9,$K3,$e9};
$g9=q#/lib/fn_init.b#;
$h9=bless({$P1,$V8,$z2,$X8,$B2,$A2,$C2,$f9,$D,$g9},$L2);
$i9=q#lib/slice::ctors#;
$j9={};
$k9=[];
$l9=q#shift->{'annotations'}#;
$m9=bless({$o,$k9,$q,$l9,$s,$t},$u);
$n9=[];
$o9=q#shift->{'code'}#;
$p9=bless({$o,$n9,$q,$o9,$s,$t},$u);
$q9=q#fn#;
$r9=[];
$s9=q#shift->{'fn'}#;
$t9=bless({$o,$r9,$q,$s9,$s,$t},$u);
$u9={$o,$m9,$q,$p9,$q9,$t9};
$v9=q#/lib/fn_ro.b#;
$w9=bless({$P1,$j9,$z2,$A2,$B2,$A2,$C2,$u9,$D,$v9},$L2);
$x9=q#lib/slice::ctors#;
$y9={};
$z9=[];
$A9=q#shift->{code}#;
$B9=bless({$o,$z9,$q,$A9,$s,$t},$u);
$C9=[];
$D9=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$E9=bless({$o,$C9,$q,$D9,$s,$t},$u);
$F9={$m5,$B9,$v5,$E9};
$G9=q#/lib/fn_ops.b#;
$H9=bless({$P1,$y9,$z2,$A2,$B2,$A2,$C2,$F9,$D,$G9},$L2);
$I9=q#lib/slice::ctors#;
$J9={};
$K9=q#serialize#;
$L9=[];
$M9=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$N9=bless({$o,$L9,$q,$M9,$s,$t},$u);
$O9={$K9,$N9};
$P9=q#/lib/fn_serialize.b#;
$Q9=bless({$P1,$J9,$z2,$A2,$B2,$A2,$C2,$O9,$D,$P9},$L2);
$R9=q#lib/slice::ctors#;
$S9=[$v4,$d6,$h9,$w9,$H9,$Q9];
$T9=bless({$P1,$T8,$D,$U8,$r2,$S9},$W1);
$U9=q#lib/fn.c::ctors#;
$V9=q#ni:/lib/fn.c#;
$W9={$W1,1};
$X9=q#/lib/fn.c#;
$Y9=[$B6];
$Z9=bless({$P1,$W9,$D,$X9,$r2,$Y9},$t2);
$ca=q#metaclass::ctors#;
$da=q#ni:/lib/fn_init.b#;
$ea=q#ni:/lib/fn_ops.b#;
$fa=q#ni:/lib/fn_ro.b#;
$ga=q#ni:/lib/fn_serialize.b#;
$ha=q#ni:/lib/global_static_test.b#;
$ia={};
$ja=q#now#;
$ka=[];
$la=q#ni('ni:/lib/test_value')->new(shift)#;
$ma=q#($)#;
$na=bless({$o,$ka,$q,$la,$s,$ma},$u);
$oa={$ja,$na};
$pa=q#/lib/global_static_test.b#;
$qa=bless({$P1,$ia,$z2,$A2,$B2,$A2,$C2,$oa,$D,$pa},$L2);
$ra=q#main#;
$sa=q#lib/slice::ctors#;
$ta=q#ni:/lib/image#;
$ua={$U3,1};
$va=q#/lib/image#;
$wa={};
$xa=[];
$ya=q#my $class = shift;
my %args  = (
  include_shebang => 1,
  include_license => 1,
  include_boot    => 1,
  include_classes => 1,
  include_run     => 1,
  local_vars      => 0,
  use_newlines    => 0,
  @_);

+{include_shebang => $args{include_shebang},
  include_license => $args{include_license},
  include_boot    => $args{include_boot},
  include_classes => $args{include_classes},
  include_run     => $args{include_run},
  local_vars      => $args{local_vars},
  use_newlines    => $args{use_newlines},

  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$za=bless({$o,$xa,$q,$ya,$s,$t},$u);
$Aa={$K3,$za};
$Ba=q#/lib/image_init.b#;
$Ca=bless({$P1,$wa,$z2,$A2,$B2,$A2,$C2,$Aa,$D,$Ba},$L2);
$Da=q#lib/slice::ctors#;
$Ea={};
$Fa=q#address#;
$Ga=[];
$Ha=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 16;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$Ia=bless({$o,$Ga,$q,$Ha,$s,$t},$u);
$Ja=q#allocate_gensym#;
$Ka=[];
$La=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$Ma=bless({$o,$Ka,$q,$La,$s,$t},$u);
$Na=q#boot_side_effect#;
$Oa=[];
$Pa=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Qa=bless({$o,$Oa,$q,$Pa,$s,$t},$u);
$Ra=q#circular_links#;
$Sa=[];
$Ta=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$Ua=bless({$o,$Sa,$q,$Ta,$s,$t},$u);
$Va=q#finalizer#;
$Wa=[];
$Xa=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$Ya=bless({$o,$Wa,$q,$Xa,$s,$t},$u);
$Za=q#gensym#;
$cb=[];
$db=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$eb=bless({$o,$cb,$q,$db,$s,$t},$u);
$fb=q#is_circular#;
$gb=[];
$hb=q#my $self = shift;
ref $$self{visited}{$self->address($_[0])};#;
$ib=bless({$o,$gb,$q,$hb,$s,$t},$u);
$jb=q#quote#;
$kb=[];
$lb=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? 'undef' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$mb=bless({$o,$kb,$q,$lb,$s,$t},$u);
$nb=q#quote_array#;
$ob=[];
$pb=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_])
  && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$qb=bless({$o,$ob,$q,$pb,$s,$t},$u);
$rb=q#quote_blessed#;
$sb=[];
$tb=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$ub=bless({$o,$sb,$q,$tb,$s,$t},$u);
$vb=q#quote_class#;
$wb=[];
$xb=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$yb=bless({$o,$wb,$q,$xb,$s,$t},$u);
$zb=q#quote_hash#;
$Ab=[];
$Bb=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  push @{$$self{circular}}, [$a, "{" . $self->quote($k) . "}",
                                 $self->address($$v{$k})]
  if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$Cb=bless({$o,$Ab,$q,$Bb,$s,$t},$u);
$Db=q#quote_object#;
$Eb=[];
$Fb=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$Gb=bless({$o,$Eb,$q,$Fb,$s,$t},$u);
$Hb=q#quote_scalar#;
$Ib=[];
$Jb=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$Kb=bless({$o,$Ib,$q,$Jb,$s,$t},$u);
$Lb=q#quote_value#;
$Mb=[];
$Nb=q#my $self = shift;
return $self->quote_scalar($_[0]) unless ref $_[0];
return $self->quote_array($_[0])  if 'ARRAY' eq ref $_[0];
return $self->quote_hash($_[0])   if 'HASH'  eq ref $_[0];
die "cannot serialize $_[0]"      if 'CODE'  eq ref $_[0];
$self->quote_object($_[0]);#;
$Ob=bless({$o,$Mb,$q,$Nb,$s,$t},$u);
$Pb=q#reconstruction#;
$Qb=[];
$Rb=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$Sb=bless({$o,$Qb,$q,$Rb,$s,$t},$u);
$Tb=q#side_effect#;
$Ub=[];
$Vb=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Wb=bless({$o,$Ub,$q,$Vb,$s,$t},$u);
$Xb=q#write#;
$Yb=[];
$Zb=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  ($$self{include_shebang} ? ("\#!/usr/bin/env perl\\n") : ()),
  ($$self{include_license} ? ("chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n") : ()),
  ($$self{include_boot}    ? ("BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n") : ()),
  ($$self{use_newlines}    ? map("$_\\n", $self->reconstruction) : $self->reconstruction),
  ($$self{include_run}     ? ("ni->run(\\@ARGV);", "\\n__DATA__\\n") : ());#;
$cc=bless({$o,$Yb,$q,$Zb,$s,$t},$u);
$dc={$Fa,$Ia,$Ja,$Ma,$Na,$Qa,$Ra,$Ua,$Va,$Ya,$Za,$eb,$fb,$ib,$jb,$mb,$nb,$qb,$rb,$ub,$vb,$yb,$zb,$Cb,$Db,$Gb,$Hb,$Kb,$Lb,$Ob,$Pb,$Sb,$Tb,$Wb,$Xb,$cc};
$ec=q#/lib/image_quoting.b#;
$fc=bless({$P1,$Ea,$z2,$A2,$B2,$A2,$C2,$dc,$D,$ec},$L2);
$gc=q#lib/slice::ctors#;
$hc=[$v4,$Ca,$fc];
$ic=bless({$P1,$ua,$D,$va,$r2,$hc},$X1);
$jc=q#lib/image.c::ctors#;
$kc=q#ni:/lib/image.c#;
$lc={$X1,1};
$mc=q#/lib/image.c#;
$nc=[$B6];
$oc=bless({$P1,$lc,$D,$mc,$r2,$nc},$t2);
$pc=q#metaclass::ctors#;
$qc=q#ni:/lib/image_init.b#;
$rc=q#ni:/lib/image_quoting.b#;
$sc=q#ni:/lib/instance.b#;
$tc=q#ni:/lib/instantiable.b#;
$uc=q#ni:/lib/json.b#;
$vc={};
$wc=q#json_decode#;
$xc=[];
$yc=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$zc=bless({$o,$xc,$q,$yc,$s,$ma},$u);
$Ac=q#json_encode#;
$Bc=[];
$Cc=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$Dc=bless({$o,$Bc,$q,$Cc,$s,$ma},$u);
$Ec=q#json_escape#;
$Fc=[];
$Gc=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$Hc=bless({$o,$Fc,$q,$Gc,$s,$ma},$u);
$Ic=q#json_unescape#;
$Jc=[];
$Kc=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$Lc=bless({$o,$Jc,$q,$Kc,$s,$ma},$u);
$Mc=q#json_unescape_one#;
$Nc=[];
$Oc=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$Pc=bless({$o,$Nc,$q,$Oc,$s,$ma},$u);
$Qc={$wc,$zc,$Ac,$Dc,$Ec,$Hc,$Ic,$Lc,$Mc,$Pc};
$Rc=q#/lib/json.b#;
$Sc=bless({$P1,$vc,$z2,$A2,$B2,$A2,$C2,$Qc,$D,$Rc},$L2);
$Tc=q#ni#;
$Uc=q#lib/slice::ctors#;
$Vc=q#ni:/lib/name_as_string.b#;
$Wc=q#ni:/lib/named.b#;
$Xc=q#ni:/lib/named_in_ni.b#;
$Yc=q#ni:/lib/namespaced.b#;
$Zc=q#ni:/lib/ni#;
$cd={$V3,1};
$dd=q#/lib/ni#;
$ed={};
$fd=q#is_mutable#;
$gd=[];
$hd=q#$0 ne "-" && -w $0#;
$id=bless({$o,$gd,$q,$hd,$s,$t},$u);
$jd=q#modify#;
$kd=[];
$ld=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$md=bless({$o,$kd,$q,$ld,$s,$t},$u);
$nd={$fd,$id,$jd,$md};
$od=q#/lib/ni_self.b#;
$pd=bless({$P1,$ed,$z2,$A2,$B2,$A2,$C2,$nd,$D,$od},$L2);
$qd=q#lib/slice::ctors#;
$rd={};
$sd=q#exists#;
$td=[];
$ud=q#exists $_[0]->{named}{$_[1]}#;
$vd=bless({$o,$td,$q,$ud,$s,$t},$u);
$wd=q#quoted#;
$xd=[];
$yd=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$zd=bless({$o,$xd,$q,$yd,$s,$t},$u);
$Ad={$sd,$vd,$wd,$zd};
$Bd=q#/lib/ni_image.b#;
$Cd=bless({$P1,$rd,$z2,$A2,$B2,$A2,$C2,$Ad,$D,$Bd},$L2);
$Dd=q#lib/slice::ctors#;
$Ed={};
$Fd=q#--internal/+=#;
$Gd=[];
$Hd=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
  die "ni: failed to run $_: $!" unless $r;
}
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$Id=bless({$o,$Gd,$q,$Hd,$s,$t},$u);
$Jd=q#--internal/eval#;
$Kd=[];
$Ld=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$Md=bless({$o,$Kd,$q,$Ld,$s,$t},$u);
$Nd=q#--internal/image#;
$Od=[];
$Pd=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$Qd=bless({$o,$Od,$q,$Pd,$s,$t},$u);
$Rd=q#--internal/test#;
$Sd=[];
$Td=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
my $passed = @tests - $fails;
print "$passed test(s) passed\\n";
!!$fails;#;
$Ud=bless({$o,$Sd,$q,$Td,$s,$t},$u);
$Vd=q#run#;
$Wd=[];
$Xd=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$Yd=bless({$o,$Wd,$q,$Xd,$s,$t},$u);
$Zd={$Fd,$Id,$Jd,$Md,$Nd,$Qd,$Rd,$Ud,$Vd,$Yd};
$ce=q#/lib/ni_main.b#;
$de=bless({$P1,$Ed,$z2,$A2,$B2,$A2,$C2,$Zd,$D,$ce},$L2);
$ee=q#lib/slice::ctors#;
$fe={};
$ge=[];
$he=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$ie=bless({$o,$ge,$q,$he,$s,$t},$u);
$je=q#resolver_for#;
$ke=[];
$le=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$me=bless({$o,$ke,$q,$le,$s,$t},$u);
$ne={$w3,$ie,$je,$me};
$oe=q#/lib/ni_resolver.b#;
$pe=bless({$P1,$fe,$z2,$A2,$B2,$A2,$C2,$ne,$D,$oe},$L2);
$qe=q#lib/slice::ctors#;
$re=[$v4,$pd,$Cd,$de,$pe];
$se=bless({$P1,$cd,$D,$dd,$r2,$re},$Y1);
$te=q#lib/ni.c::ctors#;
$ue=q#ni:/lib/ni.c#;
$ve={$Y1,1};
$we=q#/lib/ni.c#;
$xe=[$B6];
$ye=bless({$P1,$ve,$D,$we,$r2,$xe},$t2);
$ze=q#metaclass::ctors#;
$Ae=q#ni:/lib/ni_image.b#;
$Be=q#ni:/lib/ni_main.b#;
$Ce=q#ni:/lib/ni_resolver.b#;
$De=q#ni:/lib/ni_self.b#;
$Ee=q#ni:/lib/ni_static_util.b#;
$Fe={};
$Ge=q#abbrev#;
$He=[];
$Ie=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$Je=bless({$o,$He,$q,$Ie,$s,$t},$u);
$Ke=q#dor#;
$Le=[];
$Me=q#defined $_[0] ? $_[0] : $_[1]#;
$Ne=bless({$o,$Le,$q,$Me,$s,$t},$u);
$Oe=q#indent#;
$Pe=[];
$Qe=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$Re=bless({$o,$Pe,$q,$Qe,$s,$t},$u);
$Se=q#max#;
$Te=[];
$Ue=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$Ve=bless({$o,$Te,$q,$Ue,$s,$t},$u);
$We=q#maxstr#;
$Xe=[];
$Ye=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$Ze=bless({$o,$Xe,$q,$Ye,$s,$t},$u);
$cf=q#mean#;
$df=[];
$ef=q#sum(@_) / (@_ || 1)#;
$ff=bless({$o,$df,$q,$ef,$s,$t},$u);
$gf=q#min#;
$hf=[];
$if=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$jf=bless({$o,$hf,$q,$if,$s,$t},$u);
$kf=q#minstr#;
$lf=[];
$mf=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$nf=bless({$o,$lf,$q,$mf,$s,$t},$u);
$of=q#sgr#;
$pf=[];
$qf=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$rf=bless({$o,$pf,$q,$qf,$s,$t},$u);
$sf=q#sr#;
$tf=[];
$uf=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$vf=bless({$o,$tf,$q,$uf,$s,$t},$u);
$wf=q#sum#;
$xf=[];
$yf=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$zf=bless({$o,$xf,$q,$yf,$s,$t},$u);
$Af=q#swap#;
$Bf=[];
$Cf=q#@_[0, 1] = @_[1, 0]#;
$Df=bless({$o,$Bf,$q,$Cf,$s,$t},$u);
$Ef={$Ge,$Je,$Ke,$Ne,$Oe,$Re,$Se,$Ve,$We,$Ze,$cf,$ff,$gf,$jf,$kf,$nf,$of,$rf,$sf,$vf,$wf,$zf,$Af,$Df};
$Ff=q#/lib/ni_static_util.b#;
$Gf=bless({$P1,$Fe,$z2,$A2,$B2,$A2,$C2,$Ef,$D,$Ff},$L2);
$Hf=q#lib/slice::ctors#;
$If=q#ni:/lib/perlbranch.b#;
$Jf=q#ni:/lib/ref_eq.b#;
$Kf=q#ni:/lib/resolver.b#;
$Lf=q#ni:/lib/slice#;
$Mf={$L2,1};
$Nf=q#/lib/slice#;
$Of=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$Pf=bless({$q,$Of,$s,$t},$u);
$Qf=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$Rf=bless({$q,$Qf,$s,$t},$u);
$Sf=q#lib/slice::apply#;
$Tf=q#lib/slice::apply_unsafe#;
$Uf={};
$Vf=q#apply_unsafe#;
$Wf={$G2,$Pf,$Vf,$Rf};
$Xf=q#/lib/slice.b#;
$Yf=bless({$P1,$Uf,$C2,$Wf,$D,$Xf},$L2);
$Zf=q#lib/slice::ctors#;
$cg={};
$dg=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$eg=bless({$q,$dg,$s,$t},$u);
$fg={$K3,$eg};
$gg=q#/lib/slice_init.b#;
$hg=bless({$P1,$cg,$C2,$fg,$D,$gg},$L2);
$ig=q#lib/slice::ctors#;
$jg={};
$kg=[];
$lg=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$mg=bless({$o,$kg,$q,$lg,$s,$t},$u);
$ng={$K9,$mg};
$og=q#/lib/slice_serialize.b#;
$pg=bless({$P1,$jg,$z2,$A2,$B2,$A2,$C2,$ng,$D,$og},$L2);
$qg=q#lib/slice::ctors#;
$rg=[$J4,$X2,$Yf,$hg,$pg];
$sg=bless({$P1,$Mf,$D,$Nf,$r2,$rg},$Z1);
$tg=q#lib/slice.c::ctors#;
$ug=q#ni:/lib/slice.b#;
$vg=q#ni:/lib/slice.c#;
$wg={$Z1,1};
$xg=q#/lib/slice.c#;
$yg=[$G6];
$zg=bless({$P1,$wg,$D,$xg,$r2,$yg},$t2);
$Ag=q#metaclass::ctors#;
$Bg=q#ni:/lib/slice_init.b#;
$Cg=q#ni:/lib/slice_serialize.b#;
$Dg=q#ni:/lib/static_fn.b#;
$Eg={};
$Fg=[];
$Gg=q#ni('ni:/lib/fn')->new(@_)#;
$Hg=bless({$o,$Fg,$q,$Gg,$s,$ma},$u);
$Ig=q#fp#;
$Jg=[];
$Kg=q#ni('ni:/lib/fn')->new(@_)#;
$Lg=q#($$)#;
$Mg=bless({$o,$Jg,$q,$Kg,$s,$Lg},$u);
$Ng={$q9,$Hg,$Ig,$Mg};
$Og=q#/lib/static_fn.b#;
$Pg=bless({$P1,$Eg,$z2,$A2,$B2,$A2,$C2,$Ng,$D,$Og},$L2);
$Qg=q#lib/slice::ctors#;
$Rg=q#ni:/lib/subclass.b#;
$Sg=q#ni:/lib/tag#;
$Tg={$Y2,1};
$Ug=q#/lib/tag#;
$Vg={};
$Wg=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$Xg=bless({$q,$Wg,$s,$t},$u);
$Yg={$G2,$Xg};
$Zg=q#/lib/tag.b#;
$ch=bless({$P1,$Vg,$z2,$A2,$B2,$A2,$C2,$Yg,$D,$Zg},$L2);
$dh=q#lib/slice::ctors#;
$eh={};
$fh=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$gh=bless({$q,$fh,$s,$t},$u);
$hh={$K3,$gh};
$ih=q#/lib/tag_init.b#;
$jh=bless({$P1,$eh,$z2,$A2,$B2,$A2,$C2,$hh,$D,$ih},$L2);
$kh=q#lib/slice::ctors#;
$lh=[$J4,$X2,$ch,$jh];
$mh=bless({$P1,$Tg,$D,$Ug,$r2,$lh},$c2);
$nh=q#lib/tag.c::ctors#;
$oh=q#ni:/lib/tag.b#;
$ph=q#ni:/lib/tag.c#;
$qh={$c2,1};
$rh=q#/lib/tag.c#;
$sh=[$G6];
$th=bless({$P1,$qh,$D,$rh,$r2,$sh},$t2);
$uh=q#metaclass::ctors#;
$vh=q#ni:/lib/tag_init.b#;
$wh=q#ni:/lib/test_value#;
$xh={$W3,1};
$yh=q#/lib/test_value#;
$zh={};
$Ah=[];
$Bh=q#\\$_[1]#;
$Ch=bless({$o,$Ah,$q,$Bh,$s,$t},$u);
$Dh={$K3,$Ch};
$Eh=q#/lib/test_value_init.b#;
$Fh=bless({$P1,$zh,$z2,$A2,$B2,$A2,$C2,$Dh,$D,$Eh},$L2);
$Gh=q#lib/slice::ctors#;
$Hh={};
$Ih=q#(==#;
$Jh=[];
$Kh=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$Lh=bless({$o,$Jh,$q,$Kh,$s,$t},$u);
$Mh=q#diff#;
$Nh=[];
$Oh=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$Ph=bless({$o,$Nh,$q,$Oh,$s,$t},$u);
$Qh={$Ih,$Lh,$Mh,$Ph};
$Rh=q#/lib/test_value_eq.b#;
$Sh=bless({$P1,$Hh,$z2,$A2,$B2,$A2,$C2,$Qh,$D,$Rh},$L2);
$Th=q#lib/slice::ctors#;
$Uh={};
$Vh=[];
$Wh=q#ni::json_encode ${$_[0]}#;
$Xh=bless({$o,$Vh,$q,$Wh,$s,$t},$u);
$Yh={$m5,$Xh};
$Zh=q#/lib/test_value_str.b#;
$ci=bless({$P1,$Uh,$z2,$A2,$B2,$A2,$C2,$Yh,$D,$Zh},$L2);
$di=q#lib/slice::ctors#;
$ei=[$v4,$Fh,$Sh,$ci];
$fi=q#lib/test_value.c#;
$gi=bless({$P1,$xh,$D,$yh,$r2,$ei},$fi);
$hi=q#lib/test_value.c::ctors#;
$ii=q#ni:/lib/test_value.c#;
$ji=q#lib/test_value.c#;
$ki={$ji,1};
$li=q#/lib/test_value.c#;
$mi=[$B6];
$ni=bless({$P1,$ki,$D,$li,$r2,$mi},$t2);
$oi=q#metaclass::ctors#;
$pi=q#ni:/lib/test_value_eq.b#;
$qi=q#ni:/lib/test_value_init.b#;
$ri=q#ni:/lib/test_value_str.b#;
$si=q#ni:/metaclass#;
$ti={$t2,1};
$ui=q#/metaclass#;
$vi=[$F3,$d6,$P3,$Q5];
$wi=bless({$P1,$ti,$D,$ui,$r2,$vi},$e2);
$xi=q#metaclass.c::ctors#;
$yi=q#ni:/metaclass.c#;
$zi={$e2,1};
$Ai=q#/metaclass.c#;
$Bi=[$q6];
$Ci=bless({$P1,$zi,$D,$Ai,$r2,$Bi},$t2);
$Di=q#metaclass::ctors#;
$Ei=q#ni:/module#;
$Fi=q#ni:/module.c#;
$Gi=q#ni:/object#;
$Hi=q#ni:/object.c#;
$Ii=q#ni:/unix/cat#;
$Ji={$Z3,1};
$Ki={$Z3,1,$d4,1,$e4,1,$f4,1,$g4,1,$h4,1,$i4,1,$j4,1};
$Li=q#/unix/io#;
$Mi={};
$Ni=q#(bool#;
$Oi=[];
$Pi=bless({$o,$Oi,$q,1,$s,$t},$u);
$Qi={$Ni,$Pi};
$Ri=q#/unix/io_ops.b#;
$Si=bless({$P1,$Mi,$z2,$A2,$B2,$A2,$C2,$Qi,$D,$Ri},$L2);
$Ti=q#lib/slice::ctors#;
$Ui={};
$Vi=q#into#;
$Wi=[];
$Xi=q#local $_;
my ($self, $dest, $each) = @_;
my $block_size = $self->can('read_size') ? $self->read_size : 8192;
while ($self->read($_, $block_size)) {
  $dest->write($_);
  &$each($_) && return if defined $each;
}#;
$Yi=bless({$o,$Wi,$q,$Xi,$s,$t},$u);
$Zi={$Vi,$Yi};
$cj=q#/unix/io_stream.b#;
$dj=bless({$P1,$Ui,$z2,$A2,$B2,$A2,$C2,$Zi,$D,$cj},$L2);
$ej=q#lib/slice::ctors#;
$fj={};
$gj=q#(+#;
$hj=[];
$ij=q#ni('ni:/unix/cat')->new(@_[0, 1])#;
$jj=bless({$o,$hj,$q,$ij,$s,$t},$u);
$kj={$gj,$jj};
$lj=q#/unix/io_constructors.b#;
$mj=bless({$P1,$fj,$z2,$A2,$B2,$A2,$C2,$kj,$D,$lj},$L2);
$nj=q#lib/slice::ctors#;
$oj={};
$pj=q#read_all#;
$qj=[];
$rj=q#shift->into(ni('ni:/unix/str')->new(my $data = ''));
$data;#;
$sj=bless({$o,$qj,$q,$rj,$s,$t},$u);
$tj={$pj,$sj};
$uj=q#/unix/io_memory.b#;
$vj=bless({$P1,$oj,$z2,$A2,$B2,$A2,$C2,$tj,$D,$uj},$L2);
$wj=q#lib/slice::ctors#;
$xj=[$v4,$Si,$dj,$mj,$vj];
$yj=bless({$P1,$Ki,$D,$Li,$r2,$xj},$m2);
$zj=q#unix/io.c::ctors#;
$Aj={};
$Bj=[];
$Cj=q#shift; +{fs => [@_]}#;
$Dj=bless({$o,$Bj,$q,$Cj,$s,$t},$u);
$Ej={$K3,$Dj};
$Fj=q#/unix/cat_init.b#;
$Gj=bless({$P1,$Aj,$z2,$A2,$B2,$A2,$C2,$Ej,$D,$Fj},$L2);
$Hj=q#lib/slice::ctors#;
$Ij={};
$Jj=q#read#;
$Kj=[];
$Lj=q#my $fs = shift->{fs};
my $n;
shift @$fs until !@$fs or $n = $$fs[0]->read(@_);
return $n;#;
$Mj=bless({$o,$Kj,$q,$Lj,$s,$t},$u);
$Nj={$Jj,$Mj};
$Oj=q#/unix/cat_read.b#;
$Pj=bless({$P1,$Ij,$z2,$A2,$B2,$A2,$C2,$Nj,$D,$Oj},$L2);
$Qj=q#lib/slice::ctors#;
$Rj=[$yj,$Gj,$Pj];
$Sj=bless({$P1,$Ji,$D,$k1,$r2,$Rj},$h2);
$Tj=q#unix/cat.c::ctors#;
$Uj=q#ni:/unix/cat.c#;
$Vj={$h2,1};
$Wj=q#/unix/cat.c#;
$Xj={$h2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1};
$Yj=q#/unix/io.c#;
$Zj={};
$ck=q#has_fd#;
$dk=[];
$ek=q#shift->add('/unix/has_fd.b')#;
$fk=bless({$o,$dk,$q,$ek,$s,$t},$u);
$gk={$ck,$fk};
$hk=q#/unix/io.c_has_fd.b#;
$ik=bless({$P1,$Zj,$z2,$A2,$B2,$A2,$C2,$gk,$D,$hk},$L2);
$jk=q#lib/slice::ctors#;
$kk=[$B6,$ik];
$lk=bless({$P1,$Xj,$D,$Yj,$r2,$kk},$t2);
$mk=q#metaclass::ctors#;
$nk=[$lk];
$ok=bless({$P1,$Vj,$D,$Wj,$r2,$nk},$t2);
$pk=q#metaclass::ctors#;
$qk=q#ni:/unix/cat_init.b#;
$rk=q#ni:/unix/cat_read.b#;
$sk=q#ni:/unix/exec#;
$tk={$c4,1};
$uk={};
$vk=q#argv#;
$wk=[];
$xk=q#shift->{'argv'}#;
$yk=bless({$o,$wk,$q,$xk,$s,$t},$u);
$zk={$vk,$yk};
$Ak=q#/unix/exec_ro.b#;
$Bk=bless({$P1,$uk,$z2,$A2,$B2,$A2,$C2,$zk,$D,$Ak},$L2);
$Ck=q#lib/slice::ctors#;
$Dk={};
$Ek=[];
$Fk=q#my ($class, @argv) = @_;
+{argv  => \\@argv,
  env   => {%ENV},
  fds   => {},
  pipes => {}};#;
$Gk=bless({$o,$Ek,$q,$Fk,$s,$t},$u);
$Hk={$K3,$Gk};
$Ik=q#/unix/exec_init.b#;
$Jk=bless({$P1,$Dk,$z2,$A2,$B2,$A2,$C2,$Hk,$D,$Ik},$L2);
$Kk=q#lib/slice::ctors#;
$Lk={};
$Mk=q#fds#;
$Nk=[];
$Ok=q#my ($self, %fds) = @_;
return $$self{fds} unless keys %fds;
@{$$self{fds}}{keys %fds} = values %fds;
$self;#;
$Pk=bless({$o,$Nk,$q,$Ok,$s,$t},$u);
$Qk=q#pipes#;
$Rk=[];
$Sk=q#local $^F = 1024;
my ($self, @fds) = @_;
return $$self{pipes} unless @fds;
for (@fds) {
  die "ni:/unix/exec: must append 'r' or 'w' to extended fds"
    if $_ > 2 && !/^(\\d+)[rw]$/;
  $$self{pipes}{$_} ||= $$self{fds}{$_} = ni("ni:/unix/fifo")->new;
}
$self;#;
$Tk=bless({$o,$Rk,$q,$Sk,$s,$t},$u);
$Uk=q#setup_stdio#;
$Vk=[];
$Wk=q#my $self = shift;
$self->pipes(grep !exists $$self{fds}{$_}, 0..2);
$self;#;
$Xk=bless({$o,$Vk,$q,$Wk,$s,$t},$u);
$Yk={$Mk,$Pk,$Qk,$Tk,$Uk,$Xk};
$Zk=q#/unix/exec_io_setup.b#;
$cl=bless({$P1,$Lk,$z2,$A2,$B2,$A2,$C2,$Yk,$D,$Zk},$L2);
$dl=q#lib/slice::ctors#;
$el={};
$fl=q#fd#;
$gl=[];
$hl=q#my ($self, $fd) = @_;
return $$self{pipes}{$fd} if exists $$self{pipes}{$fd};
$self->pipes($fd)->fd($fd);#;
$il=bless({$o,$gl,$q,$hl,$s,$t},$u);
$jl=q#stderr#;
$kl=[];
$ll=q#shift->fd(2)#;
$ml=bless({$o,$kl,$q,$ll,$s,$t},$u);
$nl=q#stdin#;
$ol=[];
$pl=q#shift->fd(0)#;
$ql=bless({$o,$ol,$q,$pl,$s,$t},$u);
$rl=q#stdout#;
$sl=[];
$tl=q#shift->fd(1)#;
$ul=bless({$o,$sl,$q,$tl,$s,$t},$u);
$vl={$fl,$il,$jl,$ml,$nl,$ql,$rl,$ul};
$wl=q#/unix/exec_io_accessors.b#;
$xl=bless({$P1,$el,$z2,$A2,$B2,$A2,$C2,$vl,$D,$wl},$L2);
$yl=q#lib/slice::ctors#;
$zl={};
$Al=q#env#;
$Bl=[];
$Cl=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$Dl=bless({$o,$Bl,$q,$Cl,$s,$t},$u);
$El={$Al,$Dl};
$Fl=q#/unix/exec_env.b#;
$Gl=bless({$P1,$zl,$z2,$A2,$B2,$A2,$C2,$El,$D,$Fl},$L2);
$Hl=q#lib/slice::ctors#;
$Il={};
$Jl=q#exec#;
$Kl=[];
$Ll=q#no warnings 'numeric';
my $self = shift->setup_stdio;
local %ENV = %{$$self{env}};
$self->move_fds;
for (keys %{$$self{pipes}}) {
  my $p = $$self{pipes}{$_};
  ($_ < 2 ? !$_ : /r$/) ? $p->r : $p->w;
}
my @argv = (@{$$self{argv}}, @_);
{ exec @argv };
print STDERR "ni:/unix/exec: exec @argv failed: $!";
exit 1;#;
$Ml=bless({$o,$Kl,$q,$Ll,$s,$t},$u);
$Nl=q#fork#;
$Ol=[];
$Pl=q#no warnings 'numeric';
my $self = shift->setup_stdio;
my $pid = fork;
die "ni:/unix/exec: fork failed: $!" unless defined $pid;
return $self->exec(@_) unless $pid;
for (keys %{$$self{pipes}}) {
  my $p = $$self{pipes}{$_};
  ($_ < 2 ? $_ : /r$/) ? $p->w : $p->r;
}
ni('ni:/unix/pid')->new($pid, %{$$self{pipes}});#;
$Ql=bless({$o,$Ol,$q,$Pl,$s,$t},$u);
$Rl=q#move_fds#;
$Sl=[];
$Tl=q#my $self = shift;
$$self{fds}{$_}->be($_) for keys %{$$self{fds}};
$self;#;
$Ul=bless({$o,$Sl,$q,$Tl,$s,$t},$u);
$Vl={$Jl,$Ml,$Nl,$Ql,$Rl,$Ul};
$Wl=q#/unix/exec_fork.b#;
$Xl=bless({$P1,$Il,$z2,$A2,$B2,$A2,$C2,$Vl,$D,$Wl},$L2);
$Yl=q#lib/slice::ctors#;
$Zl=[$v4,$Bk,$Jk,$cl,$xl,$Gl,$Xl];
$cm=bless({$P1,$tk,$D,$w1,$r2,$Zl},$i2);
$dm=q#unix/exec.c::ctors#;
$em=q#ni:/unix/exec.c#;
$fm={$i2,1};
$gm=q#/unix/exec.c#;
$hm=[$B6];
$im=bless({$P1,$fm,$D,$gm,$r2,$hm},$t2);
$jm=q#metaclass::ctors#;
$km=q#ni:/unix/exec_env.b#;
$lm=q#ni:/unix/exec_fork.b#;
$mm=q#ni:/unix/exec_init.b#;
$nm=q#ni:/unix/exec_io_accessors.b#;
$om=q#ni:/unix/exec_io_setup.b#;
$pm=q#ni:/unix/exec_ro.b#;
$qm=q#ni:/unix/fd#;
$rm={$d4,1};
$sm=q#/unix/fd#;
$tm={};
$um=[];
$vm=q#shift->{'fd'}#;
$wm=bless({$o,$um,$q,$vm,$s,$t},$u);
$xm={$fl,$wm};
$ym=q#/unix/fd_readers.b#;
$zm=bless({$P1,$tm,$z2,$A2,$B2,$A2,$C2,$xm,$D,$ym},$L2);
$Am=q#lib/slice::ctors#;
$Bm={};
$Cm=[];
$Dm=q#my ($class, $fd) = @_;
+{fd => ref $fd ? fileno $fd : $fd,
  fh => ref $fd ? $fd        : undef};#;
$Em=bless({$o,$Cm,$q,$Dm,$s,$t},$u);
$Fm={$K3,$Em};
$Gm=q#/unix/fd_init.b#;
$Hm=bless({$P1,$Bm,$z2,$A2,$B2,$A2,$C2,$Fm,$D,$Gm},$L2);
$Im=q#lib/slice::ctors#;
$Jm={};
$Km=q#be#;
$Lm=[];
$Mm=q#use POSIX qw/dup2/;
my ($self, $new) = @_;
return $self if $new == $$self{fd};
close $$self{fh} if Scalar::Util::openhandle $$self{fh};
dup2 $$self{fd}, $new or die "ni:/unix/fd: dup2($$self{fd}, $new): $!";
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$Nm=bless({$o,$Lm,$q,$Mm,$s,$t},$u);
$Om={$Km,$Nm};
$Pm=q#/unix/fd_shell.b#;
$Qm=bless({$P1,$Jm,$z2,$A2,$B2,$A2,$C2,$Om,$D,$Pm},$L2);
$Rm=q#lib/slice::ctors#;
$Sm={$d4,1,$e4,1,$f4,1,$h4,1,$i4,1};
$Tm=q#/unix/has_fd.b#;
$Um={};
$Vm=q#read_fd#;
$Wm=[];
$Xm=q#ni("ni:/unix/fd")->new(fileno shift->read_fh)#;
$Ym=bless({$o,$Wm,$q,$Xm,$s,$t},$u);
$Zm=q#write_fd#;
$cn=[];
$dn=q#ni("ni:/unix/fd")->new(fileno shift->write_fh)#;
$en=bless({$o,$cn,$q,$dn,$s,$t},$u);
$fn={$Vm,$Ym,$Zm,$en};
$gn=q#/unix/fd_accessors.b#;
$hn=bless({$P1,$Um,$z2,$A2,$B2,$A2,$C2,$fn,$D,$gn},$L2);
$in=q#lib/slice::ctors#;
$jn={};
$kn=[];
$ln=q#no warnings 'io';
use Errno qw/EINTR/;
my $fh = shift->read_fh;
my $n;
do {
  return $n if defined($n = read $fh, $_[0], $_[1], $_[2] || 0);
} while $!{EINTR};
return undef;#;
$mn=bless({$o,$kn,$q,$ln,$s,$t},$u);
$nn=[];
$on=q#my $fh = shift->write_fh;
my $n;
do {
  return $n if defined($n = syswrite $fh, $_[0]);
} while $!{EINTR};
return undef;#;
$pn=bless({$o,$nn,$q,$on,$s,$t},$u);
$qn={$Jj,$mn,$Xb,$pn};
$rn=q#/unix/fd_safeio.b#;
$sn=bless({$P1,$jn,$z2,$A2,$B2,$A2,$C2,$qn,$D,$rn},$L2);
$tn=q#lib/slice::ctors#;
$un=[$hn,$sn];
$vn=bless({$P1,$Sm,$D,$Tm,$r2,$un},$N2);
$wn=q#lib/branch::ctors#;
$xn={};
$yn=q#read_fh#;
$zn=[];
$An=q#my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, '<&=', $$self{fd}
  or die "ni:/unix/fd $$self{fd} failed to read: $!";
$self->{fh} = $fh;#;
$Bn=bless({$o,$zn,$q,$An,$s,$t},$u);
$Cn=q#write_fh#;
$Dn=[];
$En=q#my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, '>&=', $$self{fd}
  or die "ni:/unix/file $$self{fd} failed to write: $!";
$self->{fh} = $fh;#;
$Fn=bless({$o,$Dn,$q,$En,$s,$t},$u);
$Gn={$yn,$Bn,$Cn,$Fn};
$Hn=q#/unix/fd_io.b#;
$In=bless({$P1,$xn,$z2,$A2,$B2,$A2,$C2,$Gn,$D,$Hn},$L2);
$Jn=q#lib/slice::ctors#;
$Kn=[$yj,$zm,$Hm,$Qm,$vn,$In];
$Ln=bless({$P1,$rm,$D,$sm,$r2,$Kn},$j2);
$Mn=q#unix/fd.c::ctors#;
$Nn=q#ni:/unix/fd.c#;
$On={$j2,1};
$Pn=q#/unix/fd.c#;
$Qn=[$lk];
$Rn=bless({$P1,$On,$D,$Pn,$r2,$Qn},$t2);
$Sn=q#metaclass::ctors#;
$Tn=q#ni:/unix/fd_accessors.b#;
$Un=q#ni:/unix/fd_init.b#;
$Vn=q#ni:/unix/fd_io.b#;
$Wn=q#ni:/unix/fd_readers.b#;
$Xn=q#ni:/unix/fd_safeio.b#;
$Yn=q#ni:/unix/fd_shell.b#;
$Zn=q#ni:/unix/fifo#;
$co={$e4,1};
$do=q#/unix/fifo#;
$eo={};
$fo=[];
$go=q#shift->{'read_fh'}#;
$ho=bless({$o,$fo,$q,$go,$s,$t},$u);
$io=[];
$jo=q#shift->{'write_fh'}#;
$ko=bless({$o,$io,$q,$jo,$s,$t},$u);
$lo={$yn,$ho,$Cn,$ko};
$mo=q#/unix/fifo_io.b#;
$no=bless({$P1,$eo,$z2,$A2,$B2,$A2,$C2,$lo,$D,$mo},$L2);
$oo=q#lib/slice::ctors#;
$po={};
$qo=[];
$ro=q#my ($class) = @_;
pipe my ($r, $w) or die "ni:/unix/fifo failed: $!";
+{read_fh => $r, write_fh => $w};#;
$so=bless({$o,$qo,$q,$ro,$s,$t},$u);
$to={$K3,$so};
$uo=q#/unix/fifo_init.b#;
$vo=bless({$P1,$po,$z2,$A2,$B2,$A2,$C2,$to,$D,$uo},$L2);
$wo=q#lib/slice::ctors#;
$xo={};
$yo=[];
$zo=q#my ($self, $fd) = @_;
(!$fd || $fd > 2 && $fd =~ s/[rw]$// && $1 eq 'r'
  ? $self->r
  : $self->w)->be($fd);
$self;#;
$Ao=bless({$o,$yo,$q,$zo,$s,$t},$u);
$Bo={$Km,$Ao};
$Co=q#/unix/fifo_stdio.b#;
$Do=bless({$P1,$xo,$z2,$A2,$B2,$A2,$C2,$Bo,$D,$Co},$L2);
$Eo=q#lib/slice::ctors#;
$Fo={};
$Go=q#r#;
$Ho=[];
$Io=q#my $self = shift;
close $$self{write_fh};
$self->read_fd;#;
$Jo=bless({$o,$Ho,$q,$Io,$s,$t},$u);
$Ko=q#w#;
$Lo=[];
$Mo=q#my $self = shift;
close $$self{read_fh};
$self->write_fd;#;
$No=bless({$o,$Lo,$q,$Mo,$s,$t},$u);
$Oo={$Go,$Jo,$Ko,$No};
$Po=q#/unix/fifo_direction.b#;
$Qo=bless({$P1,$Fo,$z2,$A2,$B2,$A2,$C2,$Oo,$D,$Po},$L2);
$Ro=q#lib/slice::ctors#;
$So=[$yj,$no,$vo,$Do,$vn,$Qo];
$To=bless({$P1,$co,$D,$do,$r2,$So},$k2);
$Uo=q#unix/fifo.c::ctors#;
$Vo=q#ni:/unix/fifo.c#;
$Wo={$k2,1};
$Xo=q#/unix/fifo.c#;
$Yo=[$lk];
$Zo=bless({$P1,$Wo,$D,$Xo,$r2,$Yo},$t2);
$cp=q#metaclass::ctors#;
$dp=q#ni:/unix/fifo_direction.b#;
$ep=q#ni:/unix/fifo_init.b#;
$fp=q#ni:/unix/fifo_io.b#;
$gp=q#ni:/unix/fifo_stdio.b#;
$hp=q#ni:/unix/file#;
$ip={$f4,1};
$jp=q#/unix/file#;
$kp={};
$lp=[];
$mp=q#shift->{'name'}#;
$np=bless({$o,$lp,$q,$mp,$s,$t},$u);
$op={$D,$np};
$pp=q#/unix/file_readers.b#;
$qp=bless({$P1,$kp,$z2,$A2,$B2,$A2,$C2,$op,$D,$pp},$L2);
$rp=q#lib/slice::ctors#;
$sp={};
$tp=[];
$up=q#my ($class, $name) = @_;
+{name => $name, fh => undef};#;
$vp=bless({$o,$tp,$q,$up,$s,$t},$u);
$wp={$K3,$vp};
$xp=q#/unix/file_init.b#;
$yp=bless({$P1,$sp,$z2,$A2,$B2,$A2,$C2,$wp,$D,$xp},$L2);
$zp=q#lib/slice::ctors#;
$Ap={};
$Bp=[];
$Cp=q#my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, '<', $self->{name}
  or die "ni:/unix/file $self->{name} failed to read: $!";
$self->{fh} = $fh;#;
$Dp=bless({$o,$Bp,$q,$Cp,$s,$t},$u);
$Ep=[];
$Fp=q#my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, '>', $self->{name}
  or die "ni:/unix/file $self->{name} failed to write: $!";
$self->{fh} = $fh;#;
$Gp=bless({$o,$Ep,$q,$Fp,$s,$t},$u);
$Hp={$yn,$Dp,$Cn,$Gp};
$Ip=q#/unix/file_io.b#;
$Jp=bless({$P1,$Ap,$z2,$A2,$B2,$A2,$C2,$Hp,$D,$Ip},$L2);
$Kp=q#lib/slice::ctors#;
$Lp=[$yj,$qp,$yp,$vn,$Jp];
$Mp=bless({$P1,$ip,$D,$jp,$r2,$Lp},$l2);
$Np=q#unix/file.c::ctors#;
$Op=q#ni:/unix/file.c#;
$Pp={$l2,1};
$Qp=q#/unix/file.c#;
$Rp=[$lk];
$Sp=bless({$P1,$Pp,$D,$Qp,$r2,$Rp},$t2);
$Tp=q#metaclass::ctors#;
$Up=q#ni:/unix/file_init.b#;
$Vp=q#ni:/unix/file_io.b#;
$Wp=q#ni:/unix/file_readers.b#;
$Xp=q#ni:/unix/has_fd.b#;
$Yp=q#ni:/unix/io#;
$Zp=q#ni:/unix/io.c#;
$cq=q#ni:/unix/io.c_has_fd.b#;
$dq=q#ni:/unix/io_constructors.b#;
$eq=q#ni:/unix/io_memory.b#;
$fq=q#ni:/unix/io_ops.b#;
$gq=q#ni:/unix/io_stream.b#;
$hq=q#ni:/unix/pid#;
$iq={$h4,1};
$jq={};
$kq=q#pid#;
$lq=[];
$mq=q#shift->{'pid'}#;
$nq=bless({$o,$lq,$q,$mq,$s,$t},$u);
$oq=q#status#;
$pq=[];
$qq=q#shift->{'status'}#;
$rq=bless({$o,$pq,$q,$qq,$s,$t},$u);
$sq={$kq,$nq,$oq,$rq};
$tq=q#/unix/pid_readers.b#;
$uq=bless({$P1,$jq,$z2,$A2,$B2,$A2,$C2,$sq,$D,$tq},$L2);
$vq=q#lib/slice::ctors#;
$wq={};
$xq=[];
$yq=q#shift->await#;
$zq=bless({$o,$xq,$q,$yq,$s,$t},$u);
$Aq=[];
$Bq=q#my ($class, $pid, %exposed_fds) = @_;
+{pid    => $pid,
  fds    => \\%exposed_fds,
  status => undef};#;
$Cq=bless({$o,$Aq,$q,$Bq,$s,$t},$u);
$Dq={$K3,$Cq};
$Eq=q#/unix/pid_init.b#;
$Fq=bless({$P1,$wq,$z2,$A2,$B2,$zq,$C2,$Dq,$D,$Eq},$L2);
$Gq=q#lib/slice::ctors#;
$Hq={};
$Iq=q#await#;
$Jq=[];
$Kq=q#my $self = shift;
return $$self{status} if defined $$self{status};
defined(waitpid $$self{pid}, 0)
  ? $$self{status} = $?
  : die "/unix/pid_wait.b: waitpid: $!";#;
$Lq=bless({$o,$Jq,$q,$Kq,$s,$t},$u);
$Mq=q#running#;
$Nq=[];
$Oq=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$Pq=bless({$o,$Nq,$q,$Oq,$s,$t},$u);
$Qq={$Iq,$Lq,$Mq,$Pq};
$Rq=q#/unix/pid_wait.b#;
$Sq=bless({$P1,$Hq,$z2,$A2,$B2,$A2,$C2,$Qq,$D,$Rq},$L2);
$Tq=q#lib/slice::ctors#;
$Uq={};
$Vq=[];
$Wq=q#shift->fd(1)->read_fh#;
$Xq=bless({$o,$Vq,$q,$Wq,$s,$t},$u);
$Yq=[];
$Zq=q#shift->fd(0)->write_fh#;
$cr=bless({$o,$Yq,$q,$Zq,$s,$t},$u);
$dr={$yn,$Xq,$Cn,$cr};
$er=q#/unix/pid_io.b#;
$fr=bless({$P1,$Uq,$z2,$A2,$B2,$A2,$C2,$dr,$D,$er},$L2);
$gr=q#lib/slice::ctors#;
$hr={};
$ir=[];
$jr=q#$_[0]->{fds}{$_[1]}#;
$kr=bless({$o,$ir,$q,$jr,$s,$t},$u);
$lr=[];
$mr=bless({$o,$lr,$q,$ll,$s,$t},$u);
$nr=[];
$or=bless({$o,$nr,$q,$pl,$s,$t},$u);
$pr=[];
$qr=bless({$o,$pr,$q,$tl,$s,$t},$u);
$rr={$fl,$kr,$jl,$mr,$nl,$or,$rl,$qr};
$sr=q#/unix/pid_accessors.b#;
$tr=bless({$P1,$hr,$z2,$A2,$B2,$A2,$C2,$rr,$D,$sr},$L2);
$ur=q#lib/slice::ctors#;
$vr=[$yj,$uq,$Fq,$Sq,$vn,$fr,$tr];
$wr=bless({$P1,$iq,$D,$M1,$r2,$vr},$n2);
$xr=q#unix/pid.c::ctors#;
$yr=q#ni:/unix/pid.c#;
$zr={$n2,1};
$Ar=q#/unix/pid.c#;
$Br=[$lk];
$Cr=bless({$P1,$zr,$D,$Ar,$r2,$Br},$t2);
$Dr=q#metaclass::ctors#;
$Er=q#ni:/unix/pid_accessors.b#;
$Fr=q#ni:/unix/pid_init.b#;
$Gr=q#ni:/unix/pid_io.b#;
$Hr=q#ni:/unix/pid_readers.b#;
$Ir=q#ni:/unix/pid_wait.b#;
$Jr=q#ni:/unix/pipeline#;
$Kr={$i4,1};
$Lr=q#/unix/pipeline#;
$Mr={};
$Nr=[];
$Or=q#shift->{'stdin'}#;
$Pr=bless({$o,$Nr,$q,$Or,$s,$t},$u);
$Qr=[];
$Rr=q#shift->{'stdout'}#;
$Sr=bless({$o,$Qr,$q,$Rr,$s,$t},$u);
$Tr={$nl,$Pr,$rl,$Sr};
$Ur=q#/unix/pipeline_ro.b#;
$Vr=bless({$P1,$Mr,$z2,$A2,$B2,$A2,$C2,$Tr,$D,$Ur},$L2);
$Wr=q#lib/slice::ctors#;
$Xr={};
$Yr=[];
$Zr=q#my $class  = shift;
my $stdin  = ni('ni:/unix/fifo')->new;
my $stdout = ni('ni:/unix/fifo')->new;
\# TODO: stderr and multiplexing, which probably happens here

my @rs = ($stdin, @_);
my @ws = (@_, $stdout);
my $rv; vec($rv, fileno $_->read_fh,  1) = 1 for @rs;
my $wv; vec($wv, fileno $_->write_fh, 1) = 1 for @ws;

+{ps     => [@_],
  stdin  => $stdin,
  stdout => $stdout,
  rs => \\@rs, rv => $rv,
  ws => \\@ws, wv => $wv};#;
$cs=bless({$o,$Yr,$q,$Zr,$s,$t},$u);
$ds={$K3,$cs};
$es=q#/unix/pipeline_init.b#;
$fs=bless({$P1,$Xr,$z2,$A2,$B2,$A2,$C2,$ds,$D,$es},$L2);
$gs=q#lib/slice::ctors#;
$hs={};
$is=q#async_step#;
$js=[];
$ks=q#local $_;
my $self = shift;
my $rv = $$self{rv};
my $wv = $$self{wv};
my $ev = $$self{ev};
return $self unless select $rv, $wv, $ev, 0;
for my $i (0..$\#{$$self{rs}}) {
  my $rfh = $$self{rs}[$i]->read_fh;
  my $wfh = $$self{ws}[$i]->write_fh;
  next unless vec $rv, fileno $rfh, 1 and vec $wv, fileno $wfh, 1;
  $$self{rs}[$i]->read($_, 8192);
  $$self{ws}[$i]->write($_);
}
$self;#;
$ls=bless({$o,$js,$q,$ks,$s,$t},$u);
$ms={$is,$ls};
$ns=q#/unix/pipeline_async.b#;
$os=bless({$P1,$hs,$z2,$A2,$B2,$A2,$C2,$ms,$D,$ns},$L2);
$ps=q#lib/slice::ctors#;
$qs={};
$rs=[];
$ss=q#shift->{stdout}->read_fh#;
$ts=bless({$o,$rs,$q,$ss,$s,$t},$u);
$us=[];
$vs=q#shift->{stdin}->write_fh#;
$ws=bless({$o,$us,$q,$vs,$s,$t},$u);
$xs={$yn,$ts,$Cn,$ws};
$ys=q#/unix/pipeline_io.b#;
$zs=bless({$P1,$qs,$z2,$A2,$B2,$A2,$C2,$xs,$D,$ys},$L2);
$As=q#lib/slice::ctors#;
$Bs=[$yj,$Vr,$fs,$os,$vn,$zs];
$Cs=bless({$P1,$Kr,$D,$Lr,$r2,$Bs},$o2);
$Ds=q#unix/pipeline.c::ctors#;
$Es=q#ni:/unix/pipeline.c#;
$Fs={$o2,1};
$Gs=q#/unix/pipeline.c#;
$Hs=[$lk];
$Is=bless({$P1,$Fs,$D,$Gs,$r2,$Hs},$t2);
$Js=q#metaclass::ctors#;
$Ks=q#ni:/unix/pipeline_async.b#;
$Ls=q#ni:/unix/pipeline_init.b#;
$Ms=q#ni:/unix/pipeline_io.b#;
$Ns=q#ni:/unix/pipeline_ro.b#;
$Os=q#ni:/unix/str#;
$Ps={$j4,1};
$Qs=q#/unix/str#;
$Rs={};
$Ss=q#data#;
$Ts=[];
$Us=q#shift->{'data'}#;
$Vs=bless({$o,$Ts,$q,$Us,$s,$t},$u);
$Ws=q#end#;
$Xs=[];
$Ys=q#shift->{'end'}#;
$Zs=bless({$o,$Xs,$q,$Ys,$s,$t},$u);
$ct=q#start#;
$dt=[];
$et=q#shift->{'start'}#;
$ft=bless({$o,$dt,$q,$et,$s,$t},$u);
$gt={$Ss,$Vs,$Ws,$Zs,$ct,$ft};
$ht=q#/unix/str_ro.b#;
$it=bless({$P1,$Rs,$z2,$A2,$B2,$A2,$C2,$gt,$D,$ht},$L2);
$jt=q#lib/slice::ctors#;
$kt={};
$lt=[];
$mt=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$nt=bless({$o,$lt,$q,$mt,$s,$t},$u);
$ot={$K3,$nt};
$pt=q#/unix/str_init.b#;
$qt=bless({$P1,$kt,$z2,$A2,$B2,$A2,$C2,$ot,$D,$pt},$L2);
$rt=q#lib/slice::ctors#;
$st={};
$tt=[];
$ut=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$vt=bless({$o,$tt,$q,$ut,$s,$t},$u);
$wt=q#remaining#;
$xt=[];
$yt=q#my $self = shift; $$self{end} - $$self{start}#;
$zt=bless({$o,$xt,$q,$yt,$s,$t},$u);
$At=[];
$Bt=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$Ct=bless({$o,$At,$q,$Bt,$s,$t},$u);
$Dt={$Jj,$vt,$wt,$zt,$Xb,$Ct};
$Et=q#/unix/str_io.b#;
$Ft=bless({$P1,$st,$z2,$A2,$B2,$A2,$C2,$Dt,$D,$Et},$L2);
$Gt=q#lib/slice::ctors#;
$Ht=[$yj,$it,$qt,$Ft];
$It=bless({$P1,$Ps,$D,$Qs,$r2,$Ht},$p2);
$Jt=q#unix/str.c::ctors#;
$Kt=q#ni:/unix/str.c#;
$Lt={$p2,1};
$Mt=q#/unix/str.c#;
$Nt=[$lk];
$Ot=bless({$P1,$Lt,$D,$Mt,$r2,$Nt},$t2);
$Pt=q#metaclass::ctors#;
$Qt=q#ni:/unix/str_init.b#;
$Rt=q#ni:/unix/str_io.b#;
$St=q#ni:/unix/str_ro.b#;
$Tt=q#ni:main#;
$Ut={$ra,1};
$Vt=[$Pg,$qa];
$Wt=bless({$P1,$Ut,$D,$ra,$r2,$Vt},$u2);
$Xt=q#module::ctors#;
$Yt=q#ni:ni#;
$Zt={$Tc,1};
$cu={$Tc,1};
$du=q#json_escapes#;
$eu=q##;
$fu=q#b#;
$gu=q#	#;
$hu=q#t#;
$iu=q#
#;
$ju=q#n#;
$ku=q##;
$lu=q#"#;
$mu=q#/#;
$nu=q#\\#;
$ou={$eu,$fu,$gu,$hu,$iu,$ju,$ku,$Go,$lu,$lu,$mu,$mu,$nu,$nu};
$pu=q#json_unescapes#;
$qu={$lu,$lu,$mu,$mu,$nu,$nu,$fu,$eu,$ju,$iu,$Go,$ku,$hu,$gu};
$ru={$du,$ou,$pu,$qu};
$su=q#/lib/json_data.b#;
$tu=bless({$P1,$cu,$Ss,$ru,$D,$su},$T3);
$uu=q#lib/dataslice::ctors#;
$vu=[$tu,$Sc,$Gf];
$wu=bless({$P1,$Zt,$D,$Tc,$r2,$vu},$u2);
$xu={$d,$G,$I,$X,$Y,$l1,$m1,$x1,$y1,$N1,$O1,$q6,$s6,$M6,$O6,$i5,$P6,$J4,$Q6,$G6,$R6,$e7,$g7,$M2,$h7,$l7,$n7,$Z6,$o7,$P3,$p7,$H7,$J7,$N7,$P7,$E7,$Q7,$x7,$R7,$N5,$S7,$U4,$T7,$J5,$U7,$F8,$H8,$L8,$N8,$s8,$O8,$d8,$P8,$k8,$Q8,$C8,$R8,$F4,$S8,$T9,$V9,$Z9,$da,$h9,$ea,$H9,$fa,$w9,$ga,$Q9,$ha,$qa,$ta,$ic,$kc,$oc,$qc,$Ca,$rc,$fc,$sc,$r4,$tc,$d6,$uc,$Sc,$Vc,$r5,$Wc,$X2,$Xc,$j3,$Yc,$s3,$Zc,$se,$ue,$ye,$Ae,$Cd,$Be,$de,$Ce,$pe,$De,$pd,$Ee,$Gf,$If,$F3,$Jf,$A5,$Kf,$B3,$Lf,$sg,$ug,$Yf,$vg,$zg,$Bg,$hg,$Cg,$pg,$Dg,$Pg,$Rg,$m6,$Sg,$mh,$oh,$ch,$ph,$th,$vh,$jh,$wh,$gi,$ii,$ni,$pi,$Sh,$qi,$Fh,$ri,$ci,$si,$wi,$yi,$Ci,$Ei,$Q5,$Fi,$J6,$Gi,$v4,$Hi,$B6,$Ii,$Sj,$Uj,$ok,$qk,$Gj,$rk,$Pj,$sk,$cm,$em,$im,$km,$Gl,$lm,$Xl,$mm,$Jk,$nm,$xl,$om,$cl,$pm,$Bk,$qm,$Ln,$Nn,$Rn,$Tn,$hn,$Un,$Hm,$Vn,$In,$Wn,$zm,$Xn,$sn,$Yn,$Qm,$Zn,$To,$Vo,$Zo,$dp,$Qo,$ep,$vo,$fp,$no,$gp,$Do,$hp,$Mp,$Op,$Sp,$Up,$yp,$Vp,$Jp,$Wp,$qp,$Xp,$vn,$Yp,$yj,$Zp,$lk,$cq,$ik,$dq,$mj,$eq,$vj,$fq,$Si,$gq,$dj,$hq,$wr,$yr,$Cr,$Er,$tr,$Fr,$Fq,$Gr,$fr,$Hr,$uq,$Ir,$Sq,$Jr,$Cs,$Es,$Is,$Ks,$os,$Ls,$fs,$Ms,$zs,$Ns,$Vr,$Os,$It,$Kt,$Ot,$Qt,$qt,$Rt,$Ft,$St,$it,$Tt,$Wt,$Yt,$wu};
$yu=q#resolvers#;
$zu=[];
$Au=q#ni('ni:/unix/fd')->new(0 + substr shift, 3)#;
$Bu=bless({$o,$zu,$q,$Au,$s,$t},$u);
$Cu=q#file#;
$Du=[];
$Eu=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/unix/file')->new($f);#;
$Fu=bless({$o,$Du,$q,$Eu,$s,$t},$u);
$Gu=q#sh#;
$Hu=[];
$Iu=q#ni('ni:/unix/exec')->new('/bin/sh', '-c', substr shift, 3)->fork;#;
$Ju=bless({$o,$Hu,$q,$Iu,$s,$t},$u);
$Ku=q#str#;
$Lu=[];
$Mu=q#my $s = shift;
ni('ni:/unix/str')->new(substr($s, 4) . "\\n");#;
$Nu=bless({$o,$Lu,$q,$Mu,$s,$t},$u);
$Ou={$fl,$Bu,$Cu,$Fu,$Gu,$Ju,$Ku,$Nu};
$Pu=bless({$c,$xu,$yu,$Ou},$V3);
$Qu=q#lib/ni::ctors#;
*$Tf=\&$Rf;
*$Sf=\&$Pf;
$M2->apply_unsafe($Q1);
$M2->apply_unsafe($R1);
$M2->apply_unsafe($S1);
$M2->apply_unsafe($N2);
$M2->apply_unsafe($T1);
$M2->apply_unsafe($U1);
$M2->apply_unsafe($V1);
$M2->apply_unsafe($W1);
$M2->apply_unsafe($X1);
$M2->apply_unsafe($Y1);
$M2->apply_unsafe($Z1);
$M2->apply_unsafe($c2);
$M2->apply_unsafe($O2);
$M2->apply_unsafe($t2);
$M2->apply_unsafe($e2);
$M2->apply_unsafe($u2);
$M2->apply_unsafe($f2);
$M2->apply_unsafe($g2);
$M2->apply_unsafe($h2);
$M2->apply_unsafe($i2);
$M2->apply_unsafe($j2);
$M2->apply_unsafe($k2);
$M2->apply_unsafe($l2);
$M2->apply_unsafe($m2);
$M2->apply_unsafe($n2);
$M2->apply_unsafe($o2);
$M2->apply_unsafe($p2);
$X2->apply_unsafe($Q1);
$X2->apply_unsafe($R1);
$X2->apply_unsafe($S1);
$X2->apply_unsafe($N2);
$X2->apply_unsafe($T1);
$X2->apply_unsafe($U1);
$X2->apply_unsafe($F);
$X2->apply_unsafe($V1);
$X2->apply_unsafe($W1);
$X2->apply_unsafe($X1);
$X2->apply_unsafe($Y1);
$X2->apply_unsafe($L2);
$X2->apply_unsafe($Z1);
$X2->apply_unsafe($Y2);
$X2->apply_unsafe($c2);
$X2->apply_unsafe($Z2);
$X2->apply_unsafe($t2);
$X2->apply_unsafe($e2);
$X2->apply_unsafe($u2);
$X2->apply_unsafe($f2);
$X2->apply_unsafe($g2);
$X2->apply_unsafe($h2);
$X2->apply_unsafe($i2);
$X2->apply_unsafe($j2);
$X2->apply_unsafe($k2);
$X2->apply_unsafe($l2);
$X2->apply_unsafe($m2);
$X2->apply_unsafe($n2);
$X2->apply_unsafe($o2);
$X2->apply_unsafe($p2);
$j3->apply_unsafe($Q1);
$j3->apply_unsafe($R1);
$j3->apply_unsafe($S1);
$j3->apply_unsafe($N2);
$j3->apply_unsafe($T1);
$j3->apply_unsafe($U1);
$j3->apply_unsafe($V1);
$j3->apply_unsafe($W1);
$j3->apply_unsafe($X1);
$j3->apply_unsafe($Y1);
$j3->apply_unsafe($L2);
$j3->apply_unsafe($Z1);
$j3->apply_unsafe($Y2);
$j3->apply_unsafe($c2);
$j3->apply_unsafe($k3);
$j3->apply_unsafe($t2);
$j3->apply_unsafe($e2);
$j3->apply_unsafe($u2);
$j3->apply_unsafe($f2);
$j3->apply_unsafe($g2);
$j3->apply_unsafe($h2);
$j3->apply_unsafe($i2);
$j3->apply_unsafe($j2);
$j3->apply_unsafe($k2);
$j3->apply_unsafe($l2);
$j3->apply_unsafe($m2);
$j3->apply_unsafe($n2);
$j3->apply_unsafe($o2);
$j3->apply_unsafe($p2);
$s3->apply_unsafe($Q1);
$s3->apply_unsafe($R1);
$s3->apply_unsafe($S1);
$s3->apply_unsafe($N2);
$s3->apply_unsafe($T1);
$s3->apply_unsafe($U1);
$s3->apply_unsafe($V1);
$s3->apply_unsafe($W1);
$s3->apply_unsafe($X1);
$s3->apply_unsafe($Y1);
$s3->apply_unsafe($L2);
$s3->apply_unsafe($Z1);
$s3->apply_unsafe($Y2);
$s3->apply_unsafe($c2);
$s3->apply_unsafe($t3);
$s3->apply_unsafe($t2);
$s3->apply_unsafe($e2);
$s3->apply_unsafe($u2);
$s3->apply_unsafe($f2);
$s3->apply_unsafe($g2);
$s3->apply_unsafe($h2);
$s3->apply_unsafe($i2);
$s3->apply_unsafe($j2);
$s3->apply_unsafe($k2);
$s3->apply_unsafe($l2);
$s3->apply_unsafe($m2);
$s3->apply_unsafe($n2);
$s3->apply_unsafe($o2);
$s3->apply_unsafe($p2);
$B3->apply_unsafe($Q1);
$B3->apply_unsafe($R1);
$B3->apply_unsafe($S1);
$B3->apply_unsafe($N2);
$B3->apply_unsafe($T1);
$B3->apply_unsafe($U1);
$B3->apply_unsafe($V1);
$B3->apply_unsafe($W1);
$B3->apply_unsafe($X1);
$B3->apply_unsafe($Y1);
$B3->apply_unsafe($Z1);
$B3->apply_unsafe($Y2);
$B3->apply_unsafe($c2);
$B3->apply_unsafe($C3);
$B3->apply_unsafe($t2);
$B3->apply_unsafe($e2);
$B3->apply_unsafe($u2);
$B3->apply_unsafe($f2);
$B3->apply_unsafe($g2);
$B3->apply_unsafe($h2);
$B3->apply_unsafe($i2);
$B3->apply_unsafe($j2);
$B3->apply_unsafe($k2);
$B3->apply_unsafe($l2);
$B3->apply_unsafe($m2);
$B3->apply_unsafe($n2);
$B3->apply_unsafe($o2);
$B3->apply_unsafe($p2);
$P3->apply_unsafe($Q1);
$P3->apply_unsafe($R1);
$P3->apply_unsafe($S1);
$P3->apply_unsafe($T1);
$P3->apply_unsafe($U1);
$P3->apply_unsafe($V1);
$P3->apply_unsafe($W1);
$P3->apply_unsafe($X1);
$P3->apply_unsafe($Y1);
$P3->apply_unsafe($Z1);
$P3->apply_unsafe($c2);
$P3->apply_unsafe($Q3);
$P3->apply_unsafe($t2);
$P3->apply_unsafe($e2);
$P3->apply_unsafe($u2);
$P3->apply_unsafe($f2);
$P3->apply_unsafe($g2);
$P3->apply_unsafe($h2);
$P3->apply_unsafe($i2);
$P3->apply_unsafe($j2);
$P3->apply_unsafe($k2);
$P3->apply_unsafe($l2);
$P3->apply_unsafe($m2);
$P3->apply_unsafe($n2);
$P3->apply_unsafe($o2);
$P3->apply_unsafe($p2);
$r4->apply_unsafe($Q1);
$r4->apply_unsafe($R1);
$r4->apply_unsafe($S3);
$r4->apply_unsafe($S1);
$r4->apply_unsafe($N2);
$r4->apply_unsafe($T1);
$r4->apply_unsafe($T3);
$r4->apply_unsafe($U1);
$r4->apply_unsafe($F);
$r4->apply_unsafe($V1);
$r4->apply_unsafe($u);
$r4->apply_unsafe($W1);
$r4->apply_unsafe($U3);
$r4->apply_unsafe($X1);
$r4->apply_unsafe($V3);
$r4->apply_unsafe($Y1);
$r4->apply_unsafe($L2);
$r4->apply_unsafe($Z1);
$r4->apply_unsafe($Y2);
$r4->apply_unsafe($c2);
$r4->apply_unsafe($W3);
$r4->apply_unsafe($s4);
$r4->apply_unsafe($t2);
$r4->apply_unsafe($e2);
$r4->apply_unsafe($u2);
$r4->apply_unsafe($f2);
$r4->apply_unsafe($Y3);
$r4->apply_unsafe($g2);
$r4->apply_unsafe($Z3);
$r4->apply_unsafe($h2);
$r4->apply_unsafe($c4);
$r4->apply_unsafe($i2);
$r4->apply_unsafe($d4);
$r4->apply_unsafe($j2);
$r4->apply_unsafe($e4);
$r4->apply_unsafe($k2);
$r4->apply_unsafe($f4);
$r4->apply_unsafe($l2);
$r4->apply_unsafe($g4);
$r4->apply_unsafe($m2);
$r4->apply_unsafe($h4);
$r4->apply_unsafe($n2);
$r4->apply_unsafe($i4);
$r4->apply_unsafe($o2);
$r4->apply_unsafe($j4);
$r4->apply_unsafe($p2);
$F4->apply_unsafe($Q1);
$F4->apply_unsafe($R1);
$F4->apply_unsafe($S3);
$F4->apply_unsafe($S1);
$F4->apply_unsafe($N2);
$F4->apply_unsafe($T1);
$F4->apply_unsafe($T3);
$F4->apply_unsafe($U1);
$F4->apply_unsafe($V1);
$F4->apply_unsafe($W1);
$F4->apply_unsafe($X1);
$F4->apply_unsafe($Y1);
$F4->apply_unsafe($L2);
$F4->apply_unsafe($Z1);
$F4->apply_unsafe($Y2);
$F4->apply_unsafe($c2);
$F4->apply_unsafe($G4);
$F4->apply_unsafe($t2);
$F4->apply_unsafe($e2);
$F4->apply_unsafe($u2);
$F4->apply_unsafe($f2);
$F4->apply_unsafe($g2);
$F4->apply_unsafe($h2);
$F4->apply_unsafe($i2);
$F4->apply_unsafe($j2);
$F4->apply_unsafe($k2);
$F4->apply_unsafe($l2);
$F4->apply_unsafe($m2);
$F4->apply_unsafe($n2);
$F4->apply_unsafe($o2);
$F4->apply_unsafe($p2);
$U4->apply_unsafe($Q1);
$U4->apply_unsafe($R1);
$U4->apply_unsafe($S1);
$U4->apply_unsafe($N2);
$U4->apply_unsafe($T1);
$U4->apply_unsafe($U1);
$U4->apply_unsafe($V1);
$U4->apply_unsafe($W1);
$U4->apply_unsafe($X1);
$U4->apply_unsafe($Y1);
$U4->apply_unsafe($Z1);
$U4->apply_unsafe($c2);
$U4->apply_unsafe($V4);
$U4->apply_unsafe($t2);
$U4->apply_unsafe($e2);
$U4->apply_unsafe($u2);
$U4->apply_unsafe($f2);
$U4->apply_unsafe($g2);
$U4->apply_unsafe($h2);
$U4->apply_unsafe($i2);
$U4->apply_unsafe($j2);
$U4->apply_unsafe($k2);
$U4->apply_unsafe($l2);
$U4->apply_unsafe($m2);
$U4->apply_unsafe($n2);
$U4->apply_unsafe($o2);
$U4->apply_unsafe($p2);
$i5->apply_unsafe($Q1);
$i5->apply_unsafe($R1);
$i5->apply_unsafe($S1);
$i5->apply_unsafe($N2);
$i5->apply_unsafe($T1);
$i5->apply_unsafe($U1);
$i5->apply_unsafe($V1);
$i5->apply_unsafe($W1);
$i5->apply_unsafe($X1);
$i5->apply_unsafe($Y1);
$i5->apply_unsafe($Z1);
$i5->apply_unsafe($c2);
$i5->apply_unsafe($j5);
$i5->apply_unsafe($t2);
$i5->apply_unsafe($e2);
$i5->apply_unsafe($u2);
$i5->apply_unsafe($f2);
$i5->apply_unsafe($g2);
$i5->apply_unsafe($h2);
$i5->apply_unsafe($i2);
$i5->apply_unsafe($j2);
$i5->apply_unsafe($k2);
$i5->apply_unsafe($l2);
$i5->apply_unsafe($m2);
$i5->apply_unsafe($n2);
$i5->apply_unsafe($o2);
$i5->apply_unsafe($p2);
$r5->apply_unsafe($Q1);
$r5->apply_unsafe($R1);
$r5->apply_unsafe($S1);
$r5->apply_unsafe($N2);
$r5->apply_unsafe($T1);
$r5->apply_unsafe($U1);
$r5->apply_unsafe($V1);
$r5->apply_unsafe($W1);
$r5->apply_unsafe($X1);
$r5->apply_unsafe($Y1);
$r5->apply_unsafe($Z1);
$r5->apply_unsafe($c2);
$r5->apply_unsafe($s5);
$r5->apply_unsafe($t2);
$r5->apply_unsafe($e2);
$r5->apply_unsafe($u2);
$r5->apply_unsafe($f2);
$r5->apply_unsafe($g2);
$r5->apply_unsafe($h2);
$r5->apply_unsafe($i2);
$r5->apply_unsafe($j2);
$r5->apply_unsafe($k2);
$r5->apply_unsafe($l2);
$r5->apply_unsafe($m2);
$r5->apply_unsafe($n2);
$r5->apply_unsafe($o2);
$r5->apply_unsafe($p2);
$A5->apply_unsafe($Q1);
$A5->apply_unsafe($R1);
$A5->apply_unsafe($S1);
$A5->apply_unsafe($N2);
$A5->apply_unsafe($T1);
$A5->apply_unsafe($U1);
$A5->apply_unsafe($V1);
$A5->apply_unsafe($W1);
$A5->apply_unsafe($X1);
$A5->apply_unsafe($Y1);
$A5->apply_unsafe($Z1);
$A5->apply_unsafe($c2);
$A5->apply_unsafe($B5);
$A5->apply_unsafe($t2);
$A5->apply_unsafe($e2);
$A5->apply_unsafe($u2);
$A5->apply_unsafe($f2);
$A5->apply_unsafe($g2);
$A5->apply_unsafe($h2);
$A5->apply_unsafe($i2);
$A5->apply_unsafe($j2);
$A5->apply_unsafe($k2);
$A5->apply_unsafe($l2);
$A5->apply_unsafe($m2);
$A5->apply_unsafe($n2);
$A5->apply_unsafe($o2);
$A5->apply_unsafe($p2);
$J5->apply_unsafe($Q1);
$J5->apply_unsafe($R1);
$J5->apply_unsafe($S1);
$J5->apply_unsafe($N2);
$J5->apply_unsafe($T1);
$J5->apply_unsafe($U1);
$J5->apply_unsafe($V1);
$J5->apply_unsafe($W1);
$J5->apply_unsafe($X1);
$J5->apply_unsafe($Y1);
$J5->apply_unsafe($Z1);
$J5->apply_unsafe($c2);
$J5->apply_unsafe($K5);
$J5->apply_unsafe($t2);
$J5->apply_unsafe($e2);
$J5->apply_unsafe($u2);
$J5->apply_unsafe($f2);
$J5->apply_unsafe($g2);
$J5->apply_unsafe($h2);
$J5->apply_unsafe($i2);
$J5->apply_unsafe($j2);
$J5->apply_unsafe($k2);
$J5->apply_unsafe($l2);
$J5->apply_unsafe($m2);
$J5->apply_unsafe($n2);
$J5->apply_unsafe($o2);
$J5->apply_unsafe($p2);
$d6->apply_unsafe($Q1);
$d6->apply_unsafe($R1);
$d6->apply_unsafe($S1);
$d6->apply_unsafe($T1);
$d6->apply_unsafe($U1);
$d6->apply_unsafe($V1);
$d6->apply_unsafe($u);
$d6->apply_unsafe($W1);
$d6->apply_unsafe($X1);
$d6->apply_unsafe($Y1);
$d6->apply_unsafe($L2);
$d6->apply_unsafe($Z1);
$d6->apply_unsafe($Y2);
$d6->apply_unsafe($c2);
$d6->apply_unsafe($e6);
$d6->apply_unsafe($t2);
$d6->apply_unsafe($e2);
$d6->apply_unsafe($f2);
$d6->apply_unsafe($g2);
$d6->apply_unsafe($h2);
$d6->apply_unsafe($i2);
$d6->apply_unsafe($j2);
$d6->apply_unsafe($k2);
$d6->apply_unsafe($l2);
$d6->apply_unsafe($m2);
$d6->apply_unsafe($n2);
$d6->apply_unsafe($o2);
$d6->apply_unsafe($p2);
$m6->apply_unsafe($Q1);
$m6->apply_unsafe($R1);
$m6->apply_unsafe($S1);
$m6->apply_unsafe($T1);
$m6->apply_unsafe($U1);
$m6->apply_unsafe($V1);
$m6->apply_unsafe($W1);
$m6->apply_unsafe($X1);
$m6->apply_unsafe($Y1);
$m6->apply_unsafe($Z1);
$m6->apply_unsafe($c2);
$m6->apply_unsafe($n6);
$m6->apply_unsafe($e2);
$m6->apply_unsafe($f2);
$m6->apply_unsafe($g2);
$m6->apply_unsafe($h2);
$m6->apply_unsafe($i2);
$m6->apply_unsafe($j2);
$m6->apply_unsafe($k2);
$m6->apply_unsafe($l2);
$m6->apply_unsafe($m2);
$m6->apply_unsafe($n2);
$m6->apply_unsafe($o2);
$m6->apply_unsafe($p2);
$Z6->apply_unsafe($N2);
$x7->apply_unsafe($T3);
$E7->apply_unsafe($T3);
$d8->apply_unsafe($F);
$k8->apply_unsafe($F);
$s8->apply_unsafe($F);
$C8->apply_unsafe($F);
$h9->apply_unsafe($u);
$w9->apply_unsafe($u);
$H9->apply_unsafe($u);
$Q9->apply_unsafe($u);
$qa->apply_unsafe($ra);
$Ca->apply_unsafe($U3);
$fc->apply_unsafe($U3);
$Sc->apply_unsafe($Tc);
$pd->apply_unsafe($V3);
$Cd->apply_unsafe($V3);
$de->apply_unsafe($V3);
$pe->apply_unsafe($V3);
$Gf->apply_unsafe($Tc);
$Yf->apply_unsafe($L2);
$hg->apply_unsafe($L2);
$pg->apply_unsafe($L2);
$Pg->apply_unsafe($ra);
$ch->apply_unsafe($Y2);
$jh->apply_unsafe($Y2);
$Fh->apply_unsafe($W3);
$Sh->apply_unsafe($W3);
$ci->apply_unsafe($W3);
$Si->apply_unsafe($Z3);
$Si->apply_unsafe($d4);
$Si->apply_unsafe($e4);
$Si->apply_unsafe($f4);
$Si->apply_unsafe($g4);
$Si->apply_unsafe($h4);
$Si->apply_unsafe($i4);
$Si->apply_unsafe($j4);
$dj->apply_unsafe($Z3);
$dj->apply_unsafe($d4);
$dj->apply_unsafe($e4);
$dj->apply_unsafe($f4);
$dj->apply_unsafe($g4);
$dj->apply_unsafe($h4);
$dj->apply_unsafe($i4);
$dj->apply_unsafe($j4);
$mj->apply_unsafe($Z3);
$mj->apply_unsafe($d4);
$mj->apply_unsafe($e4);
$mj->apply_unsafe($f4);
$mj->apply_unsafe($g4);
$mj->apply_unsafe($h4);
$mj->apply_unsafe($i4);
$mj->apply_unsafe($j4);
$vj->apply_unsafe($Z3);
$vj->apply_unsafe($d4);
$vj->apply_unsafe($e4);
$vj->apply_unsafe($f4);
$vj->apply_unsafe($g4);
$vj->apply_unsafe($h4);
$vj->apply_unsafe($i4);
$vj->apply_unsafe($j4);
$Gj->apply_unsafe($Z3);
$Pj->apply_unsafe($Z3);
$ik->apply_unsafe($h2);
$ik->apply_unsafe($j2);
$ik->apply_unsafe($k2);
$ik->apply_unsafe($l2);
$ik->apply_unsafe($m2);
$ik->apply_unsafe($n2);
$ik->apply_unsafe($o2);
$ik->apply_unsafe($p2);
$Bk->apply_unsafe($c4);
$Jk->apply_unsafe($c4);
$cl->apply_unsafe($c4);
$xl->apply_unsafe($c4);
$Gl->apply_unsafe($c4);
$Xl->apply_unsafe($c4);
$zm->apply_unsafe($d4);
$Hm->apply_unsafe($d4);
$Qm->apply_unsafe($d4);
$hn->apply_unsafe($d4);
$hn->apply_unsafe($e4);
$hn->apply_unsafe($f4);
$hn->apply_unsafe($h4);
$hn->apply_unsafe($i4);
$sn->apply_unsafe($d4);
$sn->apply_unsafe($e4);
$sn->apply_unsafe($f4);
$sn->apply_unsafe($h4);
$sn->apply_unsafe($i4);
$In->apply_unsafe($d4);
$no->apply_unsafe($e4);
$vo->apply_unsafe($e4);
$Do->apply_unsafe($e4);
$Qo->apply_unsafe($e4);
$qp->apply_unsafe($f4);
$yp->apply_unsafe($f4);
$Jp->apply_unsafe($f4);
$uq->apply_unsafe($h4);
$Fq->apply_unsafe($h4);
$Sq->apply_unsafe($h4);
$fr->apply_unsafe($h4);
$tr->apply_unsafe($h4);
$Vr->apply_unsafe($i4);
$fs->apply_unsafe($i4);
$os->apply_unsafe($i4);
$zs->apply_unsafe($i4);
$it->apply_unsafe($j4);
$qt->apply_unsafe($j4);
$Ft->apply_unsafe($j4);
$ni::self=$Pu;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($P)for@$w;
&$_($T)for@$w;
&$_($X)for@$H;
&$_($h1)for@$w;
&$_($l1)for@$H;
&$_($t1)for@$w;
&$_($x1)for@$H;
&$_($B1)for@$w;
&$_($F1)for@$w;
&$_($J1)for@$w;
&$_($N1)for@$H;
&$_($F2)for@$w;
&$_($I2)for@$w;
&$_($M2)for@$P2;
&$_($S2)for@$w;
&$_($U2)for@$w;
&$_($X2)for@$c3;
&$_($g3)for@$w;
&$_($j3)for@$l3;
&$_($p3)for@$w;
&$_($s3)for@$u3;
&$_($y3)for@$w;
&$_($B3)for@$D3;
&$_($F3)for@$G3;
&$_($J3)for@$w;
&$_($M3)for@$w;
&$_($P3)for@$R3;
&$_($o4)for@$w;
&$_($r4)for@$t4;
&$_($v4)for@$w4;
&$_($C4)for@$w;
&$_($F4)for@$H4;
&$_($J4)for@$K4;
&$_($R4)for@$w;
&$_($U4)for@$W4;
&$_($c5)for@$w;
&$_($f5)for@$w;
&$_($i5)for@$k5;
&$_($o5)for@$w;
&$_($r5)for@$t5;
&$_($x5)for@$w;
&$_($A5)for@$C5;
&$_($G5)for@$w;
&$_($J5)for@$L5;
&$_($N5)for@$O5;
&$_($Q5)for@$R5;
&$_($V5)for@$w;
&$_($Y5)for@$w;
&$_($d6)for@$f6;
&$_($j6)for@$w;
&$_($m6)for@$o6;
&$_($q6)for@$r6;
&$_($B6)for@$C6;
&$_($G6)for@$H6;
&$_($J6)for@$K6;
&$_($M6)for@$N6;
&$_($W6)for@$w;
&$_($Z6)for@$c7;
&$_($e7)for@$f7;
&$_($l7)for@$m7;
&$_($u7)for@$w;
&$_($x7)for@$y7;
&$_($B7)for@$w;
&$_($E7)for@$F7;
&$_($H7)for@$I7;
&$_($N7)for@$O7;
&$_($Y7)for@$w;
&$_($d8)for@$e8;
&$_($h8)for@$w;
&$_($k8)for@$l8;
&$_($p8)for@$w;
&$_($s8)for@$t8;
&$_($w8)for@$w;
&$_($z8)for@$w;
&$_($C8)for@$D8;
&$_($F8)for@$G8;
&$_($L8)for@$M8;
&$_($X8)for@$w;
&$_($c9)for@$w;
&$_($e9)for@$w;
&$_($h9)for@$i9;
&$_($m9)for@$w;
&$_($p9)for@$w;
&$_($t9)for@$w;
&$_($w9)for@$x9;
&$_($B9)for@$w;
&$_($E9)for@$w;
&$_($H9)for@$I9;
&$_($N9)for@$w;
&$_($Q9)for@$R9;
&$_($T9)for@$U9;
&$_($Z9)for@$ca;
&$_($na)for@$w;
&$_($qa)for@$sa;
&$_($za)for@$w;
&$_($Ca)for@$Da;
&$_($Ia)for@$w;
&$_($Ma)for@$w;
&$_($Qa)for@$w;
&$_($Ua)for@$w;
&$_($Ya)for@$w;
&$_($eb)for@$w;
&$_($ib)for@$w;
&$_($mb)for@$w;
&$_($qb)for@$w;
&$_($ub)for@$w;
&$_($yb)for@$w;
&$_($Cb)for@$w;
&$_($Gb)for@$w;
&$_($Kb)for@$w;
&$_($Ob)for@$w;
&$_($Sb)for@$w;
&$_($Wb)for@$w;
&$_($cc)for@$w;
&$_($fc)for@$gc;
&$_($ic)for@$jc;
&$_($oc)for@$pc;
&$_($zc)for@$w;
&$_($Dc)for@$w;
&$_($Hc)for@$w;
&$_($Lc)for@$w;
&$_($Pc)for@$w;
&$_($Sc)for@$Uc;
&$_($id)for@$w;
&$_($md)for@$w;
&$_($pd)for@$qd;
&$_($vd)for@$w;
&$_($zd)for@$w;
&$_($Cd)for@$Dd;
&$_($Id)for@$w;
&$_($Md)for@$w;
&$_($Qd)for@$w;
&$_($Ud)for@$w;
&$_($Yd)for@$w;
&$_($de)for@$ee;
&$_($ie)for@$w;
&$_($me)for@$w;
&$_($pe)for@$qe;
&$_($se)for@$te;
&$_($ye)for@$ze;
&$_($Je)for@$w;
&$_($Ne)for@$w;
&$_($Re)for@$w;
&$_($Ve)for@$w;
&$_($Ze)for@$w;
&$_($ff)for@$w;
&$_($jf)for@$w;
&$_($nf)for@$w;
&$_($rf)for@$w;
&$_($vf)for@$w;
&$_($zf)for@$w;
&$_($Df)for@$w;
&$_($Gf)for@$Hf;
&$_($Pf)for@$w;
&$_($Rf)for@$w;
&$_($Yf)for@$Zf;
&$_($eg)for@$w;
&$_($hg)for@$ig;
&$_($mg)for@$w;
&$_($pg)for@$qg;
&$_($sg)for@$tg;
&$_($zg)for@$Ag;
&$_($Hg)for@$w;
&$_($Mg)for@$w;
&$_($Pg)for@$Qg;
&$_($Xg)for@$w;
&$_($ch)for@$dh;
&$_($gh)for@$w;
&$_($jh)for@$kh;
&$_($mh)for@$nh;
&$_($th)for@$uh;
&$_($Ch)for@$w;
&$_($Fh)for@$Gh;
&$_($Lh)for@$w;
&$_($Ph)for@$w;
&$_($Sh)for@$Th;
&$_($Xh)for@$w;
&$_($ci)for@$di;
&$_($gi)for@$hi;
&$_($ni)for@$oi;
&$_($wi)for@$xi;
&$_($Ci)for@$Di;
&$_($Pi)for@$w;
&$_($Si)for@$Ti;
&$_($Yi)for@$w;
&$_($dj)for@$ej;
&$_($jj)for@$w;
&$_($mj)for@$nj;
&$_($sj)for@$w;
&$_($vj)for@$wj;
&$_($yj)for@$zj;
&$_($Dj)for@$w;
&$_($Gj)for@$Hj;
&$_($Mj)for@$w;
&$_($Pj)for@$Qj;
&$_($Sj)for@$Tj;
&$_($fk)for@$w;
&$_($ik)for@$jk;
&$_($lk)for@$mk;
&$_($ok)for@$pk;
&$_($yk)for@$w;
&$_($Bk)for@$Ck;
&$_($Gk)for@$w;
&$_($Jk)for@$Kk;
&$_($Pk)for@$w;
&$_($Tk)for@$w;
&$_($Xk)for@$w;
&$_($cl)for@$dl;
&$_($il)for@$w;
&$_($ml)for@$w;
&$_($ql)for@$w;
&$_($ul)for@$w;
&$_($xl)for@$yl;
&$_($Dl)for@$w;
&$_($Gl)for@$Hl;
&$_($Ml)for@$w;
&$_($Ql)for@$w;
&$_($Ul)for@$w;
&$_($Xl)for@$Yl;
&$_($cm)for@$dm;
&$_($im)for@$jm;
&$_($wm)for@$w;
&$_($zm)for@$Am;
&$_($Em)for@$w;
&$_($Hm)for@$Im;
&$_($Nm)for@$w;
&$_($Qm)for@$Rm;
&$_($Ym)for@$w;
&$_($en)for@$w;
&$_($hn)for@$in;
&$_($mn)for@$w;
&$_($pn)for@$w;
&$_($sn)for@$tn;
&$_($vn)for@$wn;
&$_($Bn)for@$w;
&$_($Fn)for@$w;
&$_($In)for@$Jn;
&$_($Ln)for@$Mn;
&$_($Rn)for@$Sn;
&$_($ho)for@$w;
&$_($ko)for@$w;
&$_($no)for@$oo;
&$_($so)for@$w;
&$_($vo)for@$wo;
&$_($Ao)for@$w;
&$_($Do)for@$Eo;
&$_($Jo)for@$w;
&$_($No)for@$w;
&$_($Qo)for@$Ro;
&$_($To)for@$Uo;
&$_($Zo)for@$cp;
&$_($np)for@$w;
&$_($qp)for@$rp;
&$_($vp)for@$w;
&$_($yp)for@$zp;
&$_($Dp)for@$w;
&$_($Gp)for@$w;
&$_($Jp)for@$Kp;
&$_($Mp)for@$Np;
&$_($Sp)for@$Tp;
&$_($nq)for@$w;
&$_($rq)for@$w;
&$_($uq)for@$vq;
&$_($zq)for@$w;
&$_($Cq)for@$w;
&$_($Fq)for@$Gq;
&$_($Lq)for@$w;
&$_($Pq)for@$w;
&$_($Sq)for@$Tq;
&$_($Xq)for@$w;
&$_($cr)for@$w;
&$_($fr)for@$gr;
&$_($kr)for@$w;
&$_($mr)for@$w;
&$_($or)for@$w;
&$_($qr)for@$w;
&$_($tr)for@$ur;
&$_($wr)for@$xr;
&$_($Cr)for@$Dr;
&$_($Pr)for@$w;
&$_($Sr)for@$w;
&$_($Vr)for@$Wr;
&$_($cs)for@$w;
&$_($fs)for@$gs;
&$_($ls)for@$w;
&$_($os)for@$ps;
&$_($ts)for@$w;
&$_($ws)for@$w;
&$_($zs)for@$As;
&$_($Cs)for@$Ds;
&$_($Is)for@$Js;
&$_($Vs)for@$w;
&$_($Zs)for@$w;
&$_($ft)for@$w;
&$_($it)for@$jt;
&$_($nt)for@$w;
&$_($qt)for@$rt;
&$_($vt)for@$w;
&$_($zt)for@$w;
&$_($Ct)for@$w;
&$_($Ft)for@$Gt;
&$_($It)for@$Jt;
&$_($Ot)for@$Pt;
&$_($Wt)for@$Xt;
&$_($tu)for@$uu;
&$_($wu)for@$Xt;
&$_($Bu)for@$w;
&$_($Fu)for@$w;
&$_($Ju)for@$w;
&$_($Nu)for@$w;
&$_($Pu)for@$Qu;
ni->run(@ARGV);
__DATA__
