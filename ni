#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q'named';
$d=q'ni.doc:/class';
$e=q'doc';
$f=q'synopsis';
$g=q'
    ni(\'ni:/object\')->child(\'/message\')
      ->add(\'/behaviorname.b\')          # add existing behavior
      ->def(\'/message_init.b\',          # define new slice behavior
        instantiate => fn q{            # called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       # return object to be blessed
        })
      ->def(\'/behaviorname.b\',          # define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! \'" . $$self{message} . "\'\\n";
        });
    ni(\'ni:/child\')->new(\'hello world!\')->method1;
  ';
$h=[$f,$g];
$i=q'description';
$j=q'ni:class is at the core of ni\'s object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you\'d expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.';
$k=[$i,$j];
$l=q'behaviors';
$m=q'ni\'s objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.';
$n=q'eg';
$o=q'annotations';
$p=[];
$q=q'code';
$r=q'my $fn = fn q{"hi"};
my $slice = ni(\'ni:/lib/slice\')->new(\'myslice\', f => $fn);
$slice->apply(\'foo\');
now foo->f == \'hi\';';
$s=q'proto';
$t=q'';
$u=q'lib/fn';
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q'lib/fn::ctors';
$x=q'TODO...';
$y=[$l,$m,$n,$v,$x];
$z=q'classes';
$A=q'ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni\'s classes are slice unions and as such don\'t
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn\'t in the picture,
      which makes multiple inheritance straightforward to implement.';
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q'name';
$E=q'/class';
$F=q'lib/doc';
$G=bless({$e,$C,$D,$E},$F);
$H=q'lib/doc::ctors';
$I=q'ni.doc:/lib/doc';
$J=q'
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...';
$K=[$f,$J];
$L=q'Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class\'s code without bringing along all of
      its documentation and unit tests.';
$M=q'Documentation objects are internally represented as arrays of quoted
      method calls:';
$N=[];
$O=q'my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];';
$P=bless({$o,$N,$q,$O,$s,$t},$u);
$Q=q'This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":';
$R=[];
$S=q'my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];';
$T=bless({$o,$R,$q,$S,$s,$t},$u);
$U=[$i,$L,$M,$n,$P,$Q,$n,$T];
$V=[$K,$U];
$W=q'/lib/doc';
$X=bless({$e,$V,$D,$W},$F);
$Y=q'ni.doc:/unix/cat';
$Z=q'
    my $combined = ni(\'ni:/unix/cat\')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  ';
$c1=[$f,$Z];
$d1=q'Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.';
$e1=[$i,$d1];
$f1=[];
$g1=q'my $cat = ni("str:foo") + ni("str:bar");
now $cat->read_all == "foo\\nbar\\n";';
$h1=bless({$o,$f1,$q,$g1,$s,$t},$u);
$i1=[$n,$h1];
$j1=[$c1,$e1,$i1];
$k1=q'/unix/cat';
$l1=bless({$e,$j1,$D,$k1},$F);
$m1=q'ni.doc:/unix/pid';
$n1=q'
    my $pid = ni::fork {something};
    my $pid = ni::fork_with(stdin => $mypipe, ..., sub {something});
    my $pid = ni::fork_exec("ls", "-l")';
$o1=[$f,$n1];
$p1=[];
$q1=q'my $pid = ni("sh:seq 4");
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];';
$r1=bless({$o,$p1,$q,$q1,$s,$t},$u);
$s1=[$n,$r1];
$t1=[];
$u1=q'my $pid = ni("sh:seq 10");
my $filter = ni::fork_with stdin => $pid->stdout, sub {exec \'egrep\', \'[13579]$\'};
my $data = $filter->read_all;
now [$pid->await, $filter->await, $data] == [0, 0, "1\\n3\\n5\\n7\\n9\\n"];';
$v1=bless({$o,$t1,$q,$u1,$s,$t},$u);
$w1=[$n,$v1];
$x1=[$o1,$s1,$w1];
$y1=q'/unix/pid';
$z1=bless({$e,$x1,$D,$y1},$F);
$A1=q'ni:/class';
$B1=q'applied_to';
$C1=q'class';
$D1=q'class.c';
$E1=q'lib/behavior.c';
$F1=q'lib/branch.c';
$G1=q'lib/dataslice.c';
$H1=q'lib/doc.c';
$I1=q'lib/fn.c';
$J1=q'lib/image.c';
$K1=q'lib/ni.c';
$L1=q'lib/slice.c';
$M1=q'lib/tag.c';
$N1=q'lib/test_value.c';
$O1=q'metaclass.c';
$P1=q'module.c';
$Q1=q'object.c';
$R1=q'unix/cat.c';
$S1=q'unix/fd.c';
$T1=q'unix/fifo.c';
$U1=q'unix/file.c';
$V1=q'unix/io.c';
$W1=q'unix/pid.c';
$X1=q'unix/pipeline.c';
$Y1=q'unix/str.c';
$Z1={$C1,1,$D1,1,$E1,1,$F1,1,$G1,1,$H1,1,$I1,1,$J1,1,$K1,1,$L1,1,$M1,1,$N1,1,$O1,1,$P1,1,$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1};
$c2=q'slices';
$d2=q'lib/test_value.c';
$e2=q'metaclass';
$f2=q'module';
$g2={$C1,1,$D1,1,$E1,1,$F1,1,$G1,1,$H1,1,$I1,1,$J1,1,$K1,1,$L1,1,$M1,1,$d2,1,$e2,1,$O1,1,$f2,1,$P1,1,$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1};
$h2=q'/module';
$i2=q'/lib/perlbranch.b';
$j2={};
$k2=q'ctor';
$l2=undef;
$m2=q'dtor';
$n2=q'methods';
$o2=q'add';
$p2=q'local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;';
$q2=bless({$q,$p2,$s,$t},$u);
$r2=q'apply';
$s2=q'local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;';
$t2=bless({$q,$s2,$s,$t},$u);
$u2={$o2,$q2,$r2,$t2};
$v2=q'/lib/branch.b';
$w2=q'lib/slice';
$x2=bless({$B1,$j2,$k2,$l2,$m2,$l2,$n2,$u2,$D,$v2},$w2);
$y2=q'lib/branch';
$z2=q'lib/test_value.c';
$A2=q'lib/slice::ctors';
$B2={};
$C2=q'my $s = shift; ni->def($s->name, $s)';
$D2=bless({$q,$C2,$s,$t},$u);
$E2=q'$_[0]->namespace . ":" . $_[0]->{name}';
$F2=bless({$q,$E2,$s,$t},$u);
$G2={$D,$F2};
$H2=q'/lib/named.b';
$I2=bless({$B1,$B2,$k2,$D2,$m2,$l2,$n2,$G2,$D,$H2},$w2);
$J2=q'lib/tag';
$K2=q'lib/test_value.c';
$L2=q'lib/slice::ctors';
$M2={};
$N2=q'namespace';
$O2=q'\'ni\'';
$P2=bless({$q,$O2,$s,$t},$u);
$Q2={$N2,$P2};
$R2=q'/lib/named_in_ni.b';
$S2=bless({$B1,$M2,$k2,$l2,$m2,$l2,$n2,$Q2,$D,$R2},$w2);
$T2=q'lib/test_value.c';
$U2=q'lib/slice::ctors';
$V2={};
$W2=q'package';
$X2=q'(my $name = shift->{name}) =~ s/^\\///; $name';
$Y2=bless({$q,$X2,$s,$t},$u);
$Z2={$W2,$Y2};
$c3=q'/lib/namespaced.b';
$d3=bless({$B1,$V2,$k2,$l2,$m2,$l2,$n2,$Z2,$D,$c3},$w2);
$e3=q'lib/test_value.c';
$f3=q'lib/slice::ctors';
$g3={};
$h3=q'resolve';
$i3=q'ref $_[1] ? $_[1] : ni"ni:$_[1]"';
$j3=bless({$q,$i3,$s,$t},$u);
$k3={$h3,$j3};
$l3=q'/lib/resolver.b';
$m3=bless({$B1,$g3,$k2,$l2,$m2,$l2,$n2,$k3,$D,$l3},$w2);
$n3=q'lib/test_value.c';
$o3=q'lib/slice::ctors';
$p3=[$x2,$I2,$S2,$d3,$m3];
$q3=bless({$D,$i2,$c2,$p3},$J2);
$r3=q'lib/tag::ctors';
$s3={};
$t3=q'my $s = shift; $s->apply($s->package)';
$u3=bless({$q,$t3,$s,$t},$u);
$v3=q'instantiate';
$w3=q'local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};';
$x3=bless({$q,$w3,$s,$t},$u);
$y3={$v3,$x3};
$z3=q'/lib/class_init.b';
$A3=bless({$B1,$s3,$k2,$u3,$m2,$l2,$n2,$y3,$D,$z3},$w2);
$B3=q'lib/test_value.c';
$C3=q'lib/slice::ctors';
$D3=q'lib/behavior';
$E3=q'lib/dataslice';
$F3=q'lib/image';
$G3=q'lib/ni';
$H3=q'lib/test_value';
$I3=q'lib/test_value.c';
$J3=q'object';
$K3=q'unix/cat';
$L3=q'unix/fd';
$M3=q'unix/fifo';
$N3=q'unix/file';
$O3=q'unix/io';
$P3=q'unix/pid';
$Q3=q'unix/pipeline';
$R3=q'unix/str';
$S3={$C1,1,$D1,1,$D3,1,$E1,1,$y2,1,$F1,1,$E3,1,$G1,1,$F,1,$H1,1,$u,1,$I1,1,$F3,1,$J1,1,$G3,1,$K1,1,$w2,1,$L1,1,$J2,1,$M1,1,$H3,1,$I3,1,$e2,1,$O1,1,$f2,1,$P1,1,$J3,1,$Q1,1,$K3,1,$R1,1,$L3,1,$S1,1,$M3,1,$T1,1,$N3,1,$U1,1,$O3,1,$V1,1,$P3,1,$W1,1,$Q3,1,$X1,1,$R3,1,$Y1,1};
$T3=q'/object';
$U3={};
$V3=q'ni \'ni:/\' . ref shift';
$W3=bless({$q,$V3,$s,$t},$u);
$X3={$C1,$W3};
$Y3=q'/lib/instance.b';
$Z3=bless({$B1,$U3,$k2,$l2,$m2,$l2,$n2,$X3,$D,$Y3},$w2);
$c4=q'lib/test_value.c';
$d4=q'lib/slice::ctors';
$e4=[$Z3];
$f4=bless({$B1,$S3,$D,$T3,$c2,$e4},$Q1);
$g4=q'object.c::ctors';
$h4=q'lib/test_value.c';
$i4={$C1,1,$D1,1,$D3,1,$E1,1,$y2,1,$F1,1,$E3,1,$G1,1,$H1,1,$I1,1,$J1,1,$K1,1,$w2,1,$L1,1,$J2,1,$M1,1,$h4,1,$e2,1,$O1,1,$f2,1,$P1,1,$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1};
$j4=q'/lib/behavior';
$k4={};
$l4=q'my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can(\'exists\') && ni->exists("ni.doc:$name");
ni(\'ni:/lib/doc\')->new($name);';
$m4=bless({$q,$l4,$s,$t},$u);
$n4={$e,$m4};
$o4=q'/lib/documentable.b';
$p4=bless({$B1,$k4,$k2,$l2,$m2,$l2,$n2,$n4,$D,$o4},$w2);
$q4=q'lib/test_value.c';
$r4=q'lib/slice::ctors';
$s4=[$f4,$p4];
$t4=bless({$B1,$i4,$D,$j4,$c2,$s4},$E1);
$u4=q'lib/behavior.c::ctors';
$v4=q'lib/test_value.c';
$w4={$C1,1,$D1,1,$E1,1,$y2,1,$F1,1,$G1,1,$H1,1,$I1,1,$J1,1,$K1,1,$L1,1,$M1,1,$v4,1,$e2,1,$O1,1,$f2,1,$P1,1,$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1};
$x4=q'/lib/definition.b';
$y4={};
$z4=q'def';
$A4=q'shift->add(ni(\'ni:/lib/slice\')->new(@_))';
$B4=bless({$q,$A4,$s,$t},$u);
$C4={$z4,$B4};
$D4=q'/lib/definition_def.b';
$E4=bless({$B1,$y4,$k2,$l2,$m2,$l2,$n2,$C4,$D,$D4},$w2);
$F4=q'lib/test_value.c';
$G4=q'lib/slice::ctors';
$H4={};
$I4=q'ro';
$J4=q'my ($self, $slice, @rs) = @_;
$self->add(ni(\'ni:/lib/slice\')->new(
  $slice,
  map +($_ => fn qq{shift->{\'$_\'}}), @rs));';
$K4=bless({$q,$J4,$s,$t},$u);
$L4=q'rw';
$M4=q'my ($self, $slice, @as) = @_;
$self->add(ni(\'ni:/lib/slice\')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{\'$_\'} = \\$_[1] : shift->{\'$_\'}}), @as));';
$N4=bless({$q,$M4,$s,$t},$u);
$O4={$I4,$K4,$L4,$N4};
$P4=q'/lib/accessor.b';
$Q4=bless({$B1,$H4,$k2,$l2,$m2,$l2,$n2,$O4,$D,$P4},$w2);
$R4=q'lib/test_value.c';
$S4=q'lib/slice::ctors';
$T4={};
$U4=q'(""';
$V4=q'shift->name';
$W4=bless({$q,$V4,$s,$t},$u);
$X4={$U4,$W4};
$Y4=q'/lib/name_as_string.b';
$Z4=bless({$B1,$T4,$k2,$l2,$m2,$l2,$n2,$X4,$D,$Y4},$w2);
$c5=q'lib/test_value.c';
$d5=q'lib/slice::ctors';
$e5={};
$f5=q'(eq';
$g5=q'ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);';
$h5=bless({$q,$g5,$s,$t},$u);
$i5={$f5,$h5};
$j5=q'/lib/ref_eq.b';
$k5=bless({$B1,$e5,$k2,$l2,$m2,$l2,$n2,$i5,$D,$j5},$w2);
$l5=q'lib/test_value.c';
$m5=q'lib/slice::ctors';
$n5={};
$o5=q'defdata';
$p5=q'shift->add(ni(\'ni:/lib/dataslice\')->new(@_))';
$q5=bless({$q,$p5,$s,$t},$u);
$r5={$o5,$q5};
$s5=q'/lib/definition_defdata.b';
$t5=bless({$B1,$n5,$k2,$l2,$m2,$l2,$n2,$r5,$D,$s5},$w2);
$u5=q'lib/test_value.c';
$v5=q'lib/slice::ctors';
$w5=[$E4,$Q4,$Z4,$k5,$t5];
$x5=bless({$B1,$w4,$D,$x4,$c2,$w5},$y2);
$y5=q'lib/branch::ctors';
$z5=[$q3,$A3,$f4,$t4,$x5];
$A5=bless({$B1,$g2,$D,$h2,$c2,$z5},$P1);
$B5=q'module.c::ctors';
$C5={};
$D5=q'DESTROY';
$E5=q'local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};';
$F5=bless({$q,$E5,$s,$t},$u);
$G5=q'new';
$H5=q'local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;';
$I5=bless({$q,$H5,$s,$t},$u);
$J5={$D5,$F5,$G5,$I5};
$K5=q'/lib/instantiable.b';
$L5=bless({$B1,$C5,$n2,$J5,$D,$K5},$w2);
$M5=q'lib/test_value.c';
$N5=q'lib/slice::ctors';
$O5={};
$P5=q'child';
$Q5=q'my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);';
$R5=bless({$q,$Q5,$s,$t},$u);
$S5={$P5,$R5};
$T5=q'/lib/subclass.b';
$U5=bless({$B1,$O5,$k2,$l2,$m2,$l2,$n2,$S5,$D,$T5},$w2);
$V5=q'lib/test_value.c';
$W5=q'lib/slice::ctors';
$X5=[$A5,$L5,$A3,$A5,$U5];
$Y5=bless({$B1,$Z1,$D,$E,$c2,$X5},$D1);
$Z5=q'class.c::ctors';
$c6=q'ni:/class.c';
$d6={$D1,1};
$e6=q'/class.c';
$f6={$D1,1,$P1,1};
$g6=q'/module.c';
$h6=q'lib/test_value.c';
$i6={$D1,1,$E1,1,$F1,1,$G1,1,$H1,1,$I1,1,$J1,1,$K1,1,$L1,1,$M1,1,$h6,1,$P1,1,$Q1,1,$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1};
$j6=q'/object.c';
$k6=[$Y5];
$l6=bless({$B1,$i6,$D,$j6,$c2,$k6},$e2);
$m6=q'metaclass::ctors';
$n6={$D1,1,$E1,1,$F1,1,$G1,1,$L1,1,$M1,1,$P1,1};
$o6=q'/lib/behavior.c';
$p6=[$l6];
$q6=bless({$B1,$n6,$D,$o6,$c2,$p6},$e2);
$r6=q'metaclass::ctors';
$s6=[$l6,$L5,$q6];
$t6=bless({$B1,$f6,$D,$g6,$c2,$s6},$e2);
$u6=q'metaclass::ctors';
$v6=[$t6];
$w6=bless({$B1,$d6,$D,$e6,$c2,$v6},$e2);
$x6=q'metaclass::ctors';
$y6=q'ni:/lib/accessor.b';
$z6=q'ni:/lib/behavior';
$A6=q'ni:/lib/behavior.c';
$B6=q'ni:/lib/branch';
$C6={$y2,1};
$D6=q'/lib/branch';
$E6={};
$F6=q'local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};';
$G6=bless({$q,$F6,$s,$t},$u);
$H6={$v3,$G6};
$I6=q'/lib/branch_init.b';
$J6=bless({$B1,$E6,$k2,$l2,$m2,$l2,$n2,$H6,$D,$I6},$w2);
$K6=q'lib/slice::ctors';
$L6=[$t4,$I2,$x2,$J6,$x5];
$M6=bless({$B1,$C6,$D,$D6,$c2,$L6},$F1);
$N6=q'lib/branch.c::ctors';
$O6=q'ni:/lib/branch.b';
$P6=q'ni:/lib/branch.c';
$Q6={$F1,1};
$R6=q'/lib/branch.c';
$S6=[$q6];
$T6=bless({$B1,$Q6,$D,$R6,$c2,$S6},$e2);
$U6=q'metaclass::ctors';
$V6=q'ni:/lib/branch_init.b';
$W6=q'ni:/lib/class_init.b';
$X6=q'ni:/lib/dataslice';
$Y6={$E3,1};
$Z6=q'/lib/dataslice';
$c7={};
$d7=q'my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};';
$e7=bless({$q,$d7,$s,$t},$u);
$f7={$v3,$e7};
$g7=q'/lib/dataslice_init.b';
$h7=bless({$B1,$c7,$k2,$l2,$m2,$l2,$n2,$f7,$D,$g7},$w2);
$i7=q'lib/slice::ctors';
$j7={};
$k7=q'local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;';
$l7=bless({$q,$k7,$s,$t},$u);
$m7={$r2,$l7};
$n7=q'/lib/dataslice_apply.b';
$o7=bless({$B1,$j7,$k2,$l2,$m2,$l2,$n2,$m7,$D,$n7},$w2);
$p7=q'lib/slice::ctors';
$q7=[$t4,$h7,$o7];
$r7=bless({$B1,$Y6,$D,$Z6,$c2,$q7},$G1);
$s7=q'lib/dataslice.c::ctors';
$t7=q'ni:/lib/dataslice.c';
$u7={$G1,1};
$v7=q'/lib/dataslice.c';
$w7=[$q6];
$x7=bless({$B1,$u7,$D,$v7,$c2,$w7},$e2);
$y7=q'metaclass::ctors';
$z7=q'ni:/lib/dataslice_apply.b';
$A7=q'ni:/lib/dataslice_init.b';
$B7=q'ni:/lib/definition.b';
$C7=q'ni:/lib/definition_def.b';
$D7=q'ni:/lib/definition_defdata.b';
$E7=q'ni:/lib/doc';
$F7={$F,1};
$G7={};
$H7=q'shift; +{name => shift, doc => []}';
$I7=bless({$q,$H7,$s,$t},$u);
$J7={$v3,$I7};
$K7=q'/lib/doc_init.b';
$L7=bless({$B1,$G7,$k2,$l2,$m2,$l2,$n2,$J7,$D,$K7},$w2);
$M7=q'lib/slice::ctors';
$N7={};
$O7=q'\'ni.doc\'';
$P7=bless({$q,$O7,$s,$t},$u);
$Q7={$N2,$P7};
$R7=q'/lib/doc_namespace.b';
$S7=bless({$B1,$N7,$k2,$l2,$m2,$l2,$n2,$Q7,$D,$R7},$w2);
$T7=q'lib/slice::ctors';
$U7={};
$V7=q'AUTOLOAD';
$W7=q'my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;';
$X7=bless({$q,$W7,$s,$t},$u);
$Y7={$V7,$X7};
$Z7=q'/lib/doc_define.b';
$c8=bless({$B1,$U7,$k2,$l2,$m2,$l2,$n2,$Y7,$D,$Z7},$w2);
$d8=q'lib/slice::ctors';
$e8={};
$f8=q'my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;';
$g8=bless({$q,$f8,$s,$t},$u);
$h8=q'tests';
$i8=q'my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq \'eg\';
}
@tests;';
$j8=bless({$q,$i8,$s,$t},$u);
$k8={$n,$g8,$h8,$j8};
$l8=q'/lib/doc_test.b';
$m8=bless({$B1,$e8,$k2,$l2,$m2,$l2,$n2,$k8,$D,$l8},$w2);
$n8=q'lib/slice::ctors';
$o8=[$f4,$I2,$L7,$S7,$c8,$m8];
$p8=bless({$B1,$F7,$D,$W,$c2,$o8},$H1);
$q8=q'lib/doc.c::ctors';
$r8=q'ni:/lib/doc.c';
$s8={$H1,1};
$t8=q'/lib/doc.c';
$u8=[$l6];
$v8=bless({$B1,$s8,$D,$t8,$c2,$u8},$e2);
$w8=q'metaclass::ctors';
$x8=q'ni:/lib/doc_define.b';
$y8=q'ni:/lib/doc_init.b';
$z8=q'ni:/lib/doc_namespace.b';
$A8=q'ni:/lib/doc_test.b';
$B8=q'ni:/lib/documentable.b';
$C8=q'ni:/lib/fn';
$D8={$u,1};
$E8=q'/lib/fn';
$F8={};
$G8=q'shift->compile';
$H8=bless({$q,$G8,$s,$t},$u);
$I8=q'compile';
$J8=q'local $@;
my $self = shift;
$$self{proto} ||= \'\';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};';
$K8=bless({$q,$J8,$s,$t},$u);
$L8=q'my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : \'\';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};';
$M8=bless({$q,$L8,$s,$t},$u);
$N8={$I8,$K8,$v3,$M8};
$O8=q'/lib/fn_init.b';
$P8=bless({$B1,$F8,$k2,$H8,$m2,$l2,$n2,$N8,$D,$O8},$w2);
$Q8=q'lib/slice::ctors';
$R8={};
$S8=[];
$T8=q'shift->{\'annotations\'}';
$U8=bless({$o,$S8,$q,$T8,$s,$t},$u);
$V8=[];
$W8=q'shift->{\'code\'}';
$X8=bless({$o,$V8,$q,$W8,$s,$t},$u);
$Y8=q'fn';
$Z8=[];
$c9=q'shift->{\'fn\'}';
$d9=bless({$o,$Z8,$q,$c9,$s,$t},$u);
$e9={$o,$U8,$q,$X8,$Y8,$d9};
$f9=q'/lib/fn_ro.b';
$g9=bless({$B1,$R8,$k2,$l2,$m2,$l2,$n2,$e9,$D,$f9},$w2);
$h9=q'lib/slice::ctors';
$i9={};
$j9=[];
$k9=q'shift->{code}';
$l9=bless({$o,$j9,$q,$k9,$s,$t},$u);
$m9=[];
$n9=q'ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])';
$o9=bless({$o,$m9,$q,$n9,$s,$t},$u);
$p9={$U4,$l9,$f5,$o9};
$q9=q'/lib/fn_ops.b';
$r9=bless({$B1,$i9,$k2,$l2,$m2,$l2,$n2,$p9,$D,$q9},$w2);
$s9=q'lib/slice::ctors';
$t9={};
$u9=q'serialize';
$v9=[];
$w9=q'local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = \' \' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);';
$x9=bless({$o,$v9,$q,$w9,$s,$t},$u);
$y9={$u9,$x9};
$z9=q'/lib/fn_serialize.b';
$A9=bless({$B1,$t9,$k2,$l2,$m2,$l2,$n2,$y9,$D,$z9},$w2);
$B9=q'lib/slice::ctors';
$C9=[$f4,$L5,$P8,$g9,$r9,$A9];
$D9=bless({$B1,$D8,$D,$E8,$c2,$C9},$I1);
$E9=q'lib/fn.c::ctors';
$F9=q'ni:/lib/fn.c';
$G9={$I1,1};
$H9=q'/lib/fn.c';
$I9=[$l6];
$J9=bless({$B1,$G9,$D,$H9,$c2,$I9},$e2);
$K9=q'metaclass::ctors';
$L9=q'ni:/lib/fn_init.b';
$M9=q'ni:/lib/fn_ops.b';
$N9=q'ni:/lib/fn_ro.b';
$O9=q'ni:/lib/fn_serialize.b';
$P9=q'ni:/lib/global_static_test.b';
$Q9={};
$R9=q'now';
$S9=[];
$T9=q'ni(\'ni:/lib/test_value\')->new(shift)';
$U9=q'($)';
$V9=bless({$o,$S9,$q,$T9,$s,$U9},$u);
$W9={$R9,$V9};
$X9=q'/lib/global_static_test.b';
$Y9=bless({$B1,$Q9,$k2,$l2,$m2,$l2,$n2,$W9,$D,$X9},$w2);
$Z9=q'main';
$ca=q'lib/slice::ctors';
$da=q'ni:/lib/image';
$ea={$F3,1};
$fa=q'/lib/image';
$ga={};
$ha=[];
$ia=q'my $class = shift;
my %args  = (
  include_shebang => 1,
  include_license => 1,
  include_boot    => 1,
  include_classes => 1,
  include_run     => 1,
  local_vars      => 0,
  use_newlines    => 0,
  @_);

+{include_shebang => $args{include_shebang},
  include_license => $args{include_license},
  include_boot    => $args{include_boot},
  include_classes => $args{include_classes},
  include_run     => $args{include_run},
  local_vars      => $args{local_vars},
  use_newlines    => $args{use_newlines},

  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};';
$ja=bless({$o,$ha,$q,$ia,$s,$t},$u);
$ka={$v3,$ja};
$la=q'/lib/image_init.b';
$ma=bless({$B1,$ga,$k2,$l2,$m2,$l2,$n2,$ka,$D,$la},$w2);
$na=q'lib/slice::ctors';
$oa={};
$pa=q'address';
$qa=[];
$ra=q'return \'undef\' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 16;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);';
$sa=bless({$o,$qa,$q,$ra,$s,$t},$u);
$ta=q'allocate_gensym';
$ua=[];
$va=q'my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;';
$wa=bless({$o,$ua,$q,$va,$s,$t},$u);
$xa=q'boot_side_effect';
$ya=[];
$za=q'unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]';
$Aa=bless({$o,$ya,$q,$za,$s,$t},$u);
$Ba=q'circular_links';
$Ca=[];
$Da=q'local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};';
$Ea=bless({$o,$Ca,$q,$Da,$s,$t},$u);
$Fa=q'finalizer';
$Ga=[];
$Ha=q'push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]';
$Ia=bless({$o,$Ga,$q,$Ha,$s,$t},$u);
$Ja=q'gensym';
$Ka=[];
$La=q'my $n = shift->{gensym_n}++;
my $s = \'$\' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;';
$Ma=bless({$o,$Ka,$q,$La,$s,$t},$u);
$Na=q'is_circular';
$Oa=[];
$Pa=q'my $self = shift;
ref $$self{visited}{$self->address($_[0])};';
$Qa=bless({$o,$Oa,$q,$Pa,$s,$t},$u);
$Ra=q'quote';
$Sa=[];
$Ta=q'my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? \'undef\' : $v if defined $v;
$$self{visited}{$a} = \\\'undef\';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));';
$Ua=bless({$o,$Sa,$q,$Ta,$s,$t},$u);
$Va=q'quote_array';
$Wa=[];
$Xa=q'local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_])
  && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
for 0..$#{$v};
\'[\' . join(\',\', map $self->quote($_), @$v) . \']\';';
$Ya=bless({$o,$Wa,$q,$Xa,$s,$t},$u);
$Za=q'quote_blessed';
$cb=[];
$db=q'my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq \'HASH\' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";';
$eb=bless({$o,$cb,$q,$db,$s,$t},$u);
$fb=q'quote_class';
$gb=[];
$hb=q'my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");';
$ib=bless({$o,$gb,$q,$hb,$s,$t},$u);
$jb=q'quote_hash';
$kb=[];
$lb=q'local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  push @{$$self{circular}}, [$a, "{" . $self->quote($k) . "}",
                                 $self->address($$v{$k})]
  if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
\'{\' . join(",", @qs) . \'}\';';
$mb=bless({$o,$kb,$q,$lb,$s,$t},$u);
$nb=q'quote_object';
$ob=[];
$pb=q'my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can(\'serialize\') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;';
$qb=bless({$o,$ob,$q,$pb,$s,$t},$u);
$rb=q'quote_scalar';
$sb=[];
$tb=q'my $v = $_[1];
return \'undef\' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\'])/\\\\$1/g;
"q\'$v\'";';
$ub=bless({$o,$sb,$q,$tb,$s,$t},$u);
$vb=q'quote_value';
$wb=[];
$xb=q'my $self = shift;
return $self->quote_scalar($_[0]) unless ref $_[0];
return $self->quote_array($_[0])  if \'ARRAY\' eq ref $_[0];
return $self->quote_hash($_[0])   if \'HASH\'  eq ref $_[0];
die "cannot serialize $_[0]"      if \'CODE\'  eq ref $_[0];
$self->quote_object($_[0]);';
$yb=bless({$o,$wb,$q,$xb,$s,$t},$u);
$zb=q'reconstruction';
$Ab=[];
$Bb=q'my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});';
$Cb=bless({$o,$Ab,$q,$Bb,$s,$t},$u);
$Db=q'side_effect';
$Eb=[];
$Fb=q'push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]';
$Gb=bless({$o,$Eb,$q,$Fb,$s,$t},$u);
$Hb=q'write';
$Ib=[];
$Jb=q'local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  ($$self{include_shebang} ? ("#!/usr/bin/env perl\\n") : ()),
  ($$self{include_license} ? ("chomp(\\$ni::license=<<\'_\');\\n", $ni::license, "\\n_\\n") : ()),
  ($$self{include_boot}    ? ("BEGIN{eval(\\$ni::boot=<<\'_\')}\\n", $ni::boot, "\\n_\\n") : ()),
  ($$self{use_newlines}    ? map("$_\\n", $self->reconstruction) : $self->reconstruction),
  ($$self{include_run}     ? ("ni->run(\\@ARGV);", "\\n__DATA__\\n") : ());';
$Kb=bless({$o,$Ib,$q,$Jb,$s,$t},$u);
$Lb={$pa,$sa,$ta,$wa,$xa,$Aa,$Ba,$Ea,$Fa,$Ia,$Ja,$Ma,$Na,$Qa,$Ra,$Ua,$Va,$Ya,$Za,$eb,$fb,$ib,$jb,$mb,$nb,$qb,$rb,$ub,$vb,$yb,$zb,$Cb,$Db,$Gb,$Hb,$Kb};
$Mb=q'/lib/image_quoting.b';
$Nb=bless({$B1,$oa,$k2,$l2,$m2,$l2,$n2,$Lb,$D,$Mb},$w2);
$Ob=q'lib/slice::ctors';
$Pb=[$f4,$ma,$Nb];
$Qb=bless({$B1,$ea,$D,$fa,$c2,$Pb},$J1);
$Rb=q'lib/image.c::ctors';
$Sb=q'ni:/lib/image.c';
$Tb={$J1,1};
$Ub=q'/lib/image.c';
$Vb=[$l6];
$Wb=bless({$B1,$Tb,$D,$Ub,$c2,$Vb},$e2);
$Xb=q'metaclass::ctors';
$Yb=q'ni:/lib/image_init.b';
$Zb=q'ni:/lib/image_quoting.b';
$cc=q'ni:/lib/instance.b';
$dc=q'ni:/lib/instantiable.b';
$ec=q'ni:/lib/json.b';
$fc={};
$gc=q'json_decode';
$hc=[];
$ic=q'local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];';
$jc=bless({$o,$hc,$q,$ic,$s,$U9},$u);
$kc=q'json_encode';
$lc=[];
$mc=q'local $_;
my ($v) = @_;
return "[" . join(\',\', map ni::json_encode($_), @$v) . "]" if \'ARRAY\' eq ref $v;
return "{" . join(\',\', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if \'HASH\' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : \'null\';';
$nc=bless({$o,$lc,$q,$mc,$s,$U9},$u);
$oc=q'json_escape';
$pc=[];
$qc=q'(my $x = $_[0]) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . $ni::json_escapes{$1}/eg;
"\\"$x\\"";';
$rc=bless({$o,$pc,$q,$qc,$s,$U9},$u);
$sc=q'json_unescape';
$tc=[];
$uc=q'my $x = substr $_[0], 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;';
$vc=bless({$o,$tc,$q,$uc,$s,$U9},$u);
$wc=q'json_unescape_one';
$xc=[];
$yc=q'$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1';
$zc=bless({$o,$xc,$q,$yc,$s,$U9},$u);
$Ac={$gc,$jc,$kc,$nc,$oc,$rc,$sc,$vc,$wc,$zc};
$Bc=q'/lib/json.b';
$Cc=bless({$B1,$fc,$k2,$l2,$m2,$l2,$n2,$Ac,$D,$Bc},$w2);
$Dc=q'ni';
$Ec=q'lib/slice::ctors';
$Fc=q'ni:/lib/name_as_string.b';
$Gc=q'ni:/lib/named.b';
$Hc=q'ni:/lib/named_in_ni.b';
$Ic=q'ni:/lib/namespaced.b';
$Jc=q'ni:/lib/ni';
$Kc={$G3,1};
$Lc=q'/lib/ni';
$Mc={};
$Nc=q'is_mutable';
$Oc=[];
$Pc=q'$0 ne "-" && -w $0';
$Qc=bless({$o,$Oc,$q,$Pc,$s,$t},$u);
$Rc=q'modify';
$Sc=[];
$Tc=q'my ($self, $fn) = @_;
# TODO: replace all of this with a generalized "atomic-update" function
# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join \'/\', @r;
open my $w, \'>\', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";';
$Uc=bless({$o,$Sc,$q,$Tc,$s,$t},$u);
$Vc={$Nc,$Qc,$Rc,$Uc};
$Wc=q'/lib/ni_self.b';
$Xc=bless({$B1,$Mc,$k2,$l2,$m2,$l2,$n2,$Vc,$D,$Wc},$w2);
$Yc=q'lib/slice::ctors';
$Zc={};
$cd=q'exists';
$dd=[];
$ed=q'exists $_[0]->{named}{$_[1]}';
$fd=bless({$o,$dd,$q,$ed,$s,$t},$u);
$gd=q'quoted';
$hd=[];
$id=q'my $self = shift;
my $q = ni(\'ni:/lib/image\')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;';
$jd=bless({$o,$hd,$q,$id,$s,$t},$u);
$kd={$cd,$fd,$gd,$jd};
$ld=q'/lib/ni_image.b';
$md=bless({$B1,$Zc,$k2,$l2,$m2,$l2,$n2,$kd,$D,$ld},$w2);
$nd=q'lib/slice::ctors';
$od={};
$pd=q'--internal/+=';
$qd=[];
$rd=q'my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
  die "ni: failed to run $_: $!" unless $r;
}
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;';
$sd=bless({$o,$qd,$q,$rd,$s,$t},$u);
$td=q'--internal/eval';
$ud=[];
$vd=q'my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;';
$wd=bless({$o,$ud,$q,$vd,$s,$t},$u);
$xd=q'--internal/image';
$yd=[];
$zd=q'shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;';
$Ad=bless({$o,$yd,$q,$zd,$s,$t},$u);
$Bd=q'--internal/test';
$Cd=[];
$Dd=q'my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL: $@ in $t\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL: $r\\n";
  }
}
my $passed = @tests - $fails;
print "$passed test(s) passed\\n";
!!$fails;';
$Ed=bless({$o,$Cd,$q,$Dd,$s,$t},$u);
$Fd=q'run';
$Gd=[];
$Hd=q'my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);';
$Id=bless({$o,$Gd,$q,$Hd,$s,$t},$u);
$Jd={$pd,$sd,$td,$wd,$xd,$Ad,$Bd,$Ed,$Fd,$Id};
$Kd=q'/lib/ni_main.b';
$Ld=bless({$B1,$od,$k2,$l2,$m2,$l2,$n2,$Jd,$D,$Kd},$w2);
$Md=q'lib/slice::ctors';
$Nd={};
$Od=[];
$Pd=q'my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";';
$Qd=bless({$o,$Od,$q,$Pd,$s,$t},$u);
$Rd=q'resolver_for';
$Sd=[];
$Td=q'my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;';
$Ud=bless({$o,$Sd,$q,$Td,$s,$t},$u);
$Vd={$h3,$Qd,$Rd,$Ud};
$Wd=q'/lib/ni_resolver.b';
$Xd=bless({$B1,$Nd,$k2,$l2,$m2,$l2,$n2,$Vd,$D,$Wd},$w2);
$Yd=q'lib/slice::ctors';
$Zd=[$f4,$Xc,$md,$Ld,$Xd];
$ce=bless({$B1,$Kc,$D,$Lc,$c2,$Zd},$K1);
$de=q'lib/ni.c::ctors';
$ee=q'ni:/lib/ni.c';
$fe={$K1,1};
$ge=q'/lib/ni.c';
$he=[$l6];
$ie=bless({$B1,$fe,$D,$ge,$c2,$he},$e2);
$je=q'metaclass::ctors';
$ke=q'ni:/lib/ni_fork.b';
$le={};
$me=q'fork';
$ne=[];
$oe=q'ni::fork_with(shift)';
$pe=q'(&)';
$qe=bless({$o,$ne,$q,$oe,$s,$pe},$u);
$re=q'fork_with';
$se=[];
$te=q'my $fn     = pop;
my %pipes  = @_;
my $stdin  = $pipes{stdin}  || ni(\'ni:unix/fifo\')->new;
my $stdout = $pipes{stdout} || ni(\'ni:unix/fifo\')->new;
my $stderr = $pipes{stderr} || ni(\'ni:unix/fifo\')->new;
my $pid    = fork;
die "/lib/ni_fork.b: failed to fork: $!" unless defined $pid;

return ni(\'ni:/unix/pid\')->new($pid,
  exists $pipes{stdin}  ? undef : $stdin->write_side,
  exists $pipes{stdout} ? undef : $stdout->read_side,
  exists $pipes{stderr} ? undef : $stderr->read_side) if $pid;

exists $pipes{stdin}  ? $stdin->be_stdin   : $stdin->read_side->be_stdin;
exists $pipes{stdout} ? $stdout->be_stdout : $stdout->write_side->be_stdout;
exists $pipes{stderr} ? $stderr->be_stderr : $stderr->write_side->be_stderr;
exit &$fn($stdin, $stdout, $stderr);';
$ue=bless({$o,$se,$q,$te,$s,$t},$u);
$ve={$me,$qe,$re,$ue};
$we=q'/lib/ni_fork.b';
$xe=bless({$B1,$le,$k2,$l2,$m2,$l2,$n2,$ve,$D,$we},$w2);
$ye=q'lib/slice::ctors';
$ze=q'ni:/lib/ni_fork_exec.b';
$Ae={};
$Be=q'fork_exec';
$Ce=[];
$De=q'my @argv = @_;
ni::fork {exec @argv or die "ni:/unix/pid.c: failed to exec @argv: $!"};';
$Ee=bless({$o,$Ce,$q,$De,$s,$t},$u);
$Fe={$Be,$Ee};
$Ge=q'/lib/ni_fork_exec.b';
$He=bless({$B1,$Ae,$k2,$l2,$m2,$l2,$n2,$Fe,$D,$Ge},$w2);
$Ie=q'lib/slice::ctors';
$Je=q'ni:/lib/ni_image.b';
$Ke=q'ni:/lib/ni_main.b';
$Le=q'ni:/lib/ni_resolver.b';
$Me=q'ni:/lib/ni_self.b';
$Ne=q'ni:/lib/ni_static_util.b';
$Oe={};
$Pe=q'abbrev';
$Qe=[];
$Re=q'length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . \'...\'';
$Se=bless({$o,$Qe,$q,$Re,$s,$t},$u);
$Te=q'dor';
$Ue=[];
$Ve=q'defined $_[0] ? $_[0] : $_[1]';
$We=bless({$o,$Ue,$q,$Ve,$s,$t},$u);
$Xe=q'indent';
$Ye=[];
$Ze=q'my ($s, $indent) = (@_, 2);
join "\\n", map \' \' x $indent . $_, split /\\n/, $s;';
$cf=bless({$o,$Ye,$q,$Ze,$s,$t},$u);
$df=q'max';
$ef=[];
$ff=q'local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m';
$gf=bless({$o,$ef,$q,$ff,$s,$t},$u);
$hf=q'maxstr';
$if=[];
$jf=q'local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m';
$kf=bless({$o,$if,$q,$jf,$s,$t},$u);
$lf=q'mean';
$mf=[];
$nf=q'sum(@_) / (@_ || 1)';
$of=bless({$o,$mf,$q,$nf,$s,$t},$u);
$pf=q'min';
$qf=[];
$rf=q'local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m';
$sf=bless({$o,$qf,$q,$rf,$s,$t},$u);
$tf=q'minstr';
$uf=[];
$vf=q'local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m';
$wf=bless({$o,$uf,$q,$vf,$s,$t},$u);
$xf=q'sgr';
$yf=[];
$zf=q'(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x';
$Af=bless({$o,$yf,$q,$zf,$s,$t},$u);
$Bf=q'sr';
$Cf=[];
$Df=q'(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x';
$Ef=bless({$o,$Cf,$q,$Df,$s,$t},$u);
$Ff=q'sum';
$Gf=[];
$Hf=q'local $_; my $x = 0; $x += $_ for @_; $x';
$If=bless({$o,$Gf,$q,$Hf,$s,$t},$u);
$Jf=q'swap';
$Kf=[];
$Lf=q'@_[0, 1] = @_[1, 0]';
$Mf=bless({$o,$Kf,$q,$Lf,$s,$t},$u);
$Nf={$Pe,$Se,$Te,$We,$Xe,$cf,$df,$gf,$hf,$kf,$lf,$of,$pf,$sf,$tf,$wf,$xf,$Af,$Bf,$Ef,$Ff,$If,$Jf,$Mf};
$Of=q'/lib/ni_static_util.b';
$Pf=bless({$B1,$Oe,$k2,$l2,$m2,$l2,$n2,$Nf,$D,$Of},$w2);
$Qf=q'lib/slice::ctors';
$Rf=q'ni:/lib/perlbranch.b';
$Sf=q'ni:/lib/ref_eq.b';
$Tf=q'ni:/lib/resolver.b';
$Uf=q'ni:/lib/slice';
$Vf={$w2,1};
$Wf=q'/lib/slice';
$Xf=q'local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply(\'$p\'): perl packages don\'t start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);';
$Yf=bless({$q,$Xf,$s,$t},$u);
$Zf=q'local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;';
$cg=bless({$q,$Zf,$s,$t},$u);
$dg=q'lib/slice::apply';
$eg=q'lib/slice::apply_unsafe';
$fg={};
$gg=q'apply_unsafe';
$hg={$r2,$Yf,$gg,$cg};
$ig=q'/lib/slice.b';
$jg=bless({$B1,$fg,$n2,$hg,$D,$ig},$w2);
$kg=q'lib/slice::ctors';
$lg={};
$mg=q'my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};';
$ng=bless({$q,$mg,$s,$t},$u);
$og={$v3,$ng};
$pg=q'/lib/slice_init.b';
$qg=bless({$B1,$lg,$n2,$og,$D,$pg},$w2);
$rg=q'lib/slice::ctors';
$sg={};
$tg=[];
$ug=q'local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq \'ni:/lib/slice.b\') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      \'*\' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;';
$vg=bless({$o,$tg,$q,$ug,$s,$t},$u);
$wg={$u9,$vg};
$xg=q'/lib/slice_serialize.b';
$yg=bless({$B1,$sg,$k2,$l2,$m2,$l2,$n2,$wg,$D,$xg},$w2);
$zg=q'lib/slice::ctors';
$Ag=[$t4,$I2,$jg,$qg,$yg];
$Bg=bless({$B1,$Vf,$D,$Wf,$c2,$Ag},$L1);
$Cg=q'lib/slice.c::ctors';
$Dg=q'ni:/lib/slice.b';
$Eg=q'ni:/lib/slice.c';
$Fg={$L1,1};
$Gg=q'/lib/slice.c';
$Hg=[$q6];
$Ig=bless({$B1,$Fg,$D,$Gg,$c2,$Hg},$e2);
$Jg=q'metaclass::ctors';
$Kg=q'ni:/lib/slice_init.b';
$Lg=q'ni:/lib/slice_serialize.b';
$Mg=q'ni:/lib/static_fn.b';
$Ng={};
$Og=[];
$Pg=q'ni(\'ni:/lib/fn\')->new(@_)';
$Qg=bless({$o,$Og,$q,$Pg,$s,$U9},$u);
$Rg=q'fp';
$Sg=[];
$Tg=q'ni(\'ni:/lib/fn\')->new(@_)';
$Ug=q'($$)';
$Vg=bless({$o,$Sg,$q,$Tg,$s,$Ug},$u);
$Wg={$Y8,$Qg,$Rg,$Vg};
$Xg=q'/lib/static_fn.b';
$Yg=bless({$B1,$Ng,$k2,$l2,$m2,$l2,$n2,$Wg,$D,$Xg},$w2);
$Zg=q'lib/slice::ctors';
$ch=q'ni:/lib/subclass.b';
$dh=q'ni:/lib/tag';
$eh={$J2,1};
$fh=q'/lib/tag';
$gh={};
$hh=q'local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;';
$ih=bless({$q,$hh,$s,$t},$u);
$jh={$r2,$ih};
$kh=q'/lib/tag.b';
$lh=bless({$B1,$gh,$k2,$l2,$m2,$l2,$n2,$jh,$D,$kh},$w2);
$mh=q'lib/slice::ctors';
$nh={};
$oh=q'local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};';
$ph=bless({$q,$oh,$s,$t},$u);
$qh={$v3,$ph};
$rh=q'/lib/tag_init.b';
$sh=bless({$B1,$nh,$k2,$l2,$m2,$l2,$n2,$qh,$D,$rh},$w2);
$th=q'lib/slice::ctors';
$uh=[$t4,$I2,$lh,$sh];
$vh=bless({$B1,$eh,$D,$fh,$c2,$uh},$M1);
$wh=q'lib/tag.c::ctors';
$xh=q'ni:/lib/tag.b';
$yh=q'ni:/lib/tag.c';
$zh={$M1,1};
$Ah=q'/lib/tag.c';
$Bh=[$q6];
$Ch=bless({$B1,$zh,$D,$Ah,$c2,$Bh},$e2);
$Dh=q'metaclass::ctors';
$Eh=q'ni:/lib/tag_init.b';
$Fh=q'ni:/lib/test_value';
$Gh={$H3,1};
$Hh=q'/lib/test_value';
$Ih={};
$Jh=[];
$Kh=q'\\$_[1]';
$Lh=bless({$o,$Jh,$q,$Kh,$s,$t},$u);
$Mh={$v3,$Lh};
$Nh=q'/lib/test_value_init.b';
$Oh=bless({$B1,$Ih,$k2,$l2,$m2,$l2,$n2,$Mh,$D,$Nh},$w2);
$Ph=q'lib/slice::ctors';
$Qh={};
$Rh=q'(==';
$Sh=[];
$Th=q'my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;';
$Uh=bless({$o,$Sh,$q,$Th,$s,$t},$u);
$Vh=q'diff';
$Wh=[];
$Xh=q'my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq \'HASH\') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq \'ARRAY\') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq \'SCALAR\') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;';
$Yh=bless({$o,$Wh,$q,$Xh,$s,$t},$u);
$Zh={$Rh,$Uh,$Vh,$Yh};
$ci=q'/lib/test_value_eq.b';
$di=bless({$B1,$Qh,$k2,$l2,$m2,$l2,$n2,$Zh,$D,$ci},$w2);
$ei=q'lib/slice::ctors';
$fi={};
$gi=[];
$hi=q'ni::json_encode ${$_[0]}';
$ii=bless({$o,$gi,$q,$hi,$s,$t},$u);
$ji={$U4,$ii};
$ki=q'/lib/test_value_str.b';
$li=bless({$B1,$fi,$k2,$l2,$m2,$l2,$n2,$ji,$D,$ki},$w2);
$mi=q'lib/slice::ctors';
$ni=[$f4,$Oh,$di,$li];
$oi=q'lib/test_value.c';
$pi=bless({$B1,$Gh,$D,$Hh,$c2,$ni},$oi);
$qi=q'lib/test_value.c::ctors';
$ri=q'ni:/lib/test_value.c';
$si=q'lib/test_value.c';
$ti={$si,1};
$ui=q'/lib/test_value.c';
$vi=[$l6];
$wi=bless({$B1,$ti,$D,$ui,$c2,$vi},$e2);
$xi=q'metaclass::ctors';
$yi=q'ni:/lib/test_value_eq.b';
$zi=q'ni:/lib/test_value_init.b';
$Ai=q'ni:/lib/test_value_str.b';
$Bi=q'ni:/metaclass';
$Ci={$e2,1};
$Di=q'/metaclass';
$Ei=[$q3,$L5,$A3,$A5];
$Fi=bless({$B1,$Ci,$D,$Di,$c2,$Ei},$O1);
$Gi=q'metaclass.c::ctors';
$Hi=q'ni:/metaclass.c';
$Ii={$O1,1};
$Ji=q'/metaclass.c';
$Ki=[$Y5];
$Li=bless({$B1,$Ii,$D,$Ji,$c2,$Ki},$e2);
$Mi=q'metaclass::ctors';
$Ni=q'ni:/module';
$Oi=q'ni:/module.c';
$Pi=q'ni:/object';
$Qi=q'ni:/object.c';
$Ri=q'ni:/unix/cat';
$Si={$K3,1};
$Ti={$K3,1,$L3,1,$M3,1,$N3,1,$O3,1,$P3,1,$Q3,1,$R3,1};
$Ui=q'/unix/io';
$Vi={};
$Wi=q'into';
$Xi=[];
$Yi=q'local $_;
my ($self, $dest, $each) = @_;
my $block_size = $self->can(\'read_size\') ? $self->read_size : 8192;
while ($self->read($_, $block_size)) {
  &$each($_) if defined $each;
  $dest->write($_);
}';
$Zi=bless({$o,$Xi,$q,$Yi,$s,$t},$u);
$cj={$Wi,$Zi};
$dj=q'/unix/io_stream.b';
$ej=bless({$B1,$Vi,$k2,$l2,$m2,$l2,$n2,$cj,$D,$dj},$w2);
$fj=q'lib/slice::ctors';
$gj={};
$hj=q'(+';
$ij=[];
$jj=q'ni(\'ni:/unix/cat\')->new(@_[0, 1])';
$kj=bless({$o,$ij,$q,$jj,$s,$t},$u);
$lj={$hj,$kj};
$mj=q'/unix/io_constructors.b';
$nj=bless({$B1,$gj,$k2,$l2,$m2,$l2,$n2,$lj,$D,$mj},$w2);
$oj=q'lib/slice::ctors';
$pj={};
$qj=q'read_all';
$rj=[];
$sj=q'shift->into(ni("ni:/unix/str")->new(my $data = ""));
$data;';
$tj=bless({$o,$rj,$q,$sj,$s,$t},$u);
$uj={$qj,$tj};
$vj=q'/unix/io_memory.b';
$wj=bless({$B1,$pj,$k2,$l2,$m2,$l2,$n2,$uj,$D,$vj},$w2);
$xj=q'lib/slice::ctors';
$yj={};
$zj=q'(<>';
$Aj=[];
$Bj=q'my $fh = shift->read_fh;
# TODO: buffered line reading with a pushback queue';
$Cj=bless({$o,$Aj,$q,$Bj,$s,$t},$u);
$Dj=q'(@{}';
$Ej=[];
$Fj=q'my $self = shift; [<$self>]';
$Gj=bless({$o,$Ej,$q,$Fj,$s,$t},$u);
$Hj={$zj,$Cj,$Dj,$Gj};
$Ij=q'/unix/io_readers.b';
$Jj=bless({$B1,$yj,$k2,$l2,$m2,$l2,$n2,$Hj,$D,$Ij},$w2);
$Kj=q'lib/slice::ctors';
$Lj=[$f4,$ej,$nj,$wj,$Jj];
$Mj=bless({$B1,$Ti,$D,$Ui,$c2,$Lj},$V1);
$Nj=q'unix/io.c::ctors';
$Oj={};
$Pj=[];
$Qj=q'shift; +{fs => [@_]}';
$Rj=bless({$o,$Pj,$q,$Qj,$s,$t},$u);
$Sj={$v3,$Rj};
$Tj=q'/unix/cat_init.b';
$Uj=bless({$B1,$Oj,$k2,$l2,$m2,$l2,$n2,$Sj,$D,$Tj},$w2);
$Vj=q'lib/slice::ctors';
$Wj={};
$Xj=q'read';
$Yj=[];
$Zj=q'my $fs = shift->{fs};
my $n;
shift @$fs until !@$fs or $n = $$fs[0]->read(@_);
return $n;';
$ck=bless({$o,$Yj,$q,$Zj,$s,$t},$u);
$dk={$Xj,$ck};
$ek=q'/unix/cat_read.b';
$fk=bless({$B1,$Wj,$k2,$l2,$m2,$l2,$n2,$dk,$D,$ek},$w2);
$gk=q'lib/slice::ctors';
$hk=[$Mj,$Uj,$fk];
$ik=bless({$B1,$Si,$D,$k1,$c2,$hk},$R1);
$jk=q'unix/cat.c::ctors';
$kk=q'ni:/unix/cat.c';
$lk={$R1,1};
$mk=q'/unix/cat.c';
$nk={$R1,1,$S1,1,$T1,1,$U1,1,$V1,1,$W1,1,$X1,1,$Y1,1};
$ok=q'/unix/io.c';
$pk=[$l6];
$qk=bless({$B1,$nk,$D,$ok,$c2,$pk},$e2);
$rk=q'metaclass::ctors';
$sk=[$qk];
$tk=bless({$B1,$lk,$D,$mk,$c2,$sk},$e2);
$uk=q'metaclass::ctors';
$vk=q'ni:/unix/cat_init.b';
$wk=q'ni:/unix/cat_read.b';
$xk=q'ni:/unix/fd';
$yk={$L3,1};
$zk=q'/unix/fd';
$Ak={};
$Bk=q'fd';
$Ck=[];
$Dk=q'shift->{\'fd\'}';
$Ek=bless({$o,$Ck,$q,$Dk,$s,$t},$u);
$Fk={$Bk,$Ek};
$Gk=q'/unix/fd_readers.b';
$Hk=bless({$B1,$Ak,$k2,$l2,$m2,$l2,$n2,$Fk,$D,$Gk},$w2);
$Ik=q'lib/slice::ctors';
$Jk={};
$Kk=[];
$Lk=q'my ($class, $fd) = @_;
+{fd => $fd, fh => undef};';
$Mk=bless({$o,$Kk,$q,$Lk,$s,$t},$u);
$Nk={$v3,$Mk};
$Ok=q'/unix/fd_init.b';
$Pk=bless({$B1,$Jk,$k2,$l2,$m2,$l2,$n2,$Nk,$D,$Ok},$w2);
$Qk=q'lib/slice::ctors';
$Rk={};
$Sk=q'be';
$Tk=[];
$Uk=q'use POSIX qw/dup2/;
my ($self, $new) = @_;
return $self if $new == $$self{fd};
close $$self{fh} if Scalar::Util::openhandle $$self{fh};
dup2 $$self{fd}, $new or die "ni:/unix/fd: dup2($$self{fd}, $new): $!";
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;';
$Vk=bless({$o,$Tk,$q,$Uk,$s,$t},$u);
$Wk={$Sk,$Vk};
$Xk=q'/unix/fd_shell.b';
$Yk=bless({$B1,$Rk,$k2,$l2,$m2,$l2,$n2,$Wk,$D,$Xk},$w2);
$Zk=q'lib/slice::ctors';
$cl={$L3,1,$M3,1,$N3,1,$P3,1,$Q3,1};
$dl=q'/unix/has_fd.b';
$el={};
$fl=q'be_stderr';
$gl=[];
$hl=q'ni("ni:unix/fd")->new(fileno shift->write_fh)->move_to(2)';
$il=bless({$o,$gl,$q,$hl,$s,$t},$u);
$jl=q'be_stdin';
$kl=[];
$ll=q'ni("ni:unix/fd")->new(fileno shift->read_fh)->move_to(0)';
$ml=bless({$o,$kl,$q,$ll,$s,$t},$u);
$nl=q'be_stdout';
$ol=[];
$pl=q'ni("ni:unix/fd")->new(fileno shift->write_fh)->move_to(1)';
$ql=bless({$o,$ol,$q,$pl,$s,$t},$u);
$rl={$fl,$il,$jl,$ml,$nl,$ql};
$sl=q'/unix/fd_stdio.b';
$tl=bless({$B1,$el,$k2,$l2,$m2,$l2,$n2,$rl,$D,$sl},$w2);
$ul=q'lib/slice::ctors';
$vl={};
$wl=[];
$xl=q'no warnings \'io\';
use Errno qw/EINTR/;
my $fh = shift->read_fh;
my $n;
do {
  return $n if defined($n = read $fh, $_[0], $_[1], $_[2] || 0);
} while $!{EINTR};
return undef;';
$yl=bless({$o,$wl,$q,$xl,$s,$t},$u);
$zl=[];
$Al=q'my $fh = shift->write_fh;
my $n;
do {
  return $n if defined($n = syswrite $fh, $_[0]);
} while $!{EINTR};
return undef;';
$Bl=bless({$o,$zl,$q,$Al,$s,$t},$u);
$Cl={$Xj,$yl,$Hb,$Bl};
$Dl=q'/unix/fd_safeio.b';
$El=bless({$B1,$vl,$k2,$l2,$m2,$l2,$n2,$Cl,$D,$Dl},$w2);
$Fl=q'lib/slice::ctors';
$Gl=[$tl,$El];
$Hl=bless({$B1,$cl,$D,$dl,$c2,$Gl},$y2);
$Il=q'lib/branch::ctors';
$Jl={};
$Kl=q'read_fh';
$Ll=[];
$Ml=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'<&=\', $self->{fd}
  or die "ni:/unix/fd $self->{fd} failed to read: $!";
$self->{fh} = $fh;';
$Nl=bless({$o,$Ll,$q,$Ml,$s,$t},$u);
$Ol=q'write_fh';
$Pl=[];
$Ql=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'>&=\', $self->{fd}
  or die "ni:/unix/file $self->{fd} failed to write: $!";
$self->{fh} = $fh;';
$Rl=bless({$o,$Pl,$q,$Ql,$s,$t},$u);
$Sl={$Kl,$Nl,$Ol,$Rl};
$Tl=q'/unix/fd_io.b';
$Ul=bless({$B1,$Jl,$k2,$l2,$m2,$l2,$n2,$Sl,$D,$Tl},$w2);
$Vl=q'lib/slice::ctors';
$Wl=[$Mj,$Hk,$Pk,$Yk,$Hl,$Ul];
$Xl=bless({$B1,$yk,$D,$zk,$c2,$Wl},$S1);
$Yl=q'unix/fd.c::ctors';
$Zl=q'ni:/unix/fd.c';
$cm={$S1,1};
$dm=q'/unix/fd.c';
$em=[$qk];
$fm=bless({$B1,$cm,$D,$dm,$c2,$em},$e2);
$gm=q'metaclass::ctors';
$hm=q'ni:/unix/fd_init.b';
$im=q'ni:/unix/fd_io.b';
$jm=q'ni:/unix/fd_readers.b';
$km=q'ni:/unix/fd_safeio.b';
$lm=q'ni:/unix/fd_shell.b';
$mm=q'ni:/unix/fd_stdio.b';
$nm=q'ni:/unix/fifo';
$om={$M3,1};
$pm=q'/unix/fifo';
$qm={};
$rm=[];
$sm=q'shift->{\'read_fh\'}';
$tm=bless({$o,$rm,$q,$sm,$s,$t},$u);
$um=[];
$vm=q'shift->{\'write_fh\'}';
$wm=bless({$o,$um,$q,$vm,$s,$t},$u);
$xm={$Kl,$tm,$Ol,$wm};
$ym=q'/unix/fifo_io.b';
$zm=bless({$B1,$qm,$k2,$l2,$m2,$l2,$n2,$xm,$D,$ym},$w2);
$Am=q'lib/slice::ctors';
$Bm={};
$Cm=[];
$Dm=q'my ($class) = @_;
pipe my ($r, $w) or die "ni:/unix/fifo failed: $!";
+{read_fh => $r, write_fh => $w};';
$Em=bless({$o,$Cm,$q,$Dm,$s,$t},$u);
$Fm={$v3,$Em};
$Gm=q'/unix/fifo_init.b';
$Hm=bless({$B1,$Bm,$k2,$l2,$m2,$l2,$n2,$Fm,$D,$Gm},$w2);
$Im=q'lib/slice::ctors';
$Jm={};
$Km=q'r';
$Lm=[];
$Mm=q'my $self = shift;
close $$self{write_fh};
ni("ni:/unix/fd")->new(fileno $$self{read_fh});';
$Nm=bless({$o,$Lm,$q,$Mm,$s,$t},$u);
$Om=q'w';
$Pm=[];
$Qm=q'my $self = shift;
close $$self{read_fh};
ni("ni:/unix/fd")->new(fileno $$self{write_fh});';
$Rm=bless({$o,$Pm,$q,$Qm,$s,$t},$u);
$Sm={$Km,$Nm,$Om,$Rm};
$Tm=q'/unix/fifo_direction.b';
$Um=bless({$B1,$Jm,$k2,$l2,$m2,$l2,$n2,$Sm,$D,$Tm},$w2);
$Vm=q'lib/slice::ctors';
$Wm=[$Mj,$zm,$Hm,$Hl,$Um];
$Xm=bless({$B1,$om,$D,$pm,$c2,$Wm},$T1);
$Ym=q'unix/fifo.c::ctors';
$Zm=q'ni:/unix/fifo.c';
$cn={$T1,1};
$dn=q'/unix/fifo.c';
$en=[$qk];
$fn=bless({$B1,$cn,$D,$dn,$c2,$en},$e2);
$gn=q'metaclass::ctors';
$hn=q'ni:/unix/fifo_direction.b';
$in=q'ni:/unix/fifo_init.b';
$jn=q'ni:/unix/fifo_io.b';
$kn=q'ni:/unix/file';
$ln={$N3,1};
$mn=q'/unix/file';
$nn={};
$on=[];
$pn=q'shift->{\'name\'}';
$qn=bless({$o,$on,$q,$pn,$s,$t},$u);
$rn={$D,$qn};
$sn=q'/unix/file_readers.b';
$tn=bless({$B1,$nn,$k2,$l2,$m2,$l2,$n2,$rn,$D,$sn},$w2);
$un=q'lib/slice::ctors';
$vn={};
$wn=[];
$xn=q'my ($class, $name) = @_;
+{name => $name, fh => undef};';
$yn=bless({$o,$wn,$q,$xn,$s,$t},$u);
$zn={$v3,$yn};
$An=q'/unix/file_init.b';
$Bn=bless({$B1,$vn,$k2,$l2,$m2,$l2,$n2,$zn,$D,$An},$w2);
$Cn=q'lib/slice::ctors';
$Dn={};
$En=[];
$Fn=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'<\', $self->{name}
  or die "ni:/unix/file $self->{name} failed to read: $!";
$self->{fh} = $fh;';
$Gn=bless({$o,$En,$q,$Fn,$s,$t},$u);
$Hn=[];
$In=q'my $self = shift;
return $self->{fh} if Scalar::Util::openhandle $self->{fh};
open my $fh, \'>\', $self->{name}
  or die "ni:/unix/file $self->{name} failed to write: $!";
$self->{fh} = $fh;';
$Jn=bless({$o,$Hn,$q,$In,$s,$t},$u);
$Kn={$Kl,$Gn,$Ol,$Jn};
$Ln=q'/unix/file_io.b';
$Mn=bless({$B1,$Dn,$k2,$l2,$m2,$l2,$n2,$Kn,$D,$Ln},$w2);
$Nn=q'lib/slice::ctors';
$On=[$Mj,$tn,$Bn,$Hl,$Mn];
$Pn=bless({$B1,$ln,$D,$mn,$c2,$On},$U1);
$Qn=q'unix/file.c::ctors';
$Rn=q'ni:/unix/file.c';
$Sn={$U1,1};
$Tn=q'/unix/file.c';
$Un=[$qk];
$Vn=bless({$B1,$Sn,$D,$Tn,$c2,$Un},$e2);
$Wn=q'metaclass::ctors';
$Xn=q'ni:/unix/file_init.b';
$Yn=q'ni:/unix/file_io.b';
$Zn=q'ni:/unix/file_readers.b';
$co=q'ni:/unix/has_fd.b';
$do=q'ni:/unix/io';
$eo=q'ni:/unix/io.c';
$fo=q'ni:/unix/io_constructors.b';
$go=q'ni:/unix/io_memory.b';
$ho=q'ni:/unix/io_readers.b';
$io=q'ni:/unix/io_stream.b';
$jo=q'ni:/unix/pid';
$ko={$P3,1};
$lo={};
$mo=q'pid';
$no=[];
$oo=q'shift->{\'pid\'}';
$po=bless({$o,$no,$q,$oo,$s,$t},$u);
$qo=q'status';
$ro=[];
$so=q'shift->{\'status\'}';
$to=bless({$o,$ro,$q,$so,$s,$t},$u);
$uo=q'stderr';
$vo=[];
$wo=q'shift->{\'stderr\'}';
$xo=bless({$o,$vo,$q,$wo,$s,$t},$u);
$yo=q'stdin';
$zo=[];
$Ao=q'shift->{\'stdin\'}';
$Bo=bless({$o,$zo,$q,$Ao,$s,$t},$u);
$Co=q'stdout';
$Do=[];
$Eo=q'shift->{\'stdout\'}';
$Fo=bless({$o,$Do,$q,$Eo,$s,$t},$u);
$Go={$mo,$po,$qo,$to,$uo,$xo,$yo,$Bo,$Co,$Fo};
$Ho=q'/unix/pid_readers.b';
$Io=bless({$B1,$lo,$k2,$l2,$m2,$l2,$n2,$Go,$D,$Ho},$w2);
$Jo=q'lib/slice::ctors';
$Ko={};
$Lo=[];
$Mo=q'shift->await';
$No=bless({$o,$Lo,$q,$Mo,$s,$t},$u);
$Oo=[];
$Po=q'my ($class, $pid, $i, $o, $e) = @_;
+{pid    => $pid,
  stdin  => $i,
  stdout => $o,
  stderr => $e,
  status => undef};';
$Qo=bless({$o,$Oo,$q,$Po,$s,$t},$u);
$Ro={$v3,$Qo};
$So=q'/unix/pid_init.b';
$To=bless({$B1,$Ko,$k2,$l2,$m2,$No,$n2,$Ro,$D,$So},$w2);
$Uo=q'lib/slice::ctors';
$Vo={};
$Wo=q'await';
$Xo=[];
$Yo=q'my $self = shift;
return $$self{status} if defined $$self{status};
defined(waitpid $$self{pid}, 0)
  ? $$self{status} = $?
  : die "unix/pid_wait.b: waitpid: $!";';
$Zo=bless({$o,$Xo,$q,$Yo,$s,$t},$u);
$cp=q'running';
$dp=[];
$ep=q'not defined $_[0]->{status} and kill 0, $_[0]->{pid}';
$fp=bless({$o,$dp,$q,$ep,$s,$t},$u);
$gp={$Wo,$Zo,$cp,$fp};
$hp=q'/unix/pid_wait.b';
$ip=bless({$B1,$Vo,$k2,$l2,$m2,$l2,$n2,$gp,$D,$hp},$w2);
$jp=q'lib/slice::ctors';
$kp={};
$lp=[];
$mp=q'shift->{stdout}->read_fh';
$np=bless({$o,$lp,$q,$mp,$s,$t},$u);
$op=[];
$pp=q'shift->{stdin}->write_fh';
$qp=bless({$o,$op,$q,$pp,$s,$t},$u);
$rp={$Kl,$np,$Ol,$qp};
$sp=q'/unix/pid_io.b';
$tp=bless({$B1,$kp,$k2,$l2,$m2,$l2,$n2,$rp,$D,$sp},$w2);
$up=q'lib/slice::ctors';
$vp=[$Mj,$Io,$To,$ip,$Hl,$tp];
$wp=bless({$B1,$ko,$D,$y1,$c2,$vp},$W1);
$xp=q'unix/pid.c::ctors';
$yp=q'ni:/unix/pid.c';
$zp={$W1,1};
$Ap=q'/unix/pid.c';
$Bp=[$qk];
$Cp=bless({$B1,$zp,$D,$Ap,$c2,$Bp},$e2);
$Dp=q'metaclass::ctors';
$Ep=q'ni:/unix/pid_init.b';
$Fp=q'ni:/unix/pid_io.b';
$Gp=q'ni:/unix/pid_readers.b';
$Hp=q'ni:/unix/pid_wait.b';
$Ip=q'ni:/unix/pipeline';
$Jp={$Q3,1};
$Kp=q'/unix/pipeline';
$Lp={};
$Mp=[];
$Np=q'shift->{\'stdin\'}';
$Op=bless({$o,$Mp,$q,$Np,$s,$t},$u);
$Pp=[];
$Qp=q'shift->{\'stdout\'}';
$Rp=bless({$o,$Pp,$q,$Qp,$s,$t},$u);
$Sp={$yo,$Op,$Co,$Rp};
$Tp=q'/unix/pipeline_ro.b';
$Up=bless({$B1,$Lp,$k2,$l2,$m2,$l2,$n2,$Sp,$D,$Tp},$w2);
$Vp=q'lib/slice::ctors';
$Wp={};
$Xp=[];
$Yp=q'my $class  = shift;
my $stdin  = ni(\'ni:/unix/fifo\')->new;
my $stdout = ni(\'ni:/unix/fifo\')->new;
# TODO: stderr and multiplexing, which probably happens here

my @rs = ($stdin, @_);
my @ws = (@_, $stdout);
my $rv; vec($rv, fileno $_->read_fh,  1) = 1 for @rs;
my $wv; vec($wv, fileno $_->write_fh, 1) = 1 for @ws;

+{ps     => [@_],
  stdin  => $stdin,
  stdout => $stdout,
  rs => \\@rs, rv => $rv,
  ws => \\@ws, wv => $wv};';
$Zp=bless({$o,$Xp,$q,$Yp,$s,$t},$u);
$cq={$v3,$Zp};
$dq=q'/unix/pipeline_init.b';
$eq=bless({$B1,$Wp,$k2,$l2,$m2,$l2,$n2,$cq,$D,$dq},$w2);
$fq=q'lib/slice::ctors';
$gq={};
$hq=q'async_step';
$iq=[];
$jq=q'local $_;
my $self = shift;
my $rv = $$self{rv};
my $wv = $$self{wv};
my $ev = $$self{ev};
return $self unless select $rv, $wv, $ev, 0;
for my $i (0..$#{$$self{rs}}) {
  my $rfh = $$self{rs}[$i]->read_fh;
  my $wfh = $$self{ws}[$i]->write_fh;
  next unless vec $rv, fileno $rfh, 1 and vec $wv, fileno $wfh, 1;
  $$self{rs}[$i]->read($_, 8192);
  $$self{ws}[$i]->write($_);
}
$self;';
$kq=bless({$o,$iq,$q,$jq,$s,$t},$u);
$lq={$hq,$kq};
$mq=q'/unix/pipeline_async.b';
$nq=bless({$B1,$gq,$k2,$l2,$m2,$l2,$n2,$lq,$D,$mq},$w2);
$oq=q'lib/slice::ctors';
$pq={};
$qq=[];
$rq=q'shift->{stdout}->read_fh';
$sq=bless({$o,$qq,$q,$rq,$s,$t},$u);
$tq=[];
$uq=q'shift->{stdin}->write_fh';
$vq=bless({$o,$tq,$q,$uq,$s,$t},$u);
$wq={$Kl,$sq,$Ol,$vq};
$xq=q'/unix/pipeline_io.b';
$yq=bless({$B1,$pq,$k2,$l2,$m2,$l2,$n2,$wq,$D,$xq},$w2);
$zq=q'lib/slice::ctors';
$Aq=[$Mj,$Up,$eq,$nq,$Hl,$yq];
$Bq=bless({$B1,$Jp,$D,$Kp,$c2,$Aq},$X1);
$Cq=q'unix/pipeline.c::ctors';
$Dq=q'ni:/unix/pipeline.c';
$Eq={$X1,1};
$Fq=q'/unix/pipeline.c';
$Gq=[$qk];
$Hq=bless({$B1,$Eq,$D,$Fq,$c2,$Gq},$e2);
$Iq=q'metaclass::ctors';
$Jq=q'ni:/unix/pipeline_async.b';
$Kq=q'ni:/unix/pipeline_init.b';
$Lq=q'ni:/unix/pipeline_io.b';
$Mq=q'ni:/unix/pipeline_ro.b';
$Nq=q'ni:/unix/str';
$Oq={$R3,1};
$Pq=q'/unix/str';
$Qq={};
$Rq=q'data';
$Sq=[];
$Tq=q'shift->{\'data\'}';
$Uq=bless({$o,$Sq,$q,$Tq,$s,$t},$u);
$Vq=q'end';
$Wq=[];
$Xq=q'shift->{\'end\'}';
$Yq=bless({$o,$Wq,$q,$Xq,$s,$t},$u);
$Zq=q'start';
$cr=[];
$dr=q'shift->{\'start\'}';
$er=bless({$o,$cr,$q,$dr,$s,$t},$u);
$fr={$Rq,$Uq,$Vq,$Yq,$Zq,$er};
$gr=q'/unix/str_ro.b';
$hr=bless({$B1,$Qq,$k2,$l2,$m2,$l2,$n2,$fr,$D,$gr},$w2);
$ir=q'lib/slice::ctors';
$jr={};
$kr=[];
$lr=q'my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};';
$mr=bless({$o,$kr,$q,$lr,$s,$t},$u);
$nr={$v3,$mr};
$or=q'/unix/str_init.b';
$pr=bless({$B1,$jr,$k2,$l2,$m2,$l2,$n2,$nr,$D,$or},$w2);
$qr=q'lib/slice::ctors';
$rr={};
$sr=[];
$tr=q'my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;';
$ur=bless({$o,$sr,$q,$tr,$s,$t},$u);
$vr=q'remaining';
$wr=[];
$xr=q'my $self = shift; $$self{end} - $$self{start}';
$yr=bless({$o,$wr,$q,$xr,$s,$t},$u);
$zr=[];
$Ar=q'my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];';
$Br=bless({$o,$zr,$q,$Ar,$s,$t},$u);
$Cr={$Xj,$ur,$vr,$yr,$Hb,$Br};
$Dr=q'/unix/str_io.b';
$Er=bless({$B1,$rr,$k2,$l2,$m2,$l2,$n2,$Cr,$D,$Dr},$w2);
$Fr=q'lib/slice::ctors';
$Gr=[$Mj,$hr,$pr,$Er];
$Hr=bless({$B1,$Oq,$D,$Pq,$c2,$Gr},$Y1);
$Ir=q'unix/str.c::ctors';
$Jr=q'ni:/unix/str.c';
$Kr={$Y1,1};
$Lr=q'/unix/str.c';
$Mr=[$qk];
$Nr=bless({$B1,$Kr,$D,$Lr,$c2,$Mr},$e2);
$Or=q'metaclass::ctors';
$Pr=q'ni:/unix/str_init.b';
$Qr=q'ni:/unix/str_io.b';
$Rr=q'ni:/unix/str_ro.b';
$Sr=q'ni:main';
$Tr={$Z9,1};
$Ur=[$Yg,$Y9];
$Vr=bless({$B1,$Tr,$D,$Z9,$c2,$Ur},$f2);
$Wr=q'module::ctors';
$Xr=q'ni:ni';
$Yr={$Dc,1};
$Zr={$Dc,1};
$cs=q'json_escapes';
$ds=q'';
$es=q'b';
$fs=q'	';
$gs=q't';
$hs=q'
';
$is=q'n';
$js=q'';
$ks=q'"';
$ls=q'/';
$ms=q'\\';
$ns={$ds,$es,$fs,$gs,$hs,$is,$js,$Km,$ks,$ks,$ls,$ls,$ms,$ms};
$os=q'json_unescapes';
$ps={$ks,$ks,$ls,$ls,$ms,$ms,$es,$ds,$is,$hs,$Km,$js,$gs,$fs};
$qs={$cs,$ns,$os,$ps};
$rs=q'/lib/json_data.b';
$ss=bless({$B1,$Zr,$Rq,$qs,$D,$rs},$E3);
$ts=q'lib/dataslice::ctors';
$us=[$ss,$Cc,$Pf,$xe,$He];
$vs=bless({$B1,$Yr,$D,$Dc,$c2,$us},$f2);
$ws={$d,$G,$I,$X,$Y,$l1,$m1,$z1,$A1,$Y5,$c6,$w6,$y6,$Q4,$z6,$t4,$A6,$q6,$B6,$M6,$O6,$x2,$P6,$T6,$V6,$J6,$W6,$A3,$X6,$r7,$t7,$x7,$z7,$o7,$A7,$h7,$B7,$x5,$C7,$E4,$D7,$t5,$E7,$p8,$r8,$v8,$x8,$c8,$y8,$L7,$z8,$S7,$A8,$m8,$B8,$p4,$C8,$D9,$F9,$J9,$L9,$P8,$M9,$r9,$N9,$g9,$O9,$A9,$P9,$Y9,$da,$Qb,$Sb,$Wb,$Yb,$ma,$Zb,$Nb,$cc,$Z3,$dc,$L5,$ec,$Cc,$Fc,$Z4,$Gc,$I2,$Hc,$S2,$Ic,$d3,$Jc,$ce,$ee,$ie,$ke,$xe,$ze,$He,$Je,$md,$Ke,$Ld,$Le,$Xd,$Me,$Xc,$Ne,$Pf,$Rf,$q3,$Sf,$k5,$Tf,$m3,$Uf,$Bg,$Dg,$jg,$Eg,$Ig,$Kg,$qg,$Lg,$yg,$Mg,$Yg,$ch,$U5,$dh,$vh,$xh,$lh,$yh,$Ch,$Eh,$sh,$Fh,$pi,$ri,$wi,$yi,$di,$zi,$Oh,$Ai,$li,$Bi,$Fi,$Hi,$Li,$Ni,$A5,$Oi,$t6,$Pi,$f4,$Qi,$l6,$Ri,$ik,$kk,$tk,$vk,$Uj,$wk,$fk,$xk,$Xl,$Zl,$fm,$hm,$Pk,$im,$Ul,$jm,$Hk,$km,$El,$lm,$Yk,$mm,$tl,$nm,$Xm,$Zm,$fn,$hn,$Um,$in,$Hm,$jn,$zm,$kn,$Pn,$Rn,$Vn,$Xn,$Bn,$Yn,$Mn,$Zn,$tn,$co,$Hl,$do,$Mj,$eo,$qk,$fo,$nj,$go,$wj,$ho,$Jj,$io,$ej,$jo,$wp,$yp,$Cp,$Ep,$To,$Fp,$tp,$Gp,$Io,$Hp,$ip,$Ip,$Bq,$Dq,$Hq,$Jq,$nq,$Kq,$eq,$Lq,$yq,$Mq,$Up,$Nq,$Hr,$Jr,$Nr,$Pr,$pr,$Qr,$Er,$Rr,$hr,$Sr,$Vr,$Xr,$vs};
$xs=q'resolvers';
$ys=[];
$zs=q'my $f = shift;
$f =~ s/^fd:(?:\\/\\/)?//;
ni(\'ni:/unix/fd\')->new($f);';
$As=bless({$o,$ys,$q,$zs,$s,$t},$u);
$Bs=q'file';
$Cs=[];
$Ds=q'my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni(\'ni:/unix/file\')->new($f);';
$Es=bless({$o,$Cs,$q,$Ds,$s,$t},$u);
$Fs=q'sh';
$Gs=[];
$Hs=q'ni::fork_exec \'/bin/sh\', \'-c\', substr shift, 3';
$Is=bless({$o,$Gs,$q,$Hs,$s,$t},$u);
$Js=q'str';
$Ks=[];
$Ls=q'my $s = shift;
ni(\'ni:/unix/str\')->new(substr($s, 4) . "\\n");';
$Ms=bless({$o,$Ks,$q,$Ls,$s,$t},$u);
$Ns={$Bk,$As,$Bs,$Es,$Fs,$Is,$Js,$Ms};
$Os=bless({$c,$ws,$xs,$Ns},$G3);
$Ps=q'lib/ni::ctors';
*$eg=\&$cg;
*$dg=\&$Yf;
$x2->apply_unsafe($C1);
$x2->apply_unsafe($D1);
$x2->apply_unsafe($E1);
$x2->apply_unsafe($y2);
$x2->apply_unsafe($F1);
$x2->apply_unsafe($G1);
$x2->apply_unsafe($H1);
$x2->apply_unsafe($I1);
$x2->apply_unsafe($J1);
$x2->apply_unsafe($K1);
$x2->apply_unsafe($L1);
$x2->apply_unsafe($M1);
$x2->apply_unsafe($z2);
$x2->apply_unsafe($e2);
$x2->apply_unsafe($O1);
$x2->apply_unsafe($f2);
$x2->apply_unsafe($P1);
$x2->apply_unsafe($Q1);
$x2->apply_unsafe($R1);
$x2->apply_unsafe($S1);
$x2->apply_unsafe($T1);
$x2->apply_unsafe($U1);
$x2->apply_unsafe($V1);
$x2->apply_unsafe($W1);
$x2->apply_unsafe($X1);
$x2->apply_unsafe($Y1);
$I2->apply_unsafe($C1);
$I2->apply_unsafe($D1);
$I2->apply_unsafe($E1);
$I2->apply_unsafe($y2);
$I2->apply_unsafe($F1);
$I2->apply_unsafe($G1);
$I2->apply_unsafe($F);
$I2->apply_unsafe($H1);
$I2->apply_unsafe($I1);
$I2->apply_unsafe($J1);
$I2->apply_unsafe($K1);
$I2->apply_unsafe($w2);
$I2->apply_unsafe($L1);
$I2->apply_unsafe($J2);
$I2->apply_unsafe($M1);
$I2->apply_unsafe($K2);
$I2->apply_unsafe($e2);
$I2->apply_unsafe($O1);
$I2->apply_unsafe($f2);
$I2->apply_unsafe($P1);
$I2->apply_unsafe($Q1);
$I2->apply_unsafe($R1);
$I2->apply_unsafe($S1);
$I2->apply_unsafe($T1);
$I2->apply_unsafe($U1);
$I2->apply_unsafe($V1);
$I2->apply_unsafe($W1);
$I2->apply_unsafe($X1);
$I2->apply_unsafe($Y1);
$S2->apply_unsafe($C1);
$S2->apply_unsafe($D1);
$S2->apply_unsafe($E1);
$S2->apply_unsafe($y2);
$S2->apply_unsafe($F1);
$S2->apply_unsafe($G1);
$S2->apply_unsafe($H1);
$S2->apply_unsafe($I1);
$S2->apply_unsafe($J1);
$S2->apply_unsafe($K1);
$S2->apply_unsafe($w2);
$S2->apply_unsafe($L1);
$S2->apply_unsafe($J2);
$S2->apply_unsafe($M1);
$S2->apply_unsafe($T2);
$S2->apply_unsafe($e2);
$S2->apply_unsafe($O1);
$S2->apply_unsafe($f2);
$S2->apply_unsafe($P1);
$S2->apply_unsafe($Q1);
$S2->apply_unsafe($R1);
$S2->apply_unsafe($S1);
$S2->apply_unsafe($T1);
$S2->apply_unsafe($U1);
$S2->apply_unsafe($V1);
$S2->apply_unsafe($W1);
$S2->apply_unsafe($X1);
$S2->apply_unsafe($Y1);
$d3->apply_unsafe($C1);
$d3->apply_unsafe($D1);
$d3->apply_unsafe($E1);
$d3->apply_unsafe($y2);
$d3->apply_unsafe($F1);
$d3->apply_unsafe($G1);
$d3->apply_unsafe($H1);
$d3->apply_unsafe($I1);
$d3->apply_unsafe($J1);
$d3->apply_unsafe($K1);
$d3->apply_unsafe($w2);
$d3->apply_unsafe($L1);
$d3->apply_unsafe($J2);
$d3->apply_unsafe($M1);
$d3->apply_unsafe($e3);
$d3->apply_unsafe($e2);
$d3->apply_unsafe($O1);
$d3->apply_unsafe($f2);
$d3->apply_unsafe($P1);
$d3->apply_unsafe($Q1);
$d3->apply_unsafe($R1);
$d3->apply_unsafe($S1);
$d3->apply_unsafe($T1);
$d3->apply_unsafe($U1);
$d3->apply_unsafe($V1);
$d3->apply_unsafe($W1);
$d3->apply_unsafe($X1);
$d3->apply_unsafe($Y1);
$m3->apply_unsafe($C1);
$m3->apply_unsafe($D1);
$m3->apply_unsafe($E1);
$m3->apply_unsafe($y2);
$m3->apply_unsafe($F1);
$m3->apply_unsafe($G1);
$m3->apply_unsafe($H1);
$m3->apply_unsafe($I1);
$m3->apply_unsafe($J1);
$m3->apply_unsafe($K1);
$m3->apply_unsafe($L1);
$m3->apply_unsafe($J2);
$m3->apply_unsafe($M1);
$m3->apply_unsafe($n3);
$m3->apply_unsafe($e2);
$m3->apply_unsafe($O1);
$m3->apply_unsafe($f2);
$m3->apply_unsafe($P1);
$m3->apply_unsafe($Q1);
$m3->apply_unsafe($R1);
$m3->apply_unsafe($S1);
$m3->apply_unsafe($T1);
$m3->apply_unsafe($U1);
$m3->apply_unsafe($V1);
$m3->apply_unsafe($W1);
$m3->apply_unsafe($X1);
$m3->apply_unsafe($Y1);
$A3->apply_unsafe($C1);
$A3->apply_unsafe($D1);
$A3->apply_unsafe($E1);
$A3->apply_unsafe($F1);
$A3->apply_unsafe($G1);
$A3->apply_unsafe($H1);
$A3->apply_unsafe($I1);
$A3->apply_unsafe($J1);
$A3->apply_unsafe($K1);
$A3->apply_unsafe($L1);
$A3->apply_unsafe($M1);
$A3->apply_unsafe($B3);
$A3->apply_unsafe($e2);
$A3->apply_unsafe($O1);
$A3->apply_unsafe($f2);
$A3->apply_unsafe($P1);
$A3->apply_unsafe($Q1);
$A3->apply_unsafe($R1);
$A3->apply_unsafe($S1);
$A3->apply_unsafe($T1);
$A3->apply_unsafe($U1);
$A3->apply_unsafe($V1);
$A3->apply_unsafe($W1);
$A3->apply_unsafe($X1);
$A3->apply_unsafe($Y1);
$Z3->apply_unsafe($C1);
$Z3->apply_unsafe($D1);
$Z3->apply_unsafe($D3);
$Z3->apply_unsafe($E1);
$Z3->apply_unsafe($y2);
$Z3->apply_unsafe($F1);
$Z3->apply_unsafe($E3);
$Z3->apply_unsafe($G1);
$Z3->apply_unsafe($F);
$Z3->apply_unsafe($H1);
$Z3->apply_unsafe($u);
$Z3->apply_unsafe($I1);
$Z3->apply_unsafe($F3);
$Z3->apply_unsafe($J1);
$Z3->apply_unsafe($G3);
$Z3->apply_unsafe($K1);
$Z3->apply_unsafe($w2);
$Z3->apply_unsafe($L1);
$Z3->apply_unsafe($J2);
$Z3->apply_unsafe($M1);
$Z3->apply_unsafe($H3);
$Z3->apply_unsafe($c4);
$Z3->apply_unsafe($e2);
$Z3->apply_unsafe($O1);
$Z3->apply_unsafe($f2);
$Z3->apply_unsafe($P1);
$Z3->apply_unsafe($J3);
$Z3->apply_unsafe($Q1);
$Z3->apply_unsafe($K3);
$Z3->apply_unsafe($R1);
$Z3->apply_unsafe($L3);
$Z3->apply_unsafe($S1);
$Z3->apply_unsafe($M3);
$Z3->apply_unsafe($T1);
$Z3->apply_unsafe($N3);
$Z3->apply_unsafe($U1);
$Z3->apply_unsafe($O3);
$Z3->apply_unsafe($V1);
$Z3->apply_unsafe($P3);
$Z3->apply_unsafe($W1);
$Z3->apply_unsafe($Q3);
$Z3->apply_unsafe($X1);
$Z3->apply_unsafe($R3);
$Z3->apply_unsafe($Y1);
$p4->apply_unsafe($C1);
$p4->apply_unsafe($D1);
$p4->apply_unsafe($D3);
$p4->apply_unsafe($E1);
$p4->apply_unsafe($y2);
$p4->apply_unsafe($F1);
$p4->apply_unsafe($E3);
$p4->apply_unsafe($G1);
$p4->apply_unsafe($H1);
$p4->apply_unsafe($I1);
$p4->apply_unsafe($J1);
$p4->apply_unsafe($K1);
$p4->apply_unsafe($w2);
$p4->apply_unsafe($L1);
$p4->apply_unsafe($J2);
$p4->apply_unsafe($M1);
$p4->apply_unsafe($q4);
$p4->apply_unsafe($e2);
$p4->apply_unsafe($O1);
$p4->apply_unsafe($f2);
$p4->apply_unsafe($P1);
$p4->apply_unsafe($Q1);
$p4->apply_unsafe($R1);
$p4->apply_unsafe($S1);
$p4->apply_unsafe($T1);
$p4->apply_unsafe($U1);
$p4->apply_unsafe($V1);
$p4->apply_unsafe($W1);
$p4->apply_unsafe($X1);
$p4->apply_unsafe($Y1);
$E4->apply_unsafe($C1);
$E4->apply_unsafe($D1);
$E4->apply_unsafe($E1);
$E4->apply_unsafe($y2);
$E4->apply_unsafe($F1);
$E4->apply_unsafe($G1);
$E4->apply_unsafe($H1);
$E4->apply_unsafe($I1);
$E4->apply_unsafe($J1);
$E4->apply_unsafe($K1);
$E4->apply_unsafe($L1);
$E4->apply_unsafe($M1);
$E4->apply_unsafe($F4);
$E4->apply_unsafe($e2);
$E4->apply_unsafe($O1);
$E4->apply_unsafe($f2);
$E4->apply_unsafe($P1);
$E4->apply_unsafe($Q1);
$E4->apply_unsafe($R1);
$E4->apply_unsafe($S1);
$E4->apply_unsafe($T1);
$E4->apply_unsafe($U1);
$E4->apply_unsafe($V1);
$E4->apply_unsafe($W1);
$E4->apply_unsafe($X1);
$E4->apply_unsafe($Y1);
$Q4->apply_unsafe($C1);
$Q4->apply_unsafe($D1);
$Q4->apply_unsafe($E1);
$Q4->apply_unsafe($y2);
$Q4->apply_unsafe($F1);
$Q4->apply_unsafe($G1);
$Q4->apply_unsafe($H1);
$Q4->apply_unsafe($I1);
$Q4->apply_unsafe($J1);
$Q4->apply_unsafe($K1);
$Q4->apply_unsafe($L1);
$Q4->apply_unsafe($M1);
$Q4->apply_unsafe($R4);
$Q4->apply_unsafe($e2);
$Q4->apply_unsafe($O1);
$Q4->apply_unsafe($f2);
$Q4->apply_unsafe($P1);
$Q4->apply_unsafe($Q1);
$Q4->apply_unsafe($R1);
$Q4->apply_unsafe($S1);
$Q4->apply_unsafe($T1);
$Q4->apply_unsafe($U1);
$Q4->apply_unsafe($V1);
$Q4->apply_unsafe($W1);
$Q4->apply_unsafe($X1);
$Q4->apply_unsafe($Y1);
$Z4->apply_unsafe($C1);
$Z4->apply_unsafe($D1);
$Z4->apply_unsafe($E1);
$Z4->apply_unsafe($y2);
$Z4->apply_unsafe($F1);
$Z4->apply_unsafe($G1);
$Z4->apply_unsafe($H1);
$Z4->apply_unsafe($I1);
$Z4->apply_unsafe($J1);
$Z4->apply_unsafe($K1);
$Z4->apply_unsafe($L1);
$Z4->apply_unsafe($M1);
$Z4->apply_unsafe($c5);
$Z4->apply_unsafe($e2);
$Z4->apply_unsafe($O1);
$Z4->apply_unsafe($f2);
$Z4->apply_unsafe($P1);
$Z4->apply_unsafe($Q1);
$Z4->apply_unsafe($R1);
$Z4->apply_unsafe($S1);
$Z4->apply_unsafe($T1);
$Z4->apply_unsafe($U1);
$Z4->apply_unsafe($V1);
$Z4->apply_unsafe($W1);
$Z4->apply_unsafe($X1);
$Z4->apply_unsafe($Y1);
$k5->apply_unsafe($C1);
$k5->apply_unsafe($D1);
$k5->apply_unsafe($E1);
$k5->apply_unsafe($y2);
$k5->apply_unsafe($F1);
$k5->apply_unsafe($G1);
$k5->apply_unsafe($H1);
$k5->apply_unsafe($I1);
$k5->apply_unsafe($J1);
$k5->apply_unsafe($K1);
$k5->apply_unsafe($L1);
$k5->apply_unsafe($M1);
$k5->apply_unsafe($l5);
$k5->apply_unsafe($e2);
$k5->apply_unsafe($O1);
$k5->apply_unsafe($f2);
$k5->apply_unsafe($P1);
$k5->apply_unsafe($Q1);
$k5->apply_unsafe($R1);
$k5->apply_unsafe($S1);
$k5->apply_unsafe($T1);
$k5->apply_unsafe($U1);
$k5->apply_unsafe($V1);
$k5->apply_unsafe($W1);
$k5->apply_unsafe($X1);
$k5->apply_unsafe($Y1);
$t5->apply_unsafe($C1);
$t5->apply_unsafe($D1);
$t5->apply_unsafe($E1);
$t5->apply_unsafe($y2);
$t5->apply_unsafe($F1);
$t5->apply_unsafe($G1);
$t5->apply_unsafe($H1);
$t5->apply_unsafe($I1);
$t5->apply_unsafe($J1);
$t5->apply_unsafe($K1);
$t5->apply_unsafe($L1);
$t5->apply_unsafe($M1);
$t5->apply_unsafe($u5);
$t5->apply_unsafe($e2);
$t5->apply_unsafe($O1);
$t5->apply_unsafe($f2);
$t5->apply_unsafe($P1);
$t5->apply_unsafe($Q1);
$t5->apply_unsafe($R1);
$t5->apply_unsafe($S1);
$t5->apply_unsafe($T1);
$t5->apply_unsafe($U1);
$t5->apply_unsafe($V1);
$t5->apply_unsafe($W1);
$t5->apply_unsafe($X1);
$t5->apply_unsafe($Y1);
$L5->apply_unsafe($C1);
$L5->apply_unsafe($D1);
$L5->apply_unsafe($E1);
$L5->apply_unsafe($F1);
$L5->apply_unsafe($G1);
$L5->apply_unsafe($H1);
$L5->apply_unsafe($u);
$L5->apply_unsafe($I1);
$L5->apply_unsafe($J1);
$L5->apply_unsafe($K1);
$L5->apply_unsafe($w2);
$L5->apply_unsafe($L1);
$L5->apply_unsafe($J2);
$L5->apply_unsafe($M1);
$L5->apply_unsafe($M5);
$L5->apply_unsafe($e2);
$L5->apply_unsafe($O1);
$L5->apply_unsafe($P1);
$L5->apply_unsafe($Q1);
$L5->apply_unsafe($R1);
$L5->apply_unsafe($S1);
$L5->apply_unsafe($T1);
$L5->apply_unsafe($U1);
$L5->apply_unsafe($V1);
$L5->apply_unsafe($W1);
$L5->apply_unsafe($X1);
$L5->apply_unsafe($Y1);
$U5->apply_unsafe($C1);
$U5->apply_unsafe($D1);
$U5->apply_unsafe($E1);
$U5->apply_unsafe($F1);
$U5->apply_unsafe($G1);
$U5->apply_unsafe($H1);
$U5->apply_unsafe($I1);
$U5->apply_unsafe($J1);
$U5->apply_unsafe($K1);
$U5->apply_unsafe($L1);
$U5->apply_unsafe($M1);
$U5->apply_unsafe($V5);
$U5->apply_unsafe($O1);
$U5->apply_unsafe($P1);
$U5->apply_unsafe($Q1);
$U5->apply_unsafe($R1);
$U5->apply_unsafe($S1);
$U5->apply_unsafe($T1);
$U5->apply_unsafe($U1);
$U5->apply_unsafe($V1);
$U5->apply_unsafe($W1);
$U5->apply_unsafe($X1);
$U5->apply_unsafe($Y1);
$J6->apply_unsafe($y2);
$h7->apply_unsafe($E3);
$o7->apply_unsafe($E3);
$L7->apply_unsafe($F);
$S7->apply_unsafe($F);
$c8->apply_unsafe($F);
$m8->apply_unsafe($F);
$P8->apply_unsafe($u);
$g9->apply_unsafe($u);
$r9->apply_unsafe($u);
$A9->apply_unsafe($u);
$Y9->apply_unsafe($Z9);
$ma->apply_unsafe($F3);
$Nb->apply_unsafe($F3);
$Cc->apply_unsafe($Dc);
$Xc->apply_unsafe($G3);
$md->apply_unsafe($G3);
$Ld->apply_unsafe($G3);
$Xd->apply_unsafe($G3);
$xe->apply_unsafe($Dc);
$He->apply_unsafe($Dc);
$Pf->apply_unsafe($Dc);
$jg->apply_unsafe($w2);
$qg->apply_unsafe($w2);
$yg->apply_unsafe($w2);
$Yg->apply_unsafe($Z9);
$lh->apply_unsafe($J2);
$sh->apply_unsafe($J2);
$Oh->apply_unsafe($H3);
$di->apply_unsafe($H3);
$li->apply_unsafe($H3);
$ej->apply_unsafe($K3);
$ej->apply_unsafe($L3);
$ej->apply_unsafe($M3);
$ej->apply_unsafe($N3);
$ej->apply_unsafe($O3);
$ej->apply_unsafe($P3);
$ej->apply_unsafe($Q3);
$ej->apply_unsafe($R3);
$nj->apply_unsafe($K3);
$nj->apply_unsafe($L3);
$nj->apply_unsafe($M3);
$nj->apply_unsafe($N3);
$nj->apply_unsafe($O3);
$nj->apply_unsafe($P3);
$nj->apply_unsafe($Q3);
$nj->apply_unsafe($R3);
$wj->apply_unsafe($K3);
$wj->apply_unsafe($L3);
$wj->apply_unsafe($M3);
$wj->apply_unsafe($N3);
$wj->apply_unsafe($O3);
$wj->apply_unsafe($P3);
$wj->apply_unsafe($Q3);
$wj->apply_unsafe($R3);
$Jj->apply_unsafe($K3);
$Jj->apply_unsafe($L3);
$Jj->apply_unsafe($M3);
$Jj->apply_unsafe($N3);
$Jj->apply_unsafe($O3);
$Jj->apply_unsafe($P3);
$Jj->apply_unsafe($Q3);
$Jj->apply_unsafe($R3);
$Uj->apply_unsafe($K3);
$fk->apply_unsafe($K3);
$Hk->apply_unsafe($L3);
$Pk->apply_unsafe($L3);
$Yk->apply_unsafe($L3);
$tl->apply_unsafe($L3);
$tl->apply_unsafe($M3);
$tl->apply_unsafe($N3);
$tl->apply_unsafe($P3);
$tl->apply_unsafe($Q3);
$El->apply_unsafe($L3);
$El->apply_unsafe($M3);
$El->apply_unsafe($N3);
$El->apply_unsafe($P3);
$El->apply_unsafe($Q3);
$Ul->apply_unsafe($L3);
$zm->apply_unsafe($M3);
$Hm->apply_unsafe($M3);
$Um->apply_unsafe($M3);
$tn->apply_unsafe($N3);
$Bn->apply_unsafe($N3);
$Mn->apply_unsafe($N3);
$Io->apply_unsafe($P3);
$To->apply_unsafe($P3);
$ip->apply_unsafe($P3);
$tp->apply_unsafe($P3);
$Up->apply_unsafe($Q3);
$eq->apply_unsafe($Q3);
$nq->apply_unsafe($Q3);
$yq->apply_unsafe($Q3);
$hr->apply_unsafe($R3);
$pr->apply_unsafe($R3);
$Er->apply_unsafe($R3);
$ni::self=$Os;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($P)for@$w;
&$_($T)for@$w;
&$_($X)for@$H;
&$_($h1)for@$w;
&$_($l1)for@$H;
&$_($r1)for@$w;
&$_($v1)for@$w;
&$_($z1)for@$H;
&$_($q2)for@$w;
&$_($t2)for@$w;
&$_($x2)for@$A2;
&$_($D2)for@$w;
&$_($F2)for@$w;
&$_($I2)for@$L2;
&$_($P2)for@$w;
&$_($S2)for@$U2;
&$_($Y2)for@$w;
&$_($d3)for@$f3;
&$_($j3)for@$w;
&$_($m3)for@$o3;
&$_($q3)for@$r3;
&$_($u3)for@$w;
&$_($x3)for@$w;
&$_($A3)for@$C3;
&$_($W3)for@$w;
&$_($Z3)for@$d4;
&$_($f4)for@$g4;
&$_($m4)for@$w;
&$_($p4)for@$r4;
&$_($t4)for@$u4;
&$_($B4)for@$w;
&$_($E4)for@$G4;
&$_($K4)for@$w;
&$_($N4)for@$w;
&$_($Q4)for@$S4;
&$_($W4)for@$w;
&$_($Z4)for@$d5;
&$_($h5)for@$w;
&$_($k5)for@$m5;
&$_($q5)for@$w;
&$_($t5)for@$v5;
&$_($x5)for@$y5;
&$_($A5)for@$B5;
&$_($F5)for@$w;
&$_($I5)for@$w;
&$_($L5)for@$N5;
&$_($R5)for@$w;
&$_($U5)for@$W5;
&$_($Y5)for@$Z5;
&$_($l6)for@$m6;
&$_($q6)for@$r6;
&$_($t6)for@$u6;
&$_($w6)for@$x6;
&$_($G6)for@$w;
&$_($J6)for@$K6;
&$_($M6)for@$N6;
&$_($T6)for@$U6;
&$_($e7)for@$w;
&$_($h7)for@$i7;
&$_($l7)for@$w;
&$_($o7)for@$p7;
&$_($r7)for@$s7;
&$_($x7)for@$y7;
&$_($I7)for@$w;
&$_($L7)for@$M7;
&$_($P7)for@$w;
&$_($S7)for@$T7;
&$_($X7)for@$w;
&$_($c8)for@$d8;
&$_($g8)for@$w;
&$_($j8)for@$w;
&$_($m8)for@$n8;
&$_($p8)for@$q8;
&$_($v8)for@$w8;
&$_($H8)for@$w;
&$_($K8)for@$w;
&$_($M8)for@$w;
&$_($P8)for@$Q8;
&$_($U8)for@$w;
&$_($X8)for@$w;
&$_($d9)for@$w;
&$_($g9)for@$h9;
&$_($l9)for@$w;
&$_($o9)for@$w;
&$_($r9)for@$s9;
&$_($x9)for@$w;
&$_($A9)for@$B9;
&$_($D9)for@$E9;
&$_($J9)for@$K9;
&$_($V9)for@$w;
&$_($Y9)for@$ca;
&$_($ja)for@$w;
&$_($ma)for@$na;
&$_($sa)for@$w;
&$_($wa)for@$w;
&$_($Aa)for@$w;
&$_($Ea)for@$w;
&$_($Ia)for@$w;
&$_($Ma)for@$w;
&$_($Qa)for@$w;
&$_($Ua)for@$w;
&$_($Ya)for@$w;
&$_($eb)for@$w;
&$_($ib)for@$w;
&$_($mb)for@$w;
&$_($qb)for@$w;
&$_($ub)for@$w;
&$_($yb)for@$w;
&$_($Cb)for@$w;
&$_($Gb)for@$w;
&$_($Kb)for@$w;
&$_($Nb)for@$Ob;
&$_($Qb)for@$Rb;
&$_($Wb)for@$Xb;
&$_($jc)for@$w;
&$_($nc)for@$w;
&$_($rc)for@$w;
&$_($vc)for@$w;
&$_($zc)for@$w;
&$_($Cc)for@$Ec;
&$_($Qc)for@$w;
&$_($Uc)for@$w;
&$_($Xc)for@$Yc;
&$_($fd)for@$w;
&$_($jd)for@$w;
&$_($md)for@$nd;
&$_($sd)for@$w;
&$_($wd)for@$w;
&$_($Ad)for@$w;
&$_($Ed)for@$w;
&$_($Id)for@$w;
&$_($Ld)for@$Md;
&$_($Qd)for@$w;
&$_($Ud)for@$w;
&$_($Xd)for@$Yd;
&$_($ce)for@$de;
&$_($ie)for@$je;
&$_($qe)for@$w;
&$_($ue)for@$w;
&$_($xe)for@$ye;
&$_($Ee)for@$w;
&$_($He)for@$Ie;
&$_($Se)for@$w;
&$_($We)for@$w;
&$_($cf)for@$w;
&$_($gf)for@$w;
&$_($kf)for@$w;
&$_($of)for@$w;
&$_($sf)for@$w;
&$_($wf)for@$w;
&$_($Af)for@$w;
&$_($Ef)for@$w;
&$_($If)for@$w;
&$_($Mf)for@$w;
&$_($Pf)for@$Qf;
&$_($Yf)for@$w;
&$_($cg)for@$w;
&$_($jg)for@$kg;
&$_($ng)for@$w;
&$_($qg)for@$rg;
&$_($vg)for@$w;
&$_($yg)for@$zg;
&$_($Bg)for@$Cg;
&$_($Ig)for@$Jg;
&$_($Qg)for@$w;
&$_($Vg)for@$w;
&$_($Yg)for@$Zg;
&$_($ih)for@$w;
&$_($lh)for@$mh;
&$_($ph)for@$w;
&$_($sh)for@$th;
&$_($vh)for@$wh;
&$_($Ch)for@$Dh;
&$_($Lh)for@$w;
&$_($Oh)for@$Ph;
&$_($Uh)for@$w;
&$_($Yh)for@$w;
&$_($di)for@$ei;
&$_($ii)for@$w;
&$_($li)for@$mi;
&$_($pi)for@$qi;
&$_($wi)for@$xi;
&$_($Fi)for@$Gi;
&$_($Li)for@$Mi;
&$_($Zi)for@$w;
&$_($ej)for@$fj;
&$_($kj)for@$w;
&$_($nj)for@$oj;
&$_($tj)for@$w;
&$_($wj)for@$xj;
&$_($Cj)for@$w;
&$_($Gj)for@$w;
&$_($Jj)for@$Kj;
&$_($Mj)for@$Nj;
&$_($Rj)for@$w;
&$_($Uj)for@$Vj;
&$_($ck)for@$w;
&$_($fk)for@$gk;
&$_($ik)for@$jk;
&$_($qk)for@$rk;
&$_($tk)for@$uk;
&$_($Ek)for@$w;
&$_($Hk)for@$Ik;
&$_($Mk)for@$w;
&$_($Pk)for@$Qk;
&$_($Vk)for@$w;
&$_($Yk)for@$Zk;
&$_($il)for@$w;
&$_($ml)for@$w;
&$_($ql)for@$w;
&$_($tl)for@$ul;
&$_($yl)for@$w;
&$_($Bl)for@$w;
&$_($El)for@$Fl;
&$_($Hl)for@$Il;
&$_($Nl)for@$w;
&$_($Rl)for@$w;
&$_($Ul)for@$Vl;
&$_($Xl)for@$Yl;
&$_($fm)for@$gm;
&$_($tm)for@$w;
&$_($wm)for@$w;
&$_($zm)for@$Am;
&$_($Em)for@$w;
&$_($Hm)for@$Im;
&$_($Nm)for@$w;
&$_($Rm)for@$w;
&$_($Um)for@$Vm;
&$_($Xm)for@$Ym;
&$_($fn)for@$gn;
&$_($qn)for@$w;
&$_($tn)for@$un;
&$_($yn)for@$w;
&$_($Bn)for@$Cn;
&$_($Gn)for@$w;
&$_($Jn)for@$w;
&$_($Mn)for@$Nn;
&$_($Pn)for@$Qn;
&$_($Vn)for@$Wn;
&$_($po)for@$w;
&$_($to)for@$w;
&$_($xo)for@$w;
&$_($Bo)for@$w;
&$_($Fo)for@$w;
&$_($Io)for@$Jo;
&$_($No)for@$w;
&$_($Qo)for@$w;
&$_($To)for@$Uo;
&$_($Zo)for@$w;
&$_($fp)for@$w;
&$_($ip)for@$jp;
&$_($np)for@$w;
&$_($qp)for@$w;
&$_($tp)for@$up;
&$_($wp)for@$xp;
&$_($Cp)for@$Dp;
&$_($Op)for@$w;
&$_($Rp)for@$w;
&$_($Up)for@$Vp;
&$_($Zp)for@$w;
&$_($eq)for@$fq;
&$_($kq)for@$w;
&$_($nq)for@$oq;
&$_($sq)for@$w;
&$_($vq)for@$w;
&$_($yq)for@$zq;
&$_($Bq)for@$Cq;
&$_($Hq)for@$Iq;
&$_($Uq)for@$w;
&$_($Yq)for@$w;
&$_($er)for@$w;
&$_($hr)for@$ir;
&$_($mr)for@$w;
&$_($pr)for@$qr;
&$_($ur)for@$w;
&$_($yr)for@$w;
&$_($Br)for@$w;
&$_($Er)for@$Fr;
&$_($Hr)for@$Ir;
&$_($Nr)for@$Or;
&$_($Vr)for@$Wr;
&$_($ss)for@$ts;
&$_($vs)for@$Wr;
&$_($As)for@$w;
&$_($Es)for@$w;
&$_($Is)for@$w;
&$_($Ms)for@$w;
&$_($Os)for@$Ps;
ni->run(@ARGV);
__DATA__
