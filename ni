#!/usr/bin/env perl
chomp($ni::license=<<'_');
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use strict;
use warnings;
no warnings qw/redefine void/;
no strict 'refs';
use POSIX;
use Scalar::Util;
chomp $ni::boot;
$ni::self = bless {named => {}}, 'lib/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::self->resolve($_[0]) : $ni::self}
sub ni::eval {eval shift}
*{'lib/ni::def'} = sub {
  my ($self, %kvs) = @_;
  $$self{named}{$_} = $kvs{$_} for keys %kvs;
};
*{'lib/fn::OVERLOAD'} = {};
*{'lib/fn::(bool'} = sub {1};
*{'lib/fn::()'}    = sub {};
*{'lib/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'lib/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/lib/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
sub fn($);
_
$c=q#named#;
$d=q#ni.doc:/class#;
$e=q#doc#;
$f=q#synopsis#;
$g=q#
    ni('ni:/object')->child('/message')
      ->add('/behaviorname.b')          \# add existing behavior
      ->def('/message_init.b',          \# define new slice behavior
        instantiate => fn q{            \# called from ->new()
          my ($class, $message) = @_;
          +{message => $message};       \# return object to be blessed
        })
      ->def('/behaviorname.b',          \# define another behavior
        method1 => fn q{
          my $self = shift;
          print "message for you sir! '" . $$self{message} . "'\\n";
        });
    ni('ni:/child')->new('hello world!')->method1;
  #;
$h=[$f,$g];
$i=q#description#;
$j=q#ni:class is at the core of ni's object-oriented system, along with core
      classes like ni:object and ni:metaclass. There are two layers of
      abstraction involved here: Perl packages are modified by behaviors, and
      classes encode the higher-level declarative features you'd expect from a
      language like Ruby or Smalltalk. This documentation covers both layers.#;
$k=[$i,$j];
$l=q#behaviors#;
$m=q#ni's objects are blessed Perl references, and behaviors are objects
      that modify Perl packages in specific ways. The simplest is
      ni:/lib/slice, which represents a set of methods you can add to a
      package.#;
$n=q#eg#;
$o=q#annotations#;
$p=[];
$q=q#code#;
$r=q#my $fn = fn q{"hi"};
my $slice = ni('ni:/lib/slice')->new('myslice', f => $fn);
$slice->apply('foo');
now foo->f == 'hi';#;
$s=q#proto#;
$t=q##;
$u=q#lib/fn#;
$v=bless({$o,$p,$q,$r,$s,$t},$u);
$w=q#lib/fn::ctors#;
$x=q#TODO...#;
$y=[$l,$m,$n,$v,$x];
$z=q#classes#;
$A=q#ni implements a Smalltalk 80-style metaclass system with a couple of
      differences. First, ni's classes are slice unions and as such don't
      support colliding methods; and second, they support multiple inheritance.
      These two points are related: method overriding isn't in the picture,
      which makes multiple inheritance straightforward to implement.#;
$B=[$z,$A,$x];
$C=[$h,$k,$y,$B];
$D=q#name#;
$E=q#/class#;
$F=q#lib/doc#;
$G=bless({$e,$C,$D,$E},$F);
$H=q#lib/doc::ctors#;
$I=q#ni.doc:/fabric#;
$J=q#Abstractions to bridge the gaps between separate machines and processes.
      This module is designed to make it appear as though all resources are
      local, or at least can be referred to locally -- even when they belong to
      an external process (e.g. a Hadoop mapper) or another machine (e.g. a
      file over SSH). If we can bidirectionally communicate with a remote ni
      instance, then we can see its resources.#;
$K=[$i,$J];
$L=[$K];
$M=q#/fabric#;
$N=bless({$e,$L,$D,$M},$F);
$O=q#ni.doc:/io#;
$P=q#An implementation of IO in terms of system-level FDs. We need this for a
      few reasons, three of them being that (1) old versions of Perl don't
      correctly handle interrupted system calls, (2) we want tighter control
      over which FDs are closed at what times, and (3) we want to be able to
      "unread" things -- push back against the read buffer (or use a custom
      read format in general).#;
$Q=[$i,$P];
$R=[$Q];
$S=q#/io#;
$T=bless({$e,$R,$D,$S},$F);
$U=q#ni.doc:/io/cat#;
$V=q#
    my $combined = ni('ni:/io/cat')->new($io1, $io2, ...);
    my $combined = $io1 + $io2 + $io3;
    $combined->into($destination_io);
  #;
$W=[$f,$V];
$X=q#Concatenates multiple IO objects into a single read-only data source.
      This is a mutable object that consumes its inputs and then loses its
      references to them as quickly as possible, allowing their resources to be
      freed. Once fully consumed, the cat object holds no references.#;
$Y=[$i,$X];
$Z=[];
$c1=q#my $cat = ni('str:foo') + ni('str:bar');
now $cat->read_all == "foo\\nbar\\n";#;
$d1=bless({$o,$Z,$q,$c1,$s,$t},$u);
$e1=[$n,$d1];
$f1=[$W,$Y,$e1];
$g1=q#/io/cat#;
$h1=bless({$e,$f1,$D,$g1},$F);
$i1=q#ni.doc:/io/exec#;
$j1=q#
    my $pid = ni("ni:/io/exec")->new("ls", "-l")
      ->fds(1 => ni"file:foo")
      ->env(ENV_VAR => "value", ENV2 => "val2")
      ->fork;
    $? = $pid->await or die "ls -l failed: $?";#;
$k1=[$f,$j1];
$l1=q#An object that represents a fork+exec operation that hasn't yet happened.
      It allows you to incrementally specify the context of the process,
      including environment variables and file descriptor mappings. It is also
      an IO object and will set up pipes to stdin/out if you use it this way.#;
$m1=[$i,$l1];
$n1=[];
$o1=q#my $e   = ni('ni:/io/exec')->new('sh', '-c', 'echo hi');
my $out = $e->stdout;
my $pid = $e->fork;
now [$out->read_all, $pid->await] == ["hi\\n", 0];#;
$p1=bless({$o,$n1,$q,$o1,$s,$t},$u);
$q1=[$n,$p1];
$r1=[$k1,$m1,$q1];
$s1=q#/io/exec#;
$t1=bless({$e,$r1,$D,$s1},$F);
$u1=q#ni.doc:/io/pid#;
$v1=[];
$w1=q#now [ni('sh:true')->await, ni('sh:false')->await] == [0, 1 << 8];#;
$x1=bless({$o,$v1,$q,$w1,$s,$t},$u);
$y1=[$n,$x1];
$z1=[];
$A1=q#my $pid = ni('sh:seq 4');
my $data = $pid->read_all;
now [$pid->await, $data] == [0, "1\\n2\\n3\\n4\\n"];#;
$B1=bless({$o,$z1,$q,$A1,$s,$t},$u);
$C1=[$n,$B1];
$D1=[];
$E1=q#my $seq = ni('sh:seq 10');
my $grep = ni('ni:/io/exec')->new('egrep', '[13579]$')
  ->fds(0 => $seq->stdout)
  ->fork;
now $grep->read_all == "1\\n3\\n5\\n7\\n9\\n";
now $seq->await == 0;
now $grep->await == 0;#;
$F1=bless({$o,$D1,$q,$E1,$s,$t},$u);
$G1=[$n,$F1];
$H1=[$y1,$C1,$G1];
$I1=q#/io/pid#;
$J1=bless({$e,$H1,$D,$I1},$F);
$K1=q#ni.doc:/lib/doc#;
$L1=q#
    ni("ni:/some/class")->doc
      ->synopsis(...)
      ->description(...)
      ->eg(...)
      ...#;
$M1=[$f,$L1];
$N1=q#Associate documentation with the specified class. Documentation is stored
      separately and in the "ni.doc" namespace; this way you can serialize
      instances of the class and the class's code without bringing along all of
      its documentation and unit tests.#;
$O1=q#Documentation objects are internally represented as arrays of quoted
      method calls:#;
$P1=[];
$Q1=q#my $doc = ni("ni:/lib/doc")->new("foo");
now $doc->{doc} == [];
$doc->foo("bar bif baz");
now $doc->{doc} == [["foo", "bar bif baz"]];#;
$R1=bless({$o,$P1,$q,$Q1,$s,$t},$u);
$S1=q#This documentation can later be compiled into things like manpages,
      markdown, or HTML by target-specific conversion functions. Documentation
      also stores unit tests, which are specified using "eg":#;
$T1=[];
$U1=q#my $doc = ni("ni:/lib/doc")->new("foo");
my $passing_test = fn q{return 1};
my $failing_test = fn q{return 0};
$doc->eg($passing_test)
    ->description(q[Foo objects are contrived examples.],
                  eg => $failing_test,
                  q[So there.]);
now [$doc->tests] == [$passing_test, $failing_test];#;
$V1=bless({$o,$T1,$q,$U1,$s,$t},$u);
$W1=[$i,$N1,$O1,$n,$R1,$S1,$n,$V1];
$X1=[$M1,$W1];
$Y1=q#/lib/doc#;
$Z1=bless({$e,$X1,$D,$Y1},$F);
$c2=q#ni:/class#;
$d2=q#applied_to#;
$e2=q#class#;
$f2=q#class.c#;
$g2=q#io/cat.c#;
$h2=q#io/exec.c#;
$i2=q#io/fd.c#;
$j2=q#io/file.c#;
$k2=q#io/object.c#;
$l2=q#io/pid.c#;
$m2=q#io/str.c#;
$n2=q#lib/behavior.c#;
$o2=q#lib/branch.c#;
$p2=q#lib/dataslice.c#;
$q2=q#lib/doc.c#;
$r2=q#lib/fn.c#;
$s2=q#lib/image.c#;
$t2=q#lib/ni.c#;
$u2=q#lib/slice.c#;
$v2=q#lib/tag.c#;
$w2=q#lib/test_value.c#;
$x2=q#metaclass.c#;
$y2=q#module.c#;
$z2=q#object.c#;
$A2={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$w2,1,$x2,1,$y2,1,$z2,1};
$B2=q#slices#;
$C2=q#lib/test_value.c#;
$D2=q#metaclass#;
$E2=q#module#;
$F2={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$C2,1,$D2,1,$x2,1,$E2,1,$y2,1,$z2,1};
$G2=q#/module#;
$H2=q#/lib/perlbranch.b#;
$I2={};
$J2=q#ctor#;
$K2=undef;
$L2=q#dtor#;
$M2=q#methods#;
$N2=q#add#;
$O2=q#local $_;
my $self = shift;
my @s = map $self->resolve($_), @_;
push @{$$self{slices}}, @s;
for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
$self;#;
$P2=bless({$q,$O2,$s,$t},$u);
$Q2=q#apply#;
$R2=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
$$self{applied_to}{$p} = 1;
$_->apply($p) for @{$$self{slices}};
$self;#;
$S2=bless({$q,$R2,$s,$t},$u);
$T2={$N2,$P2,$Q2,$S2};
$U2=q#/lib/branch.b#;
$V2=q#lib/slice#;
$W2=bless({$d2,$I2,$J2,$K2,$L2,$K2,$M2,$T2,$D,$U2},$V2);
$X2=q#lib/branch#;
$Y2=q#lib/test_value.c#;
$Z2=q#lib/slice::ctors#;
$c3={};
$d3=q#my $s = shift; ni->def($s->name, $s)#;
$e3=bless({$q,$d3,$s,$t},$u);
$f3=q#$_[0]->namespace . ":" . $_[0]->{name}#;
$g3=bless({$q,$f3,$s,$t},$u);
$h3={$D,$g3};
$i3=q#/lib/named.b#;
$j3=bless({$d2,$c3,$J2,$e3,$L2,$K2,$M2,$h3,$D,$i3},$V2);
$k3=q#lib/tag#;
$l3=q#lib/test_value.c#;
$m3=q#lib/slice::ctors#;
$n3={};
$o3=q#namespace#;
$p3=q#'ni'#;
$q3=bless({$q,$p3,$s,$t},$u);
$r3={$o3,$q3};
$s3=q#/lib/named_in_ni.b#;
$t3=bless({$d2,$n3,$J2,$K2,$L2,$K2,$M2,$r3,$D,$s3},$V2);
$u3=q#lib/test_value.c#;
$v3=q#lib/slice::ctors#;
$w3={};
$x3=q#package#;
$y3=q#(my $name = shift->{name}) =~ s/^\\///; $name#;
$z3=bless({$q,$y3,$s,$t},$u);
$A3={$x3,$z3};
$B3=q#/lib/namespaced.b#;
$C3=bless({$d2,$w3,$J2,$K2,$L2,$K2,$M2,$A3,$D,$B3},$V2);
$D3=q#lib/test_value.c#;
$E3=q#lib/slice::ctors#;
$F3={};
$G3=q#resolve#;
$H3=q#ref $_[1] ? $_[1] : ni"ni:$_[1]"#;
$I3=bless({$q,$H3,$s,$t},$u);
$J3={$G3,$I3};
$K3=q#/lib/resolver.b#;
$L3=bless({$d2,$F3,$J2,$K2,$L2,$K2,$M2,$J3,$D,$K3},$V2);
$M3=q#lib/test_value.c#;
$N3=q#lib/slice::ctors#;
$O3=[$W2,$j3,$t3,$C3,$L3];
$P3=bless({$D,$H2,$B2,$O3},$k3);
$Q3=q#lib/tag::ctors#;
$R3={};
$S3=q#my $s = shift; $s->apply($s->package)#;
$T3=bless({$q,$S3,$s,$t},$u);
$U3=q#instantiate#;
$V3=q#local $_;
my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map $class->resolve($_), @slices]};#;
$W3=bless({$q,$V3,$s,$t},$u);
$X3={$U3,$W3};
$Y3=q#/lib/class_init.b#;
$Z3=bless({$d2,$R3,$J2,$T3,$L2,$K2,$M2,$X3,$D,$Y3},$V2);
$c4=q#lib/test_value.c#;
$d4=q#lib/slice::ctors#;
$e4=q#io/cat#;
$f4=q#io/exec#;
$g4=q#io/fd#;
$h4=q#io/file#;
$i4=q#io/object#;
$j4=q#io/pid#;
$k4=q#io/str#;
$l4=q#lib/behavior#;
$m4=q#lib/dataslice#;
$n4=q#lib/image#;
$o4=q#lib/ni#;
$p4=q#lib/test_value#;
$q4=q#lib/test_value.c#;
$r4=q#object#;
$s4={$e2,1,$f2,1,$e4,1,$g2,1,$f4,1,$h2,1,$g4,1,$i2,1,$h4,1,$j2,1,$i4,1,$k2,1,$j4,1,$l2,1,$k4,1,$m2,1,$l4,1,$n2,1,$X2,1,$o2,1,$m4,1,$p2,1,$F,1,$q2,1,$u,1,$r2,1,$n4,1,$s2,1,$o4,1,$t2,1,$V2,1,$u2,1,$k3,1,$v2,1,$p4,1,$q4,1,$D2,1,$x2,1,$E2,1,$y2,1,$r4,1,$z2,1};
$t4=q#/object#;
$u4={};
$v4=q#ni 'ni:/' . ref shift#;
$w4=bless({$q,$v4,$s,$t},$u);
$x4={$e2,$w4};
$y4=q#/lib/instance.b#;
$z4=bless({$d2,$u4,$J2,$K2,$L2,$K2,$M2,$x4,$D,$y4},$V2);
$A4=q#lib/test_value.c#;
$B4=q#lib/slice::ctors#;
$C4=[$z4];
$D4=bless({$d2,$s4,$D,$t4,$B2,$C4},$z2);
$E4=q#object.c::ctors#;
$F4=q#lib/test_value.c#;
$G4={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$l4,1,$n2,1,$X2,1,$o2,1,$m4,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$V2,1,$u2,1,$k3,1,$v2,1,$F4,1,$D2,1,$x2,1,$E2,1,$y2,1,$z2,1};
$H4=q#/lib/behavior#;
$I4={};
$J4=q#my $self = shift;
(my $name = $self->name) =~ s/^[^:]*://;
return ni("ni.doc:$name") if ni->can('exists') && ni->exists("ni.doc:$name");
ni('ni:/lib/doc')->new($name);#;
$K4=bless({$q,$J4,$s,$t},$u);
$L4={$e,$K4};
$M4=q#/lib/documentable.b#;
$N4=bless({$d2,$I4,$J2,$K2,$L2,$K2,$M2,$L4,$D,$M4},$V2);
$O4=q#lib/test_value.c#;
$P4=q#lib/slice::ctors#;
$Q4=[$D4,$N4];
$R4=bless({$d2,$G4,$D,$H4,$B2,$Q4},$n2);
$S4=q#lib/behavior.c::ctors#;
$T4=q#lib/test_value.c#;
$U4={$e2,1,$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$X2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$T4,1,$D2,1,$x2,1,$E2,1,$y2,1,$z2,1};
$V4=q#/lib/definition.b#;
$W4={};
$X4=q#def#;
$Y4=q#shift->add(ni('ni:/lib/slice')->new(@_))#;
$Z4=bless({$q,$Y4,$s,$t},$u);
$c5={$X4,$Z4};
$d5=q#/lib/definition_def.b#;
$e5=bless({$d2,$W4,$J2,$K2,$L2,$K2,$M2,$c5,$D,$d5},$V2);
$f5=q#lib/test_value.c#;
$g5=q#lib/slice::ctors#;
$h5={};
$i5=q#ro#;
$j5=q#my ($self, $slice, @rs) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{shift->{'$_'}}), @rs));#;
$k5=bless({$q,$j5,$s,$t},$u);
$l5=q#rw#;
$m5=q#my ($self, $slice, @as) = @_;
$self->add(ni('ni:/lib/slice')->new(
  $slice,
  map +($_ => fn qq{\\@_ == 2 ? \\$_[0]->{'$_'} = \\$_[1] : shift->{'$_'}}), @as));#;
$n5=bless({$q,$m5,$s,$t},$u);
$o5={$i5,$k5,$l5,$n5};
$p5=q#/lib/accessor.b#;
$q5=bless({$d2,$h5,$J2,$K2,$L2,$K2,$M2,$o5,$D,$p5},$V2);
$r5=q#lib/test_value.c#;
$s5=q#lib/slice::ctors#;
$t5={};
$u5=q#(""#;
$v5=q#shift->name#;
$w5=bless({$q,$v5,$s,$t},$u);
$x5={$u5,$w5};
$y5=q#/lib/name_as_string.b#;
$z5=bless({$d2,$t5,$J2,$K2,$L2,$K2,$M2,$x5,$D,$y5},$V2);
$A5=q#lib/test_value.c#;
$B5=q#lib/slice::ctors#;
$C5={};
$D5=q#(eq#;
$E5=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1]);#;
$F5=bless({$q,$E5,$s,$t},$u);
$G5={$D5,$F5};
$H5=q#/lib/ref_eq.b#;
$I5=bless({$d2,$C5,$J2,$K2,$L2,$K2,$M2,$G5,$D,$H5},$V2);
$J5=q#lib/test_value.c#;
$K5=q#lib/slice::ctors#;
$L5={};
$M5=q#defdata#;
$N5=q#shift->add(ni('ni:/lib/dataslice')->new(@_))#;
$O5=bless({$q,$N5,$s,$t},$u);
$P5={$M5,$O5};
$Q5=q#/lib/definition_defdata.b#;
$R5=bless({$d2,$L5,$J2,$K2,$L2,$K2,$M2,$P5,$D,$Q5},$V2);
$S5=q#lib/test_value.c#;
$T5=q#lib/slice::ctors#;
$U5=[$e5,$q5,$z5,$I5,$R5];
$V5=bless({$d2,$U4,$D,$V4,$B2,$U5},$X2);
$W5=q#lib/branch::ctors#;
$X5=[$P3,$Z3,$D4,$R4,$V5];
$Y5=bless({$d2,$F2,$D,$G2,$B2,$X5},$y2);
$Z5=q#module.c::ctors#;
$c6={};
$d6=q#DESTROY#;
$e6=q#local $_;
my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};#;
$f6=bless({$q,$e6,$s,$t},$u);
$g6=q#new#;
$h6=q#local $_;
my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self) for @{ref($self) . "::ctors"};
$self;#;
$i6=bless({$q,$h6,$s,$t},$u);
$j6={$d6,$f6,$g6,$i6};
$k6=q#/lib/instantiable.b#;
$l6=bless({$d2,$c6,$M2,$j6,$D,$k6},$V2);
$m6=q#lib/test_value.c#;
$n6=q#lib/slice::ctors#;
$o6={};
$p6=q#child#;
$q6=q#my ($self, $name, @slices) = @_;
ni("ni:/metaclass")->new("$name.c", $self->class)
->new($name, $self, @slices);#;
$r6=bless({$q,$q6,$s,$t},$u);
$s6={$p6,$r6};
$t6=q#/lib/subclass.b#;
$u6=bless({$d2,$o6,$J2,$K2,$L2,$K2,$M2,$s6,$D,$t6},$V2);
$v6=q#lib/test_value.c#;
$w6=q#lib/slice::ctors#;
$x6=[$Y5,$l6,$Z3,$Y5,$u6];
$y6=bless({$d2,$A2,$D,$E,$B2,$x6},$f2);
$z6=q#class.c::ctors#;
$A6=q#ni:/class.c#;
$B6={$f2,1};
$C6=q#/class.c#;
$D6={$f2,1,$y2,1};
$E6=q#/module.c#;
$F6=q#lib/test_value.c#;
$G6={$f2,1,$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1,$n2,1,$o2,1,$p2,1,$q2,1,$r2,1,$s2,1,$t2,1,$u2,1,$v2,1,$F6,1,$y2,1,$z2,1};
$H6=q#/object.c#;
$I6=[$y6];
$J6=bless({$d2,$G6,$D,$H6,$B2,$I6},$D2);
$K6=q#metaclass::ctors#;
$L6={$f2,1,$n2,1,$o2,1,$p2,1,$u2,1,$v2,1,$y2,1};
$M6=q#/lib/behavior.c#;
$N6=[$J6];
$O6=bless({$d2,$L6,$D,$M6,$B2,$N6},$D2);
$P6=q#metaclass::ctors#;
$Q6=[$J6,$l6,$O6];
$R6=bless({$d2,$D6,$D,$E6,$B2,$Q6},$D2);
$S6=q#metaclass::ctors#;
$T6=[$R6];
$U6=bless({$d2,$B6,$D,$C6,$B2,$T6},$D2);
$V6=q#metaclass::ctors#;
$W6=q#ni:/io/cat#;
$X6={$e4,1};
$Y6={$e4,1,$f4,1,$g4,1,$h4,1,$i4,1,$j4,1,$k4,1};
$Z6=q#/io/object#;
$c7={};
$d7=q#(bool#;
$e7=[];
$f7=bless({$o,$e7,$q,1,$s,$t},$u);
$g7={$d7,$f7};
$h7=q#/io/object_ops.b#;
$i7=bless({$d2,$c7,$J2,$K2,$L2,$K2,$M2,$g7,$D,$h7},$V2);
$j7=q#lib/slice::ctors#;
$k7={};
$l7=q#into#;
$m7=[];
$n7=q#local $_;
my ($self, $dest, $each) = @_;
my $block_size = $self->can('read_size') ? $self->read_size : 32768;
while ($self->read($_, $block_size)) {
  $dest->write($_);
  &$each($_) && return if defined $each;
}#;
$o7=bless({$o,$m7,$q,$n7,$s,$t},$u);
$p7={$l7,$o7};
$q7=q#/io/object_stream.b#;
$r7=bless({$d2,$k7,$J2,$K2,$L2,$K2,$M2,$p7,$D,$q7},$V2);
$s7=q#lib/slice::ctors#;
$t7={};
$u7=q#io_check#;
$v7=[];
$w7=q#my $self  = shift;
my $check = shift;
my $fn    = shift;
my $r     = &$fn(@_);
$self->die($!) unless &$check($r);
$r;#;
$x7=bless({$o,$v7,$q,$w7,$s,$t},$u);
$y7=q#io_check_defined#;
$z7=[];
$A7=q#shift->io_check(\\&defined, @_)#;
$B7=bless({$o,$z7,$q,$A7,$s,$t},$u);
$C7=q#io_check_true#;
$D7=[];
$E7=q#shift->io_check(sub {shift}, @_)#;
$F7=bless({$o,$D7,$q,$E7,$s,$t},$u);
$G7={$u7,$x7,$y7,$B7,$C7,$F7};
$H7=q#/io/object_checks.b#;
$I7=bless({$d2,$t7,$J2,$K2,$L2,$K2,$M2,$G7,$D,$H7},$V2);
$J7=q#lib/slice::ctors#;
$K7={};
$L7=q#(+#;
$M7=[];
$N7=q#ni('ni:/io/cat')->new(@_[0, 1])#;
$O7=bless({$o,$M7,$q,$N7,$s,$t},$u);
$P7={$L7,$O7};
$Q7=q#/io/object_constructors.b#;
$R7=bless({$d2,$K7,$J2,$K2,$L2,$K2,$M2,$P7,$D,$Q7},$V2);
$S7=q#lib/slice::ctors#;
$T7={};
$U7=q#read_all#;
$V7=[];
$W7=q#shift->into(ni('ni:/io/str')->new(my $data = ''));
$data;#;
$X7=bless({$o,$V7,$q,$W7,$s,$t},$u);
$Y7={$U7,$X7};
$Z7=q#/io/object_memory.b#;
$c8=bless({$d2,$T7,$J2,$K2,$L2,$K2,$M2,$Y7,$D,$Z7},$V2);
$d8=q#lib/slice::ctors#;
$e8=[$D4,$i7,$r7,$I7,$R7,$c8];
$f8=bless({$d2,$Y6,$D,$Z6,$B2,$e8},$k2);
$g8=q#io/object.c::ctors#;
$h8={};
$i8=[];
$j8=q#shift; +{fs => [@_]}#;
$k8=bless({$o,$i8,$q,$j8,$s,$t},$u);
$l8={$U3,$k8};
$m8=q#/io/cat_init.b#;
$n8=bless({$d2,$h8,$J2,$K2,$L2,$K2,$M2,$l8,$D,$m8},$V2);
$o8=q#lib/slice::ctors#;
$p8={};
$q8=q#read#;
$r8=[];
$s8=q#my $fs = shift->{fs};
my $n;
until (!@$fs or $n = $$fs[0]->read(@_)) {
  return $n unless defined $n;
  shift @$fs;
}
return $n;#;
$t8=bless({$o,$r8,$q,$s8,$s,$t},$u);
$u8={$q8,$t8};
$v8=q#/io/cat_read.b#;
$w8=bless({$d2,$p8,$J2,$K2,$L2,$K2,$M2,$u8,$D,$v8},$V2);
$x8=q#lib/slice::ctors#;
$y8=[$f8,$n8,$w8];
$z8=bless({$d2,$X6,$D,$g1,$B2,$y8},$g2);
$A8=q#io/cat.c::ctors#;
$B8=q#ni:/io/cat.c#;
$C8={$g2,1};
$D8=q#/io/cat.c#;
$E8={$g2,1,$h2,1,$i2,1,$j2,1,$k2,1,$l2,1,$m2,1};
$F8=q#/io/object.c#;
$G8=[$J6];
$H8=bless({$d2,$E8,$D,$F8,$B2,$G8},$D2);
$I8=q#metaclass::ctors#;
$J8=[$H8];
$K8=bless({$d2,$C8,$D,$D8,$B2,$J8},$D2);
$L8=q#metaclass::ctors#;
$M8=q#ni:/io/cat_init.b#;
$N8=q#ni:/io/cat_read.b#;
$O8=q#ni:/io/exec#;
$P8={$f4,1};
$Q8={};
$R8=q#argv#;
$S8=[];
$T8=q#shift->{'argv'}#;
$U8=bless({$o,$S8,$q,$T8,$s,$t},$u);
$V8={$R8,$U8};
$W8=q#/io/exec_ro.b#;
$X8=bless({$d2,$Q8,$J2,$K2,$L2,$K2,$M2,$V8,$D,$W8},$V2);
$Y8=q#lib/slice::ctors#;
$Z8={};
$c9=[];
$d9=q#my ($class, @argv) = @_;
+{argv         => \\@argv,
  env          => {%ENV},
  internal_fds => {},
  external_fds => {}};#;
$e9=bless({$o,$c9,$q,$d9,$s,$t},$u);
$f9={$U3,$e9};
$g9=q#/io/exec_init.b#;
$h9=bless({$d2,$Z8,$J2,$K2,$L2,$K2,$M2,$f9,$D,$g9},$V2);
$i9=q#lib/slice::ctors#;
$j9={};
$k9=q#connect#;
$l9=[];
$m9=q#my ($self, %fds) = @_;
@{$$self{internal_fds}}{keys %fds} = values %fds;
$self;#;
$n9=bless({$o,$l9,$q,$m9,$s,$t},$u);
$o9=q#in_pipe#;
$p9=[];
$q9=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(1);
}
$self;#;
$r9=bless({$o,$p9,$q,$q9,$s,$t},$u);
$s9=q#out_pipe#;
$t9=[];
$u9=q#local $_;
my $self = shift;
for (@_) {
  my ($r, $w) = POSIX::pipe;
  $self->die($!) unless defined $r;
  $$self{internal_fds}{$_} = ni('ni:/io/fd')->new($w)->cloexec(0);
  $$self{external_fds}{$_} = ni('ni:/io/fd')->new($r)->cloexec(1);
}
$self;#;
$v9=bless({$o,$t9,$q,$u9,$s,$t},$u);
$w9=q#setup_stdio#;
$x9=[];
$y9=q#my $self = shift;
$self->in_pipe(0) unless $$self{internal_fds}{0};
$self->out_pipe(1) unless $$self{external_fds}{1};
$self->out_pipe(2) unless $$self{external_fds}{2};
$self;#;
$z9=bless({$o,$x9,$q,$y9,$s,$t},$u);
$A9={$k9,$n9,$o9,$r9,$s9,$v9,$w9,$z9};
$B9=q#/io/exec_io_setup.b#;
$C9=bless({$d2,$j9,$J2,$K2,$L2,$K2,$M2,$A9,$D,$B9},$V2);
$D9=q#lib/slice::ctors#;
$E9={};
$F9=q#binds_fd#;
$G9=[];
$H9=q#my ($self, $fd) = @_;
$$self{internal_fds}{$fd};#;
$I9=bless({$o,$G9,$q,$H9,$s,$t},$u);
$J9=q#fd#;
$K9=[];
$L9=q#my ($self, $fd) = @_;
$$self{external_fds}{$fd};#;
$M9=bless({$o,$K9,$q,$L9,$s,$t},$u);
$N9=q#stderr#;
$O9=[];
$P9=q#my $self = shift;
$self->binds_fd(2) ? $self->fd(2) : $self->out_pipe(2)->fd(2);#;
$Q9=bless({$o,$O9,$q,$P9,$s,$t},$u);
$R9=q#stdin#;
$S9=[];
$T9=q#my $self = shift;
$self->binds_fd(0) ? $self->fd(0) : $self->in_pipe(0)->fd(0);#;
$U9=bless({$o,$S9,$q,$T9,$s,$t},$u);
$V9=q#stdout#;
$W9=[];
$X9=q#my $self = shift;
$self->binds_fd(1) ? $self->fd(1) : $self->out_pipe(1)->fd(1);#;
$Y9=bless({$o,$W9,$q,$X9,$s,$t},$u);
$Z9={$F9,$I9,$J9,$M9,$N9,$Q9,$R9,$U9,$V9,$Y9};
$ca=q#/io/exec_io_accessors.b#;
$da=bless({$d2,$E9,$J2,$K2,$L2,$K2,$M2,$Z9,$D,$ca},$V2);
$ea=q#lib/slice::ctors#;
$fa={};
$ga=q#env#;
$ha=[];
$ia=q#my ($self, %env) = @_;
return $$self{env} unless keys %env;
@{$$self{env}}{keys %env} = values %env;
$self;#;
$ja=bless({$o,$ha,$q,$ia,$s,$t},$u);
$ka={$ga,$ja};
$la=q#/io/exec_env.b#;
$ma=bless({$d2,$fa,$J2,$K2,$L2,$K2,$M2,$ka,$D,$la},$V2);
$na=q#lib/slice::ctors#;
$oa={};
$pa=q#exec#;
$qa=[];
$ra=q#my $self = shift->setup_stdio->move_fds;
delete $$self{external_fds};
local %ENV = %{$$self{env}};
my @argv = (@{$$self{argv}}, @_);
{ exec @argv };
$self->die_over_stderr("exec failed", $!);
exit 1;#;
$sa=bless({$o,$qa,$q,$ra,$s,$t},$u);
$ta=q#fork#;
$ua=[];
$va=q#my $self = shift->setup_stdio;
my $pid = $self->io_check_defined(\\&fork);
return $self->exec(@_) unless $pid;
delete $$self{internal_pids};
ni('ni:/io/pid')->new($pid, %{$$self{external_fds}});#;
$wa=bless({$o,$ua,$q,$va,$s,$t},$u);
$xa=q#move_fds#;
$ya=[];
$za=q#my $self = shift;
$$self{internal_fds}{$_}->be($_) for keys %{$$self{fds}};
$self;#;
$Aa=bless({$o,$ya,$q,$za,$s,$t},$u);
$Ba={$pa,$sa,$ta,$wa,$xa,$Aa};
$Ca=q#/io/exec_fork.b#;
$Da=bless({$d2,$oa,$J2,$K2,$L2,$K2,$M2,$Ba,$D,$Ca},$V2);
$Ea=q#lib/slice::ctors#;
$Fa=[$f8,$X8,$h9,$C9,$da,$ma,$Da];
$Ga=bless({$d2,$P8,$D,$s1,$B2,$Fa},$h2);
$Ha=q#io/exec.c::ctors#;
$Ia=q#ni:/io/exec.c#;
$Ja={$h2,1};
$Ka=q#/io/exec.c#;
$La=[$H8];
$Ma=bless({$d2,$Ja,$D,$Ka,$B2,$La},$D2);
$Na=q#metaclass::ctors#;
$Oa=q#ni:/io/exec_env.b#;
$Pa=q#ni:/io/exec_fork.b#;
$Qa=q#ni:/io/exec_init.b#;
$Ra=q#ni:/io/exec_io_accessors.b#;
$Sa=q#ni:/io/exec_io_setup.b#;
$Ta=q#ni:/io/exec_ro.b#;
$Ua=q#ni:/io/fd#;
$Va={$g4,1};
$Wa=q#/io/fd#;
$Xa={};
$Ya=[];
$Za=q#shift->{'fd'}#;
$cb=bless({$o,$Ya,$q,$Za,$s,$t},$u);
$db={$J9,$cb};
$eb=q#/io/fd_readers.b#;
$fb=bless({$d2,$Xa,$J2,$K2,$L2,$K2,$M2,$db,$D,$eb},$V2);
$gb=q#lib/slice::ctors#;
$hb={};
$ib=[];
$jb=q#my ($class, $fd) = @_;
+{fd  => ref $fd ? fileno $fd : $fd,
  rfh => undef,
  wfh => undef};#;
$kb=bless({$o,$ib,$q,$jb,$s,$t},$u);
$lb={$U3,$kb};
$mb=q#/io/fd_init.b#;
$nb=bless({$d2,$hb,$J2,$K2,$L2,$K2,$M2,$lb,$D,$mb},$V2);
$ob=q#lib/slice::ctors#;
$pb={};
$qb=q#be#;
$rb=[];
$sb=q#my ($self, $new) = @_;
return $self if $new == $$self{fd};
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
$$self{rfh} = $$self{wfh} = undef;
$self->io_check_defined(\\&POSIX::dup2, $$self{fd}, $new);
POSIX::close $$self{fd};
$$self{fd} = $new;
$self;#;
$tb=bless({$o,$rb,$q,$sb,$s,$t},$u);
$ub={$qb,$tb};
$vb=q#/io/fd_shell.b#;
$wb=bless({$d2,$pb,$J2,$K2,$L2,$K2,$M2,$ub,$D,$vb},$V2);
$xb=q#lib/slice::ctors#;
$yb={};
$zb=q#cloexec#;
$Ab=[];
$Bb=q#shift->fcntl_flag(Fcntl::FD_CLOEXEC, @_)#;
$Cb=bless({$o,$Ab,$q,$Bb,$s,$t},$u);
$Db=q#fcntl_flag#;
$Eb=[];
$Fb=q#my ($self, $flag, $value) = @_;
$self->errno_if_undef(\\&open, $$self{rfh}, "<&=$$self{fd}")
  unless $$self{rfh};
my $flags = $self->errno_if_false(
  \\&fcntl, $$self{rfh}, Fcntl::F_GETFL, 0);
if (@_) {
  shift ? $flags |= $flag : $flags &= ~$flag;
  $self->errno_if_false(\\&fcntl, $$self{rfh}, Fcntl::F_SETFL, $flags);
  $self;
} else {
  !!($flags & $flag);
}#;
$Gb=bless({$o,$Eb,$q,$Fb,$s,$t},$u);
$Hb=q#nonblock#;
$Ib=[];
$Jb=q#shift->fcntl_flag(Fcntl::O_NONBLOCK, @_)#;
$Kb=bless({$o,$Ib,$q,$Jb,$s,$t},$u);
$Lb={$zb,$Cb,$Db,$Gb,$Hb,$Kb};
$Mb=q#/io/fd_fcntl.b#;
$Nb=bless({$d2,$yb,$J2,$K2,$L2,$K2,$M2,$Lb,$D,$Mb},$V2);
$Ob=q#lib/slice::ctors#;
$Pb={};
$Qb=[];
$Rb=q#shift->close#;
$Sb=bless({$o,$Qb,$q,$Rb,$s,$t},$u);
$Tb=q#close#;
$Ub=[];
$Vb=q#my $self = shift;
return $self if $$self{closed};
close $$self{rfh} if $$self{rfh};
close $$self{wfh} if $$self{wfh};
POSIX::close $$self{fd};
$$self{fd} = $$self{rfh} = $$self{wfh} = undef;
$self;#;
$Wb=bless({$o,$Ub,$q,$Vb,$s,$t},$u);
$Xb={$Tb,$Wb};
$Yb=q#/io/fd_gc.b#;
$Zb=bless({$d2,$Pb,$J2,$K2,$L2,$Sb,$M2,$Xb,$D,$Yb},$V2);
$cc=q#lib/slice::ctors#;
$dc={};
$ec=[];
$fc=q#my $self = shift;
open $$self{rfh}, "<&=$$self{fd}" or return undef unless $$self{rfh};
my $r;
do {
  return $r if defined($r = sysread $$self{rfh}, $_[0], $_[1], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$gc=bless({$o,$ec,$q,$fc,$s,$t},$u);
$hc=q#write#;
$ic=[];
$jc=q#my $self = shift;
open $$self{wfh}, ">&=$$self{fd}" or return undef unless $$self{wfh};
my $r;
do {
  return $r if defined($r = syswrite $$self{wfh}, $_[0], $_[1] || length $_[0], $_[2] || 0);
} while ($!{EINTR});
$r;#;
$kc=bless({$o,$ic,$q,$jc,$s,$t},$u);
$lc={$q8,$gc,$hc,$kc};
$mc=q#/io/fd_perlio.b#;
$nc=bless({$d2,$dc,$J2,$K2,$L2,$K2,$M2,$lc,$D,$mc},$V2);
$oc=q#lib/slice::ctors#;
$pc=[$f8,$fb,$nb,$wb,$Nb,$Zb,$nc];
$qc=bless({$d2,$Va,$D,$Wa,$B2,$pc},$i2);
$rc=q#io/fd.c::ctors#;
$sc=q#ni:/io/fd.c#;
$tc={$i2,1};
$uc=q#/io/fd.c#;
$vc=[$H8];
$wc=bless({$d2,$tc,$D,$uc,$B2,$vc},$D2);
$xc=q#metaclass::ctors#;
$yc=q#ni:/io/fd_fcntl.b#;
$zc=q#ni:/io/fd_gc.b#;
$Ac=q#ni:/io/fd_init.b#;
$Bc=q#ni:/io/fd_perlio.b#;
$Cc=q#ni:/io/fd_readers.b#;
$Dc=q#ni:/io/fd_shell.b#;
$Ec=q#ni:/io/file#;
$Fc={$h4,1};
$Gc=q#/io/file#;
$Hc={};
$Ic=[];
$Jc=q#shift->{'name'}#;
$Kc=bless({$o,$Ic,$q,$Jc,$s,$t},$u);
$Lc={$D,$Kc};
$Mc=q#/io/file_readers.b#;
$Nc=bless({$d2,$Hc,$J2,$K2,$L2,$K2,$M2,$Lc,$D,$Mc},$V2);
$Oc=q#lib/slice::ctors#;
$Pc={};
$Qc=q#mode#;
$Rc=[];
$Sc=q#@_ == 2 ? $_[0]->{'mode'} = $_[1] : shift->{'mode'}#;
$Tc=bless({$o,$Rc,$q,$Sc,$s,$t},$u);
$Uc={$Qc,$Tc};
$Vc=q#/io/file_accessors.b#;
$Wc=bless({$d2,$Pc,$J2,$K2,$L2,$K2,$M2,$Uc,$D,$Vc},$V2);
$Xc=q#lib/slice::ctors#;
$Yc={};
$Zc=[];
$cd=q#my ($class, $name, $mode) = @_;
+{name => $name,
  mode => $mode || 0644,
  r    => undef,
  w    => undef};#;
$dd=bless({$o,$Zc,$q,$cd,$s,$t},$u);
$ed={$U3,$dd};
$fd=q#/io/file_init.b#;
$gd=bless({$d2,$Yc,$J2,$K2,$L2,$K2,$M2,$ed,$D,$fd},$V2);
$hd=q#lib/slice::ctors#;
$id={};
$jd=q#r#;
$kd=[];
$ld=q#my $self = shift;
return $$self{r} if defined $$self{r};
$$self{r} = ni('ni:/io/fd')->new(
  $self->io_check_defined(
    \\&POSIX::open, $$self{name}, POSIX::O_RDONLY));#;
$md=bless({$o,$kd,$q,$ld,$s,$t},$u);
$nd=[];
$od=q#shift->r->read(@_)#;
$pd=bless({$o,$nd,$q,$od,$s,$t},$u);
$qd=q#w#;
$rd=[];
$sd=q#my $self = shift;
return $$self{w} if defined $$self{w};
$$self{w} = ni('ni:/io/fd')->new(
  $self->io_check_defined(
    \\&POSIX::open, $$self{name},
      POSIX::O_WRONLY | POSIX::O_TRUNC | POSIX::O_CREAT,
      $$self{mode}));#;
$td=bless({$o,$rd,$q,$sd,$s,$t},$u);
$ud=[];
$vd=q#shift->w->write(@_)#;
$wd=bless({$o,$ud,$q,$vd,$s,$t},$u);
$xd={$jd,$md,$q8,$pd,$qd,$td,$hc,$wd};
$yd=q#/io/file_io.b#;
$zd=bless({$d2,$id,$J2,$K2,$L2,$K2,$M2,$xd,$D,$yd},$V2);
$Ad=q#lib/slice::ctors#;
$Bd=[$f8,$Nc,$Wc,$gd,$zd];
$Cd=bless({$d2,$Fc,$D,$Gc,$B2,$Bd},$j2);
$Dd=q#io/file.c::ctors#;
$Ed=q#ni:/io/file.c#;
$Fd={$j2,1};
$Gd=q#/io/file.c#;
$Hd=[$H8];
$Id=bless({$d2,$Fd,$D,$Gd,$B2,$Hd},$D2);
$Jd=q#metaclass::ctors#;
$Kd=q#ni:/io/file_accessors.b#;
$Ld=q#ni:/io/file_init.b#;
$Md=q#ni:/io/file_io.b#;
$Nd=q#ni:/io/file_readers.b#;
$Od=q#ni:/io/object#;
$Pd=q#ni:/io/object.c#;
$Qd=q#ni:/io/object_checks.b#;
$Rd=q#ni:/io/object_constructors.b#;
$Sd=q#ni:/io/object_memory.b#;
$Td=q#ni:/io/object_ops.b#;
$Ud=q#ni:/io/object_stream.b#;
$Vd=q#ni:/io/pid#;
$Wd={$j4,1};
$Xd={};
$Yd=q#pid#;
$Zd=[];
$ce=q#shift->{'pid'}#;
$de=bless({$o,$Zd,$q,$ce,$s,$t},$u);
$ee=q#status#;
$fe=[];
$ge=q#shift->{'status'}#;
$he=bless({$o,$fe,$q,$ge,$s,$t},$u);
$ie={$Yd,$de,$ee,$he};
$je=q#/io/pid_readers.b#;
$ke=bless({$d2,$Xd,$J2,$K2,$L2,$K2,$M2,$ie,$D,$je},$V2);
$le=q#lib/slice::ctors#;
$me={};
$ne=[];
$oe=q#shift->await#;
$pe=bless({$o,$ne,$q,$oe,$s,$t},$u);
$qe=[];
$re=q#my ($class, $pid, %external_fds) = @_;
+{pid          => $pid,
  external_fds => \\%external_fds,
  status       => undef};#;
$se=bless({$o,$qe,$q,$re,$s,$t},$u);
$te={$U3,$se};
$ue=q#/io/pid_init.b#;
$ve=bless({$d2,$me,$J2,$K2,$L2,$pe,$M2,$te,$D,$ue},$V2);
$we=q#lib/slice::ctors#;
$xe={};
$ye=q#await#;
$ze=[];
$Ae=q#my $self = shift;
return $$self{status} if defined $$self{status};
$self->io_check_defined(\\&waitpid, $$self{pid}, 0);
$$self{status} = $?;#;
$Be=bless({$o,$ze,$q,$Ae,$s,$t},$u);
$Ce=q#running#;
$De=[];
$Ee=q#not defined $_[0]->{status} and kill 0, $_[0]->{pid}#;
$Fe=bless({$o,$De,$q,$Ee,$s,$t},$u);
$Ge={$ye,$Be,$Ce,$Fe};
$He=q#/io/pid_wait.b#;
$Ie=bless({$d2,$xe,$J2,$K2,$L2,$K2,$M2,$Ge,$D,$He},$V2);
$Je=q#lib/slice::ctors#;
$Ke={};
$Le=[];
$Me=q#shift->stdout->read(@_)#;
$Ne=bless({$o,$Le,$q,$Me,$s,$t},$u);
$Oe=[];
$Pe=q#shift->stdin->write(@_)#;
$Qe=bless({$o,$Oe,$q,$Pe,$s,$t},$u);
$Re={$q8,$Ne,$hc,$Qe};
$Se=q#/io/pid_io.b#;
$Te=bless({$d2,$Ke,$J2,$K2,$L2,$K2,$M2,$Re,$D,$Se},$V2);
$Ue=q#lib/slice::ctors#;
$Ve={};
$We=[];
$Xe=q#$_[0]->{external_fds}{$_[1]}#;
$Ye=bless({$o,$We,$q,$Xe,$s,$t},$u);
$Ze=[];
$cf=q#shift->fd(2)#;
$df=bless({$o,$Ze,$q,$cf,$s,$t},$u);
$ef=[];
$ff=q#shift->fd(0)#;
$gf=bless({$o,$ef,$q,$ff,$s,$t},$u);
$hf=[];
$if=q#shift->fd(1)#;
$jf=bless({$o,$hf,$q,$if,$s,$t},$u);
$kf={$J9,$Ye,$N9,$df,$R9,$gf,$V9,$jf};
$lf=q#/io/pid_accessors.b#;
$mf=bless({$d2,$Ve,$J2,$K2,$L2,$K2,$M2,$kf,$D,$lf},$V2);
$nf=q#lib/slice::ctors#;
$of=[$f8,$ke,$ve,$Ie,$Te,$mf];
$pf=bless({$d2,$Wd,$D,$I1,$B2,$of},$l2);
$qf=q#io/pid.c::ctors#;
$rf=q#ni:/io/pid.c#;
$sf={$l2,1};
$tf=q#/io/pid.c#;
$uf=[$H8];
$vf=bless({$d2,$sf,$D,$tf,$B2,$uf},$D2);
$wf=q#metaclass::ctors#;
$xf=q#ni:/io/pid_accessors.b#;
$yf=q#ni:/io/pid_init.b#;
$zf=q#ni:/io/pid_io.b#;
$Af=q#ni:/io/pid_readers.b#;
$Bf=q#ni:/io/pid_wait.b#;
$Cf=q#ni:/io/str#;
$Df={$k4,1};
$Ef=q#/io/str#;
$Ff={};
$Gf=q#data#;
$Hf=[];
$If=q#shift->{'data'}#;
$Jf=bless({$o,$Hf,$q,$If,$s,$t},$u);
$Kf=q#end#;
$Lf=[];
$Mf=q#shift->{'end'}#;
$Nf=bless({$o,$Lf,$q,$Mf,$s,$t},$u);
$Of=q#start#;
$Pf=[];
$Qf=q#shift->{'start'}#;
$Rf=bless({$o,$Pf,$q,$Qf,$s,$t},$u);
$Sf={$Gf,$Jf,$Kf,$Nf,$Of,$Rf};
$Tf=q#/io/str_ro.b#;
$Uf=bless({$d2,$Ff,$J2,$K2,$L2,$K2,$M2,$Sf,$D,$Tf},$V2);
$Vf=q#lib/slice::ctors#;
$Wf={};
$Xf=[];
$Yf=q#my $class = shift;
+{data  => \\$_[0],
  start => $_[1] || 0,
  end   => $_[2] || length $_[0]};#;
$Zf=bless({$o,$Xf,$q,$Yf,$s,$t},$u);
$cg={$U3,$Zf};
$dg=q#/io/str_init.b#;
$eg=bless({$d2,$Wf,$J2,$K2,$L2,$K2,$M2,$cg,$D,$dg},$V2);
$fg=q#lib/slice::ctors#;
$gg={};
$hg=[];
$ig=q#my $self = shift;
return 0 if $$self{start} >= $$self{end};
my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
if (@_ == 3) {
  substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
} else {
  $_[0] = substr ${$$self{data}}, $$self{start}, $l;
}
$$self{start} += $l;
$l;#;
$jg=bless({$o,$hg,$q,$ig,$s,$t},$u);
$kg=q#remaining#;
$lg=[];
$mg=q#my $self = shift; $$self{end} - $$self{start}#;
$ng=bless({$o,$lg,$q,$mg,$s,$t},$u);
$og=[];
$pg=q#my $self = shift;
${$$self{data}} .= $_[0];
$$self{start} += length $_[0];
$$self{end} = length ${$$self{data}};
length $_[0];#;
$qg=bless({$o,$og,$q,$pg,$s,$t},$u);
$rg={$q8,$jg,$kg,$ng,$hc,$qg};
$sg=q#/io/str_io.b#;
$tg=bless({$d2,$gg,$J2,$K2,$L2,$K2,$M2,$rg,$D,$sg},$V2);
$ug=q#lib/slice::ctors#;
$vg=[$f8,$Uf,$eg,$tg];
$wg=bless({$d2,$Df,$D,$Ef,$B2,$vg},$m2);
$xg=q#io/str.c::ctors#;
$yg=q#ni:/io/str.c#;
$zg={$m2,1};
$Ag=q#/io/str.c#;
$Bg=[$H8];
$Cg=bless({$d2,$zg,$D,$Ag,$B2,$Bg},$D2);
$Dg=q#metaclass::ctors#;
$Eg=q#ni:/io/str_init.b#;
$Fg=q#ni:/io/str_io.b#;
$Gg=q#ni:/io/str_ro.b#;
$Hg=q#ni:/lib/accessor.b#;
$Ig=q#ni:/lib/behavior#;
$Jg=q#ni:/lib/behavior.c#;
$Kg=q#ni:/lib/branch#;
$Lg={$X2,1};
$Mg=q#/lib/branch#;
$Ng={};
$Og=q#local $_;
my $class = shift;
my $name  = shift;
+{name       => $name,
  applied_to => {},
  slices     => [map $class->resolve($_), @_]};#;
$Pg=bless({$q,$Og,$s,$t},$u);
$Qg={$U3,$Pg};
$Rg=q#/lib/branch_init.b#;
$Sg=bless({$d2,$Ng,$J2,$K2,$L2,$K2,$M2,$Qg,$D,$Rg},$V2);
$Tg=q#lib/slice::ctors#;
$Ug=[$R4,$j3,$W2,$Sg,$V5];
$Vg=bless({$d2,$Lg,$D,$Mg,$B2,$Ug},$o2);
$Wg=q#lib/branch.c::ctors#;
$Xg=q#ni:/lib/branch.b#;
$Yg=q#ni:/lib/branch.c#;
$Zg={$o2,1};
$ch=q#/lib/branch.c#;
$dh=[$O6];
$eh=bless({$d2,$Zg,$D,$ch,$B2,$dh},$D2);
$fh=q#metaclass::ctors#;
$gh=q#ni:/lib/branch_init.b#;
$hh=q#ni:/lib/class_init.b#;
$ih=q#ni:/lib/dataslice#;
$jh={$m4,1};
$kh=q#/lib/dataslice#;
$lh={};
$mh=q#my $class = shift;
my $name = shift;
+{name => $name, data => {@_}};#;
$nh=bless({$q,$mh,$s,$t},$u);
$oh={$U3,$nh};
$ph=q#/lib/dataslice_init.b#;
$qh=bless({$d2,$lh,$J2,$K2,$L2,$K2,$M2,$oh,$D,$ph},$V2);
$rh=q#lib/slice::ctors#;
$sh={};
$th=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
*{"$p\\::$_"} = $$self{data}{$_} for keys %{$$self{data}};
$self;#;
$uh=bless({$q,$th,$s,$t},$u);
$vh={$Q2,$uh};
$wh=q#/lib/dataslice_apply.b#;
$xh=bless({$d2,$sh,$J2,$K2,$L2,$K2,$M2,$vh,$D,$wh},$V2);
$yh=q#lib/slice::ctors#;
$zh=[$R4,$qh,$xh];
$Ah=bless({$d2,$jh,$D,$kh,$B2,$zh},$p2);
$Bh=q#lib/dataslice.c::ctors#;
$Ch=q#ni:/lib/dataslice.c#;
$Dh={$p2,1};
$Eh=q#/lib/dataslice.c#;
$Fh=[$O6];
$Gh=bless({$d2,$Dh,$D,$Eh,$B2,$Fh},$D2);
$Hh=q#metaclass::ctors#;
$Ih=q#ni:/lib/dataslice_apply.b#;
$Jh=q#ni:/lib/dataslice_init.b#;
$Kh=q#ni:/lib/definition.b#;
$Lh=q#ni:/lib/definition_def.b#;
$Mh=q#ni:/lib/definition_defdata.b#;
$Nh=q#ni:/lib/doc#;
$Oh={$F,1};
$Ph={};
$Qh=q#shift; +{name => shift, doc => []}#;
$Rh=bless({$q,$Qh,$s,$t},$u);
$Sh={$U3,$Rh};
$Th=q#/lib/doc_init.b#;
$Uh=bless({$d2,$Ph,$J2,$K2,$L2,$K2,$M2,$Sh,$D,$Th},$V2);
$Vh=q#lib/slice::ctors#;
$Wh={};
$Xh=q#'ni.doc'#;
$Yh=bless({$q,$Xh,$s,$t},$u);
$Zh={$o3,$Yh};
$ci=q#/lib/doc_namespace.b#;
$di=bless({$d2,$Wh,$J2,$K2,$L2,$K2,$M2,$Zh,$D,$ci},$V2);
$ei=q#lib/slice::ctors#;
$fi={};
$gi=q#AUTOLOAD#;
$hi=q#my $self = shift;
(my $method = ${__PACKAGE__ . "::AUTOLOAD"}) =~ s/^.*:://;
push @{$$self{doc}}, [$method, @_];
$self;#;
$ii=bless({$q,$hi,$s,$t},$u);
$ji={$gi,$ii};
$ki=q#/lib/doc_define.b#;
$li=bless({$d2,$fi,$J2,$K2,$L2,$K2,$M2,$ji,$D,$ki},$V2);
$mi=q#lib/slice::ctors#;
$ni={};
$oi=q#my $self = shift;
push @{$$self{doc}}, [eg => $_] for @_;
$self;#;
$pi=bless({$q,$oi,$s,$t},$u);
$qi=q#tests#;
$ri=q#my $self = shift;
my @flattened = map @$_, @{$$self{doc}};
my @tests;
return () unless @flattened;
for (0..$\#flattened - 1) {
  push @tests, $flattened[$_ + 1]
    if !ref $flattened[$_] && $flattened[$_] eq 'eg';
}
@tests;#;
$si=bless({$q,$ri,$s,$t},$u);
$ti={$n,$pi,$qi,$si};
$ui=q#/lib/doc_test.b#;
$vi=bless({$d2,$ni,$J2,$K2,$L2,$K2,$M2,$ti,$D,$ui},$V2);
$wi=q#lib/slice::ctors#;
$xi=[$D4,$j3,$Uh,$di,$li,$vi];
$yi=bless({$d2,$Oh,$D,$Y1,$B2,$xi},$q2);
$zi=q#lib/doc.c::ctors#;
$Ai=q#ni:/lib/doc.c#;
$Bi={$q2,1};
$Ci=q#/lib/doc.c#;
$Di=[$J6];
$Ei=bless({$d2,$Bi,$D,$Ci,$B2,$Di},$D2);
$Fi=q#metaclass::ctors#;
$Gi=q#ni:/lib/doc_define.b#;
$Hi=q#ni:/lib/doc_init.b#;
$Ii=q#ni:/lib/doc_namespace.b#;
$Ji=q#ni:/lib/doc_test.b#;
$Ki=q#ni:/lib/documentable.b#;
$Li=q#ni:/lib/fn#;
$Mi={$u,1};
$Ni=q#/lib/fn#;
$Oi={};
$Pi=q#shift->compile#;
$Qi=bless({$q,$Pi,$s,$t},$u);
$Ri=q#compile#;
$Si=q#local $@;
my $self = shift;
$$self{proto} ||= '';
$$self{fn} = ni::eval "sub $$self{proto} {$$self{code}\\n}";
die "ni:/lib/fn: failed to compile $$self{code}: $@" if $@;
$$self{fn};#;
$Ti=bless({$q,$Si,$s,$t},$u);
$Ui=q#my $class = shift;
my $code  = pop;
my $proto = @_ && $_[-1] =~ /^\\(/ ? pop : '';
+{code        => $code,
  proto       => $proto,
  annotations => [@_]};#;
$Vi=bless({$q,$Ui,$s,$t},$u);
$Wi={$Ri,$Ti,$U3,$Vi};
$Xi=q#/lib/fn_init.b#;
$Yi=bless({$d2,$Oi,$J2,$Qi,$L2,$K2,$M2,$Wi,$D,$Xi},$V2);
$Zi=q#lib/slice::ctors#;
$cj={};
$dj=[];
$ej=q#shift->{'annotations'}#;
$fj=bless({$o,$dj,$q,$ej,$s,$t},$u);
$gj=[];
$hj=q#shift->{'code'}#;
$ij=bless({$o,$gj,$q,$hj,$s,$t},$u);
$jj=q#fn#;
$kj=[];
$lj=q#shift->{'fn'}#;
$mj=bless({$o,$kj,$q,$lj,$s,$t},$u);
$nj={$o,$fj,$q,$ij,$jj,$mj};
$oj=q#/lib/fn_ro.b#;
$pj=bless({$d2,$cj,$J2,$K2,$L2,$K2,$M2,$nj,$D,$oj},$V2);
$qj=q#lib/slice::ctors#;
$rj={};
$sj=[];
$tj=q#shift->{code}#;
$uj=bless({$o,$sj,$q,$tj,$s,$t},$u);
$vj=[];
$wj=q#ref($_[0]) eq ref($_[1])
  and Scalar::Util::refaddr($_[0]) == Scalar::Util::refaddr($_[1])#;
$xj=bless({$o,$vj,$q,$wj,$s,$t},$u);
$yj={$u5,$uj,$D5,$xj};
$zj=q#/lib/fn_ops.b#;
$Aj=bless({$d2,$rj,$J2,$K2,$L2,$K2,$M2,$yj,$D,$zj},$V2);
$Bj=q#lib/slice::ctors#;
$Cj={};
$Dj=q#serialize#;
$Ej=[];
$Fj=q#local $_;
my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*\\n|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^([ \\t]*)\\S/ && length $1 < $spaces;
}
$spaces = ' ' x $spaces;
s/^$spaces// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);#;
$Gj=bless({$o,$Ej,$q,$Fj,$s,$t},$u);
$Hj={$Dj,$Gj};
$Ij=q#/lib/fn_serialize.b#;
$Jj=bless({$d2,$Cj,$J2,$K2,$L2,$K2,$M2,$Hj,$D,$Ij},$V2);
$Kj=q#lib/slice::ctors#;
$Lj=[$D4,$l6,$Yi,$pj,$Aj,$Jj];
$Mj=bless({$d2,$Mi,$D,$Ni,$B2,$Lj},$r2);
$Nj=q#lib/fn.c::ctors#;
$Oj=q#ni:/lib/fn.c#;
$Pj={$r2,1};
$Qj=q#/lib/fn.c#;
$Rj=[$J6];
$Sj=bless({$d2,$Pj,$D,$Qj,$B2,$Rj},$D2);
$Tj=q#metaclass::ctors#;
$Uj=q#ni:/lib/fn_init.b#;
$Vj=q#ni:/lib/fn_ops.b#;
$Wj=q#ni:/lib/fn_ro.b#;
$Xj=q#ni:/lib/fn_serialize.b#;
$Yj=q#ni:/lib/global_static_test.b#;
$Zj={};
$ck=q#now#;
$dk=[];
$ek=q#ni('ni:/lib/test_value')->new(shift)#;
$fk=q#($)#;
$gk=bless({$o,$dk,$q,$ek,$s,$fk},$u);
$hk={$ck,$gk};
$ik=q#/lib/global_static_test.b#;
$jk=bless({$d2,$Zj,$J2,$K2,$L2,$K2,$M2,$hk,$D,$ik},$V2);
$kk=q#main#;
$lk=q#lib/slice::ctors#;
$mk=q#ni:/lib/image#;
$nk={$n4,1};
$ok=q#/lib/image#;
$pk={};
$qk=[];
$rk=q#my $class = shift;
my %args  = (
  include_shebang => 1,
  include_license => 1,
  include_boot    => 1,
  include_classes => 1,
  include_run     => 1,
  local_vars      => 0,
  use_newlines    => 0,
  @_);

+{include_shebang => $args{include_shebang},
  include_license => $args{include_license},
  include_boot    => $args{include_boot},
  include_classes => $args{include_classes},
  include_run     => $args{include_run},
  local_vars      => $args{local_vars},
  use_newlines    => $args{use_newlines},

  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  objects      => {},
  side_effects => [],
  finalizers   => [],
  visited      => {},
  ordering     => []};#;
$sk=bless({$o,$qk,$q,$rk,$s,$t},$u);
$tk={$U3,$sk};
$uk=q#/lib/image_init.b#;
$vk=bless({$d2,$pk,$J2,$K2,$L2,$K2,$M2,$tk,$D,$uk},$V2);
$wk=q#lib/slice::ctors#;
$xk={};
$yk=q#address#;
$zk=[];
$Ak=q#return 'undef' unless defined $_[1];
return "id:$_[1]" if !ref $_[1] && length $_[1] < 16;
"addr:" . Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);#;
$Bk=bless({$o,$zk,$q,$Ak,$s,$t},$u);
$Ck=q#allocate_gensym#;
$Dk=[];
$Ek=q#my $self = shift;
my $a = $self->address(shift);
return $$self{visited}{$a} if $_[0] =~ /^\\$\\w+$/;
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = $$self{local_vars} ? "my$g=$_[0];" : "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;#;
$Fk=bless({$o,$Dk,$q,$Ek,$s,$t},$u);
$Gk=q#boot_side_effect#;
$Hk=[];
$Ik=q#unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Jk=bless({$o,$Hk,$q,$Ik,$s,$t},$u);
$Kk=q#circular_links#;
$Lk=[];
$Mk=q#local $_;
my $self = shift;
map "\\$$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};#;
$Nk=bless({$o,$Lk,$q,$Mk,$s,$t},$u);
$Ok=q#finalizer#;
$Pk=[];
$Qk=q#push    @{${$_[0]}{finalizers}},   $_[1]; $_[0]#;
$Rk=bless({$o,$Pk,$q,$Qk,$s,$t},$u);
$Sk=q#gensym#;
$Tk=[];
$Uk=q#my $n = shift->{gensym_n}++;
my $s = '$' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int $n / 63;
}
$s;#;
$Vk=bless({$o,$Tk,$q,$Uk,$s,$t},$u);
$Wk=q#is_circular#;
$Xk=[];
$Yk=q#my $self = shift;
ref $$self{visited}{$self->address($_[0])};#;
$Zk=bless({$o,$Xk,$q,$Yk,$s,$t},$u);
$cl=q#quote#;
$dl=[];
$el=q#my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
$$self{objects}{$a} = \\$_[0];
my $v = $$self{visited}{$a};
return ref $v ? 'undef' : $v if defined $v;
$$self{visited}{$a} = \\'undef';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));#;
$fl=bless({$o,$dl,$q,$el,$s,$t},$u);
$gl=q#quote_array#;
$hl=[];
$il=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_])
  && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
for 0..$\#{$v};
'[' . join(',', map $self->quote($_), @$v) . ']';#;
$jl=bless({$o,$hl,$q,$il,$s,$t},$u);
$kl=q#quote_blessed#;
$ll=[];
$ml=q#my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $t = Scalar::Util::reftype $x;
my $quoted = $t eq 'HASH' ? $self->quote_hash($x) : $self->quote_array($x);
"bless($quoted," . $self->quote($r) . ")";#;
$nl=bless({$o,$ll,$q,$ml,$s,$t},$u);
$ol=q#quote_class#;
$pl=[];
$ql=q#my ($self, $class) = @_;
$self->quote(ni"ni:$class") if $$self{include_classes} && ni->exists("ni:$class");#;
$rl=bless({$o,$pl,$q,$ql,$s,$t},$u);
$sl=q#quote_hash#;
$tl=[];
$ul=q#local $_;
my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
my @qs;
for my $k (@ks) {
  push @{$$self{circular}}, [$a, "{" . $self->quote($k) . "}",
                                 $self->address($$v{$k})]
  if $self->is_circular($$v{$k});
  push @qs, $self->quote($k) . "," . $self->quote($$v{$k});
}
'{' . join(",", @qs) . '}';#;
$vl=bless({$o,$tl,$q,$ul,$s,$t},$u);
$wl=q#quote_object#;
$xl=[];
$yl=q#my $self = shift;
my $q = $self->allocate_gensym($_[0],
  $_[0]->can('serialize') ? $_[0]->serialize($self) : $self->quote_blessed(@_));
$self->finalizer("&\\$_($q)for\\@" . $self->quote(ref($_[0]) . "::ctors") . ";");
$q;#;
$zl=bless({$o,$xl,$q,$yl,$s,$t},$u);
$Al=q#quote_scalar#;
$Bl=[];
$Cl=q#my $v = $_[1];
return 'undef' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\#])/\\\\$1/g;
"q\#$v\#";#;
$Dl=bless({$o,$Bl,$q,$Cl,$s,$t},$u);
$El=q#quote_value#;
$Fl=[];
$Gl=q#my $self = shift;
return $self->quote_scalar($_[0]) unless ref $_[0];
return $self->quote_array($_[0])  if 'ARRAY' eq ref $_[0];
return $self->quote_hash($_[0])   if 'HASH'  eq ref $_[0];
die "cannot serialize $_[0]"      if 'CODE'  eq ref $_[0];
$self->quote_object($_[0]);#;
$Hl=bless({$o,$Fl,$q,$Gl,$s,$t},$u);
$Il=q#reconstruction#;
$Jl=[];
$Kl=q#my $self = shift;
(@{$$self{definitions}}{@{$$self{ordering}}},
 $self->circular_links,
 @{$$self{side_effects}},
 @{$$self{finalizers}});#;
$Ll=bless({$o,$Jl,$q,$Kl,$s,$t},$u);
$Ml=q#side_effect#;
$Nl=[];
$Ol=q#push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]#;
$Pl=bless({$o,$Nl,$q,$Ol,$s,$t},$u);
$Ql=[];
$Rl=q#local $_;
my ($self, $fh) = @_;
$fh->print($_) for
  ($$self{include_shebang} ? ("\#!/usr/bin/env perl\\n") : ()),
  ($$self{include_license} ? ("chomp(\\$ni::license=<<'_');\\n", $ni::license, "\\n_\\n") : ()),
  ($$self{include_boot}    ? ("BEGIN{eval(\\$ni::boot=<<'_')}\\n", $ni::boot, "\\n_\\n") : ()),
  ($$self{use_newlines}    ? map("$_\\n", $self->reconstruction) : $self->reconstruction),
  ($$self{include_run}     ? ("ni->run(\\@ARGV);", "\\n__DATA__\\n") : ());#;
$Sl=bless({$o,$Ql,$q,$Rl,$s,$t},$u);
$Tl={$yk,$Bk,$Ck,$Fk,$Gk,$Jk,$Kk,$Nk,$Ok,$Rk,$Sk,$Vk,$Wk,$Zk,$cl,$fl,$gl,$jl,$kl,$nl,$ol,$rl,$sl,$vl,$wl,$zl,$Al,$Dl,$El,$Hl,$Il,$Ll,$Ml,$Pl,$hc,$Sl};
$Ul=q#/lib/image_quoting.b#;
$Vl=bless({$d2,$xk,$J2,$K2,$L2,$K2,$M2,$Tl,$D,$Ul},$V2);
$Wl=q#lib/slice::ctors#;
$Xl=[$D4,$vk,$Vl];
$Yl=bless({$d2,$nk,$D,$ok,$B2,$Xl},$s2);
$Zl=q#lib/image.c::ctors#;
$cm=q#ni:/lib/image.c#;
$dm={$s2,1};
$em=q#/lib/image.c#;
$fm=[$J6];
$gm=bless({$d2,$dm,$D,$em,$B2,$fm},$D2);
$hm=q#metaclass::ctors#;
$im=q#ni:/lib/image_init.b#;
$jm=q#ni:/lib/image_quoting.b#;
$km=q#ni:/lib/instance.b#;
$lm=q#ni:/lib/instantiable.b#;
$mm=q#ni:/lib/json.b#;
$nm={};
$om=q#json_decode#;
$pm=[];
$qm=q#local $_;
my @v = [];
for ($_[0] =~ /[][{}]|true|false|null|"(?:[^"\\\\]+|\\\\.)*"|[-+eE\\d.]+/g) {
  if (/^[[{]$/) {
    push @v, [];
  } elsif (/^\\]$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, $v[-1];
    pop @v;
  } elsif (/^\\}$/) {
    die "json_decode $_[0]: too many closing brackets" if @v < 2;
    push @{$v[-2]}, {@{$v[-1]}};
    pop @v;
  } else {
    push @{$v[-1]}, /^"/      ? json_unescape $_
                  : /^true$/  ? 1
                  : /^false$/ ? 0
                  : /^null$/  ? undef
                  :             0 + $_;
  }
}
my $r = pop @v;
die "json_decode $_[0]: not enough closing brackets" if @v;
wantarray ? @$r : $$r[0];#;
$rm=bless({$o,$pm,$q,$qm,$s,$fk},$u);
$sm=q#json_encode#;
$tm=[];
$um=q#local $_;
my ($v) = @_;
return "[" . join(',', map ni::json_encode($_), @$v) . "]" if 'ARRAY' eq ref $v;
return "{" . join(',', map ni::json_escape($_) . ":" . ni::json_encode($$v{$_}),
                           sort keys %$v) . "}" if 'HASH' eq ref $v;
Scalar::Util::looks_like_number $v
  ? $v
  : defined $v ? ni::json_escape($v) : 'null';#;
$vm=bless({$o,$tm,$q,$um,$s,$fk},$u);
$wm=q#json_escape#;
$xm=[];
$ym=q#(my $x = shift) =~ s/([\\b\\f\\n\\r\\t"\\\\])/"\\\\" . ($ni::json_escapes{$1} || "")/eg;
"\\"$x\\"";#;
$zm=bless({$o,$xm,$q,$ym,$s,$fk},$u);
$Am=q#json_unescape#;
$Bm=[];
$Cm=q#my $x = substr shift, 1, -1;
$x =~ s/\\\\(["\\\\\\/bfnrt]|u[0-9a-fA-F]{4})/ni::json_unescape_one($1)/eg;
$x;#;
$Dm=bless({$o,$Bm,$q,$Cm,$s,$fk},$u);
$Em=q#json_unescape_one#;
$Fm=[];
$Gm=q#$ni::json_unescapes{$_[0]} || chr hex substr $_[0], 1#;
$Hm=bless({$o,$Fm,$q,$Gm,$s,$fk},$u);
$Im={$om,$rm,$sm,$vm,$wm,$zm,$Am,$Dm,$Em,$Hm};
$Jm=q#/lib/json.b#;
$Km=bless({$d2,$nm,$J2,$K2,$L2,$K2,$M2,$Im,$D,$Jm},$V2);
$Lm=q#ni#;
$Mm=q#lib/slice::ctors#;
$Nm=q#ni:/lib/name_as_string.b#;
$Om=q#ni:/lib/named.b#;
$Pm=q#ni:/lib/named_in_ni.b#;
$Qm=q#ni:/lib/namespaced.b#;
$Rm=q#ni:/lib/ni#;
$Sm={$o4,1};
$Tm=q#/lib/ni#;
$Um={};
$Vm=q#extend#;
$Wm=[];
$Xm=q#my $self = shift;
for (@_) {
  my $r = do $_;
  die "ni: failed to parse $_: $@" if $@;
  die "ni: failed to execute $_: $!" unless defined $r;
}
$self;#;
$Ym=bless({$o,$Wm,$q,$Xm,$s,$t},$u);
$Zm=q#is_mutable#;
$cn=[];
$dn=q#$0 ne "-" && -w $0#;
$en=bless({$o,$cn,$q,$dn,$s,$t},$u);
$fn=q#modify#;
$gn=[];
$hn=q#my ($self, $fn) = @_;
\# TODO: replace all of this with a generalized "atomic-update" function
\# against UNIX files.
die "ni: cannot modify immutable instance" unless $self->is_mutable;
my (undef, undef, $mode) = stat $0;
my $temp = map chr 97 + rand(26), 1..16;
my @r = split /\\//, $0;
$r[-1] =~ s/^/./;
$r[-1] =~ s/$/.$temp/;
my $r = join '/', @r;
open my $w, '>', $r or die "ni: failed to create staging file: $!";
chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
&$fn($w);
close $w;
rename $r, $0 or die "ni: failed to rename: $!";#;
$in=bless({$o,$gn,$q,$hn,$s,$t},$u);
$jn={$Vm,$Ym,$Zm,$en,$fn,$in};
$kn=q#/lib/ni_self.b#;
$ln=bless({$d2,$Um,$J2,$K2,$L2,$K2,$M2,$jn,$D,$kn},$V2);
$mn=q#lib/slice::ctors#;
$nn={};
$on=q#exists#;
$pn=[];
$qn=q#exists $_[0]->{named}{$_[1]}#;
$rn=bless({$o,$pn,$q,$qn,$s,$t},$u);
$sn=q#quoted#;
$tn=[];
$un=q#my $self = shift;
my $q = ni('ni:/lib/image')->new(@_);
my $gs = $q->quote($self);
$q->side_effect("\\$ni::self=$gs;");
$q;#;
$vn=bless({$o,$tn,$q,$un,$s,$t},$u);
$wn={$on,$rn,$sn,$vn};
$xn=q#/lib/ni_image.b#;
$yn=bless({$d2,$nn,$J2,$K2,$L2,$K2,$M2,$wn,$D,$xn},$V2);
$zn=q#lib/slice::ctors#;
$An={};
$Bn=q#--internal/+=#;
$Cn=[];
$Dn=q#my $self = shift;
$self->extend($_) for @_;
my $q = $self->quoted(use_newlines => 1);
$self->modify(sub {$q->write(shift)});
0;#;
$En=bless({$o,$Cn,$q,$Dn,$s,$t},$u);
$Fn=q#--internal/eval#;
$Gn=[];
$Hn=q#my $self = shift;
for (@_) {
  my $r = ni::eval($_);
  print $@ ? "ERROR $@\\n" : "$r\\n";
}
0;#;
$In=bless({$o,$Gn,$q,$Hn,$s,$t},$u);
$Jn=q#--internal/image#;
$Kn=[];
$Ln=q#shift->quoted(use_newlines => 1)->write(\\*STDOUT);
0;#;
$Mn=bless({$o,$Kn,$q,$Ln,$s,$t},$u);
$Nn=q#--internal/test#;
$On=[];
$Pn=q#my $self = shift;
my @tests = map ni($_)->tests, grep /^ni\\.doc:/, keys %{$$self{named}};
my $fails = 0;
print scalar(@tests) . " test(s)\\n";
my %names = %{ni->{named}};
for my $t (@tests) {
  %{ni->{named}} = %names;
  my $r = eval {&$t};
  if ($@) {
    ++$fails;
    print "FAIL\\n$@ in\\n$t\\n\\n";
  } elsif (!$r) {
    ++$fails;
    print "FAIL\\n$r\\n";
  }
}
printf "% 4d test(s) passed\\n", @tests - $fails;
printf "% 4d test(s) failed\\n", $fails;
!!$fails;#;
$Qn=bless({$o,$On,$q,$Pn,$s,$t},$u);
$Rn=q#run#;
$Sn=[];
$Tn=q#my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
exit $self->default(@_);#;
$Un=bless({$o,$Sn,$q,$Tn,$s,$t},$u);
$Vn={$Bn,$En,$Fn,$In,$Jn,$Mn,$Nn,$Qn,$Rn,$Un};
$Wn=q#/lib/ni_main.b#;
$Xn=bless({$d2,$An,$J2,$K2,$L2,$K2,$M2,$Vn,$D,$Wn},$V2);
$Yn=q#lib/slice::ctors#;
$Zn={};
$co=[];
$do=q#my $self = shift;
return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
return $$self{resolvers}{$1}->($_[0]) if
  $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
die "ni:self failed to resolve $_[0]";#;
$eo=bless({$o,$co,$q,$do,$s,$t},$u);
$fo=q#resolver_for#;
$go=[];
$ho=q#my $self = shift;
${$$self{resolvers}}{$_[0]} = $_[1];
$self;#;
$io=bless({$o,$go,$q,$ho,$s,$t},$u);
$jo={$G3,$eo,$fo,$io};
$ko=q#/lib/ni_resolver.b#;
$lo=bless({$d2,$Zn,$J2,$K2,$L2,$K2,$M2,$jo,$D,$ko},$V2);
$mo=q#lib/slice::ctors#;
$no=[$D4,$ln,$yn,$Xn,$lo];
$oo=bless({$d2,$Sm,$D,$Tm,$B2,$no},$t2);
$po=q#lib/ni.c::ctors#;
$qo=q#ni:/lib/ni.c#;
$ro={$t2,1};
$so=q#/lib/ni.c#;
$to=[$J6];
$uo=bless({$d2,$ro,$D,$so,$B2,$to},$D2);
$vo=q#metaclass::ctors#;
$wo=q#ni:/lib/ni_image.b#;
$xo=q#ni:/lib/ni_main.b#;
$yo=q#ni:/lib/ni_resolver.b#;
$zo=q#ni:/lib/ni_self.b#;
$Ao=q#ni:/lib/ni_static_util.b#;
$Bo={};
$Co=q#abbrev#;
$Do=[];
$Eo=q#length($_[0]) < $_[1] ? $_[0] : substr($_[0], 0, $_[1] - 3) . '...'#;
$Fo=bless({$o,$Do,$q,$Eo,$s,$t},$u);
$Go=q#dor#;
$Ho=[];
$Io=q#defined $_[0] ? $_[0] : $_[1]#;
$Jo=bless({$o,$Ho,$q,$Io,$s,$t},$u);
$Ko=q#indent#;
$Lo=[];
$Mo=q#my ($s, $indent) = (@_, 2);
join "\\n", map ' ' x $indent . $_, split /\\n/, $s;#;
$No=bless({$o,$Lo,$q,$Mo,$s,$t},$u);
$Oo=q#max#;
$Po=[];
$Qo=q#local $_; my $m = pop @_; $m = $m >  $_ ? $m : $_ for @_; $m#;
$Ro=bless({$o,$Po,$q,$Qo,$s,$t},$u);
$So=q#maxstr#;
$To=[];
$Uo=q#local $_; my $m = pop @_; $m = $m gt $_ ? $m : $_ for @_; $m#;
$Vo=bless({$o,$To,$q,$Uo,$s,$t},$u);
$Wo=q#mean#;
$Xo=[];
$Yo=q#sum(@_) / (@_ || 1)#;
$Zo=bless({$o,$Xo,$q,$Yo,$s,$t},$u);
$cp=q#min#;
$dp=[];
$ep=q#local $_; my $m = pop @_; $m = $m <  $_ ? $m : $_ for @_; $m#;
$fp=bless({$o,$dp,$q,$ep,$s,$t},$u);
$gp=q#minstr#;
$hp=[];
$ip=q#local $_; my $m = pop @_; $m = $m lt $_ ? $m : $_ for @_; $m#;
$jp=bless({$o,$hp,$q,$ip,$s,$t},$u);
$kp=q#sgr#;
$lp=[];
$mp=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/g; $x#;
$np=bless({$o,$lp,$q,$mp,$s,$t},$u);
$op=q#sr#;
$pp=[];
$qp=q#(my $x = $_[0]) =~ s/$_[1]/$_[2]/;  $x#;
$rp=bless({$o,$pp,$q,$qp,$s,$t},$u);
$sp=q#sum#;
$tp=[];
$up=q#local $_; my $x = 0; $x += $_ for @_; $x#;
$vp=bless({$o,$tp,$q,$up,$s,$t},$u);
$wp=q#swap#;
$xp=[];
$yp=q#@_[0, 1] = @_[1, 0]#;
$zp=bless({$o,$xp,$q,$yp,$s,$t},$u);
$Ap={$Co,$Fo,$Go,$Jo,$Ko,$No,$Oo,$Ro,$So,$Vo,$Wo,$Zo,$cp,$fp,$gp,$jp,$kp,$np,$op,$rp,$sp,$vp,$wp,$zp};
$Bp=q#/lib/ni_static_util.b#;
$Cp=bless({$d2,$Bo,$J2,$K2,$L2,$K2,$M2,$Ap,$D,$Bp},$V2);
$Dp=q#lib/slice::ctors#;
$Ep=q#ni:/lib/perlbranch.b#;
$Fp=q#ni:/lib/ref_eq.b#;
$Gp=q#ni:/lib/resolver.b#;
$Hp=q#ni:/lib/slice#;
$Ip={$V2,1};
$Jp=q#/lib/slice#;
$Kp=q#local $_;
my ($self, $p) = @_;
$p = $p->package if ref $p;
die "/lib/slice.b->apply('$p'): perl packages don't start with "
  . "slashes (this fails on older versions of perl)" if $p =~ /^\\//;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);#;
$Lp=bless({$q,$Kp,$s,$t},$u);
$Mp=q#local $_;
my ($self, $p) = @_;
return if $$self{applied_to}{$p};
$$self{applied_to}{$p} = 1;
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
if (grep /^\\(/, keys %{$$self{methods}}) {
  *{"$p\\::()"} = sub {};
  *{"$p\\::OVERLOAD"} = {};
}
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;#;
$Np=bless({$q,$Mp,$s,$t},$u);
$Op=q#lib/slice::apply#;
$Pp=q#lib/slice::apply_unsafe#;
$Qp={};
$Rp=q#apply_unsafe#;
$Sp={$Q2,$Lp,$Rp,$Np};
$Tp=q#/lib/slice.b#;
$Up=bless({$d2,$Qp,$M2,$Sp,$D,$Tp},$V2);
$Vp=q#lib/slice::ctors#;
$Wp={};
$Xp=q#my $class = shift;
my $name  = shift;
my %args  = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  name       => $name,
  methods    => \\%args};#;
$Yp=bless({$q,$Xp,$s,$t},$u);
$Zp={$U3,$Yp};
$cq=q#/lib/slice_init.b#;
$dq=bless({$d2,$Wp,$M2,$Zp,$D,$cq},$V2);
$eq=q#lib/slice::ctors#;
$fq={};
$gq=[];
$hq=q#local $_;
my ($self, $quote) = @_;
my $name = $self->name;
$quote->quote_class(ref $self);

if (defined $name and $name eq 'ni:/lib/slice.b') {
  my %methods;
  my @ks = sort keys %{$$self{methods}};
  @methods{@ks} = map $quote->quote($_), @{$$self{methods}}{@ks};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      '*' . $quote->quote("$p\\::$_") . "=\\\\\\&$methods{$_};")
      for @ks;
  }
}

my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed({%$self, applied_to => {}}, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;#;
$iq=bless({$o,$gq,$q,$hq,$s,$t},$u);
$jq={$Dj,$iq};
$kq=q#/lib/slice_serialize.b#;
$lq=bless({$d2,$fq,$J2,$K2,$L2,$K2,$M2,$jq,$D,$kq},$V2);
$mq=q#lib/slice::ctors#;
$nq=[$R4,$j3,$Up,$dq,$lq];
$oq=bless({$d2,$Ip,$D,$Jp,$B2,$nq},$u2);
$pq=q#lib/slice.c::ctors#;
$qq=q#ni:/lib/slice.b#;
$rq=q#ni:/lib/slice.c#;
$sq={$u2,1};
$tq=q#/lib/slice.c#;
$uq=[$O6];
$vq=bless({$d2,$sq,$D,$tq,$B2,$uq},$D2);
$wq=q#metaclass::ctors#;
$xq=q#ni:/lib/slice_init.b#;
$yq=q#ni:/lib/slice_serialize.b#;
$zq=q#ni:/lib/static_fn.b#;
$Aq={};
$Bq=[];
$Cq=q#ni('ni:/lib/fn')->new(@_)#;
$Dq=bless({$o,$Bq,$q,$Cq,$s,$fk},$u);
$Eq=q#fp#;
$Fq=[];
$Gq=q#ni('ni:/lib/fn')->new(@_)#;
$Hq=q#($$)#;
$Iq=bless({$o,$Fq,$q,$Gq,$s,$Hq},$u);
$Jq={$jj,$Dq,$Eq,$Iq};
$Kq=q#/lib/static_fn.b#;
$Lq=bless({$d2,$Aq,$J2,$K2,$L2,$K2,$M2,$Jq,$D,$Kq},$V2);
$Mq=q#lib/slice::ctors#;
$Nq=q#ni:/lib/subclass.b#;
$Oq=q#ni:/lib/tag#;
$Pq={$k3,1};
$Qq=q#/lib/tag#;
$Rq={};
$Sq=q#local $_;
my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;#;
$Tq=bless({$q,$Sq,$s,$t},$u);
$Uq={$Q2,$Tq};
$Vq=q#/lib/tag.b#;
$Wq=bless({$d2,$Rq,$J2,$K2,$L2,$K2,$M2,$Uq,$D,$Vq},$V2);
$Xq=q#lib/slice::ctors#;
$Yq={};
$Zq=q#local $_;
my $class = shift;
my $name  = shift;
+{name   => $name,
  slices => [map $class->resolve($_), @_]};#;
$cr=bless({$q,$Zq,$s,$t},$u);
$dr={$U3,$cr};
$er=q#/lib/tag_init.b#;
$fr=bless({$d2,$Yq,$J2,$K2,$L2,$K2,$M2,$dr,$D,$er},$V2);
$gr=q#lib/slice::ctors#;
$hr=[$R4,$j3,$Wq,$fr];
$ir=bless({$d2,$Pq,$D,$Qq,$B2,$hr},$v2);
$jr=q#lib/tag.c::ctors#;
$kr=q#ni:/lib/tag.b#;
$lr=q#ni:/lib/tag.c#;
$mr={$v2,1};
$nr=q#/lib/tag.c#;
$or=[$O6];
$pr=bless({$d2,$mr,$D,$nr,$B2,$or},$D2);
$qr=q#metaclass::ctors#;
$rr=q#ni:/lib/tag_init.b#;
$sr=q#ni:/lib/test_value#;
$tr={$p4,1};
$ur=q#/lib/test_value#;
$vr={};
$wr=[];
$xr=q#\\$_[1]#;
$yr=bless({$o,$wr,$q,$xr,$s,$t},$u);
$zr={$U3,$yr};
$Ar=q#/lib/test_value_init.b#;
$Br=bless({$d2,$vr,$J2,$K2,$L2,$K2,$M2,$zr,$D,$Ar},$V2);
$Cr=q#lib/slice::ctors#;
$Dr={};
$Er=q#(==#;
$Fr=[];
$Gr=q#my ($self, $rhs) = @_;
my $diff = $self->diff($rhs);
die $self->class->new($diff) if defined $diff;
1;#;
$Hr=bless({$o,$Fr,$q,$Gr,$s,$t},$u);
$Ir=q#diff#;
$Jr=[];
$Kr=q#my ($self, $rhs) = @_;
my $class = $self->class;
my $lhs = $$self;
my $rl = ref $lhs;
my $rr = ref $rhs;
my $realtype = Scalar::Util::reftype($lhs) || "";
return {type_difference => [$rl, $rr]} unless $rl eq $rr;
if ($realtype eq 'HASH') {
  my @left_only  = grep !exists $$rhs{$_}, keys %$lhs;
  my @right_only = grep !exists $$lhs{$_}, keys %$rhs;
  return {hash_key_mismatch => 1,
          object_type       => $rl,
          left_only         => \\@left_only,
          right_only        => \\@right_only}
    if @left_only || @right_only;
  my %diff;
  $diff{$_} = $class->new($$lhs{$_})->diff($$rhs{$_})
    for keys %$lhs;
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {hash_value_mismatch => 1,
          object_type         => $rl,
          diffs               => \\%diff} if keys %diff;
} elsif ($realtype eq 'ARRAY') {
  my $n_diff = @$lhs - @$rhs;
  return {array_length_mismatch => $n_diff} if $n_diff;
  my %diff;
  $diff{$_} = $class->new($$lhs[$_])->diff($$rhs[$_])
    for 0..$\#{$lhs};
  delete @diff{grep !defined($diff{$_}), keys %diff};
  return {array_value_mismatch => 1,
          object_type          => $rl,
          diffs                => \\%diff} if keys %diff;
} elsif ($realtype eq 'SCALAR') {
  return $class->new($$lhs)->diff($$rhs);
} elsif (!$rl) {
  return {scalar_difference => [$lhs, $rhs]} unless $lhs eq $rhs;
}
return undef;#;
$Lr=bless({$o,$Jr,$q,$Kr,$s,$t},$u);
$Mr={$Er,$Hr,$Ir,$Lr};
$Nr=q#/lib/test_value_eq.b#;
$Or=bless({$d2,$Dr,$J2,$K2,$L2,$K2,$M2,$Mr,$D,$Nr},$V2);
$Pr=q#lib/slice::ctors#;
$Qr={};
$Rr=[];
$Sr=q#ni::json_encode ${$_[0]}#;
$Tr=bless({$o,$Rr,$q,$Sr,$s,$t},$u);
$Ur={$u5,$Tr};
$Vr=q#/lib/test_value_str.b#;
$Wr=bless({$d2,$Qr,$J2,$K2,$L2,$K2,$M2,$Ur,$D,$Vr},$V2);
$Xr=q#lib/slice::ctors#;
$Yr=[$D4,$Br,$Or,$Wr];
$Zr=q#lib/test_value.c#;
$cs=bless({$d2,$tr,$D,$ur,$B2,$Yr},$Zr);
$ds=q#lib/test_value.c::ctors#;
$es=q#ni:/lib/test_value.c#;
$fs=q#lib/test_value.c#;
$gs={$fs,1};
$hs=q#/lib/test_value.c#;
$is=[$J6];
$js=bless({$d2,$gs,$D,$hs,$B2,$is},$D2);
$ks=q#metaclass::ctors#;
$ls=q#ni:/lib/test_value_eq.b#;
$ms=q#ni:/lib/test_value_init.b#;
$ns=q#ni:/lib/test_value_str.b#;
$os=q#ni:/metaclass#;
$ps={$D2,1};
$qs=q#/metaclass#;
$rs=[$P3,$l6,$Z3,$Y5];
$ss=bless({$d2,$ps,$D,$qs,$B2,$rs},$x2);
$ts=q#metaclass.c::ctors#;
$us=q#ni:/metaclass.c#;
$vs={$x2,1};
$ws=q#/metaclass.c#;
$xs=[$y6];
$ys=bless({$d2,$vs,$D,$ws,$B2,$xs},$D2);
$zs=q#metaclass::ctors#;
$As=q#ni:/module#;
$Bs=q#ni:/module.c#;
$Cs=q#ni:/object#;
$Ds=q#ni:/object.c#;
$Es=q#ni:main#;
$Fs={$kk,1};
$Gs=[$Lq,$jk];
$Hs=bless({$d2,$Fs,$D,$kk,$B2,$Gs},$E2);
$Is=q#module::ctors#;
$Js=q#ni:ni#;
$Ks={$Lm,1};
$Ls={$Lm,1};
$Ms=q#json_escapes#;
$Ns=q##;
$Os=q#b#;
$Ps=q#	#;
$Qs=q#t#;
$Rs=q#
#;
$Ss=q#n#;
$Ts=q##;
$Us=q#"#;
$Vs=q#/#;
$Ws=q#\\#;
$Xs={$Ns,$Os,$Ps,$Qs,$Rs,$Ss,$Ts,$jd,$Us,$Us,$Vs,$Vs,$Ws,$Ws};
$Ys=q#json_unescapes#;
$Zs={$Us,$Us,$Vs,$Vs,$Ws,$Ws,$Os,$Ns,$Ss,$Rs,$jd,$Ts,$Qs,$Ps};
$ct={$Ms,$Xs,$Ys,$Zs};
$dt=q#/lib/json_data.b#;
$et=bless({$d2,$Ls,$Gf,$ct,$D,$dt},$m4);
$ft=q#lib/dataslice::ctors#;
$gt=[$et,$Km,$Cp];
$ht=bless({$d2,$Ks,$D,$Lm,$B2,$gt},$E2);
$it={$d,$G,$I,$N,$O,$T,$U,$h1,$i1,$t1,$u1,$J1,$K1,$Z1,$c2,$y6,$A6,$U6,$W6,$z8,$B8,$K8,$M8,$n8,$N8,$w8,$O8,$Ga,$Ia,$Ma,$Oa,$ma,$Pa,$Da,$Qa,$h9,$Ra,$da,$Sa,$C9,$Ta,$X8,$Ua,$qc,$sc,$wc,$yc,$Nb,$zc,$Zb,$Ac,$nb,$Bc,$nc,$Cc,$fb,$Dc,$wb,$Ec,$Cd,$Ed,$Id,$Kd,$Wc,$Ld,$gd,$Md,$zd,$Nd,$Nc,$Od,$f8,$Pd,$H8,$Qd,$I7,$Rd,$R7,$Sd,$c8,$Td,$i7,$Ud,$r7,$Vd,$pf,$rf,$vf,$xf,$mf,$yf,$ve,$zf,$Te,$Af,$ke,$Bf,$Ie,$Cf,$wg,$yg,$Cg,$Eg,$eg,$Fg,$tg,$Gg,$Uf,$Hg,$q5,$Ig,$R4,$Jg,$O6,$Kg,$Vg,$Xg,$W2,$Yg,$eh,$gh,$Sg,$hh,$Z3,$ih,$Ah,$Ch,$Gh,$Ih,$xh,$Jh,$qh,$Kh,$V5,$Lh,$e5,$Mh,$R5,$Nh,$yi,$Ai,$Ei,$Gi,$li,$Hi,$Uh,$Ii,$di,$Ji,$vi,$Ki,$N4,$Li,$Mj,$Oj,$Sj,$Uj,$Yi,$Vj,$Aj,$Wj,$pj,$Xj,$Jj,$Yj,$jk,$mk,$Yl,$cm,$gm,$im,$vk,$jm,$Vl,$km,$z4,$lm,$l6,$mm,$Km,$Nm,$z5,$Om,$j3,$Pm,$t3,$Qm,$C3,$Rm,$oo,$qo,$uo,$wo,$yn,$xo,$Xn,$yo,$lo,$zo,$ln,$Ao,$Cp,$Ep,$P3,$Fp,$I5,$Gp,$L3,$Hp,$oq,$qq,$Up,$rq,$vq,$xq,$dq,$yq,$lq,$zq,$Lq,$Nq,$u6,$Oq,$ir,$kr,$Wq,$lr,$pr,$rr,$fr,$sr,$cs,$es,$js,$ls,$Or,$ms,$Br,$ns,$Wr,$os,$ss,$us,$ys,$As,$Y5,$Bs,$R6,$Cs,$D4,$Ds,$J6,$Es,$Hs,$Js,$ht};
$jt=q#resolvers#;
$kt=[];
$lt=q#ni('ni:/io/fd')->new(0 + substr shift, 3)#;
$mt=bless({$o,$kt,$q,$lt,$s,$t},$u);
$nt=q#file#;
$ot=[];
$pt=q#my $f = shift;
$f =~ s/^file:(?:\\/\\/)?//;
ni('ni:/io/file')->new($f);#;
$qt=bless({$o,$ot,$q,$pt,$s,$t},$u);
$rt=q#sh#;
$st=[];
$tt=q#ni('ni:/io/exec')->new('/bin/sh', '-c', substr shift, 3)->fork#;
$ut=bless({$o,$st,$q,$tt,$s,$t},$u);
$vt=q#str#;
$wt=[];
$xt=q#my $s = shift;
ni('ni:/io/str')->new(substr($s, 4) . "\\n");#;
$yt=bless({$o,$wt,$q,$xt,$s,$t},$u);
$zt={$J9,$mt,$nt,$qt,$rt,$ut,$vt,$yt};
$At=bless({$c,$it,$jt,$zt},$o4);
$Bt=q#lib/ni::ctors#;
*$Pp=\&$Np;
*$Op=\&$Lp;
$W2->apply_unsafe($e2);
$W2->apply_unsafe($f2);
$W2->apply_unsafe($g2);
$W2->apply_unsafe($h2);
$W2->apply_unsafe($i2);
$W2->apply_unsafe($j2);
$W2->apply_unsafe($k2);
$W2->apply_unsafe($l2);
$W2->apply_unsafe($m2);
$W2->apply_unsafe($n2);
$W2->apply_unsafe($X2);
$W2->apply_unsafe($o2);
$W2->apply_unsafe($p2);
$W2->apply_unsafe($q2);
$W2->apply_unsafe($r2);
$W2->apply_unsafe($s2);
$W2->apply_unsafe($t2);
$W2->apply_unsafe($u2);
$W2->apply_unsafe($v2);
$W2->apply_unsafe($Y2);
$W2->apply_unsafe($D2);
$W2->apply_unsafe($x2);
$W2->apply_unsafe($E2);
$W2->apply_unsafe($y2);
$W2->apply_unsafe($z2);
$j3->apply_unsafe($e2);
$j3->apply_unsafe($f2);
$j3->apply_unsafe($g2);
$j3->apply_unsafe($h2);
$j3->apply_unsafe($i2);
$j3->apply_unsafe($j2);
$j3->apply_unsafe($k2);
$j3->apply_unsafe($l2);
$j3->apply_unsafe($m2);
$j3->apply_unsafe($n2);
$j3->apply_unsafe($X2);
$j3->apply_unsafe($o2);
$j3->apply_unsafe($p2);
$j3->apply_unsafe($F);
$j3->apply_unsafe($q2);
$j3->apply_unsafe($r2);
$j3->apply_unsafe($s2);
$j3->apply_unsafe($t2);
$j3->apply_unsafe($V2);
$j3->apply_unsafe($u2);
$j3->apply_unsafe($k3);
$j3->apply_unsafe($v2);
$j3->apply_unsafe($l3);
$j3->apply_unsafe($D2);
$j3->apply_unsafe($x2);
$j3->apply_unsafe($E2);
$j3->apply_unsafe($y2);
$j3->apply_unsafe($z2);
$t3->apply_unsafe($e2);
$t3->apply_unsafe($f2);
$t3->apply_unsafe($g2);
$t3->apply_unsafe($h2);
$t3->apply_unsafe($i2);
$t3->apply_unsafe($j2);
$t3->apply_unsafe($k2);
$t3->apply_unsafe($l2);
$t3->apply_unsafe($m2);
$t3->apply_unsafe($n2);
$t3->apply_unsafe($X2);
$t3->apply_unsafe($o2);
$t3->apply_unsafe($p2);
$t3->apply_unsafe($q2);
$t3->apply_unsafe($r2);
$t3->apply_unsafe($s2);
$t3->apply_unsafe($t2);
$t3->apply_unsafe($V2);
$t3->apply_unsafe($u2);
$t3->apply_unsafe($k3);
$t3->apply_unsafe($v2);
$t3->apply_unsafe($u3);
$t3->apply_unsafe($D2);
$t3->apply_unsafe($x2);
$t3->apply_unsafe($E2);
$t3->apply_unsafe($y2);
$t3->apply_unsafe($z2);
$C3->apply_unsafe($e2);
$C3->apply_unsafe($f2);
$C3->apply_unsafe($g2);
$C3->apply_unsafe($h2);
$C3->apply_unsafe($i2);
$C3->apply_unsafe($j2);
$C3->apply_unsafe($k2);
$C3->apply_unsafe($l2);
$C3->apply_unsafe($m2);
$C3->apply_unsafe($n2);
$C3->apply_unsafe($X2);
$C3->apply_unsafe($o2);
$C3->apply_unsafe($p2);
$C3->apply_unsafe($q2);
$C3->apply_unsafe($r2);
$C3->apply_unsafe($s2);
$C3->apply_unsafe($t2);
$C3->apply_unsafe($V2);
$C3->apply_unsafe($u2);
$C3->apply_unsafe($k3);
$C3->apply_unsafe($v2);
$C3->apply_unsafe($D3);
$C3->apply_unsafe($D2);
$C3->apply_unsafe($x2);
$C3->apply_unsafe($E2);
$C3->apply_unsafe($y2);
$C3->apply_unsafe($z2);
$L3->apply_unsafe($e2);
$L3->apply_unsafe($f2);
$L3->apply_unsafe($g2);
$L3->apply_unsafe($h2);
$L3->apply_unsafe($i2);
$L3->apply_unsafe($j2);
$L3->apply_unsafe($k2);
$L3->apply_unsafe($l2);
$L3->apply_unsafe($m2);
$L3->apply_unsafe($n2);
$L3->apply_unsafe($X2);
$L3->apply_unsafe($o2);
$L3->apply_unsafe($p2);
$L3->apply_unsafe($q2);
$L3->apply_unsafe($r2);
$L3->apply_unsafe($s2);
$L3->apply_unsafe($t2);
$L3->apply_unsafe($u2);
$L3->apply_unsafe($k3);
$L3->apply_unsafe($v2);
$L3->apply_unsafe($M3);
$L3->apply_unsafe($D2);
$L3->apply_unsafe($x2);
$L3->apply_unsafe($E2);
$L3->apply_unsafe($y2);
$L3->apply_unsafe($z2);
$Z3->apply_unsafe($e2);
$Z3->apply_unsafe($f2);
$Z3->apply_unsafe($g2);
$Z3->apply_unsafe($h2);
$Z3->apply_unsafe($i2);
$Z3->apply_unsafe($j2);
$Z3->apply_unsafe($k2);
$Z3->apply_unsafe($l2);
$Z3->apply_unsafe($m2);
$Z3->apply_unsafe($n2);
$Z3->apply_unsafe($o2);
$Z3->apply_unsafe($p2);
$Z3->apply_unsafe($q2);
$Z3->apply_unsafe($r2);
$Z3->apply_unsafe($s2);
$Z3->apply_unsafe($t2);
$Z3->apply_unsafe($u2);
$Z3->apply_unsafe($v2);
$Z3->apply_unsafe($c4);
$Z3->apply_unsafe($D2);
$Z3->apply_unsafe($x2);
$Z3->apply_unsafe($E2);
$Z3->apply_unsafe($y2);
$Z3->apply_unsafe($z2);
$z4->apply_unsafe($e2);
$z4->apply_unsafe($f2);
$z4->apply_unsafe($e4);
$z4->apply_unsafe($g2);
$z4->apply_unsafe($f4);
$z4->apply_unsafe($h2);
$z4->apply_unsafe($g4);
$z4->apply_unsafe($i2);
$z4->apply_unsafe($h4);
$z4->apply_unsafe($j2);
$z4->apply_unsafe($i4);
$z4->apply_unsafe($k2);
$z4->apply_unsafe($j4);
$z4->apply_unsafe($l2);
$z4->apply_unsafe($k4);
$z4->apply_unsafe($m2);
$z4->apply_unsafe($l4);
$z4->apply_unsafe($n2);
$z4->apply_unsafe($X2);
$z4->apply_unsafe($o2);
$z4->apply_unsafe($m4);
$z4->apply_unsafe($p2);
$z4->apply_unsafe($F);
$z4->apply_unsafe($q2);
$z4->apply_unsafe($u);
$z4->apply_unsafe($r2);
$z4->apply_unsafe($n4);
$z4->apply_unsafe($s2);
$z4->apply_unsafe($o4);
$z4->apply_unsafe($t2);
$z4->apply_unsafe($V2);
$z4->apply_unsafe($u2);
$z4->apply_unsafe($k3);
$z4->apply_unsafe($v2);
$z4->apply_unsafe($p4);
$z4->apply_unsafe($A4);
$z4->apply_unsafe($D2);
$z4->apply_unsafe($x2);
$z4->apply_unsafe($E2);
$z4->apply_unsafe($y2);
$z4->apply_unsafe($r4);
$z4->apply_unsafe($z2);
$N4->apply_unsafe($e2);
$N4->apply_unsafe($f2);
$N4->apply_unsafe($g2);
$N4->apply_unsafe($h2);
$N4->apply_unsafe($i2);
$N4->apply_unsafe($j2);
$N4->apply_unsafe($k2);
$N4->apply_unsafe($l2);
$N4->apply_unsafe($m2);
$N4->apply_unsafe($l4);
$N4->apply_unsafe($n2);
$N4->apply_unsafe($X2);
$N4->apply_unsafe($o2);
$N4->apply_unsafe($m4);
$N4->apply_unsafe($p2);
$N4->apply_unsafe($q2);
$N4->apply_unsafe($r2);
$N4->apply_unsafe($s2);
$N4->apply_unsafe($t2);
$N4->apply_unsafe($V2);
$N4->apply_unsafe($u2);
$N4->apply_unsafe($k3);
$N4->apply_unsafe($v2);
$N4->apply_unsafe($O4);
$N4->apply_unsafe($D2);
$N4->apply_unsafe($x2);
$N4->apply_unsafe($E2);
$N4->apply_unsafe($y2);
$N4->apply_unsafe($z2);
$e5->apply_unsafe($e2);
$e5->apply_unsafe($f2);
$e5->apply_unsafe($g2);
$e5->apply_unsafe($h2);
$e5->apply_unsafe($i2);
$e5->apply_unsafe($j2);
$e5->apply_unsafe($k2);
$e5->apply_unsafe($l2);
$e5->apply_unsafe($m2);
$e5->apply_unsafe($n2);
$e5->apply_unsafe($X2);
$e5->apply_unsafe($o2);
$e5->apply_unsafe($p2);
$e5->apply_unsafe($q2);
$e5->apply_unsafe($r2);
$e5->apply_unsafe($s2);
$e5->apply_unsafe($t2);
$e5->apply_unsafe($u2);
$e5->apply_unsafe($v2);
$e5->apply_unsafe($f5);
$e5->apply_unsafe($D2);
$e5->apply_unsafe($x2);
$e5->apply_unsafe($E2);
$e5->apply_unsafe($y2);
$e5->apply_unsafe($z2);
$q5->apply_unsafe($e2);
$q5->apply_unsafe($f2);
$q5->apply_unsafe($g2);
$q5->apply_unsafe($h2);
$q5->apply_unsafe($i2);
$q5->apply_unsafe($j2);
$q5->apply_unsafe($k2);
$q5->apply_unsafe($l2);
$q5->apply_unsafe($m2);
$q5->apply_unsafe($n2);
$q5->apply_unsafe($X2);
$q5->apply_unsafe($o2);
$q5->apply_unsafe($p2);
$q5->apply_unsafe($q2);
$q5->apply_unsafe($r2);
$q5->apply_unsafe($s2);
$q5->apply_unsafe($t2);
$q5->apply_unsafe($u2);
$q5->apply_unsafe($v2);
$q5->apply_unsafe($r5);
$q5->apply_unsafe($D2);
$q5->apply_unsafe($x2);
$q5->apply_unsafe($E2);
$q5->apply_unsafe($y2);
$q5->apply_unsafe($z2);
$z5->apply_unsafe($e2);
$z5->apply_unsafe($f2);
$z5->apply_unsafe($g2);
$z5->apply_unsafe($h2);
$z5->apply_unsafe($i2);
$z5->apply_unsafe($j2);
$z5->apply_unsafe($k2);
$z5->apply_unsafe($l2);
$z5->apply_unsafe($m2);
$z5->apply_unsafe($n2);
$z5->apply_unsafe($X2);
$z5->apply_unsafe($o2);
$z5->apply_unsafe($p2);
$z5->apply_unsafe($q2);
$z5->apply_unsafe($r2);
$z5->apply_unsafe($s2);
$z5->apply_unsafe($t2);
$z5->apply_unsafe($u2);
$z5->apply_unsafe($v2);
$z5->apply_unsafe($A5);
$z5->apply_unsafe($D2);
$z5->apply_unsafe($x2);
$z5->apply_unsafe($E2);
$z5->apply_unsafe($y2);
$z5->apply_unsafe($z2);
$I5->apply_unsafe($e2);
$I5->apply_unsafe($f2);
$I5->apply_unsafe($g2);
$I5->apply_unsafe($h2);
$I5->apply_unsafe($i2);
$I5->apply_unsafe($j2);
$I5->apply_unsafe($k2);
$I5->apply_unsafe($l2);
$I5->apply_unsafe($m2);
$I5->apply_unsafe($n2);
$I5->apply_unsafe($X2);
$I5->apply_unsafe($o2);
$I5->apply_unsafe($p2);
$I5->apply_unsafe($q2);
$I5->apply_unsafe($r2);
$I5->apply_unsafe($s2);
$I5->apply_unsafe($t2);
$I5->apply_unsafe($u2);
$I5->apply_unsafe($v2);
$I5->apply_unsafe($J5);
$I5->apply_unsafe($D2);
$I5->apply_unsafe($x2);
$I5->apply_unsafe($E2);
$I5->apply_unsafe($y2);
$I5->apply_unsafe($z2);
$R5->apply_unsafe($e2);
$R5->apply_unsafe($f2);
$R5->apply_unsafe($g2);
$R5->apply_unsafe($h2);
$R5->apply_unsafe($i2);
$R5->apply_unsafe($j2);
$R5->apply_unsafe($k2);
$R5->apply_unsafe($l2);
$R5->apply_unsafe($m2);
$R5->apply_unsafe($n2);
$R5->apply_unsafe($X2);
$R5->apply_unsafe($o2);
$R5->apply_unsafe($p2);
$R5->apply_unsafe($q2);
$R5->apply_unsafe($r2);
$R5->apply_unsafe($s2);
$R5->apply_unsafe($t2);
$R5->apply_unsafe($u2);
$R5->apply_unsafe($v2);
$R5->apply_unsafe($S5);
$R5->apply_unsafe($D2);
$R5->apply_unsafe($x2);
$R5->apply_unsafe($E2);
$R5->apply_unsafe($y2);
$R5->apply_unsafe($z2);
$l6->apply_unsafe($e2);
$l6->apply_unsafe($f2);
$l6->apply_unsafe($g2);
$l6->apply_unsafe($h2);
$l6->apply_unsafe($i2);
$l6->apply_unsafe($j2);
$l6->apply_unsafe($k2);
$l6->apply_unsafe($l2);
$l6->apply_unsafe($m2);
$l6->apply_unsafe($n2);
$l6->apply_unsafe($o2);
$l6->apply_unsafe($p2);
$l6->apply_unsafe($q2);
$l6->apply_unsafe($u);
$l6->apply_unsafe($r2);
$l6->apply_unsafe($s2);
$l6->apply_unsafe($t2);
$l6->apply_unsafe($V2);
$l6->apply_unsafe($u2);
$l6->apply_unsafe($k3);
$l6->apply_unsafe($v2);
$l6->apply_unsafe($m6);
$l6->apply_unsafe($D2);
$l6->apply_unsafe($x2);
$l6->apply_unsafe($y2);
$l6->apply_unsafe($z2);
$u6->apply_unsafe($e2);
$u6->apply_unsafe($f2);
$u6->apply_unsafe($g2);
$u6->apply_unsafe($h2);
$u6->apply_unsafe($i2);
$u6->apply_unsafe($j2);
$u6->apply_unsafe($k2);
$u6->apply_unsafe($l2);
$u6->apply_unsafe($m2);
$u6->apply_unsafe($n2);
$u6->apply_unsafe($o2);
$u6->apply_unsafe($p2);
$u6->apply_unsafe($q2);
$u6->apply_unsafe($r2);
$u6->apply_unsafe($s2);
$u6->apply_unsafe($t2);
$u6->apply_unsafe($u2);
$u6->apply_unsafe($v2);
$u6->apply_unsafe($v6);
$u6->apply_unsafe($x2);
$u6->apply_unsafe($y2);
$u6->apply_unsafe($z2);
$i7->apply_unsafe($e4);
$i7->apply_unsafe($f4);
$i7->apply_unsafe($g4);
$i7->apply_unsafe($h4);
$i7->apply_unsafe($i4);
$i7->apply_unsafe($j4);
$i7->apply_unsafe($k4);
$r7->apply_unsafe($e4);
$r7->apply_unsafe($f4);
$r7->apply_unsafe($g4);
$r7->apply_unsafe($h4);
$r7->apply_unsafe($i4);
$r7->apply_unsafe($j4);
$r7->apply_unsafe($k4);
$I7->apply_unsafe($e4);
$I7->apply_unsafe($f4);
$I7->apply_unsafe($g4);
$I7->apply_unsafe($h4);
$I7->apply_unsafe($i4);
$I7->apply_unsafe($j4);
$I7->apply_unsafe($k4);
$R7->apply_unsafe($e4);
$R7->apply_unsafe($f4);
$R7->apply_unsafe($g4);
$R7->apply_unsafe($h4);
$R7->apply_unsafe($i4);
$R7->apply_unsafe($j4);
$R7->apply_unsafe($k4);
$c8->apply_unsafe($e4);
$c8->apply_unsafe($f4);
$c8->apply_unsafe($g4);
$c8->apply_unsafe($h4);
$c8->apply_unsafe($i4);
$c8->apply_unsafe($j4);
$c8->apply_unsafe($k4);
$n8->apply_unsafe($e4);
$w8->apply_unsafe($e4);
$X8->apply_unsafe($f4);
$h9->apply_unsafe($f4);
$C9->apply_unsafe($f4);
$da->apply_unsafe($f4);
$ma->apply_unsafe($f4);
$Da->apply_unsafe($f4);
$fb->apply_unsafe($g4);
$nb->apply_unsafe($g4);
$wb->apply_unsafe($g4);
$Nb->apply_unsafe($g4);
$Zb->apply_unsafe($g4);
$nc->apply_unsafe($g4);
$Nc->apply_unsafe($h4);
$Wc->apply_unsafe($h4);
$gd->apply_unsafe($h4);
$zd->apply_unsafe($h4);
$ke->apply_unsafe($j4);
$ve->apply_unsafe($j4);
$Ie->apply_unsafe($j4);
$Te->apply_unsafe($j4);
$mf->apply_unsafe($j4);
$Uf->apply_unsafe($k4);
$eg->apply_unsafe($k4);
$tg->apply_unsafe($k4);
$Sg->apply_unsafe($X2);
$qh->apply_unsafe($m4);
$xh->apply_unsafe($m4);
$Uh->apply_unsafe($F);
$di->apply_unsafe($F);
$li->apply_unsafe($F);
$vi->apply_unsafe($F);
$Yi->apply_unsafe($u);
$pj->apply_unsafe($u);
$Aj->apply_unsafe($u);
$Jj->apply_unsafe($u);
$jk->apply_unsafe($kk);
$vk->apply_unsafe($n4);
$Vl->apply_unsafe($n4);
$Km->apply_unsafe($Lm);
$ln->apply_unsafe($o4);
$yn->apply_unsafe($o4);
$Xn->apply_unsafe($o4);
$lo->apply_unsafe($o4);
$Cp->apply_unsafe($Lm);
$Up->apply_unsafe($V2);
$dq->apply_unsafe($V2);
$lq->apply_unsafe($V2);
$Lq->apply_unsafe($kk);
$Wq->apply_unsafe($k3);
$fr->apply_unsafe($k3);
$Br->apply_unsafe($p4);
$Or->apply_unsafe($p4);
$Wr->apply_unsafe($p4);
$ni::self=$At;
&$_($v)for@$w;
&$_($G)for@$H;
&$_($N)for@$H;
&$_($T)for@$H;
&$_($d1)for@$w;
&$_($h1)for@$H;
&$_($p1)for@$w;
&$_($t1)for@$H;
&$_($x1)for@$w;
&$_($B1)for@$w;
&$_($F1)for@$w;
&$_($J1)for@$H;
&$_($R1)for@$w;
&$_($V1)for@$w;
&$_($Z1)for@$H;
&$_($P2)for@$w;
&$_($S2)for@$w;
&$_($W2)for@$Z2;
&$_($e3)for@$w;
&$_($g3)for@$w;
&$_($j3)for@$m3;
&$_($q3)for@$w;
&$_($t3)for@$v3;
&$_($z3)for@$w;
&$_($C3)for@$E3;
&$_($I3)for@$w;
&$_($L3)for@$N3;
&$_($P3)for@$Q3;
&$_($T3)for@$w;
&$_($W3)for@$w;
&$_($Z3)for@$d4;
&$_($w4)for@$w;
&$_($z4)for@$B4;
&$_($D4)for@$E4;
&$_($K4)for@$w;
&$_($N4)for@$P4;
&$_($R4)for@$S4;
&$_($Z4)for@$w;
&$_($e5)for@$g5;
&$_($k5)for@$w;
&$_($n5)for@$w;
&$_($q5)for@$s5;
&$_($w5)for@$w;
&$_($z5)for@$B5;
&$_($F5)for@$w;
&$_($I5)for@$K5;
&$_($O5)for@$w;
&$_($R5)for@$T5;
&$_($V5)for@$W5;
&$_($Y5)for@$Z5;
&$_($f6)for@$w;
&$_($i6)for@$w;
&$_($l6)for@$n6;
&$_($r6)for@$w;
&$_($u6)for@$w6;
&$_($y6)for@$z6;
&$_($J6)for@$K6;
&$_($O6)for@$P6;
&$_($R6)for@$S6;
&$_($U6)for@$V6;
&$_($f7)for@$w;
&$_($i7)for@$j7;
&$_($o7)for@$w;
&$_($r7)for@$s7;
&$_($x7)for@$w;
&$_($B7)for@$w;
&$_($F7)for@$w;
&$_($I7)for@$J7;
&$_($O7)for@$w;
&$_($R7)for@$S7;
&$_($X7)for@$w;
&$_($c8)for@$d8;
&$_($f8)for@$g8;
&$_($k8)for@$w;
&$_($n8)for@$o8;
&$_($t8)for@$w;
&$_($w8)for@$x8;
&$_($z8)for@$A8;
&$_($H8)for@$I8;
&$_($K8)for@$L8;
&$_($U8)for@$w;
&$_($X8)for@$Y8;
&$_($e9)for@$w;
&$_($h9)for@$i9;
&$_($n9)for@$w;
&$_($r9)for@$w;
&$_($v9)for@$w;
&$_($z9)for@$w;
&$_($C9)for@$D9;
&$_($I9)for@$w;
&$_($M9)for@$w;
&$_($Q9)for@$w;
&$_($U9)for@$w;
&$_($Y9)for@$w;
&$_($da)for@$ea;
&$_($ja)for@$w;
&$_($ma)for@$na;
&$_($sa)for@$w;
&$_($wa)for@$w;
&$_($Aa)for@$w;
&$_($Da)for@$Ea;
&$_($Ga)for@$Ha;
&$_($Ma)for@$Na;
&$_($cb)for@$w;
&$_($fb)for@$gb;
&$_($kb)for@$w;
&$_($nb)for@$ob;
&$_($tb)for@$w;
&$_($wb)for@$xb;
&$_($Cb)for@$w;
&$_($Gb)for@$w;
&$_($Kb)for@$w;
&$_($Nb)for@$Ob;
&$_($Sb)for@$w;
&$_($Wb)for@$w;
&$_($Zb)for@$cc;
&$_($gc)for@$w;
&$_($kc)for@$w;
&$_($nc)for@$oc;
&$_($qc)for@$rc;
&$_($wc)for@$xc;
&$_($Kc)for@$w;
&$_($Nc)for@$Oc;
&$_($Tc)for@$w;
&$_($Wc)for@$Xc;
&$_($dd)for@$w;
&$_($gd)for@$hd;
&$_($md)for@$w;
&$_($pd)for@$w;
&$_($td)for@$w;
&$_($wd)for@$w;
&$_($zd)for@$Ad;
&$_($Cd)for@$Dd;
&$_($Id)for@$Jd;
&$_($de)for@$w;
&$_($he)for@$w;
&$_($ke)for@$le;
&$_($pe)for@$w;
&$_($se)for@$w;
&$_($ve)for@$we;
&$_($Be)for@$w;
&$_($Fe)for@$w;
&$_($Ie)for@$Je;
&$_($Ne)for@$w;
&$_($Qe)for@$w;
&$_($Te)for@$Ue;
&$_($Ye)for@$w;
&$_($df)for@$w;
&$_($gf)for@$w;
&$_($jf)for@$w;
&$_($mf)for@$nf;
&$_($pf)for@$qf;
&$_($vf)for@$wf;
&$_($Jf)for@$w;
&$_($Nf)for@$w;
&$_($Rf)for@$w;
&$_($Uf)for@$Vf;
&$_($Zf)for@$w;
&$_($eg)for@$fg;
&$_($jg)for@$w;
&$_($ng)for@$w;
&$_($qg)for@$w;
&$_($tg)for@$ug;
&$_($wg)for@$xg;
&$_($Cg)for@$Dg;
&$_($Pg)for@$w;
&$_($Sg)for@$Tg;
&$_($Vg)for@$Wg;
&$_($eh)for@$fh;
&$_($nh)for@$w;
&$_($qh)for@$rh;
&$_($uh)for@$w;
&$_($xh)for@$yh;
&$_($Ah)for@$Bh;
&$_($Gh)for@$Hh;
&$_($Rh)for@$w;
&$_($Uh)for@$Vh;
&$_($Yh)for@$w;
&$_($di)for@$ei;
&$_($ii)for@$w;
&$_($li)for@$mi;
&$_($pi)for@$w;
&$_($si)for@$w;
&$_($vi)for@$wi;
&$_($yi)for@$zi;
&$_($Ei)for@$Fi;
&$_($Qi)for@$w;
&$_($Ti)for@$w;
&$_($Vi)for@$w;
&$_($Yi)for@$Zi;
&$_($fj)for@$w;
&$_($ij)for@$w;
&$_($mj)for@$w;
&$_($pj)for@$qj;
&$_($uj)for@$w;
&$_($xj)for@$w;
&$_($Aj)for@$Bj;
&$_($Gj)for@$w;
&$_($Jj)for@$Kj;
&$_($Mj)for@$Nj;
&$_($Sj)for@$Tj;
&$_($gk)for@$w;
&$_($jk)for@$lk;
&$_($sk)for@$w;
&$_($vk)for@$wk;
&$_($Bk)for@$w;
&$_($Fk)for@$w;
&$_($Jk)for@$w;
&$_($Nk)for@$w;
&$_($Rk)for@$w;
&$_($Vk)for@$w;
&$_($Zk)for@$w;
&$_($fl)for@$w;
&$_($jl)for@$w;
&$_($nl)for@$w;
&$_($rl)for@$w;
&$_($vl)for@$w;
&$_($zl)for@$w;
&$_($Dl)for@$w;
&$_($Hl)for@$w;
&$_($Ll)for@$w;
&$_($Pl)for@$w;
&$_($Sl)for@$w;
&$_($Vl)for@$Wl;
&$_($Yl)for@$Zl;
&$_($gm)for@$hm;
&$_($rm)for@$w;
&$_($vm)for@$w;
&$_($zm)for@$w;
&$_($Dm)for@$w;
&$_($Hm)for@$w;
&$_($Km)for@$Mm;
&$_($Ym)for@$w;
&$_($en)for@$w;
&$_($in)for@$w;
&$_($ln)for@$mn;
&$_($rn)for@$w;
&$_($vn)for@$w;
&$_($yn)for@$zn;
&$_($En)for@$w;
&$_($In)for@$w;
&$_($Mn)for@$w;
&$_($Qn)for@$w;
&$_($Un)for@$w;
&$_($Xn)for@$Yn;
&$_($eo)for@$w;
&$_($io)for@$w;
&$_($lo)for@$mo;
&$_($oo)for@$po;
&$_($uo)for@$vo;
&$_($Fo)for@$w;
&$_($Jo)for@$w;
&$_($No)for@$w;
&$_($Ro)for@$w;
&$_($Vo)for@$w;
&$_($Zo)for@$w;
&$_($fp)for@$w;
&$_($jp)for@$w;
&$_($np)for@$w;
&$_($rp)for@$w;
&$_($vp)for@$w;
&$_($zp)for@$w;
&$_($Cp)for@$Dp;
&$_($Lp)for@$w;
&$_($Np)for@$w;
&$_($Up)for@$Vp;
&$_($Yp)for@$w;
&$_($dq)for@$eq;
&$_($iq)for@$w;
&$_($lq)for@$mq;
&$_($oq)for@$pq;
&$_($vq)for@$wq;
&$_($Dq)for@$w;
&$_($Iq)for@$w;
&$_($Lq)for@$Mq;
&$_($Tq)for@$w;
&$_($Wq)for@$Xq;
&$_($cr)for@$w;
&$_($fr)for@$gr;
&$_($ir)for@$jr;
&$_($pr)for@$qr;
&$_($yr)for@$w;
&$_($Br)for@$Cr;
&$_($Hr)for@$w;
&$_($Lr)for@$w;
&$_($Or)for@$Pr;
&$_($Tr)for@$w;
&$_($Wr)for@$Xr;
&$_($cs)for@$ds;
&$_($js)for@$ks;
&$_($ss)for@$ts;
&$_($ys)for@$zs;
&$_($Hs)for@$Is;
&$_($et)for@$ft;
&$_($ht)for@$Is;
&$_($mt)for@$w;
&$_($qt)for@$w;
&$_($ut)for@$w;
&$_($yt)for@$w;
&$_($At)for@$Bt;
ni->run(@ARGV);
__DATA__
