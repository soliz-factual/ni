#!/usr/bin/env perl
$ni::license=<<'_';
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use Scalar::Util;
chomp $ni::boot, $ni::license;
$ni::self = bless {}, '/class/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::named{$_[0]} || die "ni: failed to resolve $_[0]" : $ni::self}
sub ni::name {my %h = @_; delete @h{grep !defined, keys %h}; @ni::named{keys %h} = values %h}
sub ni::eval {eval shift}
*{"/class/ni::def"} = sub {
  my ($self, %kvs) = @_;
  $ni::named{"ni.def:$_"} = $kvs{$_} for keys %kvs;
  *$_ = $kvs{$_} for keys %kvs;
};
*{'/class/fn::new'} = sub {
  my $self = bless {code => $_[1]}, $_[0];
  $self->compile;
  $self;
};
*{'/class/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/class/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
*{'/class/fn::(('}    = sub {};
*{'/class/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'/class/fn::(bool'} = sub {1};
sub fn($) {'/class/fn'->new(shift)}
_
$c='';
$d=q'applied_to';
$e=q'/class/class';
$f={$e,1};
$g='name';
$h='slices';
$i=q'/class/slice';
$j={$e,2,$i,1};
$k=q'/class/behavior';
$l=q'/class/fn';
$m={$l,1};
$n={};
$o='ctor';
$p='dtor';
$q='isa';
$r=[];
$s='methods';
$t='DESTROY';
$u='code';
$v=q'my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};';
$w=bless({$u,$v},$l);
$x='new';
$y=q'my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self, @_) for @{ref($self) . "::ctors"};
$self;';
$z=bless({$u,$y},$l);
$A={$t,$w,$x,$z};
$B=q'/behavior/lifecycle';
$C=bless({$d,$n,$o,$c,$p,$c,$q,$r,$s,$A,$g,$B},$i);
$D=q'/behavior/slice';
$E=$C;
$F=q'shift->compile';
$G=bless({$u,$F},$l);
$H=[];
$I='compile';
$J=q'my $self = shift;
$$self{fn} = ni::eval "sub{$$self{code}\\n}";
die "ni:/behavior/fn_init: failed to compile $$self{code}: $@" if $@;
$$self{fn};';
$K=bless({$u,$J},$l);
$L=q'instantiate';
$M=q'my $class = shift;
my $code  = pop;
+{code        => $code,
  annotations => [@_]};';
$N=bless({$u,$M},$l);
$O={$I,$K,$L,$N};
$P=q'/behavior/fn_init';
$Q=bless({$d,$n,$o,$G,$p,$c,$q,$H,$s,$O,$g,$P},$i);
$R=$Q;
$S=[];
$T=q'serialize';
$U=q'annotations';
$V=[];
$W=q'my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^(\\h+)/ && length $1 < $spaces;
}
my $pattern = \' \' x $spaces;
s/^$pattern// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);';
$X=bless({$U,$V,$u,$W},$l);
$Y={$T,$X};
$Z=bless({$d,$n,$o,$c,$p,$c,$q,$S,$s,$Y,$g,$c},$i);
$c1=$Z;
$d1=[$E,$R,$c1];
$e1=bless({$d,$m,$g,$l,$h,$d1},$e);
$f1=q'my ($self, $p) = @_;
return if $$self{applied_to}{$p}++;
$_->apply($p) for @{$$self{isa}};
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
*{"$p\\::(("} = sub {} if grep /^\\(/, keys %{$$self{methods}};
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;';
$g1=bless({$u,$f1},$l);
$h1=q'my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);';
$i1=bless({$u,$h1},$l);
$j1=q'/behavior/slice::apply';
$k1=q'/behavior/slice::apply_unsafe';
$l1=q'/class/slice::apply';
$m1=q'/class/slice::apply_unsafe';
$n1={};
$o1=[];
$p1='apply';
$q1=q'apply_unsafe';
$r1={$p1,$i1,$q1,$g1};
$s1=bless({$d,$n1,$o,$c,$p,$c,$q,$o1,$s,$r1,$g,$D},$i);
$t1=$s1;
$u1={$D,1,$e,1,$l,1,$i,1};
$v1=[];
$w1={$t,$w,$x,$z};
$x1=bless({$d,$u1,$q,$v1,$s,$w1},$D);
$y1={$e,1,$i,1};
$z1=[];
$A1='package';
$B1=q'shift->{name}';
$C1=bless({$u,$B1},$l);
$D1={$A1,$C1};
$E1=bless({$d,$y1,$o,$c,$p,$c,$q,$z1,$s,$D1},$D);
$F1={$e,1,$i,1};
$G1=[];
$H1=q'namespace';
$I1='\'ni\'';
$J1=bless({$u,$I1},$l);
$K1={$H1,$J1};
$L1=bless({$d,$F1,$o,$c,$p,$c,$q,$G1,$s,$K1},$D);
$M1={$e,1,$i,1};
$N1=q'my $self = shift; ni::name($self->name, $self)';
$O1=bless({$u,$N1},$l);
$P1={$e,1,$i,1};
$Q1=[];
$R1=q'my $s = shift;
return undef unless defined $$s{name};
$s->namespace . ":$$s{name}";';
$S1=bless({$u,$R1},$l);
$T1={$g,$S1};
$U1=bless({$d,$P1,$o,$c,$p,$c,$q,$Q1,$s,$T1},$D);
$V1=[$U1];
$W1={};
$X1=bless({$d,$M1,$o,$O1,$p,$c,$q,$V1,$s,$W1},$D);
$Y1=[$x1,$E1,$L1,$X1];
$Z1=bless({$d,$j,$g,$k,$h,$Y1},$e);
$c2={$e,1};
$d2=[];
$e2='add';
$f2=q'my $self = shift;
push @{$$self{slices}}, @_;
for my $p (keys %{$$self{applied_to}}) {$_->apply($p) for @_}
$self;';
$g2=bless({$u,$f2},$l);
$h2=q'my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p}++;
$_->apply($p) for @{$$self{slices}};
$self;';
$i2=bless({$u,$h2},$l);
$j2={$e2,$g2,$p1,$i2};
$k2=bless({$d,$c2,$o,$c,$p,$c,$q,$d2,$s,$j2},$D);
$l2={};
$m2=[];
$n2='def';
$o2=q'shift->add(ni(\'ni:/class/slice\')->new(undef, @_))';
$p2=bless({$u,$o2},$l);
$q2={$n2,$p2};
$r2=q'/behavior/class_method_def';
$s2=bless({$d,$l2,$o,$c,$p,$c,$q,$m2,$s,$q2,$g,$r2},$i);
$t2=$s2;
$u2=[$Z1,$k2,$t2];
$v2=bless({$d,$f,$g,$e,$h,$u2},$e);
$w2={$i,1};
$x2={$D,1,$i,1};
$y2=[];
$z2={$p1,$i1,$q1,$g1};
$A2=bless({$d,$x2,$q,$y2,$s,$z2},$D);
$B2={$i,1};
$C2=[];
$D2=q'my ($class, $name, @methods) = @_;
my $self = &{\'/behavior/slice::instantiate\'}($class, @methods);
$$self{name} = $name;
$self;';
$E2=bless({$u,$D2},$l);
$F2={$L,$E2};
$G2=bless({$d,$B2,$o,$c,$p,$c,$q,$C2,$s,$F2},$D);
$H2={};
$I2=[];
$J2=[];
$K2=q'my ($self, $quote) = @_;
if ($self->name eq \'ni:/behavior/slice\') {
  my %methods;
  @methods{keys %{$$self{methods}}} =
    map $quote->quote($_), values %{$$self{methods}};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      "\\*{" . $quote->quote("$p\\::$_") . "}=\\\\\\&$methods{$_};")
      for sort keys %methods;
  }
}

$quote->quote_class(ref $self);
my %state = %$self;
$state{applied_to} = {};
my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed(\\%state, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;';
$L2=bless({$U,$J2,$u,$K2},$l);
$M2={$T,$L2};
$N2=bless({$d,$H2,$o,$c,$p,$c,$q,$I2,$s,$M2,$g,$c},$i);
$O2=$N2;
$P2=[$Z1,$A2,$G2,$O2];
$Q2=bless({$d,$w2,$g,$i,$h,$P2},$e);
$R2={};
$S2=[];
$T2=q'internal/image';
$U2=[];
$V2=q'my $self = shift;
my $q = ni(\'ni:/class/image\')->new->partial_image(keys %ni::named);
$q->quote($self);
$q->write(\\*STDOUT);
0;';
$W2=bless({$U,$U2,$u,$V2},$l);
$X2='run';
$Y2=[];
$Z2=q'my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^--(.*)$/ && $self->can($1);
exit $self->default(@_);';
$c3=bless({$U,$Y2,$u,$Z2},$l);
$d3={$T2,$W2,$X2,$c3};
$e3=bless({$d,$R2,$o,$c,$p,$c,$q,$S2,$s,$d3,$g,$c},$i);
$f3=q'/class/ni';
$g3=$e3;
$h3=q'ni:/behavior/branch';
$i3={};
$j3=[];
$k3={$e2,$g2,$p1,$i2};
$l3=q'/behavior/branch';
$m3=bless({$d,$i3,$o,$c,$p,$c,$q,$j3,$s,$k3,$g,$l3},$i);
$n3=$m3;
$o3=q'ni:/behavior/class_init';
$p3={};
$q3=q'my $s = shift; $s->apply($s->package)';
$r3=bless({$u,$q3},$l);
$s3=[];
$t3=q'my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map ref($_) ? $_ : ni($_), @slices]};';
$u3=bless({$u,$t3},$l);
$v3={$L,$u3};
$w3=q'/behavior/class_init';
$x3=bless({$d,$p3,$o,$r3,$p,$c,$q,$s3,$s,$v3,$g,$w3},$i);
$y3=$x3;
$z3=q'ni:/behavior/class_method_def';
$A3=q'ni:/behavior/fn_init';
$B3=q'ni:/behavior/image_init';
$C3={};
$D3=[];
$E3=[];
$F3=q'my $class = shift;
my %include;
@include{@_} = map 1, @_;
+{include      => \\%include,
  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  side_effects => [],
  visited      => {},
  ordering     => []};';
$G3=bless({$U,$E3,$u,$F3},$l);
$H3={$L,$G3};
$I3=q'/behavior/image_init';
$J3=bless({$d,$C3,$o,$c,$p,$c,$q,$D3,$s,$H3,$g,$I3},$i);
$K3=q'/class/image';
$L3=$J3;
$M3=q'ni:/behavior/image_quoting';
$N3={};
$O3=[];
$P3='address';
$Q3=[];
$R3=q'return $_[1] if !ref $_[1] && length $_[1] < 64;
Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);';
$S3=bless({$U,$Q3,$u,$R3},$l);
$T3=q'allocate_gensym';
$U3=[];
$V3=q'my $self = shift;
my $a = $self->address(shift);
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;';
$W3=bless({$U,$U3,$u,$V3},$l);
$X3=q'boot_side_effect';
$Y3=[];
$Z3=q'unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]';
$c4=bless({$U,$Y3,$u,$Z3},$l);
$d4=q'circular_links';
$e4=[];
$f4=q'my $self = shift;
map "$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};';
$g4=bless({$U,$e4,$u,$f4},$l);
$h4='gensym';
$i4=[];
$j4=q'my $n = shift->{gensym_n}++;
my $s = \'$\' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int %n / 63;
}
$s;';
$k4=bless({$U,$i4,$u,$j4},$l);
$l4=q'is_circular';
$m4=[];
$n4=q'my $self = shift;
ref $$self{visited}{$self->address($_[0])};';
$o4=bless({$U,$m4,$u,$n4},$l);
$p4=q'partial_image';
$q4=[];
$r4=q'my $self = shift;
my %names;
@names{@_} = @ni::named{@_};
my $g = $self->quote(\\%names);
$self->side_effect("\\%ni::named=\\%$g;");';
$s4=bless({$U,$q4,$u,$r4},$l);
$t4='quote';
$u4=[];
$v4=q'my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
my $v = $$self{visited}{$a};
return ref $v ? \'undef\' : $v if defined $v;
$$self{visited}{$a} = \\\'undef\';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));';
$w4=bless({$U,$u4,$u,$v4},$l);
$x4=q'quote_array';
$y4=[];
$z4=q'my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_])
  && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
for 0..$#v;
\'[\' . join(\',\', map $self->quote($_), @$v) . \']\';';
$A4=bless({$U,$y4,$u,$z4},$l);
$B4=q'quote_blessed';
$C4=[];
$D4=q'my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $quote_fn = \'quote_\' . lc Scalar::Util::reftype $x;
my $quoted   = $self->$quote_fn($x);
"bless($quoted," . $self->quote($r) . ")";';
$E4=bless({$U,$C4,$u,$D4},$l);
$F4=q'quote_class';
$G4=[];
$H4=q'my ($self, $class) = @_;
$self->quote(ni"ni:$class") if exists $ni::named{"ni:$class"};';
$I4=bless({$U,$G4,$u,$H4},$l);
$J4=q'quote_hash';
$K4=[];
$L4=q'my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
$self->is_circular($$v{$_})
  && push @{$$self{circular}}, [$a, "{" . $self->quote($_) . "}",
                                    $self->address($$v{$_})]
for @ks;
\'{\' . join(\',\', map $self->quote($_), %$v{@ks}) . \'}\';';
$M4=bless({$U,$K4,$u,$L4},$l);
$N4=q'quote_object';
$O4=[];
$P4=q'my $self = shift;
return $_[0]->serialize($self) if $_[0]->can(\'serialize\');
$self->quote_blessed(@_);';
$Q4=bless({$U,$O4,$u,$P4},$l);
$R4=q'quote_scalar';
$S4=[];
$T4=q'my $v = $_[1];
return \'undef\' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\'])/\\\\$1/g;
length $v > 8 ? "q\'$v\'" : "\'$v\'";';
$U4=bless({$U,$S4,$u,$T4},$l);
$V4=q'quote_value';
$W4=[];
$X4=q'my $self = shift;
return $self->quote_scalar($_[0]) unless ref $_[0];
return $self->quote_array($_[0])  if \'ARRAY\' eq ref $_[0];
return $self->quote_hash($_[0])   if \'HASH\'  eq ref $_[0];
die "cannot serialize $_[0]"      if \'CODE\'  eq ref $_[0];
$self->quote_object($_[0]);';
$Y4=bless({$U,$W4,$u,$X4},$l);
$Z4=q'side_effect';
$c5=[];
$d5=q'push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]';
$e5=bless({$U,$c5,$u,$d5},$l);
$f5='write';
$g5=[];
$h5=q'my ($self, $fh) = @_;
$fh->print($_) for
  "#!/usr/bin/env perl\\n",
  "\\$ni::license=<<\'_\';\\n", $ni::license, "\\n_\\n",
  "BEGIN{eval(\\$ni::boot=<<\'_\')}\\n", $ni::boot, "\\n_\\n",
  map("$_\\n", @{$$self{definitions}}{@{$$self{ordering}}},
              $self->circular_links,
              @{$$self{side_effects}}),
  "ni->run(\\@ARGV);",
  "\\n__DATA__\\n";';
$i5=bless({$U,$g5,$u,$h5},$l);
$j5={$P3,$S3,$T3,$W3,$X3,$c4,$d4,$g4,$h4,$k4,$l4,$o4,$p4,$s4,$t4,$w4,$x4,$A4,$B4,$E4,$F4,$I4,$J4,$M4,$N4,$Q4,$R4,$U4,$V4,$Y4,$Z4,$e5,$f5,$i5};
$k5=q'/behavior/image_quoting';
$l5=bless({$d,$N3,$o,$c,$p,$c,$q,$O3,$s,$j5,$g,$k5},$i);
$m5=$l5;
$n5=q'ni:/behavior/lifecycle';
$o5=q'ni:/behavior/mapped_to_package';
$p5={};
$q5=[];
$r5={$A1,$C1};
$s5=q'/behavior/mapped_to_package';
$t5=bless({$d,$p5,$o,$c,$p,$c,$q,$q5,$s,$r5,$g,$s5},$i);
$u5=$t5;
$v5=q'ni:/behavior/named';
$w5={};
$x5=[];
$y5={$g,$S1};
$z5=q'/behavior/named';
$A5=bless({$d,$w5,$o,$c,$p,$c,$q,$x5,$s,$y5,$g,$z5},$i);
$B5=$A5;
$C5=q'ni:/behavior/named_persistent';
$D5={};
$E5=[$U1];
$F5={};
$G5=q'/behavior/named_persistent';
$H5=bless({$d,$D5,$o,$O1,$p,$c,$q,$E5,$s,$F5,$g,$G5},$i);
$I5=$H5;
$J5=q'ni:/behavior/named_transient';
$K5={};
$L5=q'my $s = shift; Scalar::Util::weaken($ni::named{$s->name} = $s)';
$M5=bless({$u,$L5},$l);
$N5=q'delete $ni::named{shift->name}';
$O5=bless({$u,$N5},$l);
$P5=[$U1];
$Q5={};
$R5=q'/behavior/named_transient';
$S5=bless({$d,$K5,$o,$M5,$p,$O5,$q,$P5,$s,$Q5,$g,$R5},$i);
$T5=$S5;
$U5=q'ni:/behavior/ni_namespaced';
$V5={};
$W5=[];
$X5={$H1,$J1};
$Y5=q'/behavior/ni_namespaced';
$Z5=bless({$d,$V5,$o,$c,$p,$c,$q,$W5,$s,$X5,$g,$Y5},$i);
$c6=$Z5;
$d6=q'ni:/behavior/slice';
$e6=q'ni:/behavior/slice_init';
$f6={};
$g6=[];
$h6=q'my $class = shift;
my @isa;
push @isa, shift while ref $_[0];
my %args = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  isa        => \\@isa,
  methods    => \\%args};';
$i6=bless({$u,$h6},$l);
$j6=q'instantiation';
$k6=q'my $self = shift;
(@{$$self{isa}},
 %{$$self{methods}},
 applied_to => $$self{applied_to},
 $$self{ctor} ? (ctor => $$self{ctor}) : (),
 $$self{dtor} ? (dtor => $$self{dtor}) : ());';
$l6=bless({$u,$k6},$l);
$m6={$L,$i6,$j6,$l6};
$n6=q'/behavior/slice_init';
$o6=bless({$d,$f6,$o,$c,$p,$c,$q,$g6,$s,$m6,$g,$n6},$i);
$p6=$o6;
$q6=q'ni:/behavior/slice_named_init';
$r6={};
$s6=[];
$t6={$L,$E2};
$u6=q'/behavior/slice_named_init';
$v6=bless({$d,$r6,$o,$c,$p,$c,$q,$s6,$s,$t6,$g,$u6},$i);
$w6=$v6;
$x6=q'ni:/behavior/tag';
$y6={};
$z6=[];
$A6=q'my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;';
$B6=bless({$u,$A6},$l);
$C6={$p1,$B6};
$D6=q'/behavior/tag';
$E6=bless({$d,$y6,$o,$c,$p,$c,$q,$z6,$s,$C6,$g,$D6},$i);
$F6=$E6;
$G6=q'ni:/class/behavior';
$H6=q'ni:/class/class';
$I6=q'ni:/class/fn';
$J6=q'ni:/class/image';
$K6={$K3,1};
$L6=[$L3,$m5];
$M6=bless({$d,$K6,$g,$K3,$h,$L6},$e);
$N6=q'ni:/class/ni';
$O6={$f3,1};
$P6={};
$Q6=[];
$R6='defclass';
$S6=q'shift; ni(\'ni:/class/class\')->new("/class/$_[0]", @_[1..$#_])';
$T6=bless({$u,$S6},$l);
$U6='defslice';
$V6=q'shift; ni(\'ni:/class/slice\')->new("/behavior/$_[0]", @_[1..$#_])';
$W6=bless({$u,$V6},$l);
$X6={$R6,$T6,$U6,$W6};
$Y6=bless({$d,$P6,$o,$c,$p,$c,$q,$Q6,$s,$X6,$g,$c},$i);
$Z6=$Y6;
$c7=[$Z6,$g3];
$d7=bless({$d,$O6,$g,$f3,$h,$c7},$e);
$e7=q'ni:/class/slice';
$f7={$c,$g3,$h3,$n3,$o3,$y3,$z3,$t2,$A3,$R,$B3,$L3,$M3,$m5,$n5,$E,$o5,$u5,$v5,$B5,$C5,$I5,$J5,$T5,$U5,$c6,$d6,$t1,$e6,$p6,$q6,$w6,$x6,$F6,$G6,$Z1,$H6,$v2,$I6,$e1,$J6,$M6,$N6,$d7,$e7,$Q2};
$g7=bless({},$f3);
*{$m1}=\&$g1;
*{$l1}=\&$i1;
*{$k1}=\&$g1;
*{$j1}=\&$i1;
$C->apply_unsafe($D);
$C->apply_unsafe($e);
$C->apply_unsafe($l);
$C->apply_unsafe($i);
$Q->apply_unsafe($l);
$Z->apply_unsafe($l);
$s1->apply_unsafe($D);
$s1->apply_unsafe($i);
$s2->apply_unsafe($e);
$N2->apply_unsafe($i);
$e3->apply_unsafe($f3);
$m3->apply_unsafe($e);
$x3->apply_unsafe($e);
$J3->apply_unsafe($K3);
$l5->apply_unsafe($K3);
$t5->apply_unsafe($e);
$t5->apply_unsafe($i);
$A5->apply_unsafe($e);
$A5->apply_unsafe($i);
$H5->apply_unsafe($e);
$H5->apply_unsafe($i);
$Z5->apply_unsafe($e);
$Z5->apply_unsafe($i);
$o6->apply_unsafe($D);
$v6->apply_unsafe($i);
$Y6->apply_unsafe($f3);
%ni::named=%$f7;
ni->run(@ARGV);
__DATA__
