ni::module->new(name         => '/lib/serializable',
                dependencies => [qw[ni.slice:ni::boot_module/serializable
                                    ni.slice:ni::module/serializable
                                    ni.slice:ni::boot_class/serializable
                                    ni.slice:ni::class/serializable
                                    ni.slice:ni::slice/serializable]]);

ni::class->new(name         => 'ni::serializable',
               dependencies => ['ni.module:/lib/quote'],
               code         => <<'_');
sub dependencies {
  my @q;
  my %d = ($_[0] => [@q = $_[0]->immediate_dependencies]);
  @q = grep !$d{$_}, map @{$d{$_} ||= [$_->immediate_dependencies]}, @q while @q;
  my @d;
  while (keys %d) {
    my @ks = grep {my $k = $_; !grep {$_->name ne $k && exists $d{$_}} @{$d{$k}}} sort keys %d;
    die "ni::serializable/dependencies: circular dependencies in\n"
      . join("\n", map "  $_ [@{$d{$_}}]", sort keys %d) unless @ks;
    push @d, @ks;
    delete @d{@ks};
  }
  ni::context @d;
}
sub serialize {
  my $self = shift;
  $_->serialize_self(@_) for $self->dependencies;
  shift;
}
sub serialize_self {
  my ($self, $into) = @_;
  $into << ni::quote(ref($self) . '::')
             ->new(%$self{sort grep !/^_/, keys %$self});
}
_

ni::slice->new(name => 'ni::boot_module/serializable',
               code => <<'_');
push our @ISA, qw/ni::serializable/;
sub immediate_dependencies {}
sub serialize_self {
  my ($self, $into) = @_;
  $into << join "\n",
    '#!/usr/bin/env perl',
    q{chomp($ni::license = <<'_');}, $ni::license, '_',
    'eval($ni::context{\'' . $self->name . '\'} = <<\'_\');', $$self{code}, '_',
    qq{die "\$@ evaluating $$self{name}" if \$@};
}
_

ni::slice->new(name => 'ni::module/serializable',
               code => <<'_');
push our @ISA, qw/ni::serializable/;
sub immediate_dependencies {ni::context @{shift->{dependencies}}}
_

ni::slice->new(name => 'ni::class/serializable',
               code => <<'_');
push our @ISA, qw/ni::serializable/;
sub immediate_dependencies {
  my $self = shift;
  ni::context(@{$$self{dependencies}}), $self->class, $self->parents;
}
_

ni::slice->new(name => 'ni::boot_class/serializable',
               code => <<'_');
sub immediate_dependencies {
  ni::context 'ni.module:/class'}
_

ni::slice->new(name => 'ni::slice/serializable',
               code => <<'_');
push our @ISA, qw/ni::serializable/;
sub immediate_dependencies {
  my $self = shift;
  ni::context(@{$$self{dependencies}}), $self->class, $self->target_class;
}
_
