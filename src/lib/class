# /class and /metaclass
'/lib/slice'->new('/lib/class_init.b',
  ctor => fn q{my $s = shift; $s->apply($s->package)},
  instantiate => fn q{
    local $_;
    my ($class, $name, @slices) = @_;
    +{name   => $name,
      slices => [map $class->resolve($_), @slices]};
  });

for (qw/ class metaclass class.c metaclass.c /) {
  ni('ni:/lib/perlbranch.b')->apply("/$_");
  ni('ni:/lib/class_init.b')->apply("/$_");
}

'/metaclass.c'->new('/metaclass', '/lib/perlbranch.b', '/lib/class_init.b');

ni('ni:/metaclass')->new('/metaclass.c');
ni('ni:/metaclass')->new('/object.c');
ni('ni:/metaclass')->new('/class.c', '/object.c');

ni('ni:/class.c')->new('/class', '/lib/perlbranch.b', '/lib/class_init.b');
ni('ni:/metaclass.c')->add('/class');

ni('ni:/object.c')->add('/class');
ni('ni:/object.c')->new('/object', '/lib/instance.b');

ni('ni:/class')->add('/object');
ni('ni:/metaclass')->add('/object');

# /lib/{slice,tag,branch}
ni('ni:/metaclass')->new('/lib/behavior.c', '/object.c');
ni('ni:/metaclass')->new('/lib/slice.c',    '/lib/behavior.c');
ni('ni:/metaclass')->new('/lib/tag.c',      '/lib/behavior.c');
ni('ni:/metaclass')->new('/lib/branch.c',   '/lib/behavior.c');

ni('ni:/lib/behavior.c')->new('/lib/behavior', '/object');
ni("ni:/lib/$_.c")->new("/lib/$_",
  '/lib/behavior', '/lib/named.b',
  "/lib/$_.b", "/lib/$_\_init.b") for qw/slice branch tag/;

# Definition
ni('ni:/class')->add(
  ni('ni:/lib/slice')->new('/lib/classdef.b',
    def => fn q{shift->add(ni('ni:/lib/slice')->new(@_))}));

# Subclassing
ni('ni:/class')->def('/lib/subclass.b',
  child => fn q{
    my ($self, $name, @slices) = @_;
    ni("ni:/metaclass")->new("$name.c", $self->class)
    ->new($name, @slices);
  });

# Reflection for /lib/ni
ni('ni:/object')->child('/lib/ni');
