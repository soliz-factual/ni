ni->module('/lib/class', code => <<'_');
use strict;
use warnings;
use Scalar::Util;

no strict 'refs';

ni->def(
  '/class/object::class' => sub {shift->{class}},
  '/class/object::init' => sub {},
  '/class/object::init_parents' => sub {
    print STDERR "init_parents on " . $_[0]->name . "\n";
    $_ = ni($_)->package->can('init') and $_->(@_) for $_[0]->class->isa});

ni->def(
  '/behavior/namespaced::package' => sub {shift->{name}},
  '/behavior/namespaced::methods' => sub {
    my $self = shift;
    grep defined ${$self->package . "::$_"}{CODE},
      sort keys %{$self->package . "::"}},

  '/behavior/namespaced::def' => sub {
    my ($self, %kvs) = @_;
    *{$self->package . "::$_"} = $kvs{$_} for keys %kvs});

ni->def(
  '/behavior/named::is_persistent' => sub {1},
  '/behavior/named::namespace' => sub {'ni'},
  '/behavior/named::DESTROY' => sub {delete $ni::named{shift->name}},
  '/behavior/named::name' => sub {
    my $self = shift;
    $self->namespace . ":" . $$self{name}},

  '/behavior/named::init' => sub {
    my ($self) = @_;
    print STDERR "named init for $$self{name}\n";
    $_[0] = $self = $ni::named{$self->name} if exists $ni::named{$self->name};
    $ni::named{$self->name} = $self unless $$self{anonymous};
    Scalar::Util::weaken $ni::named{$self->name} unless $self->is_persistent});

ni->def(
  '/class/class::new' => sub {
    my $o = shift->instantiate;
    $o->init(@_);
    $o->init_parents(@_);
    $o},

  '/class/class::init' => sub {
    my ($self, $name, %args) = @_;
    @$self{qw/name anonymous/} = defined $name ? ($name, 0) : (ni->gensym, 1);
    $$self{isa} = $args{isa} || [map "ni:$_", @{$self->package . "::ISA"}];
    $self->inherit_from(@{$$self{isa}});
    print STDERR "$$self{name} parents: (@{$$self{isa}})\n"
    },

  '/class/class::DESTROY' => sub {
    my $self = shift;
    delete @{$self->package . "::"}{keys %{$self->package . "::"}}
        if $$self{anonymous}},

  '/class/class::isa' => sub {@{shift->{isa}}},

  '/class/class::inherit_from' => sub {
    my $self = shift;
    print STDERR "$$self{name} inheriting from @_\n";
    @{$self->package . "::ISA"} = map ni($_)->package, @{$$self{isa}} = @_;
    $self},

  '/class/class::instantiate' => sub {
    my $self = shift;
    bless {class => $self}, $self->package},

  '/class/class::child' => sub {
    my ($self, $name, @ps) = @_;
    $self->class->child("${name}_")->new($name, isa => [$self->name, @ps])});

ni->def('/class/metaclass_::child' => sub {shift});

ni->def(
  '/class/class::ISA'      => ['/class/behavior'],
  '/class/class_::ISA'     => ['/class/behavior_'],
  '/class/behavior::ISA'   => ['/class/object', '/behavior/namespaced', '/behavior/named'],
  '/class/behavior_::ISA'  => ['/class/object_'],
  '/class/object::ISA'     => [],
  '/class/object_::ISA'    => ['/class/class'],
  '/class/metaclass::ISA'  => ['/class/class'],
  '/class/metaclass_::ISA' => ['/class/class_']);

{
  my @boot_objects = (
    bless({name => '/behavior/named'},      '/class/behavior'),
    bless({name => '/behavior/namespaced'}, '/class/behavior'),
    bless({name => '/class/behavior'},      '/class/behavior_'),
    bless({name => '/class/behavior_'},     '/class/metaclass'),
    bless({name => '/class/class'},         '/class/class_'),
    bless({name => '/class/class_'},        '/class/metaclass'),
    bless({name => '/class/metaclass'},     '/class/metaclass_'),
    bless({name => '/class/metaclass_'},    '/class/metaclass'),
    bless({name => '/class/object'},        '/class/object_'),
    bless({name => '/class/object_'},       '/class/metaclass'));

  &{'/behavior/named::init'}($_) for @boot_objects;
  $$_{class} = ni('ni:' . ref $_) for @boot_objects;
  $_->init($$_{name}) for @boot_objects;
  $_->init_parents($$_{name}) for @boot_objects;

  print STDERR "$$_{name} :: (@{$$_{isa} || []})\n" for @boot_objects;
}

ni('ni:/class/object')->child('/class/ni')->def(
  gensym => sub {"/gensym::" . ++shift->{gensym_index}});
_
