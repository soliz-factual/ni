ni::name(
  'ni:/behavior/class_init' =>
    '/behavior/slice'->new(
      ctor => fn q{my $s = shift; $s->apply($s->package)},
      instantiate => fn q{
        my ($class, $name, @slices) = @_;
        +{name   => $name,
          slices => [map ref($_) ? $_ : ni($_), @slices]};
      }),

  'ni:/class/behavior' =>
    bless {name   => '/class/behavior',
           slices => [ni"ni:/behavior/lifecycle",
                      ni"ni:/behavior/mapped_to_package",
                      ni"ni:/behavior/ni_namespaced",
                      ni"ni:/behavior/named_persistent"]},
    '/class/class');

ni('ni:/behavior/class_init')->apply('/class/class');
ni('ni:/behavior/branch')->apply('/class/class');

ni('ni:/class/behavior')->apply('/class/class');

'/class/class'->new('/class/class',
  ni"ni:/class/behavior",
  ni"ni:/behavior/branch");

ni::name('ni:/behavior/slice_named_init' =>
  '/behavior/slice'->new(
    instantiate => fn q{
      my ($class, $name, @methods) = @_;
      my $self = &{'/behavior/slice::instantiate'}($class, @methods);
      $$self{name} = $name;
      $self;
    }));

'/class/class'->new('/class/slice',
  ni"ni:/class/behavior",
  ni"ni:/behavior/slice",
  ni"ni:/behavior/slice_named_init");

ni('ni:/class/slice')->new("/behavior/$_" => ni("ni:/behavior/$_")->instantiation)
  for qw/slice slice_init lifecycle tag branch named ni_namespaced
         mapped_to_package named_transient named_persistent class_init
         slice_named_init/;

ni('ni:/class/slice')->new('/behavior/class_method_def',
  def => fn q{shift->add(ni('ni:/behavior/slice')->new(@_))});

ni('ni:/class/class')->add(ni('ni:/behavior/class_method_def'));
ni('ni:/class/class')->new('/class/ni');

ni('ni:/class/ni')->def(
  defclass => fn q{shift; ni('ni:/class/class')->new("/class/$_[0]", @_[1..$#_])},
  defslice => fn q{shift; ni('ni:/class/slice')->new("/behavior/$_[0]", @_[1..$#_])});
