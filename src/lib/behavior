ni->module('/lib/behavior', code => <<'_');
use strict;
use warnings;
use Scalar::Util;

no strict 'refs';

ni::name('ni:/behavior/slice' =>
  bless {
    methods => {
      apply => sub {
        my ($self, $p) = @_;
        $p = $p->package if ref $p;
        return if $$self{applied_to}{$p}++;
        $_->apply($p) for @{$$self{isa}};
        ${"$p\::ctors"}{$self} = $$self{ctor} if defined $$self{ctor};
        ${"$p\::dtors"}{$self} = $$self{dtor} if defined $$self{dtor};
        *{"$p\::(("} = sub {} if grep /^\(/, keys %{$$self{methods}};
        for (keys %{$$self{methods}}) {
          die "$self: overlapping method $p\::$_" if defined *{"$p\::$_"}{CODE};
          *{"$p\::$_"} = \&{$$self{methods}{$_}};
        }
        $self;
      }
    }
  }, '/behavior/slice');

ni('ni:/behavior/slice')->{methods}->{apply}
  ->(ni('ni:/behavior/slice'), '/behavior/slice');

ni::name('ni:/behavior/slice_init' =>
  bless {
    methods => {
      instantiate => sub {
        my $class = shift;
        my @isa;
        push @isa, shift while ref $_[0];
        my %args = @_;
        +{ctor    => delete($args{ctor}),
          dtor    => delete($args{dtor}),
          isa     => [@isa],
          methods => {%args}};
      },

      instantiation => sub {
        my $self = shift;
        (@{$$self{isa}},
         %{$$self{methods}},
         $$self{ctor} ? (ctor => $$self{ctor}) : (),
         $$self{dtor} ? (dtor => $$self{dtor}) : ());
      }
    }
  }, '/behavior/slice');

ni('ni:/behavior/slice_init')->apply('/behavior/slice');

ni::name('ni:/behavior/lifecycle' =>
  bless {
    methods => {
      new => sub {
        my $class = shift;
        my $self  = bless $class->instantiate(@_),
                    ref($class) ? $class->package : $class;
        $_->($self, @_) for values %{ref($self) . "::ctors"};
        $self;
      },
      DESTROY => sub {
        my $self = shift;
        $_->($self) for values %{ref($self) . "::dtors"};
      }
    }
  }, '/behavior/slice');

ni('ni:/behavior/lifecycle')->apply('/behavior/slice');

ni::name(
  'ni:/behavior/tag' =>
    '/behavior/slice'->new(
      apply => sub {
        my ($self, $p) = @_;
        $_->apply($p) for @{$$self{slices}};
        $self;
      }),

  'ni:/behavior/branch' =>
    '/behavior/slice'->new(
      apply => sub {
        my ($self, $p) = @_;
        $p = $p->package if ref $p;
        return if $$self{applied_to}{$p}++;
        $_->apply($p) for @{$$self{slices}};
        $self;
      },
      add => sub {
        my $self = shift;
        push @{$$self{slices}}, @_;
        for my $p (keys %{$$self{applied_to}}) {$_->apply($p) for @_}
        $self;
      }));

ni::name(
  'ni:/behavior/named' =>
    '/behavior/slice'->new(
      '(""' => sub {shift->name},
      name  => sub {my $s = shift; $s->namespace . ":$$s{name}"}));

ni::name(
  'ni:/behavior/ni_namespaced' =>
    '/behavior/slice'->new(namespace => sub {'ni'}),

  'ni:/behavior/mapped_to_package' =>
    '/behavior/slice'->new(package => sub {shift->{name}}),

  'ni:/behavior/named_transient' =>
    '/behavior/slice'->new(
      ni"ni:/behavior/named",
      ctor => sub {my $s = shift; Scalar::Util::weaken($ni::named{$s->name} = $s)},
      dtor => sub {delete $ni::named{shift->name}}),

  'ni:/behavior/named_persistent' =>
    '/behavior/slice'->new(
      ni"ni:/behavior/named",
      ctor => sub {my $self = shift; ni::name($self->name, $self)}));

ni::name(
  'ni:/behavior/class_init' =>
    '/behavior/slice'->new(
      ctor => sub {my $s = shift; $s->apply($s->package)},
      instantiate => sub {
        my ($class, $name, @slices) = @_;
        +{name   => $name,
          slices => [map ref($_) ? $_ : ni($_), @slices]};
      }),

  'ni:/class/behavior' =>
    bless {name   => '/class/behavior',
           slices => [ni"ni:/behavior/lifecycle",
                      ni"ni:/behavior/mapped_to_package",
                      ni"ni:/behavior/ni_namespaced",
                      ni"ni:/behavior/named_persistent"]},
    '/class/class');

ni('ni:/behavior/class_init')->apply('/class/class');
ni('ni:/behavior/branch')->apply('/class/class');

ni('ni:/class/behavior')->apply('/class/class');

'/class/class'->new('/class/class',
  ni"ni:/class/behavior",
  ni"ni:/behavior/branch");

ni::name('ni:/behavior/slice_named_init' =>
  '/behavior/slice'->new(
    instantiate => sub {
      my ($class, $name, @methods) = @_;
      my $self = &{'/behavior/slice::instantiate'}($class, @methods);
      $$self{name} = $name;
      $self;
    }));

# TODO: here's the problem.
# ni:/class/slice is an instance of ni:/class/class, whose package is
# /class/class. /class/class is an instance of itself. Because of this instance
# relationship, /class/slice->new is the instance-method version of
# '/class/class'->new -- there's no distinction.
#
# So the object form ni("foo")->new is analogous to
# ref(ni("foo"))->new(ni("foo")) -- not the usual instantiation strategy. This
# seems like a real problem in a world where perl-style instantiation is even a
# remote possibility. Need to think about how to resolve this.

'/class/class'->new('/class/slice',
  ni"ni:/class/behavior",
  ni"ni:/behavior/slice",
  ni"ni:/behavior/slice_named_init");

'/class/slice'->new("/behavior/$_" =>
                    ni("ni:/behavior/$_")->instantiation)
  for qw/slice slice_init lifecycle tag branch named ni_namespaced
         mapped_to_package named_transient named_persistent class_init
         slice_named_init/;

'/class/slice'->new('/behavior/class_method_def',
  def => sub {shift->add(ni('ni:/behavior/slice')->new(@_))});

'/class/slice'->new('/behavior/fn', '(&{}' => sub {shift->{compiled}});

'/class/slice'->new('/behavior/anonymous_fn_init',
  initialize => sub {
    my $class = shift;
    my $code  = pop;
    my $compiled = ni::eval "sub {$code\n}";
    die "ni:/behavior/anonymous_fn_init: failed to compile $code: $@" if $@;
    +{code        => $code,
      annotations => [@_]};
  });

'/class/class'->new('/class/fn',
  ni"ni:/behavior/lifecycle",
  ni"ni:/behavior/anonymous_fn_init",
  ni"ni:/behavior/fn");
_
