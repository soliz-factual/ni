# /lib/slice.b
ni::name('ni:/lib/slice.b' =>
  bless {
    name => '/lib/slice.b',
    methods => {
      apply => fn q{
        local $_;
        my ($self, $p) = @_;
        $p = $p->package if ref $p;
        return if $$self{applied_to}{$p};
        for (keys %{$$self{methods}}) {
          die "$self: overlapping method $p\::$_" if defined *{"$p\::$_"}{CODE};
        }
        $self->apply_unsafe($p);
      },

      apply_unsafe => fn q{
        local $_;
        my ($self, $p) = @_;
        # TODO: can't just increment this; it never converges
        return if $$self{applied_to}{$p}++;
        push @{"$p\::ctors"}, $$self{ctor} if $$self{ctor};
        push @{"$p\::dtors"}, $$self{dtor} if $$self{dtor};
        *{"$p\::(("} = sub {} if grep /^\(/, keys %{$$self{methods}};
        *{"$p\::$_"} = \&{$$self{methods}{$_}} for keys %{$$self{methods}};
        $self;
      }
    }
  }, '/lib/slice');

ni('ni:/lib/slice.b')->{methods}->{apply_unsafe}
  ->(ni('ni:/lib/slice.b'), '/lib/slice');

ni::name('ni:/lib/slice_init.b' =>
  bless {
    name => '/lib/slice_init.b',
    methods => {
      instantiate => fn q{
        my $class = shift;
        my $name  = shift;
        my %args  = @_;
        +{ctor       => delete($args{ctor}),
          dtor       => delete($args{dtor}),
          applied_to => delete($args{applied_to}),
          name       => $name,
          methods    => \%args};
      },
    }
  }, '/lib/slice');

ni('ni:/lib/slice_init.b')->apply('/lib/slice');

ni::name('ni:/lib/instantiable.b' =>
  bless {
    name => '/lib/instantiable.b',
    methods => {
      new => fn q{
        local $_;
        my $class = ref $_[0] ? shift->package : shift;
        my $self = bless $class->instantiate(@_), $class;
        $_->($self) for @{ref($self) . "::ctors"};
        $self;
      },
      DESTROY => fn q{
        local $_;
        my $self = shift;
        $_->($self) for @{ref($self) . "::dtors"};
      }
    }
  }, '/lib/slice');

ni('ni:/lib/instantiable.b')->apply('/lib/slice');

ni::name(
  'ni:/lib/named.b' =>
    '/lib/slice'->new('/lib/named.b',
      ctor => fn q{my $s = shift; ni::name($s->name, $s)},
      name => fn q{"ni:" . shift->{name}}));

ni('ni:/lib/named.b')->apply('/lib/slice');

'/lib/slice'->new('/lib/namespaced.b',
  package => fn q{shift->{name}});

ni('ni:/lib/namespaced.b')->apply('/lib/slice');

# /lib/tag.b
'/lib/slice'->new('/lib/resolver.b',
  resolve => fn q{ref $_[1] ? $_[1] : ni"ni:$_[1]"});

'/lib/slice'->new('/lib/tag.b',
  apply => fn q{
    local $_;
    my ($self, $p) = @_;
    $_->apply($p) for @{$$self{slices}};
    $self;
  });

'/lib/slice'->new('/lib/tag_init.b',
  instantiate => fn q{
    local $_;
    my $class = shift;
    my $name  = shift;
    +{name   => $name,
      slices => [map $class->resolve($_), @_]};
  });

ni('ni:/lib/tag.b')->apply('/lib/tag');
ni('ni:/lib/tag_init.b')->apply('/lib/tag');
ni('ni:/lib/named.b')->apply('/lib/tag');
ni('ni:/lib/namespaced.b')->apply('/lib/tag');
ni('ni:/lib/instantiable.b')->apply('/lib/tag');
ni('ni:/lib/resolver.b')->apply('/lib/tag');

# /lib/branch.b
'/lib/slice'->new('/lib/branch.b',
  apply => fn q{
    local $_;
    my ($self, $p) = @_;
    $p = $p->package if ref $p;
    $$self{applied_to}{$p}++;
    $_->apply($p) for @{$$self{slices}};
    $self;
  },
  add => fn q{
    local $_;
    my $self = shift;
    my @s = map $self->resolve($_), @_;
    push @{$$self{slices}}, @s;
    for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @s}
    $self;
  });

'/lib/slice'->new('/lib/branch_init.b',
  instantiate => fn q{
    local $_;
    my $class = shift;
    my $name  = shift;
    +{name       => $name,
      applied_to => {},
      slices     => [map $class->resolve($_), @_]};
  });

'/lib/tag'->new('/lib/perlbranch.b',
  '/lib/branch.b',
  '/lib/instantiable.b',
  '/lib/named.b',
  '/lib/namespaced.b',
  '/lib/resolver.b');

ni('ni:/lib/perlbranch.b')->apply('/lib/branch');
ni('ni:/lib/branch_init.b')->apply('/lib/branch');

'/lib/slice'->new('/lib/instance.b', class => fn q{ni 'ni:' . ref shift});
