ni::name('ni:/b/slice' =>
  bless {
    methods => {
      apply => fn q{
        local $_;
        my ($self, $p) = @_;
        $p = $p->package if ref $p;
        return if $$self{applied_to}{$p};
        for (keys %{$$self{methods}}) {
          die "$self: overlapping method $p\::$_" if defined *{"$p\::$_"}{CODE};
        }
        $self->apply_unsafe($p);
      },

      apply_unsafe => fn q{
        local $_;
        my ($self, $p) = @_;
        return if $$self{applied_to}{$p}++;
        push @{"$p\::ctors"}, $$self{ctor} if $$self{ctor};
        push @{"$p\::dtors"}, $$self{dtor} if $$self{dtor};
        *{"$p\::(("} = sub {} if grep /^\(/, keys %{$$self{methods}};
        *{"$p\::$_"} = \&{$$self{methods}{$_}} for keys %{$$self{methods}};
        $self;
      }
    }
  }, '/b/slice');

ni('ni:/b/slice')->{methods}->{apply_unsafe}
  ->(ni('ni:/b/slice'), '/b/slice');

ni::name('ni:/b/slice_init' =>
  bless {
    methods => {
      instantiate => fn q{
        my $class = shift;
        my %args = @_;
        +{ctor       => delete($args{ctor}),
          dtor       => delete($args{dtor}),
          applied_to => delete($args{applied_to}),
          methods    => \%args};
      },

      instantiation => fn q{
        my $self = shift;
        (%{$$self{methods}},
         %$self{qw/applied_to ctor dtor/});
      }
    }
  }, '/b/slice');

ni('ni:/b/slice_init')->apply('/b/slice');

ni::name('ni:/b/lifecycle' =>
  bless {
    methods => {
      new => fn q{
        local $_;
        my $class = ref $_[0] ? shift->package : shift;
        my $self = bless $class->instantiate(@_), $class;
        $_->($self) for @{ref($self) . "::ctors"};
        $self;
      },
      DESTROY => fn q{
        local $_;
        my $self = shift;
        $_->($self) for @{ref($self) . "::dtors"};
      }
    }
  }, '/b/slice');

# NB: theoretically we could start using ni("ni:/b/slice")->new after
# this statement, but slices won't support ->package until we replace
# /b/slice with the class version in /lib/class.
ni('ni:/b/lifecycle')->apply('/b/slice');

ni::name(
  'ni:/b/tag' =>
    '/b/slice'->new(
      apply => fn q{
        local $_;
        my ($self, $p) = @_;
        $_->apply($p) for @{$$self{slices}};
        $self;
      }),

  'ni:/b/branch' =>
    '/b/slice'->new(
      apply => fn q{
        local $_;
        my ($self, $p) = @_;
        $p = $p->package if ref $p;
        $$self{applied_to}{$p}++;
        $_->apply($p) for @{$$self{slices}};
        $self;
      },
      add => fn q{
        local $_;
        my $self = shift;
        push @{$$self{slices}}, @_;
        for my $p (sort keys %{$$self{applied_to}}) {$_->apply($p) for @_}
        $self;
      }));

ni::name(
  'ni:/b/named' =>
    '/b/slice'->new(
      name => fn q{
        my $s = shift;
        defined $$s{name} ? $s->namespace . ":$$s{name}" : undef;
      }));

ni::name(
  'ni:/b/ni_namespaced' =>
    '/b/slice'->new(namespace => fn q{'ni'}),

  'ni:/b/mapped_to_package' =>
    '/b/slice'->new(package => fn q{shift->{name}}),

  'ni:/b/named_persistent' =>
    '/b/slice'->new(
      ctor => fn q{my $self = shift; ni::name($self->name, $self) if defined $self->name}));
