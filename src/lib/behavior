use strict;
use warnings;
use Scalar::Util;

no strict 'refs';

ni::name('ni:/behavior/slice' =>
  bless {
    methods => {
      apply => fn q{
        my ($self, $p) = @_;
        $p = $p->package if ref $p;
        return if $$self{applied_to}{$p};
        for (keys %{$$self{methods}}) {
          die "$self: overlapping method $p\::$_" if defined *{"$p\::$_"}{CODE};
        }
        $self->apply_unsafe($p);
      },

      apply_unsafe => fn q{
        my ($self, $p) = @_;
        return if $$self{applied_to}{$p}++;
        $_->apply($p) for @{$$self{isa}};
        ${"$p\::ctors"}{$self} = $$self{ctor} if defined $$self{ctor};
        ${"$p\::dtors"}{$self} = $$self{dtor} if defined $$self{dtor};
        *{"$p\::(("} = sub {} if grep /^\(/, keys %{$$self{methods}};
        *{"$p\::$_"} = \&{$$self{methods}{$_}} for keys %{$$self{methods}};
        $self;
      }
    }
  }, '/behavior/slice');

ni('ni:/behavior/slice')->{methods}->{apply_unsafe}
  ->(ni('ni:/behavior/slice'), '/behavior/slice');

ni::name('ni:/behavior/slice_init' =>
  bless {
    methods => {
      instantiate => fn q{
        my $class = shift;
        my @isa;
        push @isa, shift while ref $_[0];
        my %args = @_;
        +{ctor       => delete($args{ctor}),
          dtor       => delete($args{dtor}),
          applied_to => delete($args{applied_to}),
          isa        => \@isa,
          methods    => \%args};
      },

      instantiation => fn q{
        my $self = shift;
        (@{$$self{isa}},
         applied_to => $$self{applied_to},
         %{$$self{methods}},
         $$self{ctor} ? (ctor => $$self{ctor}) : (),
         $$self{dtor} ? (dtor => $$self{dtor}) : ());
      }
    }
  }, '/behavior/slice');

ni('ni:/behavior/slice_init')->apply('/behavior/slice');

ni::name('ni:/behavior/lifecycle' =>
  bless {
    methods => {
      new => fn q{
        my $class = ref $_[0] ? shift->package : shift;
        my $self = bless $class->instantiate(@_), $class;
        my $h = \%{ref($self) . "::ctors"};
        $_->($self, @_) for @$h{sort keys %$h};
        $self;
      },
      DESTROY => fn q{
        my $self = shift;
        my $h = \%{ref($self) . "::dtors"};
        $_->($self) for @$h{sort keys %$h};
      }
    }
  }, '/behavior/slice');

# NB: theoretically we could start using ni("ni:/behavior/slice")->new after
# this statement, but slices won't support ->package until we replace
# /behavior/slice with the class version in /lib/class.
ni('ni:/behavior/lifecycle')->apply('/behavior/slice');

ni::name(
  'ni:/behavior/tag' =>
    '/behavior/slice'->new(
      apply => fn q{
        my ($self, $p) = @_;
        $_->apply($p) for @{$$self{slices}};
        $self;
      }),

  'ni:/behavior/branch' =>
    '/behavior/slice'->new(
      apply => fn q{
        my ($self, $p) = @_;
        $p = $p->package if ref $p;
        return if $$self{applied_to}{$p}++;
        $_->apply($p) for @{$$self{slices}};
        $self;
      },
      add => fn q{
        my $self = shift;
        push @{$$self{slices}}, @_;
        for my $p (keys %{$$self{applied_to}}) {$_->apply($p) for @_}
        $self;
      }));

ni::name(
  'ni:/behavior/named' =>
    '/behavior/slice'->new(
      '(""' => fn q{shift->name},
      name  => fn q{
        my $s = shift;
        return undef unless defined $$s{name};
        $s->namespace . ":$$s{name}";
      }));

ni::name(
  'ni:/behavior/ni_namespaced' =>
    '/behavior/slice'->new(namespace => fn q{'ni'}),

  'ni:/behavior/mapped_to_package' =>
    '/behavior/slice'->new(package => fn q{shift->{name}}),

  'ni:/behavior/named_transient' =>
    '/behavior/slice'->new(
      ni"ni:/behavior/named",
      ctor => fn q{my $s = shift; Scalar::Util::weaken($ni::named{$s->name} = $s)},
      dtor => fn q{delete $ni::named{shift->name}}),

  'ni:/behavior/named_persistent' =>
    '/behavior/slice'->new(
      ni"ni:/behavior/named",
      ctor => fn q{my $self = shift; ni::name($self->name, $self)}));
