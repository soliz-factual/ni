ni->module('/lib/behavior', code => <<'_');
use strict;
use warnings;
use Scalar::Util;

no strict 'refs';

ni->def(
  # TODO: figure out degrees of invariance here. It seems ambiguous:
  # ctors/dtors are more fixed than methods are. Why? Why even support a
  # definition syntax like this?
  '/behavior/slice::def' => sub {
    my ($self, %ms) = @_;
    @{$$self{methods}}{keys %ms} = values %ms;

    # TODO: slices should probably be immutable even though that means a
    # clunkier initialization process.
    if (keys %{$$self{applied_to}}) {
      my $delta = bless {methods => \%ms}, ref $self;
      $delta->apply($_) for keys %{$$self{applied_to}};
    }
    $self;
  },

  # TODO: have this return a value? Not sure, but we can't use this as a
  # constructor function because state modifications can occur in any order.
  # Maybe integrate memoized state updates in the lifecycle behavior.
  '/behavior/slice::parse_ctor_args' => sub {
    my ($self, %kv) = @_;
    @$self{keys %kv} = values %kv;
  });

ni::name('ni:/behavior/slice' =>
  bless {methods => {def => \&{'/behavior/slice::def'}},
         ctor    => \&{'/behavior/slice::parse_ctor_args'}},
  '/behavior/slice');

ni('ni:/behavior/slice')->def(
  apply => sub {
    my ($self, $p) = @_;
    return if $$self{applied_to}{$p}++;
    ${"$p\::ctors"}{$self} = $$self{ctor} if defined $$self{ctor};
    ${"$p\::dtors"}{$self} = $$self{dtor} if defined $$self{dtor};
    for (keys %{$$self{methods}}) {
      die "$self: overlapping method $p\::$_" if defined *{"$p\::$_"}{CODE};
      *{"$p\::$_"} = $$self{methods}{$_};
    }
    $self;
  },
  instantiate => sub {bless {}, shift});

delete ${'/behavior/slice::'}{def};
ni('ni:/behavior/slice')->{methods}->{apply}
  ->(ni('ni:/behavior/slice'), '/behavior/slice');

ni::name('ni:/behavior/lifecycle', bless({}, '/behavior/slice')->def(
  new => sub {
    my $self = shift->instantiate(@_);
    $_->($self, @_) for values %{ref($self) . "::ctors"};
    $self;
  },
  DESTROY => sub {
    my $self = shift;
    $_->($self) for values %{ref($self) . "::dtors"};
  }));

ni('ni:/behavior/lifecycle')->apply('/behavior/slice');

ni::name('ni:/behavior/named_transient' =>
  '/behavior/slice'->new(
    ctor => sub {my $s = shift; Scalar::Util::weaken(ni::name($s->name, $s))},
    dtor => sub {delete $ni::named{shift->name}}));

ni::name('ni:/behavior/named_persistent' =>
  '/behavior/slice'->new(
    ctor => sub {my $self = shift; ni::name($self->name, $self)}));
_
