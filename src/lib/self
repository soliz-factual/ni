ni('ni:object')->child('lib/ni')
  ->def('lib/ni_self.b',
    is_mutable => fn q{$0 ne "-" && -w $0},
    modify => fn q{
      my ($self, $fn) = @_;
      # TODO: replace all of this with a generalized "atomic-update" function
      # against UNIX files.
      die "ni: cannot modify immutable instance" unless $self->is_mutable;
      my (undef, undef, $mode) = stat $0;
      my $temp = map chr 97 + rand(26), 1..16;
      my @r = split /\//, $0;
      $r[-1] =~ s/^/./;
      $r[-1] =~ s/$/.$temp/;
      my $r = join '/', @r;
      open my $w, '>', $r or die "ni: failed to create staging file: $!";
      chmod $mode, $r or die "ni: failed to chmod $r to $mode: $!";
      &$fn($w);
      close $w;
      rename $r, $0 or die "ni: failed to rename: $!";
    })

  ->def('lib/ni_image.b',
    exists => fn q{exists $_[0]->{named}{$_[1]}},
    quoted => fn q{
      my $self = shift;
      my $q = ni('ni:lib/image')->new(@_);
      my $gs = $q->quote($self);
      $q->side_effect("\$ni::self=$gs;");
      $q;
    })

  ->def('lib/ni_main.b',
    run => fn q{
      my $self = shift;
      shift, exit $self->$1(@_) if $_[0] =~ /^(--.*)$/ && $self->can($1);
      exit $self->default(@_);
    },

    '--internal/eval' => fn q{
      my $self = shift;
      for (@_) {
        my $r = ni::eval($_);
        print $@ ? "ERROR $@\n" : "$r\n";
      }
      0;
    },

    '--internal/+=' => fn q{
      my $self = shift;
      for (@_) {
        my $r = do $_;
        die "ni: failed to parse $_: $@" if $@;
        die "ni: failed to execute $_: $!" unless defined $r;
        die "ni: failed to run $_: $!" unless $r;
      }
      my $q = $self->quoted;
      $self->modify(sub {$q->write(shift)});
      0;
    },

    '--internal/test' => fn q{
      my $self = shift;
      my @tests = map ni($_)->tests, grep /^ni\.doc:/, keys %{$$self{named}};
      my $fails = 0;
      print scalar(@tests) . " test(s)\n";
      my %names = %{ni->{named}};
      for my $t (@tests) {
        %{ni->{named}} = %names;
        my $r = eval {&$t};
        if ($@) {
          ++$fails;
          print "FAIL: $@ in $t\n";
        } elsif (!$r) {
          ++$fails;
          print "FAIL: $r\n";
        }
      }
      my $passed = @tests - $fails;
      print "$passed test(s) passed\n";
      !!$fails;
    },

    '--internal/image' => fn q{
      shift->quoted->write(\*STDOUT);
      0;
    });

ni('ni:lib/slice')->new('lib/ni_resolver.b',
  resolver_for => fn q{
    my $self = shift;
    ${$$self{resolvers}}{$_[0]} = $_[1];
    $self;
  },
  resolve => fn q{
    my $self = shift;
    return $$self{named}{$_[0]} if exists $$self{named}{$_[0]};
    return $$self{resolvers}{$1}->($_[0]) if
      $_[0] =~ /^([^:]+):/ and exists $$self{resolvers}{$1};
    die "ni:self failed to resolve $_[0]";
  });

{
  my $ni = ni('ni:lib/ni');
  my $r  = ni('ni:lib/ni_resolver.b');
  delete ${'lib/ni::'}{resolve};
  $ni->add($r);
}
