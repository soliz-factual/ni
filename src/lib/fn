ni->defslice('fn_init',
  instantiate => fn q{
    my $class = shift;
    my $code  = pop;
    +{code        => $code,
      annotations => [@_]};
  },
  compile => fn q{
    local $@;
    my $self = shift;
    my ($eval_n) = eval('__FILE__') =~ /eval (\d+)/;
    ni::name "ni.eval:$eval_n", $self;
    $$self{fn} = ni::eval "sub{$$self{code}\n}";
    die "ni:/b/fn_init: failed to compile $$self{code}: $@" if $@;
    $$self{fn};
  },
  ctor => fn q{shift->compile});

# NB: this is a one-off that won't appear in the serialized image. It does
# constrain the serialization protocol, though, in that we can't rely on method
# calls against slices to reconstruct our state. (We have to construct the
# objects and packages separately.)
delete @{'/c/fn::'}{qw/new compile/};

ni->defclass('fn',
  ni"ni:/b/lifecycle",
  ni"ni:/b/fn_init");
