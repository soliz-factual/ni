ni->defclass('image',
  ni->defslice('image_init',
    instantiate => fn q{
      my $class = shift;
      my %include;
      @include{@_} = map 1, @_;
      +{include      => \%include,
        gensym_n     => 0,
        circular     => [],
        definitions  => {},
        side_effects => [],
        visited      => {},
        ordering     => []};
    }),

  ni->defslice('image_quoting',
    gensym => fn q{
      my $n = shift->{gensym_n}++;
      my $s = '$' .
        substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
               $n % 50, 1;
      $n = int $n / 50;
      while ($n) {
        $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
                     $n % 63, 1;
        $n = int %n / 63;
      }
      $s;
    },

    circular_links => fn q{
      my $self = shift;
      map "$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
          @{$$self{circular}};
    },

    partial_image => fn q{
      my $self = shift;
      my %names;
      @names{@_} = @ni::named{@_};
      my $g = $self->quote(\%names);
      $self->side_effect("\%ni::named=\%$g;");
    },

    str => fn q{
      my $self = shift;
      join "\n",
        "#!/usr/bin/env perl",
        "\$ni::license=<<'_';", $ni::license, '_',
        "BEGIN{eval(\$ni::boot=<<'_')}", $ni::boot, '_',
        @{$$self{definitions}}{@{$$self{ordering}}},
        $self->circular_links,
        @{$$self{side_effects}},
        "ni->run(\@ARGV);",
        "__DATA__\n";
    },

    address => fn q{
      return $_[1] if !ref $_[1] && length $_[1] < 64;
      Scalar::Util::refaddr(ref $_[1] ? $_[1] : \$_[1]);
    },

    quote => fn q{
      my $self = shift;
      return $self->quote_scalar($_[0])
        if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
      my $a = $self->address($_[0]);
      my $v = $$self{visited}{$a};
      return ref $v ? 'undef' : $v if defined $v;
      $$self{visited}{$a} = \'undef';
      $self->allocate_gensym($_[0], $self->quote_value($_[0]));
    },

    allocate_gensym => fn q{
      my $self = shift;
      my $a = $self->address(shift);
      my $g = $$self{visited}{$a} = $self->gensym;
      $$self{definitions}{$g} = "$g=$_[0];";
      push @{$$self{ordering}}, $g;
      $g;
    },

    side_effect      => fn q{push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]},
    boot_side_effect => fn q{unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]},

    quote_value => fn q{
      my $self = shift;
      return $self->quote_scalar($_[0]) unless ref $_[0];
      return $self->quote_array($_[0])  if 'ARRAY' eq ref $_[0];
      return $self->quote_hash($_[0])   if 'HASH'  eq ref $_[0];
      die "cannot serialize $_[0]"      if 'CODE'  eq ref $_[0];
      $self->quote_object($_[0]);
    },

    is_circular => fn q{
      my $self = shift;
      ref $$self{visited}{$self->address($_[0])};
    },

    quote_hash => fn q{
      my ($self, $v) = @_;
      my $a = $self->address($v);
      my @ks = sort keys %$v;
      $self->is_circular($$v{$_})
        && push @{$$self{circular}}, [$a, "{" . $self->quote($_) . "}",
                                          $self->address($$v{$_})]
      for @ks;
      '{' . join(',', map $self->quote($_), %$v{@ks}) . '}';
    },

    quote_array => fn q{
      my ($self, $v) = @_;
      my $a = $self->address($v);
      $self->is_circular($$v[$_])
        && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
      for 0..$#v;
      '[' . join(',', map $self->quote($_), @$v) . ']';
    },

    quote_scalar => fn q{
      my $v = $_[1];
      return 'undef' unless defined $v;
      return $v if Scalar::Util::looks_like_number $v;
      $v =~ s/([\\\\'])/\\\\$1/g;
      length $v > 8 ? "q'$v'" : "'$v'";
    },

    quote_blessed => fn q{
      my ($self, $x, $r) = @_;
      $r ||= ref $x;
      $self->quote_class($r);
      my $quote_fn = 'quote_' . lc Scalar::Util::reftype $x;
      my $quoted   = $self->$quote_fn($x);
      "bless($quoted," . $self->quote($r) . ")";
    },

    quote_class => fn q{
      my ($self, $class) = @_;
      $self->quote(ni"ni:$class") if exists $ni::named{"ni:$class"};
    },

    quote_object => fn q{
      my $self = shift;
      return $_[0]->serialize($self) if $_[0]->can('serialize');
      $self->quote_blessed(@_);
    }));

ni('ni:/class/fn')->def(
  serialize => fn q{
    my ($self, $quote) = @_;
    $quote->quote_class(ref $self);

    (my $code = $$self{code}) =~ s/^\s*|\s*$//g;
    my @lines = split /\n/, $code;
    my $spaces = length $code;
    for (@lines) {
      $spaces = length $1 if /^(\h+)/ && length $1 < $spaces;
    }
    my $pattern = ' ' x $spaces;
    s/^$pattern// for @lines;

    my %state = %$self;
    delete $state{fn};
    $state{code} = join "\n", @lines;
    $quote->quote_blessed(\%state, ref $self);
  });

ni('ni:/class/slice')->def(
  serialize => fn q{
    my ($self, $quote) = @_;
    if ($self->name eq 'ni:/behavior/slice') {
      my %methods;
      @methods{keys %{$$self{methods}}} =
        map $quote->quote($_), values %{$$self{methods}};
      for my $p (sort keys %{$$self{applied_to}}) {
        $quote->boot_side_effect(
          "\*{" . $quote->quote("$p\::$_") . "}=\\\\\&$methods{$_};")
          for sort keys %methods;
      }
    }

    $quote->quote_class(ref $self);
    my %state = %$self;
    $state{applied_to} = {};
    my $g = $quote->allocate_gensym($self,
      $quote->quote_blessed(\%state, ref $self));
    $quote->side_effect("$g\->apply_unsafe(" . $quote->quote($_) . ");")
      for sort keys %{$$self{applied_to}};
    $g;
  });
