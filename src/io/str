ni('ni:/io/object')->child('/io/str')
  ->ro('/io/str_ro.b', qw/data start end/)
  ->def('/io/str_init.b',
    instantiate => fn q{
      my $class = shift;
      +{data  => \$_[0],
        start => $_[1] || 0,
        end   => $_[2] || length $_[0]};
    })

  ->def('/io/str_io.b',
    remaining => fn q{my $self = shift; $$self{end} - $$self{start}},

    read => fn q{
      my $self = shift;
      return 0 if $$self{start} >= $$self{end};
      my $l = @_ >= 2 ? ni::min($self->remaining, $_[1]) : $self->remaining;
      if (@_ == 3) {
        substr($_[0], $_[2] || 0, $l, substr(${$$self{data}}, $$self{start}, $l));
      } else {
        $_[0] = substr ${$$self{data}}, $$self{start}, $l;
      }
      $$self{start} += $l;
      $l;
    },
    write => fn q{
      my $self = shift;
      ${$$self{data}} .= $_[0];
      $$self{start} += length $_[0];
      $$self{end} = length ${$$self{data}};
      length $_[0];
    });

ni->resolver_for(str => fn q{
  my $s = shift;
  ni('ni:/io/str')->new(substr($s, 4) . "\n");
});
