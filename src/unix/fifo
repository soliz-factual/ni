ni('ni:/unix/io')->child('/unix/fifo')
  ->ro('/unix/fifo_io.b', qw/read_fh write_fh/)
  ->def('/unix/fifo_init.b',
    instantiate => fn q{
      my ($class) = @_;
      pipe my ($r, $w) or die "ni:/unix/fifo failed: $!";
      +{read_fh => $r, write_fh => $w};
    })

  ->def('/unix/fifo_stdio.b',
    be => fn q{
      my ($self, $fd) = @_;
      (!$fd || $fd > 2 && $fd =~ s/[rw]$// && $1 eq 'r'
        ? $self->r
        : $self->w)->be($fd);
      $self;
    })

  ->has_fd
  ->def('/unix/fifo_direction.b',
    r => fn q{
      my $self = shift;
      close $$self{write_fh};
      $self->read_fd;
    },

    w => fn q{
      my $self = shift;
      close $$self{read_fh};
      $self->write_fd;
    });
