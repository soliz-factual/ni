ni('ni:unix/io')->child('unix/pipeline')
  ->ro('unix/pipeline_ro.b', qw/stdin stdout/)
  ->def('unix/pipeline_init.b',
    instantiate => fn q{
      my $class  = shift;
      my $stdin  = ni('ni:unix/fifo')->new;
      my $stdout = ni('ni:unix/fifo')->new;
      # TODO: stderr and multiplexing, which probably happens here

      my @rs = ($stdin, @_);
      my @ws = (@_, $stdout);
      my $rv; vec($rv, fileno $_->read_fh,  1) = 1 for @rs;
      my $wv; vec($wv, fileno $_->write_fh, 1) = 1 for @ws;

      +{ps     => [@_],
        stdin  => $stdin,
        stdout => $stdout,
        rs => \@rs, rv => $rv,
        ws => \@ws, wv => $wv};
    })

  ->def('unix/pipeline_async.b',
    async_step => fn q{
      local $_;
      my $self = shift;
      my $rv = $$self{rv};
      my $wv = $$self{wv};
      my $ev = $$self{ev};
      return $self unless select $rv, $wv, $ev, 0;
      for my $i (0..$#{$$self{rs}}) {
        my $rfh = $$self{rs}[$i]->read_fh;
        my $wfh = $$self{ws}[$i]->write_fh;
        next unless vec $rv, fileno $rfh, 1 and vec $wv, fileno $wfh, 1;
        $$self{rs}[$i]->read($_, 8192);
        $$self{ws}[$i]->write($_);
      }
      $self;
    })

  ->add('unix/has_fd.b')
  ->def('unix/pipeline_io.b',
    read_fh => fn q{shift->{stdout}->read_fh},
    write_fh => fn q{shift->{stdin}->write_fh});
