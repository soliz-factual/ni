#!/usr/bin/env perl
$ni::license=<<'_';
ni: https://github.com/spencertipping/ni
Copyright (c) 2016-2017 Spencer Tipping

MIT license

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
_
BEGIN{eval($ni::boot=<<'_')}
use Scalar::Util;
chomp $ni::boot, $ni::license;
$ni::self = bless {}, '/class/ni';
sub ni(;$) {@_ ? ref($_[0]) ? $_[0] : $ni::named{$_[0]} || die "ni: failed to resolve $_[0]" : $ni::self}
sub ni::name {my %h = @_; delete @h{grep !defined, keys %h}; @ni::named{keys %h} = values %h}
sub ni::eval {eval shift}
*{"/class/ni::def"} = sub {
  my ($self, %kvs) = @_;
  $ni::named{"ni.def:$_"} = $kvs{$_} for keys %kvs;
  *$_ = $kvs{$_} for keys %kvs;
};
*{'/class/fn::new'} = sub {
  my $self = bless {code => $_[1]}, $_[0];
  $self->compile;
  $self;
};
*{'/class/fn::compile'} = sub {
  my $self = shift;
  $$self{fn} = ni::eval "sub{$$self{code}\n}";
  die "ni:/class/fn failed to compile $$self{code}: $@\n" if $@;
  $$self{fn};
};
*{'/class/fn::(('}    = sub {};
*{'/class/fn::(&{}'}  = sub {$_[0]->{fn} ||= $_[0]->compile};
*{'/class/fn::(bool'} = sub {1};
sub fn($) {'/class/fn'->new(shift)}
_
$c='';
$d=q'applied_to';
$e=q'/class/class';
$f={$e,1};
$g='name';
$h='slices';
$i=q'/class/slice';
$j={$e,2,$i,1};
$k=q'/class/behavior';
$l=q'/class/fn';
$m={$l,1};
$n={};
$o='ctor';
$p='dtor';
$q='isa';
$r=[];
$s='methods';
$t='DESTROY';
$u='code';
$v=q'my $self = shift;
$_->($self) for @{ref($self) . "::dtors"};';
$w=bless({$u,$v},$l);
$x='new';
$y=q'my $class = ref $_[0] ? shift->package : shift;
my $self = bless $class->instantiate(@_), $class;
$_->($self, @_) for @{ref($self) . "::ctors"};
$self;';
$z=bless({$u,$y},$l);
$A={$t,$w,$x,$z};
$B=q'/behavior/lifecycle';
$C=bless({$d,$n,$o,$c,$p,$c,$q,$r,$s,$A,$g,$B},$i);
$D=q'/behavior/slice';
$E=$C;
$F={};
$G=q'shift->compile';
$H=bless({$u,$G},$l);
$I=[];
$J='compile';
$K=q'my $self = shift;
$$self{fn} = ni::eval "sub{$$self{code}\\n}";
die "ni:/behavior/fn_init: failed to compile $$self{code}: $@" if $@;
$$self{fn};';
$L=bless({$u,$K},$l);
$M=q'instantiate';
$N=q'my $class = shift;
my $code  = pop;
+{code        => $code,
  annotations => [@_]};';
$O=bless({$u,$N},$l);
$P={$J,$L,$M,$O};
$Q=q'/behavior/fn_init';
$R=bless({$d,$F,$o,$H,$p,$c,$q,$I,$s,$P,$g,$Q},$i);
$S=$R;
$T={};
$U=[];
$V=q'serialize';
$W=q'annotations';
$X=[];
$Y=q'my ($self, $quote) = @_;
$quote->quote_class(ref $self);

(my $code = $$self{code}) =~ s/^\\s*|\\s*$//g;
my @lines = split /\\n/, $code;
my $spaces = length $code;
for (@lines) {
  $spaces = length $1 if /^(\\h+)/ && length $1 < $spaces;
}
my $pattern = \' \' x $spaces;
s/^$pattern// for @lines;

my %state = %$self;
delete $state{fn};
$state{code} = join "\\n", @lines;
$quote->quote_blessed(\\%state, ref $self);';
$Z=bless({$W,$X,$u,$Y},$l);
$c1={$V,$Z};
$d1=bless({$d,$T,$o,$c,$p,$c,$q,$U,$s,$c1,$g,$c},$i);
$e1=$d1;
$f1=[$E,$S,$e1];
$g1=bless({$d,$m,$g,$l,$h,$f1},$e);
$h1=q'my ($self, $p) = @_;
return if $$self{applied_to}{$p}++;
$_->apply($p) for @{$$self{isa}};
push @{"$p\\::ctors"}, $$self{ctor} if $$self{ctor};
push @{"$p\\::dtors"}, $$self{dtor} if $$self{dtor};
*{"$p\\::(("} = sub {} if grep /^\\(/, keys %{$$self{methods}};
*{"$p\\::$_"} = \\&{$$self{methods}{$_}} for keys %{$$self{methods}};
$self;';
$i1=bless({$u,$h1},$l);
$j1=q'my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p};
for (keys %{$$self{methods}}) {
  die "$self: overlapping method $p\\::$_" if defined *{"$p\\::$_"}{CODE};
}
$self->apply_unsafe($p);';
$k1=bless({$u,$j1},$l);
$l1=q'/behavior/slice::apply';
$m1=q'/behavior/slice::apply_unsafe';
$n1=q'/class/slice::apply';
$o1=q'/class/slice::apply_unsafe';
$p1={};
$q1=[];
$r1='apply';
$s1=q'apply_unsafe';
$t1={$r1,$k1,$s1,$i1};
$u1=bless({$d,$p1,$o,$c,$p,$c,$q,$q1,$s,$t1,$g,$D},$i);
$v1=$u1;
$w1={$D,1,$e,1,$l,1,$i,1};
$x1=[];
$y1={$t,$w,$x,$z};
$z1=bless({$d,$w1,$q,$x1,$s,$y1},$D);
$A1={$e,1,$i,1};
$B1=[];
$C1='package';
$D1=q'shift->{name}';
$E1=bless({$u,$D1},$l);
$F1={$C1,$E1};
$G1=bless({$d,$A1,$o,$c,$p,$c,$q,$B1,$s,$F1},$D);
$H1={$e,1,$i,1};
$I1=[];
$J1=q'namespace';
$K1='\'ni\'';
$L1=bless({$u,$K1},$l);
$M1={$J1,$L1};
$N1=bless({$d,$H1,$o,$c,$p,$c,$q,$I1,$s,$M1},$D);
$O1={$e,1,$i,1};
$P1=q'my $self = shift; ni::name($self->name, $self)';
$Q1=bless({$u,$P1},$l);
$R1={$e,1,$i,1};
$S1=[];
$T1=q'my $s = shift;
return undef unless defined $$s{name};
$s->namespace . ":$$s{name}";';
$U1=bless({$u,$T1},$l);
$V1={$g,$U1};
$W1=bless({$d,$R1,$o,$c,$p,$c,$q,$S1,$s,$V1},$D);
$X1=[$W1];
$Y1={};
$Z1=bless({$d,$O1,$o,$Q1,$p,$c,$q,$X1,$s,$Y1},$D);
$c2=[$z1,$G1,$N1,$Z1];
$d2=bless({$d,$j,$g,$k,$h,$c2},$e);
$e2={$e,1};
$f2=[];
$g2='add';
$h2=q'my $self = shift;
push @{$$self{slices}}, @_;
for my $p (keys %{$$self{applied_to}}) {$_->apply($p) for @_}
$self;';
$i2=bless({$u,$h2},$l);
$j2=q'my ($self, $p) = @_;
$p = $p->package if ref $p;
return if $$self{applied_to}{$p}++;
$_->apply($p) for @{$$self{slices}};
$self;';
$k2=bless({$u,$j2},$l);
$l2={$g2,$i2,$r1,$k2};
$m2=bless({$d,$e2,$o,$c,$p,$c,$q,$f2,$s,$l2},$D);
$n2={};
$o2=[];
$p2='def';
$q2=q'shift->add(ni(\'ni:/class/slice\')->new(undef, @_))';
$r2=bless({$u,$q2},$l);
$s2={$p2,$r2};
$t2=q'/behavior/class_method_def';
$u2=bless({$d,$n2,$o,$c,$p,$c,$q,$o2,$s,$s2,$g,$t2},$i);
$v2=$u2;
$w2=[$d2,$m2,$v2];
$x2=bless({$d,$f,$g,$e,$h,$w2},$e);
$y2={$i,1};
$z2={$D,1,$i,1};
$A2=[];
$B2={$r1,$k1,$s1,$i1};
$C2=bless({$d,$z2,$q,$A2,$s,$B2},$D);
$D2={$i,1};
$E2=[];
$F2=q'my ($class, $name, @methods) = @_;
my $self = &{\'/behavior/slice::instantiate\'}($class, @methods);
$$self{name} = $name;
$self;';
$G2=bless({$u,$F2},$l);
$H2={$M,$G2};
$I2=bless({$d,$D2,$o,$c,$p,$c,$q,$E2,$s,$H2},$D);
$J2={};
$K2=[];
$L2=[];
$M2=q'my ($self, $quote) = @_;
if ($self->name eq \'ni:/behavior/slice\') {
  my %methods;
  @methods{keys %{$$self{methods}}} =
    map $quote->quote($_), values %{$$self{methods}};
  for my $p (sort keys %{$$self{applied_to}}) {
    $quote->boot_side_effect(
      "\\*{" . $quote->quote("$p\\::$_") . "}=\\\\\\&$methods{$_};")
      for sort keys %methods;
  }
}

$quote->quote_class(ref $self);
my %state = %$self;
$state{applied_to} = {};
my $g = $quote->allocate_gensym($self,
  $quote->quote_blessed(\\%state, ref $self));
$quote->side_effect("$g\\->apply_unsafe(" . $quote->quote($_) . ");")
  for sort keys %{$$self{applied_to}};
$g;';
$N2=bless({$W,$L2,$u,$M2},$l);
$O2={$V,$N2};
$P2=bless({$d,$J2,$o,$c,$p,$c,$q,$K2,$s,$O2,$g,$c},$i);
$Q2=$P2;
$R2=[$d2,$C2,$I2,$Q2];
$S2=bless({$d,$y2,$g,$i,$h,$R2},$e);
$T2={};
$U2=[];
$V2=q'internal/image';
$W2=[];
$X2=q'my $self = shift;
my $q = ni(\'ni:/class/image\')->new->partial_image(keys %ni::named);
$q->quote($self);
$q->write(\\*STDOUT);
0;';
$Y2=bless({$W,$W2,$u,$X2},$l);
$Z2='run';
$c3=[];
$d3=q'my $self = shift;
shift, exit $self->$1(@_) if $_[0] =~ /^--(.*)$/ && $self->can($1);
exit $self->default(@_);';
$e3=bless({$W,$c3,$u,$d3},$l);
$f3={$V2,$Y2,$Z2,$e3};
$g3=bless({$d,$T2,$o,$c,$p,$c,$q,$U2,$s,$f3,$g,$c},$i);
$h3=q'/class/ni';
$i3=$g3;
$j3=q'ni:/behavior/branch';
$k3={};
$l3=[];
$m3={$g2,$i2,$r1,$k2};
$n3=q'/behavior/branch';
$o3=bless({$d,$k3,$o,$c,$p,$c,$q,$l3,$s,$m3,$g,$n3},$i);
$p3=$o3;
$q3=q'ni:/behavior/class_init';
$r3={};
$s3=q'my $s = shift; $s->apply($s->package)';
$t3=bless({$u,$s3},$l);
$u3=[];
$v3=q'my ($class, $name, @slices) = @_;
+{name   => $name,
  slices => [map ref($_) ? $_ : ni($_), @slices]};';
$w3=bless({$u,$v3},$l);
$x3={$M,$w3};
$y3=q'/behavior/class_init';
$z3=bless({$d,$r3,$o,$t3,$p,$c,$q,$u3,$s,$x3,$g,$y3},$i);
$A3=$z3;
$B3=q'ni:/behavior/class_method_def';
$C3=q'ni:/behavior/fn_init';
$D3=q'ni:/behavior/image_init';
$E3={};
$F3=[];
$G3=[];
$H3=q'my $class = shift;
my %include;
@include{@_} = map 1, @_;
+{include      => \\%include,
  gensym_n     => 0,
  circular     => [],
  definitions  => {},
  side_effects => [],
  visited      => {},
  ordering     => []};';
$I3=bless({$W,$G3,$u,$H3},$l);
$J3={$M,$I3};
$K3=q'/behavior/image_init';
$L3=bless({$d,$E3,$o,$c,$p,$c,$q,$F3,$s,$J3,$g,$K3},$i);
$M3=q'/class/image';
$N3=$L3;
$O3=q'ni:/behavior/image_quoting';
$P3={};
$Q3=[];
$R3='address';
$S3=[];
$T3=q'return $_[1] if !ref $_[1] && length $_[1] < 64;
Scalar::Util::refaddr(ref $_[1] ? $_[1] : \\$_[1]);';
$U3=bless({$W,$S3,$u,$T3},$l);
$V3=q'allocate_gensym';
$W3=[];
$X3=q'my $self = shift;
my $a = $self->address(shift);
my $g = $$self{visited}{$a} = $self->gensym;
$$self{definitions}{$g} = "$g=$_[0];";
push @{$$self{ordering}}, $g;
$g;';
$Y3=bless({$W,$W3,$u,$X3},$l);
$Z3=q'boot_side_effect';
$c4=[];
$d4=q'unshift @{${$_[0]}{side_effects}}, $_[1]; $_[0]';
$e4=bless({$W,$c4,$u,$d4},$l);
$f4=q'circular_links';
$g4=[];
$h4=q'my $self = shift;
map "$$self{visited}{$$_[0]}$$_[1]=$$self{visited}{$$_[2]};",
    @{$$self{circular}};';
$i4=bless({$W,$g4,$u,$h4},$l);
$j4='gensym';
$k4=[];
$l4=q'my $n = shift->{gensym_n}++;
my $s = \'$\' .
  substr "cdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ",
         $n % 50, 1;
$n = int $n / 50;
while ($n) {
  $s .= substr "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_",
               $n % 63, 1;
  $n = int %n / 63;
}
$s;';
$m4=bless({$W,$k4,$u,$l4},$l);
$n4=q'is_circular';
$o4=[];
$p4=q'my $self = shift;
ref $$self{visited}{$self->address($_[0])};';
$q4=bless({$W,$o4,$u,$p4},$l);
$r4=q'partial_image';
$s4=[];
$t4=q'my $self = shift;
my %names;
@names{@_} = @ni::named{@_};
my $g = $self->quote(\\%names);
$self->side_effect("\\%ni::named=\\%$g;");';
$u4=bless({$W,$s4,$u,$t4},$l);
$v4='quote';
$w4=[];
$x4=q'my $self = shift;
return $self->quote_scalar($_[0])
  if !ref $_[0] && Scalar::Util::looks_like_number($_[0]);
my $a = $self->address($_[0]);
my $v = $$self{visited}{$a};
return ref $v ? \'undef\' : $v if defined $v;
$$self{visited}{$a} = \\\'undef\';
$self->allocate_gensym($_[0], $self->quote_value($_[0]));';
$y4=bless({$W,$w4,$u,$x4},$l);
$z4=q'quote_array';
$A4=[];
$B4=q'my ($self, $v) = @_;
my $a = $self->address($v);
$self->is_circular($$v[$_])
  && push @{$$self{circular}}, [$a, "[$_]", $self->address($$v[$_])]
for 0..$#v;
\'[\' . join(\',\', map $self->quote($_), @$v) . \']\';';
$C4=bless({$W,$A4,$u,$B4},$l);
$D4=q'quote_blessed';
$E4=[];
$F4=q'my ($self, $x, $r) = @_;
$r ||= ref $x;
$self->quote_class($r);
my $quote_fn = \'quote_\' . lc Scalar::Util::reftype $x;
my $quoted   = $self->$quote_fn($x);
"bless($quoted," . $self->quote($r) . ")";';
$G4=bless({$W,$E4,$u,$F4},$l);
$H4=q'quote_class';
$I4=[];
$J4=q'my ($self, $class) = @_;
$self->quote(ni"ni:$class") if exists $ni::named{"ni:$class"};';
$K4=bless({$W,$I4,$u,$J4},$l);
$L4=q'quote_hash';
$M4=[];
$N4=q'my ($self, $v) = @_;
my $a = $self->address($v);
my @ks = sort keys %$v;
$self->is_circular($$v{$_})
  && push @{$$self{circular}}, [$a, "{" . $self->quote($_) . "}",
                                    $self->address($$v{$_})]
for @ks;
\'{\' . join(\',\', map $self->quote($_), %$v{@ks}) . \'}\';';
$O4=bless({$W,$M4,$u,$N4},$l);
$P4=q'quote_object';
$Q4=[];
$R4=q'my $self = shift;
return $_[0]->serialize($self) if $_[0]->can(\'serialize\');
$self->quote_blessed(@_);';
$S4=bless({$W,$Q4,$u,$R4},$l);
$T4=q'quote_scalar';
$U4=[];
$V4=q'my $v = $_[1];
return \'undef\' unless defined $v;
return $v if Scalar::Util::looks_like_number $v;
$v =~ s/([\\\\\'])/\\\\$1/g;
length $v > 8 ? "q\'$v\'" : "\'$v\'";';
$W4=bless({$W,$U4,$u,$V4},$l);
$X4=q'quote_value';
$Y4=[];
$Z4=q'my $self = shift;
return $self->quote_scalar($_[0]) unless ref $_[0];
return $self->quote_array($_[0])  if \'ARRAY\' eq ref $_[0];
return $self->quote_hash($_[0])   if \'HASH\'  eq ref $_[0];
die "cannot serialize $_[0]"      if \'CODE\'  eq ref $_[0];
$self->quote_object($_[0]);';
$c5=bless({$W,$Y4,$u,$Z4},$l);
$d5=q'side_effect';
$e5=[];
$f5=q'push    @{${$_[0]}{side_effects}}, $_[1]; $_[0]';
$g5=bless({$W,$e5,$u,$f5},$l);
$h5='write';
$i5=[];
$j5=q'my ($self, $fh) = @_;
$fh->print($_) for
  "#!/usr/bin/env perl\\n",
  "\\$ni::license=<<\'_\';\\n", $ni::license, "\\n_\\n",
  "BEGIN{eval(\\$ni::boot=<<\'_\')}\\n", $ni::boot, "\\n_\\n",
  map("$_\\n", @{$$self{definitions}}{@{$$self{ordering}}},
              $self->circular_links,
              @{$$self{side_effects}}),
  "ni->run(\\@ARGV);",
  "\\n__DATA__\\n";';
$k5=bless({$W,$i5,$u,$j5},$l);
$l5={$R3,$U3,$V3,$Y3,$Z3,$e4,$f4,$i4,$j4,$m4,$n4,$q4,$r4,$u4,$v4,$y4,$z4,$C4,$D4,$G4,$H4,$K4,$L4,$O4,$P4,$S4,$T4,$W4,$X4,$c5,$d5,$g5,$h5,$k5};
$m5=q'/behavior/image_quoting';
$n5=bless({$d,$P3,$o,$c,$p,$c,$q,$Q3,$s,$l5,$g,$m5},$i);
$o5=$n5;
$p5=q'ni:/behavior/lifecycle';
$q5=q'ni:/behavior/mapped_to_package';
$r5={};
$s5=[];
$t5={$C1,$E1};
$u5=q'/behavior/mapped_to_package';
$v5=bless({$d,$r5,$o,$c,$p,$c,$q,$s5,$s,$t5,$g,$u5},$i);
$w5=$v5;
$x5=q'ni:/behavior/named';
$y5={};
$z5=[];
$A5={$g,$U1};
$B5=q'/behavior/named';
$C5=bless({$d,$y5,$o,$c,$p,$c,$q,$z5,$s,$A5,$g,$B5},$i);
$D5=$C5;
$E5=q'ni:/behavior/named_persistent';
$F5={};
$G5=[$W1];
$H5={};
$I5=q'/behavior/named_persistent';
$J5=bless({$d,$F5,$o,$Q1,$p,$c,$q,$G5,$s,$H5,$g,$I5},$i);
$K5=$J5;
$L5=q'ni:/behavior/named_transient';
$M5={};
$N5=q'my $s = shift; Scalar::Util::weaken($ni::named{$s->name} = $s)';
$O5=bless({$u,$N5},$l);
$P5=q'delete $ni::named{shift->name}';
$Q5=bless({$u,$P5},$l);
$R5=[$W1];
$S5={};
$T5=q'/behavior/named_transient';
$U5=bless({$d,$M5,$o,$O5,$p,$Q5,$q,$R5,$s,$S5,$g,$T5},$i);
$V5=$U5;
$W5=q'ni:/behavior/ni_namespaced';
$X5={};
$Y5=[];
$Z5={$J1,$L1};
$c6=q'/behavior/ni_namespaced';
$d6=bless({$d,$X5,$o,$c,$p,$c,$q,$Y5,$s,$Z5,$g,$c6},$i);
$e6=$d6;
$f6=q'ni:/behavior/slice';
$g6=q'ni:/behavior/slice_init';
$h6={};
$i6=[];
$j6=q'my $class = shift;
my @isa;
push @isa, shift while ref $_[0];
my %args = @_;
+{ctor       => delete($args{ctor}),
  dtor       => delete($args{dtor}),
  applied_to => delete($args{applied_to}),
  isa        => \\@isa,
  methods    => \\%args};';
$k6=bless({$u,$j6},$l);
$l6=q'instantiation';
$m6=q'my $self = shift;
(@{$$self{isa}},
 %{$$self{methods}},
 applied_to => $$self{applied_to},
 $$self{ctor} ? (ctor => $$self{ctor}) : (),
 $$self{dtor} ? (dtor => $$self{dtor}) : ());';
$n6=bless({$u,$m6},$l);
$o6={$M,$k6,$l6,$n6};
$p6=q'/behavior/slice_init';
$q6=bless({$d,$h6,$o,$c,$p,$c,$q,$i6,$s,$o6,$g,$p6},$i);
$r6=$q6;
$s6=q'ni:/behavior/slice_named_init';
$t6={};
$u6=[];
$v6={$M,$G2};
$w6=q'/behavior/slice_named_init';
$x6=bless({$d,$t6,$o,$c,$p,$c,$q,$u6,$s,$v6,$g,$w6},$i);
$y6=$x6;
$z6=q'ni:/behavior/tag';
$A6={};
$B6=[];
$C6=q'my ($self, $p) = @_;
$_->apply($p) for @{$$self{slices}};
$self;';
$D6=bless({$u,$C6},$l);
$E6={$r1,$D6};
$F6=q'/behavior/tag';
$G6=bless({$d,$A6,$o,$c,$p,$c,$q,$B6,$s,$E6,$g,$F6},$i);
$H6=$G6;
$I6=q'ni:/class/behavior';
$J6=q'ni:/class/class';
$K6=q'ni:/class/fn';
$L6=q'ni:/class/image';
$M6={$M3,1};
$N6=[$N3,$o5];
$O6=bless({$d,$M6,$g,$M3,$h,$N6},$e);
$P6=q'ni:/class/ni';
$Q6={$h3,1};
$R6={};
$S6=[];
$T6='defclass';
$U6=q'shift; ni(\'ni:/class/class\')->new("/class/$_[0]", @_[1..$#_])';
$V6=bless({$u,$U6},$l);
$W6='defslice';
$X6=q'shift; ni(\'ni:/class/slice\')->new("/behavior/$_[0]", @_[1..$#_])';
$Y6=bless({$u,$X6},$l);
$Z6={$T6,$V6,$W6,$Y6};
$c7=bless({$d,$R6,$o,$c,$p,$c,$q,$S6,$s,$Z6,$g,$c},$i);
$d7=$c7;
$e7=[$d7,$i3];
$f7=bless({$d,$Q6,$g,$h3,$h,$e7},$e);
$g7=q'ni:/class/slice';
$h7={$c,$i3,$j3,$p3,$q3,$A3,$B3,$v2,$C3,$S,$D3,$N3,$O3,$o5,$p5,$E,$q5,$w5,$x5,$D5,$E5,$K5,$L5,$V5,$W5,$e6,$f6,$v1,$g6,$r6,$s6,$y6,$z6,$H6,$I6,$d2,$J6,$x2,$K6,$g1,$L6,$O6,$P6,$f7,$g7,$S2};
$i7=bless({},$h3);
*{$o1}=\&$i1;
*{$n1}=\&$k1;
*{$m1}=\&$i1;
*{$l1}=\&$k1;
$C->apply_unsafe($D);
$C->apply_unsafe($e);
$C->apply_unsafe($l);
$C->apply_unsafe($i);
$R->apply_unsafe($l);
$d1->apply_unsafe($l);
$u1->apply_unsafe($D);
$u1->apply_unsafe($i);
$u2->apply_unsafe($e);
$P2->apply_unsafe($i);
$g3->apply_unsafe($h3);
$o3->apply_unsafe($e);
$z3->apply_unsafe($e);
$L3->apply_unsafe($M3);
$n5->apply_unsafe($M3);
$v5->apply_unsafe($e);
$v5->apply_unsafe($i);
$C5->apply_unsafe($e);
$C5->apply_unsafe($i);
$J5->apply_unsafe($e);
$J5->apply_unsafe($i);
$d6->apply_unsafe($e);
$d6->apply_unsafe($i);
$q6->apply_unsafe($D);
$x6->apply_unsafe($i);
$c7->apply_unsafe($h3);
%ni::named=%$h7;
ni->run(@ARGV);
__DATA__
